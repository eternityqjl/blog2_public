<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sat, 05 Mar 2022 21:18:38 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Cpp内存对齐</title>
        <link>https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
        <pubDate>Wed, 22 Dec 2021 16:10:44 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/ -&lt;h2 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h2&gt;
&lt;p&gt;看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//32位系统
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; y;
}s;

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(s);  &lt;span style=&#34;color:#888&#34;&gt;// 输出8
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。&lt;/p&gt;
&lt;h2 id=&#34;进行内存对齐的原因&#34;&gt;进行内存对齐的原因&lt;/h2&gt;
&lt;p&gt;尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为&lt;strong&gt;内存存取粒度&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。&lt;/p&gt;
&lt;h2 id=&#34;默认内存对齐&#34;&gt;默认内存对齐&lt;/h2&gt;
&lt;p&gt;int类型放在地址能被4整除的位置，short类型放在地址能被2整除的位置，char能放在任何位置。&lt;/p&gt;
&lt;p&gt;结构体的对齐满足以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体变量的首地址能够被其&lt;strong&gt;最宽基本类型成员的大小&lt;/strong&gt;所整除。&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是&lt;strong&gt;成员大小的整数倍&lt;/strong&gt;，如有需要编译器会在成员之间填充字节。&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体&lt;strong&gt;最宽基本类型成员大小的整数倍&lt;/strong&gt;，如有需要编译器会在最末一个成员后填充字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pragma-pack命令&#34;&gt;#pragma pack()命令&lt;/h2&gt;
&lt;p&gt;改命令强制规定了成员的对齐方式，括号内为&lt;strong&gt;对齐的字节数&lt;/strong&gt;。若括号内的内容为空，则为默认对齐。&lt;/p&gt;
&lt;p&gt;改变默认对齐方式能够更加充分利用存储空间，但降低了计算机的读写速率，是一种以空间换事件的方法。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>测试机器大小端的方法</title>
        <link>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/</link>
        <pubDate>Wed, 22 Dec 2021 15:49:36 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/ -&lt;ul&gt;
&lt;li&gt;小端法：低位字节存放在低地址，高位字节存放在高地址&lt;/li&gt;
&lt;li&gt;大端法：低位字节存放在高地址，高位字节存放在低地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断电脑大小端模式的方法：&lt;/p&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言中的char和int：&lt;/p&gt;
&lt;p&gt;在C语言中并没有char类型的常量，其实是用int类型表示char。举个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; ch &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#888&#34;&gt;//分别输出ch的字符和对应的ascii码。即打印出的是字符或整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%c, %d&amp;#34;&lt;/span&gt;, ch, ch);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果为：a, 97&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将int 48存起来，然后取得其地址，再将这个地址转为char* 这时候，如果是小端存储，那么char*指针就指向48；48对应的ASCII码为字符‘0’；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge1&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;48&lt;/span&gt;;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;i;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
    c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)p);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;方法二&#34;&gt;方法二&lt;/h2&gt;
&lt;p&gt;定义变量int i=1；将 i 的地址拿到，强转成char*型，这时候就取到了 i 的低地址，这时候如果是1就是小端存储，如果是0就是大端存储。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge2&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;i);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (c)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;方法三&#34;&gt;方法三&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;联合体union是一种特殊数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共同体，但任何时候只能有一个成员带有值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义联合体，一个成员是多字节，一个是单字节，给多字节的成员赋一个最低一个字节不为0，其他字节为0 的值，再用第二个成员来判断，如果第二个字节不为0，就是小端，若为0，就是大端。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge3&lt;/span&gt;() {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;union&lt;/span&gt;
    {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c;
    } un;
    un.i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (un.c &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp容器库和相关操作总结</title>
        <link>https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
        <pubDate>Thu, 16 Dec 2021 15:34:43 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/ -&lt;h1 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h1&gt;
&lt;h2 id=&#34;vector&#34;&gt;vector&lt;/h2&gt;
&lt;p&gt;member functions：&lt;/p&gt;
&lt;p&gt;constructor、destructor、operator=、assign、get_allocator&lt;/p&gt;
&lt;h3 id=&#34;element-access&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iterators&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin/cbegin&lt;/li&gt;
&lt;li&gt;end/cend&lt;/li&gt;
&lt;li&gt;rbegin/c rbegin&lt;/li&gt;
&lt;li&gt;rend/c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;li&gt;reserve&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;shrink_to_fit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;emplace：相较于insert，不需要产生一个临时变量。&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;push_back&lt;/li&gt;
&lt;li&gt;resize&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;non-member functions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;operator==&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deque&#34;&gt;deque&lt;/h2&gt;
&lt;p&gt;双端队列&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;list&lt;/h2&gt;
&lt;p&gt;双向链表&lt;/p&gt;
&lt;h2 id=&#34;forward_list&#34;&gt;forward_list&lt;/h2&gt;
&lt;p&gt;单向链表&lt;/p&gt;
&lt;h2 id=&#34;array&#34;&gt;array&lt;/h2&gt;
&lt;p&gt;array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。&lt;/p&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;h3 id=&#34;iterators-1&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin/cbegin&lt;/li&gt;
&lt;li&gt;end/cend&lt;/li&gt;
&lt;li&gt;rbegin/c rbegin&lt;/li&gt;
&lt;li&gt;rend/c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-1&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;length&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;li&gt;reserve&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;shrink_to_fit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;element-access-1&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-1&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;+=&lt;/li&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;li&gt;push_back&lt;/li&gt;
&lt;li&gt;assign&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;pop_back&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;关联容器&#34;&gt;关联容器&lt;/h1&gt;
&lt;h2 id=&#34;set&#34;&gt;set&lt;/h2&gt;
&lt;h3 id=&#34;iterators-2&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin / cbegin&lt;/li&gt;
&lt;li&gt;end / cend&lt;/li&gt;
&lt;li&gt;rbegin / c rbegin&lt;/li&gt;
&lt;li&gt;rend / c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-2&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-2&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;emplace_hint&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lookup&#34;&gt;Lookup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;contains&lt;/li&gt;
&lt;li&gt;equal_range&lt;/li&gt;
&lt;li&gt;lower_bound&lt;/li&gt;
&lt;li&gt;upper_bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;
&lt;h3 id=&#34;element-accress&#34;&gt;Element accress&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator &lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iterators-3&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin / cbegin&lt;/li&gt;
&lt;li&gt;end / cend&lt;/li&gt;
&lt;li&gt;rbegin / c rbegin&lt;/li&gt;
&lt;li&gt;rend / c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-3&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-3&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;insert_or_assign&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;emplace_hint&lt;/li&gt;
&lt;li&gt;try_emplace&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lookup-1&#34;&gt;Lookup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;contains&lt;/li&gt;
&lt;li&gt;equal_range&lt;/li&gt;
&lt;li&gt;lower_bound&lt;/li&gt;
&lt;li&gt;upper_bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;multimap&#34;&gt;multimap&lt;/h2&gt;
&lt;p&gt;允许多个多个元素具有相同的关键词。主要应用有：例如词典中一个单词可以有多个意思。&lt;/p&gt;
&lt;h2 id=&#34;multiset&#34;&gt;multiset&lt;/h2&gt;
&lt;h2 id=&#34;unordered_map&#34;&gt;unordered_map&lt;/h2&gt;
&lt;p&gt;无序容器不使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器非常有用。某些应用中维护元素序的代价非常高昂，此时无序容器也很有用。&lt;/p&gt;
&lt;h2 id=&#34;unordered_set&#34;&gt;unordered_set&lt;/h2&gt;
&lt;h2 id=&#34;unordered_multimap&#34;&gt;unordered_multimap&lt;/h2&gt;
&lt;h2 id=&#34;unordered_multimet&#34;&gt;unordered_multimet&lt;/h2&gt;
&lt;h1 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h1&gt;
&lt;h2 id=&#34;priority_queue&#34;&gt;priority_queue&lt;/h2&gt;
&lt;h3 id=&#34;element-access-2&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-4&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-4&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stack&#34;&gt;stack&lt;/h2&gt;
&lt;p&gt;与priority_queue相同。&lt;/p&gt;
&lt;h2 id=&#34;queue&#34;&gt;queue&lt;/h2&gt;
&lt;h3 id=&#34;element-access-3&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-5&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-5&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;list-1&#34;&gt;list&lt;/h2&gt;
- https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C程序字节对齐方式</title>
        <link>https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</link>
        <pubDate>Tue, 14 Dec 2021 16:38:12 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/ -&lt;h2 id=&#34;默认字节对齐&#34;&gt;默认字节对齐&lt;/h2&gt;
&lt;p&gt;int类型放在地址能被4整除的位置，short类型放在地址能被2整除的位置，char能放在任何位置。&lt;/p&gt;
&lt;p&gt;结构体的对其满足以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体变量的首地址能够被其最宽基本类型成员的大小所整除。&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间填充字节。&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员后填充字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pragma-pack命令&#34;&gt;#pragma pack()命令&lt;/h2&gt;
&lt;p&gt;改命令强制规定了成员的对齐方式，括号内为对齐的字节数。若括号内的内容为空，则为默认对齐。&lt;/p&gt;
&lt;p&gt;改变默认对齐方式能够更加充分利用存储空间，但降低了计算机的读写速率，是一种以空间换事件的方法。&lt;/p&gt;
- https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp：7.链接</title>
        <link>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</link>
        <pubDate>Sat, 11 Dec 2021 21:38:11 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/ -&lt;p&gt;链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载到内存并执行。&lt;/p&gt;
&lt;p&gt;链接可以执行于编译时、加载时、运行时。&lt;/p&gt;
&lt;p&gt;链接使得分离编译成为可能。可以将巨大的源文件分解为更小的模块，可以独立地修改和编译这些模块。当我们改变其中的一个模块时，只需简单地将其重新编译并链接，无需重新编译其他文件。&lt;/p&gt;
&lt;p&gt;理解链接器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助构造大型程序&lt;/li&gt;
&lt;li&gt;避免一些危险的编程错误。例如错误地定义多个全局变量的程序将通过链接器，不产生任何警告。&lt;/li&gt;
&lt;li&gt;理解语言的作用域规则。如：全局和局部变量的区别；static属性的变量和函数的意义。&lt;/li&gt;
&lt;li&gt;帮助理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色。&lt;/li&gt;
&lt;li&gt;帮助我们利用共享库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器驱动程序&#34;&gt;编译器驱动程序&lt;/h2&gt;
&lt;p&gt;编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。例如我们经常使用的gcc驱动程序。&lt;/p&gt;
&lt;p&gt;main.c$\rightarrow$main.i$\rightarrow$main.s$\rightarrow$main.o$\rightarrow$prog&lt;/p&gt;
&lt;p&gt;源程序$\rightarrow$中间文件$\rightarrow$汇编语言文件$\rightarrow$&lt;strong&gt;可重定位目标文件&lt;/strong&gt;$\rightarrow$&lt;strong&gt;可执行目标文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次使用了：预处理器、编译器、汇编器 、链接器&lt;/p&gt;
&lt;p&gt;shell执行可执行文件时调用操作系统中的加载器函数，将prog中的代码和数据复制到内存中，然后将控制转移到这个程序的开头。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;静态链接&#34;&gt;静态链接&lt;/h2&gt;
&lt;p&gt;可重定位目标文件由不同的代码和数据节组成，每一节都是一个连续的字节序列。&lt;/p&gt;
&lt;p&gt;静态链接器以一组&lt;strong&gt;可重定位目标文件和命令行参数&lt;/strong&gt;作为输入，生成一个&lt;strong&gt;完全链接的、可以加载和运行的可执行目标文件&lt;/strong&gt;作为输出。&lt;/p&gt;
&lt;p&gt;为了构造可执行文件，链接器必须完成连个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符号解析&lt;/strong&gt;：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。将每个符号引用正好和一个符号定义关联起来。（每个符号对应于一个函数、一个全局变量或一个静态变量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定位&lt;/strong&gt;。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使它们指向这个内存位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目标文件&#34;&gt;目标文件&lt;/h2&gt;
&lt;p&gt;共有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重定位目标文件：二进制代码和数据，可在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。&lt;/li&gt;
&lt;li&gt;可执行目标文件：二进制代码和数据，其形式可以直接被复制到内存中并执行。&lt;/li&gt;
&lt;li&gt;共享目标文件：特殊类型的可重定位目标文件，可以在加载或运行时被&lt;strong&gt;动态地加载进内存并链接&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标文件是按照特定目标文件格式来组织的，各个系统的目标文件格式都不相同。&lt;/p&gt;
&lt;h2 id=&#34;可重定位目标文件&#34;&gt;可重定位目标文件&lt;/h2&gt;
&lt;p&gt;一个典型的ELF可重定位目标文件：&lt;/p&gt;
&lt;p&gt;首先是16B的ELF头，描述了生成该文件的系统的字的大小和字节顺序。&lt;/p&gt;
&lt;p&gt;然后是节：一个典型的ELF可重定位目标文件包含以下几个节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.text&lt;/code&gt;：已编译程序的机器代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rodata&lt;/code&gt;：只读数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：已初始化的全局和静态C变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.symtab&lt;/code&gt;：一个符号表，存放在程序中定义和引用的函数和全局变量的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.text&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.debug&lt;/code&gt;：调试符号表，以-g选项调用编译器驱动程序时才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.line&lt;/code&gt;：原始C程序的行号和&lt;code&gt;.text&lt;/code&gt;节中的机器指令之间的映射，以-g选项调用编译器驱动程序时才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.strtab&lt;/code&gt;：一个字符串表，其中内容包括&lt;code&gt;.symtab&lt;/code&gt;和&lt;code&gt;.debug&lt;/code&gt;节中的符号表，以及节头部中的节名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;符号和符号表&#34;&gt;符号和符号表&lt;/h2&gt;
&lt;p&gt;每个可重定位目标模块都有一个符号表&lt;code&gt;.symtab&lt;/code&gt;，它包含m定义和引用的符号的信息。在链接器的上下文，有三种不同符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由模块m定义并能被其他模块引用的全局符号：对应非静态的C函数和全局变量。&lt;/li&gt;
&lt;li&gt;由其他模块定义并被m引用的全局符号，称为外部符号：对应其他模块中定义的非静态的C函数和全局变量&lt;/li&gt;
&lt;li&gt;只被模块m定义和引用的局部符号：对应于带static属性的C函数和全局变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本地非静态程序变量的符号在运行时在&lt;strong&gt;栈中&lt;/strong&gt;被管理，不在符号表.symtab中。&lt;/p&gt;
&lt;p&gt;C中源文件扮演模块的角色，static属性就像C++使用的public和private一样。&lt;/p&gt;
&lt;p&gt;尽可能用static属性来保护变量和函数。&lt;/p&gt;
&lt;p&gt;符号表由汇编器构造，使用编译器输出到汇编语言&lt;code&gt;.s&lt;/code&gt;文件中的符号。&lt;code&gt;.symtab&lt;/code&gt;节中包含ELF符号表。以下为符号表中每个符号条目的格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; name;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;type&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,
		 &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;binding&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; reserved;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;short&lt;/span&gt; section;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; value;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; size;
} Elf64_Symbol;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符号的地址。对于可重定位目标文件来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时的地址。size是目标的大小。type通常代表数据或函数。符号表还可以包含各个节的条目。binding字段表示符号是本地还是全局。&lt;/p&gt;
&lt;p&gt;每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到节头部表的索引。&lt;/p&gt;
&lt;p&gt;以下是hello_world.c文件的符号表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
   printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;);
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Symbol table &#39;.symtab&#39; contains 70 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000318     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000338     0 SECTION LOCAL  DEFAULT    2 
     3: 0000000000000358     0 SECTION LOCAL  DEFAULT    3 
     4: 000000000000037c     0 SECTION LOCAL  DEFAULT    4 
     5: 00000000000003a0     0 SECTION LOCAL  DEFAULT    5 
     6: 00000000000003c8     0 SECTION LOCAL  DEFAULT    6 
     7: 0000000000000470     0 SECTION LOCAL  DEFAULT    7 
     8: 00000000000004f4     0 SECTION LOCAL  DEFAULT    8 
     9: 0000000000000508     0 SECTION LOCAL  DEFAULT    9 
    10: 0000000000000528     0 SECTION LOCAL  DEFAULT   10 
    11: 00000000000005e8     0 SECTION LOCAL  DEFAULT   11 
    12: 0000000000001000     0 SECTION LOCAL  DEFAULT   12 
    13: 0000000000001020     0 SECTION LOCAL  DEFAULT   13 
    14: 0000000000001040     0 SECTION LOCAL  DEFAULT   14 
    15: 0000000000001050     0 SECTION LOCAL  DEFAULT   15 
    16: 0000000000001060     0 SECTION LOCAL  DEFAULT   16 
    17: 00000000000011e8     0 SECTION LOCAL  DEFAULT   17 
    18: 0000000000002000     0 SECTION LOCAL  DEFAULT   18 
    19: 0000000000002014     0 SECTION LOCAL  DEFAULT   19 
    20: 0000000000002058     0 SECTION LOCAL  DEFAULT   20 
    21: 0000000000003db8     0 SECTION LOCAL  DEFAULT   21 
    22: 0000000000003dc0     0 SECTION LOCAL  DEFAULT   22 
    23: 0000000000003dc8     0 SECTION LOCAL  DEFAULT   23 
    24: 0000000000003fb8     0 SECTION LOCAL  DEFAULT   24 
    25: 0000000000004000     0 SECTION LOCAL  DEFAULT   25 
    26: 0000000000004010     0 SECTION LOCAL  DEFAULT   26 
    27: 0000000000000000     0 SECTION LOCAL  DEFAULT   27 
    28: 0000000000000000     0 SECTION LOCAL  DEFAULT   28 
    29: 0000000000000000     0 SECTION LOCAL  DEFAULT   29 
    30: 0000000000000000     0 SECTION LOCAL  DEFAULT   30 
    31: 0000000000000000     0 SECTION LOCAL  DEFAULT   31 
    32: 0000000000000000     0 SECTION LOCAL  DEFAULT   32 
    33: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    34: 0000000000001090     0 FUNC    LOCAL  DEFAULT   16 deregister_tm_clones
    35: 00000000000010c0     0 FUNC    LOCAL  DEFAULT   16 register_tm_clones
    36: 0000000000001100     0 FUNC    LOCAL  DEFAULT   16 __do_global_dtors_aux
    37: 0000000000004010     1 OBJECT  LOCAL  DEFAULT   26 completed.8061
    38: 0000000000003dc0     0 OBJECT  LOCAL  DEFAULT   22 __do_global_dtors_aux_fin
    39: 0000000000001140     0 FUNC    LOCAL  DEFAULT   16 frame_dummy
    40: 0000000000003db8     0 OBJECT  LOCAL  DEFAULT   21 __frame_dummy_init_array_
    41: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello_world.c
    42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    43: 000000000000215c     0 OBJECT  LOCAL  DEFAULT   20 __FRAME_END__
    44: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
    45: 0000000000003dc0     0 NOTYPE  LOCAL  DEFAULT   21 __init_array_end
    46: 0000000000003dc8     0 OBJECT  LOCAL  DEFAULT   23 _DYNAMIC
    47: 0000000000003db8     0 NOTYPE  LOCAL  DEFAULT   21 __init_array_start
    48: 0000000000002014     0 NOTYPE  LOCAL  DEFAULT   19 __GNU_EH_FRAME_HDR
    49: 0000000000003fb8     0 OBJECT  LOCAL  DEFAULT   24 _GLOBAL_OFFSET_TABLE_
    50: 0000000000001000     0 FUNC    LOCAL  DEFAULT   12 _init
    51: 00000000000011e0     5 FUNC    GLOBAL DEFAULT   16 __libc_csu_fini
    52: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
    53: 0000000000004000     0 NOTYPE  WEAK   DEFAULT   25 data_start
    54: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    55: 00000000000011e8     0 FUNC    GLOBAL HIDDEN    17 _fini
    56: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.2.5
    57: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    58: 0000000000004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    59: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    60: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    61: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    62: 0000000000001170   101 FUNC    GLOBAL DEFAULT   16 __libc_csu_init
    63: 0000000000004018     0 NOTYPE  GLOBAL DEFAULT   26 _end
    64: 0000000000001060    47 FUNC    GLOBAL DEFAULT   16 _start
    65: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    66: 0000000000001149    32 FUNC    GLOBAL DEFAULT   16 main
    67: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    68: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    69: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;符号解析&#34;&gt;符号解析&lt;/h2&gt;
&lt;p&gt;链接器解析符号引用的方法是将&lt;strong&gt;每个引用&lt;/strong&gt;与它输入的可重定位目标文件的符号表中的一个确定的&lt;strong&gt;符号定义&lt;/strong&gt;关联起来。&lt;/p&gt;
&lt;p&gt;对于引用和定义在相同模块中的局部符号（即对应static变量）的引用，符号解析非常简洁明了。编译器只允许每个局部符号有一个定义。&lt;/p&gt;
&lt;p&gt;对于全局符号的引用较为复杂，当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表，交给链接器处理。如果链接器在其他任何模块中都找不到这个被引用的符号，就输出一条错误信息并终止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器通过重整的编码方式来区分重载的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;链接器解析多重定义的全局符号&#34;&gt;链接器解析多重定义的全局符号&lt;/h3&gt;
&lt;p&gt;编译器向汇编器输出每个全局符号，或是强或是弱的，而汇编器把这些信息隐含地编码在可重定位目标文件的符号表里。&lt;strong&gt;函数和已初始化的全局变量&lt;/strong&gt;是强符号，&lt;strong&gt;未初始化的全局变量&lt;/strong&gt;是弱符号。&lt;/p&gt;
&lt;p&gt;Linux使用以下规则处理多重定义的符号名：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许由多个同名强符号&lt;/li&gt;
&lt;li&gt;如果一个强符号和多个弱符号同名，选择强符号&lt;/li&gt;
&lt;li&gt;如果有多个弱符号同名，从这些弱符号中任意选一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与静态库链接&#34;&gt;与静态库链接&lt;/h3&gt;
&lt;p&gt;所有编译器都有一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，它可以用作链接器的输入。链接器构造一个输出的可执行文件时，只复制静态库里被应用程序引用的目标模块。&lt;/p&gt;
&lt;p&gt;Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小，存档文件名由后缀&lt;code&gt;.a&lt;/code&gt;标识。&lt;/p&gt;
&lt;h3 id=&#34;链接器如何使用静态库来解析引用&#34;&gt;链接器如何使用静态库来解析引用&lt;/h3&gt;
&lt;p&gt;链接器从左到右按照在命令行上出现的顺序来扫描可重定位目标文件和存档文件。（编译器驱动程序自动将&lt;code&gt;.c&lt;/code&gt;文件翻译为&lt;code&gt;.o&lt;/code&gt;文件。在扫描中，链接器维护一个&lt;strong&gt;可重定位目标文件的集合E&lt;/strong&gt;，一个&lt;strong&gt;未解析的符号集合U&lt;/strong&gt;，以及一个在前面输入文件中&lt;strong&gt;已定义的符号集合D&lt;/strong&gt;。初始时，E、U、D均为空。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果是目标文件则将其添加到E中，修改U和D来反映f中的符号引用和定义&lt;/li&gt;
&lt;li&gt;如果f是存档文件，链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m定义了一个符号来解析U中的一个引用，那么就把m加到E中，并修改U和D来反映m中的符号定义和引用。对存档文件依次重复这个过程直到U和D不发生变化。&lt;/li&gt;
&lt;li&gt;如果链接器完成对命令行输入文件的扫描后，U是非空的，则链接器输出错误并终止。否则，合并然后重定位E中的文件，构建可执行文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重定位&#34;&gt;重定位&lt;/h2&gt;
&lt;p&gt;链接器完成符号解析这一步后，就把代码中的每个符号引用和一个符号定义关联起来了，此时链接器就知道它的输入目标模块中的代码和数据节的确切大小。然后就可以开始重定位步骤了，该步骤将&lt;strong&gt;合并输入模块&lt;/strong&gt;，并为每个符号分配&lt;strong&gt;运行时地址&lt;/strong&gt;。共分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重定位节和符号定义&lt;/strong&gt;：链接器将所有相同类型的节合并为同一类型的聚合节。例如，来自所有输入模块的.data节被全部合并为一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，付给输入模块定义的每个节、每个符号。这一步完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定位节中的符号引用&lt;/strong&gt;：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重定位条目&#34;&gt;重定位条目&lt;/h3&gt;
&lt;p&gt;汇编器生成一个目标模块是，它并不知道数据和代码最终将放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数或全局变量的位置。所以无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化的数据的重定位条目放在.rel.data中。&lt;/p&gt;
&lt;p&gt;ELF定义了32种不同的重定位类型，我们只关心之中两种最基本的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R_X86_64_PC32&lt;/code&gt;：重定位一个使用32位PC相对地址的引用。PC相对地址就是据程序计数器当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R_X86_64_32&lt;/code&gt;：重定位一个使用32位绝对地址的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重定位符号引用&#34;&gt;重定位符号引用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;重定位PC相对引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重定位PC绝对引用&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;可执行目标文件&#34;&gt;可执行目标文件&lt;/h2&gt;
&lt;p&gt;转化后的&lt;strong&gt;二进制&lt;/strong&gt;的可执行目标文件包含加载程序到内存并运行它所需的所有信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201111656939.png&#34; alt=&#34;ELF可执行目标文件结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;可执行目标文件格式类似于可重定位目标文件，ELF头描述文件的总体格式，还包括程序的入口点，即程序要运行时执行的第一条指令的地址。&lt;code&gt;.init&lt;/code&gt;节定义了一个小函数&lt;code&gt;_init&lt;/code&gt;，程序初始化代码会调用它。&lt;/p&gt;
&lt;p&gt;以下为hello_world可执行文件的ELF头描述文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;ELF Header:
  Magic:   7f &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;45&lt;/span&gt; 4c &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;46&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;02&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;01&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;00&lt;/span&gt; 
  Class:                             ELF64
  Data:                              2&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;&amp;#39;&lt;/span&gt;s complement, little endian
  Version:                           &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;current&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  OS/ABI:                            UNIX - System V
  ABI Version:                       &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;
  Type:                              DYN &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Shared object file&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
  Start of program headers:          &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;bytes into file&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  Start of section headers:          &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;16984&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;bytes into file&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  Flags:                             0x0
  Size of this header:               &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;bytes&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  Size of program headers:           &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;56&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;bytes&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  Number of program headers:         &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;13&lt;/span&gt;
  Size of section headers:           &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;bytes&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
  Number of section headers:         &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;36&lt;/span&gt;
  Section header string table index: &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;35&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可执行文件是完全链接的（已经被重定位），所以它不需要rel节。&lt;/p&gt;
&lt;p&gt;ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片被映射到&lt;strong&gt;连续的内存段&lt;/strong&gt;，程序段头部表描述了这种映射关系：&lt;/p&gt;
&lt;h2 id=&#34;加载可执行目标文件&#34;&gt;加载可执行目标文件&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;shell认为prog是一个可执行目标文件，通过调用驻留在存储器中的&lt;strong&gt;加载器&lt;/strong&gt;的系统代码来运行它。加载器将可执行目标文件中的代码和数据从磁盘复制到内存，然后通过跳转到程序的入口点运行该程序。这整个过程叫做加载。&lt;/p&gt;
&lt;p&gt;每个Linux程序都有一个运行时内存映像。在Linux x86-64中，代码段总是从地址0x400000开始，后面是数据段。运行时堆在数据段之后，通过调用&lt;code&gt;malloc&lt;/code&gt;库向上增长。&lt;strong&gt;堆&lt;/strong&gt;后面的区域是为&lt;strong&gt;共享模块&lt;/strong&gt;保留的。用户&lt;strong&gt;栈&lt;/strong&gt;总是从最大合法地址($2^{48}-1$)开始，向较小内存地址增长。栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202112242026815.png&#34; alt=&#34;image-20211224202617709&#34;&gt;&lt;/p&gt;
&lt;p&gt;加载与之后章节的进程、虚拟内存和内存映射有关。之后章节还会介绍。&lt;/p&gt;
&lt;h2 id=&#34;动态链接共享库&#34;&gt;动态链接共享库&lt;/h2&gt;
&lt;p&gt;静态库有一个缺点，需要定期维护和更新，如果应用程序需要一个&lt;strong&gt;新版本&lt;/strong&gt;，必须以某种方式了解到该库的变化情况，然后显式地将其程序与更新了的库重新链接。&lt;/p&gt;
&lt;p&gt;另一个问题是几乎每个C程序都使用&lt;strong&gt;标准I/O函数&lt;/strong&gt;。运行时这些代码会被复制到每个运行进程的文本中，在一个上百个进程的系统上，这是对内存资源的极大浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享库&lt;/strong&gt;用来解决静态库的缺陷，共享库是一个目标模块，在&lt;strong&gt;运行或加载时&lt;/strong&gt;，可以加载到任意内存地址，并与一个在内存中的程序链接起来。这个过程称为&lt;strong&gt;动态链接&lt;/strong&gt;，由叫做动态链接器的程序执行。Linux中用&lt;code&gt;.so&lt;/code&gt;后缀的文件来表示共享库，Windows中使用&lt;code&gt;.dll&lt;/code&gt;表示。&lt;/p&gt;
&lt;p&gt;下图为动态链接共享库的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201261537772.png&#34; alt=&#34;动态链接共享库&#34;&gt;&lt;/p&gt;
&lt;p&gt;任何给定文件系统中，对于一个库文件只有一个&lt;code&gt;.so&lt;/code&gt;文件。所有引用该库的可执行目标文件共享这个&lt;code&gt;.so&lt;/code&gt;文件中的数据和代码，不需要都复制和嵌入到引用它们的可执行文件中。&lt;/p&gt;
&lt;p&gt;在内存中，一个共享库的&lt;code&gt;.text&lt;/code&gt;节的一个副本可以被不同的正在运行的进程共享。第9章虚拟内存的内容中将更加详细地描述。&lt;/p&gt;
&lt;h2 id=&#34;从应用程序中加载和链接共享库&#34;&gt;从应用程序中加载和链接共享库&lt;/h2&gt;
&lt;p&gt;应用程序除了在被加载后执行前加载和链接某个共享库，还可能在&lt;strong&gt;运行时&lt;/strong&gt;要求动态链接器加载和链接某个共享库，无需在编译时将那些库链接到应用中。&lt;/p&gt;
&lt;p&gt;现实中动态链接的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分发软件：Windows应用开发者常使用动态库来分发软件更新，用户只要下载共享库的新版本然后替换当前版本即可。&lt;/li&gt;
&lt;li&gt;构建高性能Web服务器：将每个生成动态内容的函数打包在共享库中。当一个来自Web浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;位置无关代码&#34;&gt;位置无关代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可以加载而无需重定位&lt;/strong&gt;的代码称为位置无关代码（Position Independent Code, PIC）。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。&lt;strong&gt;共享库的编译&lt;/strong&gt;必须总是使用该选项。&lt;/p&gt;
&lt;h3 id=&#34;pic数据引用&#34;&gt;PIC数据引用&lt;/h3&gt;
&lt;h3 id=&#34;pic函数调用&#34;&gt;PIC函数调用&lt;/h3&gt;
&lt;h2 id=&#34;库打桩机制&#34;&gt;库打桩机制&lt;/h2&gt;
&lt;p&gt;库打桩允许我们&lt;strong&gt;截获对共享库函数的调用&lt;/strong&gt;，取而代之执行自己的代码。使用该机制可以追踪&lt;strong&gt;对某个特殊库函数的调用次数&lt;/strong&gt;，验证和追踪其输入输出值，或将其替换为一个完全不同的实现。&lt;/p&gt;
&lt;p&gt;给定一个需要打桩的目标函数，创建一个包装函数，其原型与目标函数完全相同，使用某种特殊打桩机制，就可以欺骗系统调用包装函数而不是目标函数。&lt;/p&gt;
&lt;p&gt;打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。&lt;/p&gt;
&lt;h3 id=&#34;编译时打桩&#34;&gt;编译时打桩&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//int.c
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; malloc(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt;);
    free(p);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//malloc.h
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#define malloc(size) mymalloc(size)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define free(ptr) myfree(ptr)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mymalloc&lt;/span&gt;(size_t size);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;myfree&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//mymalloc.c
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//#define COMPILETIME
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#ifdef COMPILETIME
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mymalloc&lt;/span&gt;(size_t size) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; malloc(size);
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;malloc(%d)=%p&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;)size, ptr);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr;
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;myfree&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr) {
    free(ptr);
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;free(%p)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, ptr);
}
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ gcc -DCOMPILETIME -c mymalloc.c
$ gcc -I. -o intc int.c mymalloc.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行程序&lt;code&gt;intc&lt;/code&gt;得到结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ ./intc
malloc&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;32&lt;span style=&#34;color:#333&#34;&gt;)=&lt;/span&gt;0x561e0ca432a0
free&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;0x561e0ca432a0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;链接时打桩&#34;&gt;链接时打桩&lt;/h3&gt;
&lt;p&gt;Linux静态链接器支持用&lt;code&gt;--wrap f&lt;/code&gt;标志进行链接时打桩。&lt;/p&gt;
&lt;h3 id=&#34;运行时打桩&#34;&gt;运行时打桩&lt;/h3&gt;
&lt;p&gt;编译时打桩需要访问源程序，链接时打桩需要访问程序的可重定位目标文件。有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个机制基于动态链接器的LD_PRELOAD环境变量。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——TopK问题总结</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
        <pubDate>Sat, 11 Dec 2021 10:18:53 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/ -&lt;p&gt;从具有n个数的数组中，找出最大的k数。&lt;/p&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;p&gt;将整个数组排序，取出前k大个数。&lt;/p&gt;
&lt;p&gt;时间复杂度：$O(n\log_2 n)$&lt;/p&gt;
&lt;p&gt;优化方法：只排序最大的k个数&lt;/p&gt;
&lt;h2 id=&#34;局部排序&#34;&gt;局部排序&lt;/h2&gt;
&lt;p&gt;进行k次冒泡排序，得到最大的k个数&lt;/p&gt;
&lt;p&gt;时间复杂度：$O(n\cdot k)$&lt;/p&gt;
&lt;p&gt;优化方法：只找出最大的k个数，不对它们进行排序&lt;/p&gt;
&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;
&lt;p&gt;先用前k个元素生成一个小根堆，接着从第k+1个元素开始扫描，与堆顶元素进行比较，若被扫描元素大于堆顶，则将其替换，然后调整堆。&lt;/p&gt;
&lt;p&gt;时间复杂度：$O(n\log_2 k)$&lt;/p&gt;
&lt;h2 id=&#34;随机选择&#34;&gt;随机选择&lt;/h2&gt;
&lt;p&gt;减治法，使用快速排序中的partition找到第k大元素，递归时当前半部分小于k时就求后半部分第k-i大元素，当前半部分大于k时就求前半部分第k大元素。&lt;/p&gt;
&lt;p&gt;时间复杂度为$O(n)$&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278&#34;&gt;拜托，面试别再问我TopK了！！！&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——基础查找算法实现</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 11 Dec 2021 09:49:24 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/ -&lt;h2 id=&#34;二分查找&#34;&gt;二分查找&lt;/h2&gt;
&lt;p&gt;只能在有序数组中进行二分查找。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;binarySearch&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {\
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt; high) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; high) &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[mid] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; k)
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;true&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; {
			binarySearch(nums, k, low, mid &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);
            binarySearch(nums, k, mid &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, high);
        }
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;二叉查找树&#34;&gt;二叉查找树&lt;/h2&gt;
&lt;p&gt;查找、插入都非常简单。&lt;/p&gt;
&lt;h2 id=&#34;平衡查找树&#34;&gt;平衡查找树&lt;/h2&gt;
&lt;p&gt;2-3树和红黑树，详见&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/&#34;&gt;算法——红黑树&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;散列表&#34;&gt;散列表&lt;/h2&gt;
&lt;h3 id=&#34;散列函数的构造方法&#34;&gt;散列函数的构造方法&lt;/h3&gt;
&lt;p&gt;构造散列函数时的注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;散列函数的定义域要包含&lt;strong&gt;全部的关键字&lt;/strong&gt;，而值域范围则依赖于散列表大小或地址范围。&lt;/li&gt;
&lt;li&gt;散列函数计算出的地址应该能&lt;strong&gt;等概率、均匀地&lt;/strong&gt;分布在整个地址空间中&lt;/li&gt;
&lt;li&gt;散列函数应&lt;strong&gt;尽量简单&lt;/strong&gt;，能在&lt;strong&gt;较短时间内计算出&lt;/strong&gt;任一关键字对应的散列地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;直接定址法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接取关键字的某个线性函数值为散列地址，散列函数为：
$$
H(key)=key或H(key)=a\times key +b
$$
这种方法较为简单且不会产生冲突，适合关键字分布基本连续的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除留余数法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种最简单、最常用的方法。假定散列表表厂为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址：
$$
\text{H(key)=key%p}
$$
该方法的关键是选好p。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字分析法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平方取中法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取关键字的平方值的中间几位作为散列地址。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。&lt;/p&gt;
&lt;h3 id=&#34;处理冲突的方法&#34;&gt;处理冲突的方法&lt;/h3&gt;
&lt;p&gt;发生冲突时的处理方法，即为产生冲突的关键字寻找&lt;strong&gt;下一个空的Hash地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开放定址法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开放定址法指的是&lt;strong&gt;可存放新表项的空闲地址&lt;/strong&gt;既向它的&lt;strong&gt;同义&lt;/strong&gt;表项开放，又向它的&lt;strong&gt;非同义&lt;/strong&gt;词表项开放。数学递推公式为：
$$
H_i=(H(key)+d_i)%m
$$
$H(key)$为散列函数；i=0,1,2,&amp;hellip;,k；$m$表示散列表表长；$d_i$为增量序列。&lt;/p&gt;
&lt;p&gt;取定某一增量序列后，对应处理方法就确定了，通常有以下四种取法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测法&lt;/strong&gt;：$d_i=0,1,2,&amp;hellip;,m-1$。冲突发生时，顺序查看表中&lt;strong&gt;下一个单元&lt;/strong&gt;，直到找出一个空闲地址或查遍全表。这种方法可能会造成大量元素在&lt;strong&gt;相邻散列地址上的聚集&lt;/strong&gt;，大大降低了查找效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平方探测法&lt;/strong&gt;：$d_i=0^2,1^2,-1^2,2^2,-2^2,&amp;hellip;,k^2,-k^2$。其中$k\leq m/2$，散列表m的长度m必须是一个可以表示成4k+3的素数。平方探测法可以&lt;strong&gt;避免堆积&lt;/strong&gt;，但是不能探测到散列表上的所有单元。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再散列法&lt;/strong&gt;：$d_i=Hash_2(key)$。需要使用&lt;strong&gt;两个散列函数&lt;/strong&gt;。利用第二个散列函数计算该关键字的地址增量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伪随机序列法&lt;/strong&gt;：$d_i=伪随机序列$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;拉链法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有的同义词存储在&lt;strong&gt;一个线性链表&lt;/strong&gt;中，这个线性链表由其散列地址唯一标识。这种方法适用于&lt;strong&gt;经常进行插入和删除&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;h3 id=&#34;性能分析&#34;&gt;性能分析&lt;/h3&gt;
&lt;p&gt;查找的时间为$O(1)$.&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——B树和B&#43;树</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb&#43;%E6%A0%91/</link>
        <pubDate>Fri, 10 Dec 2021 18:03:30 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb&#43;%E6%A0%91/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb&#43;%E6%A0%91/ -&lt;h2 id=&#34;b树&#34;&gt;B树&lt;/h2&gt;
&lt;p&gt;平衡树算法的扩展，支持对保存在磁盘或网络上的符号表进行外部查找。&lt;/p&gt;
&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;
&lt;p&gt;又称&lt;strong&gt;多路平衡查找树&lt;/strong&gt;，B树中&lt;strong&gt;所有结点的孩子个数的最大值&lt;/strong&gt;称为&lt;strong&gt;B数的阶&lt;/strong&gt;，通常用&lt;strong&gt;m&lt;/strong&gt;表示。&lt;/p&gt;
&lt;p&gt;具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;树中每个结点至多有&lt;strong&gt;m棵子树&lt;/strong&gt;，即至多含有&lt;strong&gt;m-1个关键字&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若根结点不是终端结点，则至少有&lt;strong&gt;两颗&lt;/strong&gt;子树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有非叶子结点的结构：（见书上所示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有叶子结点都出现在同一层次上，并且不带信息。（可视为类似于折半查找判定树的查找失败结点，实际上这些结点不存在）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B树是所有结点的&lt;strong&gt;平衡因子均等于0&lt;/strong&gt;的&lt;strong&gt;多路平衡查找树&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;b树的高度磁盘存取次数&#34;&gt;B树的高度（磁盘存取次数）&lt;/h3&gt;
&lt;p&gt;一般只讲B树的前两层放入内存中，剩余层级全部放在磁盘中，因此B树的高度就约为每次进行查找的磁盘存取次数。&lt;/p&gt;
&lt;p&gt;首先明确B树的高度不包含最后的不带任何信息的叶结点所处的那一层。&lt;/p&gt;
&lt;p&gt;假设$n\ge 1$，则对于任意一棵包含n个关键字，高度为h、阶数为m的B树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据树中关键字个数计算高度满足的范围&lt;/li&gt;
&lt;li&gt;若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树高度达到最大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b树的查找&#34;&gt;B树的查找&lt;/h3&gt;
&lt;p&gt;每个结点具有多路分支。&lt;/p&gt;
&lt;p&gt;与二叉树的查找很相似，只是每个结点都是多个关键字的有序表，要在每个结点上根据该结点的子树做多路分支决定。&lt;/p&gt;
&lt;p&gt;包含两个基本操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在B树中找结点&lt;/li&gt;
&lt;li&gt;在结点内找关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B树常&lt;strong&gt;存储在磁盘中&lt;/strong&gt;，因此前一个查找操作是在&lt;strong&gt;磁盘&lt;/strong&gt;上进行的，后一个查找操作是在&lt;strong&gt;内存&lt;/strong&gt;中进行的，即在找到目标结点后，将其读入内存，然后在结点内采用&lt;strong&gt;顺序或折半&lt;/strong&gt;查找方法查找。&lt;/p&gt;
&lt;h3 id=&#34;b树的插入&#34;&gt;B树的插入&lt;/h3&gt;
&lt;p&gt;将关键字插入B树的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定位&lt;/strong&gt;：利用前述的B树查找算法，找出插入该关键字的最低层中的某个非叶结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入&lt;/strong&gt;：每个非失败结点的关键字个数都在区间$[\lceil m/2\rceil-1,m-1]$内，插入后的结点关键字个数小于m，则可以直接插入；插入后的结点关键字大于m-1时，必须对结点进行&lt;strong&gt;分裂&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分裂的方法：取一个新结点，在插入key后的原结点，从中间位置（$\lceil m/2\rceil$）将其中的关键字分为两部分，左半部分包含的关键字放入&lt;strong&gt;原结点&lt;/strong&gt;中，右半部分包含的关键字放入&lt;strong&gt;新结点&lt;/strong&gt;中，中间位置（$\lceil m/2\rceil$）的结点插入&lt;strong&gt;原结点的父结点&lt;/strong&gt;中；如果父结点关键字个数也超过了上限，则继续&lt;strong&gt;进行这种分裂操作&lt;/strong&gt;，知道这个过程传到根结点为止，进而使得&lt;strong&gt;B树的高度增1&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;b树的删除&#34;&gt;B树的删除&lt;/h3&gt;
&lt;p&gt;与插入的操作类似，即要使得删除后结点中关键字的个数$\ge \lceil m/2\rceil-1$，将会涉及&lt;strong&gt;结点的合并&lt;/strong&gt;问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当被删除关键字k&lt;strong&gt;不在终端结点&lt;/strong&gt;：可以用k的前驱和后继替代k，然后在相应结点中删除该前驱或后继。该前驱或后继必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。&lt;/li&gt;
&lt;li&gt;当被删除结点&lt;strong&gt;在终端结点&lt;/strong&gt;中时，有以下三种情况：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接删除关键字&lt;/strong&gt;。即被删除关键字所在结点的关键字个数$\ge \lceil m/2\rceil$，表明删除后仍满足B树定义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟够接&lt;/strong&gt;。被删除前所在结点关键字个数$= \lceil m/2\rceil-1$，且与此结点相邻的兄弟结点的关键字个数$\ge \lceil m/2\rceil$，需要通过父子换位法进行调整，达到新的平衡。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟不够借&lt;/strong&gt;。被删除前所在结点关键字个数$= \lceil m/2\rceil-1$，且与此结点相邻的兄弟结点的关键字个数$= \lceil m/2\rceil -1$，则要将关键字删除后与左右兄弟结点及双亲结点中的关键字进行合并。合并过程中双亲结点中关键字会-1，若其双亲结点是根结点且关键字个数减少为0，则直接将根结点删除，合并后的新结点成为根结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细例子见书上。&lt;/p&gt;
&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;
&lt;p&gt;在实际应用中对于适当的阶数M，查找的成本是常数级别的。&lt;/p&gt;
&lt;h2 id=&#34;b树-1&#34;&gt;B+树&lt;/h2&gt;
&lt;p&gt;是B树的一种变形。一个&lt;strong&gt;m阶B+树&lt;/strong&gt;要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个分支结点&lt;strong&gt;最多有m棵子树&lt;/strong&gt;（孩子结点）&lt;/li&gt;
&lt;li&gt;非叶根节点至少有两棵子树，其他每个分支结点至少有$ \lceil m/2\rceil$棵子树。&lt;/li&gt;
&lt;li&gt;结点的&lt;strong&gt;子树个数与关键字个数相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;所有&lt;strong&gt;叶结点&lt;/strong&gt;包含&lt;strong&gt;全部关键字&lt;/strong&gt;及&lt;strong&gt;指向相应记录的指针&lt;/strong&gt;，叶结点中将关键字按大小顺序排序，并且相邻叶结点按大小顺序相互链接起来。&lt;/li&gt;
&lt;li&gt;所有分支结点只包含它的&lt;strong&gt;子结点中关键字的最大值&lt;/strong&gt;以及&lt;strong&gt;指向其子结点的指针&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/B%2B%E6%A0%91.jpg&#34; alt=&#34;B+树&#34;&gt;&lt;/p&gt;
&lt;p&gt;通常B+树有两个头指针：一个&lt;strong&gt;指向根结点&lt;/strong&gt;，另一个&lt;strong&gt;指向关键字最小的叶结点&lt;/strong&gt;。因此对B+树进行两种查找运算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从最小关键字开始的&lt;strong&gt;顺序查找&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从根结点开始的&lt;strong&gt;多路查找&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb&#43;%E6%A0%91/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——桶排序&amp;计数排序&amp;基数排序</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 09 Dec 2021 10:55:47 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/ -&lt;h2 id=&#34;桶排序bucket-sort&#34;&gt;桶排序（Bucket Sort）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将待排元素划分到不同的桶中。先扫描一遍序列，找出最大值max和最小值min，设桶的个数为k，则把区间[min, max]划分为k个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。&lt;/li&gt;
&lt;li&gt;对每个桶内的元素进行排序。一般使用快速排序。&lt;/li&gt;
&lt;li&gt;将各桶中的元素合并为一个大的有序序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当k接近于n时，桶排序的时间复杂度为O(n)，即桶越多，时间效率就越高。&lt;/p&gt;
&lt;h2 id=&#34;计数排序counting-sort&#34;&gt;计数排序（Counting Sort）&lt;/h2&gt;
&lt;p&gt;新建一个大小为maxValue-minValue+1的数组nums，然后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配。扫描一遍原始数组，以扫描到的当前值val减去1作为下标，将下标对应位置数组加1，即nums[val]++&lt;/li&gt;
&lt;li&gt;收集。顺序扫描一遍数组nums。数组的每个元素代表了按当前下标+1对应值的个数，将这些值收集起来放入新的数组就得到最终排序结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：nums=[2,1,3,1,5]，首先扫描一遍取最大值maxValue=5和最小值minValue=1，新建一个长度为5-1+1=5的数组nums：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配：得到nums=[2,1,1,0,1]，例如nums[0]表示值为0+minValue=1出现了两次。&lt;/li&gt;
&lt;li&gt;收集：得到结果，[1,1,2,3,5]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上是一种&lt;strong&gt;特殊的桶排序&lt;/strong&gt;。当桶的个数等于元素个数时就是计数排序。&lt;/p&gt;
&lt;h2 id=&#34;基数排序&#34;&gt;基数排序&lt;/h2&gt;
&lt;p&gt;基于关键字各位的大小进行排序。是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。&lt;/p&gt;
&lt;p&gt;共有&lt;strong&gt;最高位优先MSD&lt;/strong&gt;和&lt;strong&gt;最低位优先LSD&lt;/strong&gt;两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有待排序整数（注意，必须是非负整数）统一为位数相同的整数，位数较少的前面补零。一般用10进制，也可以用16进制甚至2进制。所以前提是能够找到最大值，得到最长的位数，设k进制下最长为位数为d。&lt;/li&gt;
&lt;li&gt;从最低位开始，依次进行一次稳定排序。这样从最低位一直到最高位排序完成以后，整个序列就变成了一个有序序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基数排序可以看作是多轮桶排序，每个数位上都进行一次桶排序。&lt;/p&gt;
&lt;p&gt;当使用2进制时， k=2 最小，位数 d 最大，时间复杂度 O(nd) 会变大，空间复杂度 O(n+k) 会变小。当用最大值作为基数时， k=maxV 最大， d=1 最小，此时时间复杂度 O(nd) 变小，但是空间复杂度 O(n+k) 会急剧增大，此时基数排序退化成了计数排序。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>TCP三次握手四次挥手详解</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Thu, 09 Dec 2021 09:31:30 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/ -&lt;h2 id=&#34;三次握手建立连接&#34;&gt;三次握手建立连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步：客户机的TCP向服务器的TCP发送连接请求报文段。该报文段的同步位&lt;strong&gt;SYN置为1&lt;/strong&gt;，同时选择一个初始序号&lt;strong&gt;seq=x&lt;/strong&gt;。SYN报文段&lt;strong&gt;不能携带数据&lt;/strong&gt;，但要&lt;strong&gt;消耗掉一个序号&lt;/strong&gt;。这是客户机进入&lt;strong&gt;SYN-SENT同步已发送&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;第二步：服务器的TCP收到连接请求后，如果同意建立连接，则向客户机发回确认，并为该TCP分配缓存和变量。在确认报文段中，&lt;strong&gt;SYN和ACK都置为1&lt;/strong&gt;，确认号是&lt;strong&gt;ack=x+1&lt;/strong&gt;，同时为自己选择一个初始序号&lt;strong&gt;seq=y&lt;/strong&gt;。确认报文&lt;strong&gt;不能携带数据&lt;/strong&gt;，但也要&lt;strong&gt;消耗一个序号&lt;/strong&gt;。此时服务器进入&lt;strong&gt;SYN-RCVD同步收到&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;第三步：客户机收到确认报文后，还要向服务器给出确认，并为该TCP连接&lt;strong&gt;分配缓存和变量&lt;/strong&gt;。确认报文段的&lt;strong&gt;ACK置为1&lt;/strong&gt;，确认号&lt;strong&gt;ack=y+1&lt;/strong&gt;，序号&lt;strong&gt;seq=x+1&lt;/strong&gt;.该报文段&lt;strong&gt;可以携带数据&lt;/strong&gt;，若&lt;strong&gt;不携带则不消耗序号&lt;/strong&gt;。此时TCP客户进程进入&lt;strong&gt;ESTABLISH已建立连接&lt;/strong&gt;状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三次握手的原因&#34;&gt;三次握手的原因&lt;/h3&gt;
&lt;p&gt;第一次客户端发送SYN-SENT后可能在网络中被阻塞，导致超时，客户端重新传输该报文，并与服务器建立连接，之后传输数据然后关闭连接。当被阻塞的连接到达服务器时，服务器认为这个一条新建立的连接，并向客户端发送ACK确认，但客户端将其丢弃，服务器接收不到回复，空等待，造成了资源的浪费。&lt;/p&gt;
&lt;p&gt;另一种说法：tcp三次握手只要是为了确认线路的连通，第一次客户端发送到服务端，那么服务端就可以知道客户端的发送没有问题，但客户端不知道服务器的情况，第二次服务器发送ACK给客户端，客户端收到了证明服务端的收发都没有问题的，但服务端不知道客户端的接收情况，所以第三次是客户端再回给服务器一个ACK，服务器收到后就可以确保客户端的收发没有问题。&lt;/p&gt;
&lt;h2 id=&#34;四次挥手关闭连接&#34;&gt;四次挥手关闭连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步：客户端TCP发送连接释放报文段，并&lt;strong&gt;停止发送数据&lt;/strong&gt;，终止位&lt;strong&gt;FIN置为1&lt;/strong&gt;，序号&lt;strong&gt;seq=u&lt;/strong&gt;，等于之前&lt;strong&gt;已经传送的数据的最后一个字节的序号加1&lt;/strong&gt;，FIN报文段即使&lt;strong&gt;不携带数据也要消耗一个序号&lt;/strong&gt;。此时TCP客户机进入&lt;strong&gt;FIN-WAIT-1状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第二步：服务器收到连接释放报文后即发出确认，确认号&lt;strong&gt;ack=u+1&lt;/strong&gt;，序号&lt;strong&gt;seq=v&lt;/strong&gt;，等于前面&lt;strong&gt;已经传输过的数据的最后一个字节的序号加1&lt;/strong&gt;。然后服务器进入&lt;strong&gt;CLOSE-WAIT状态&lt;/strong&gt;。此时从客户机到服务器的连接就释放了，TCP连接处于&lt;strong&gt;半关闭&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;第三步：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出&lt;strong&gt;FIN=1&lt;/strong&gt;的&lt;strong&gt;连接释放报文段&lt;/strong&gt;，该报文段的序号&lt;strong&gt;seq=w&lt;/strong&gt;（在半关闭的时候可能又传输了一些数据），还需重复上次已经发送的确认号&lt;strong&gt;ack=u+1&lt;/strong&gt;.此时服务器进入&lt;strong&gt;LAST-ACK状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第四步：客户机收到连接释放报文段后，要发送确认。把确认报文中的&lt;strong&gt;确认位ACK置为1&lt;/strong&gt;，确认号&lt;strong&gt;ack=w+1&lt;/strong&gt;，序号&lt;strong&gt;seq=u+1&lt;/strong&gt;。此时连接还未释放，要等到计时器的设置时间**2MSL（最长报文寿命）**后客户机才进入CLOSED状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;粘包&#34;&gt;粘包&lt;/h2&gt;
&lt;p&gt;应用层一次recv接收了多个send。原因是TCP协议是面向字节流的，无法区分边界，需要应用层协议去解决。可以通过在应用层为数据流加上特定标志开头。还有就是关闭Nagle协议。&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 