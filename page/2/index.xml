<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jialong's Blog</title><link>https://eternityqjl.github.io/blog2_public/</link><description>Recent content on Jialong's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2019-2021 By Jialong</copyright><lastBuildDate>Fri, 13 Aug 2021 16:15:00 +0800</lastBuildDate><atom:link href="https://eternityqjl.github.io/blog2_public/index.xml" rel="self" type="application/rss+xml"/><item><title>csapp: 1.计算机系统漫游</title><link>https://eternityqjl.github.io/blog2_public/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link><pubDate>Fri, 11 Jun 2021 12:18:22 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ -&lt;p>在本书中我们将会学习到一些使用技巧，比如如何避免由于&lt;strong>计算机表示数字的方式&lt;/strong>引起的错误；通过一些技巧&lt;strong>优化C代码&lt;/strong>，以充分利用现代处理器和存储器系统的设计；了解&lt;strong>编译器&lt;/strong>如何实现过程调用，利用这些知识避免&lt;strong>缓冲区溢出&lt;/strong>错误带来的安全漏洞；学习如何识别和避免&lt;strong>链接&lt;/strong>时的错误；如何编写Unix Shell、动态存储分配包、Web服务器；&lt;strong>并发&lt;/strong>带来的希望和陷阱，对于现在的单芯片集成多个处理器核心非常重要。&lt;/p>
&lt;p>我们通过围绕Hello程序执行时的整个生命周期来对系统进行学习：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#579">#include&lt;/span> &lt;span style="color:#579">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#579">
&lt;/span>&lt;span style="color:#579">&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>()
{
printf(&lt;span style="background-color:#fff0f0">&amp;#34;Hello, world&lt;/span>&lt;span style="color:#666;background-color:#fff0f0;font-weight:bold">\n&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;&lt;/span>);
&lt;span style="color:#080;font-weight:bold">return&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="信息就是位上下文">信息就是位+上下文&lt;/h2>
&lt;p>8位为一个字节。&lt;/p>
&lt;p>现代计算机系统使用ASCII标准来表示文本字符。即用一个&lt;strong>单字节&lt;/strong>大小的整数值表示一个符号。&lt;/p>
&lt;p>数字的机器表示是对真值的有限近似。&lt;/p>
&lt;h2 id="程序被翻译为不同的格式">程序被翻译为不同的格式&lt;/h2>
&lt;p>&lt;code>hello.c&lt;/code>中的每条C语句都会转换为一系列低级&lt;strong>机器语言&lt;/strong>指令。这些指令按照&lt;strong>可执行目标程序&lt;/strong>格式打包，以二进制磁盘文件的形式存放。&lt;/p>
&lt;p>编译系统：&lt;/p>
&lt;p>hello.c(源程序，文本) -&amp;gt; &lt;code>预处理器(cpp)&lt;/code> -&amp;gt; hello.i(修改了的源程序，文本) -&amp;gt; &lt;code>编译器(ccl)&lt;/code> -&amp;gt; hello.s(汇编程序，文本) -&amp;gt; &lt;code>汇编器&lt;/code> -&amp;gt; hello.o(可重定位目标程序，二进制) -&amp;gt; &lt;code>链接器&lt;/code> -&amp;gt; hello(可执行目标程序，二进制)&lt;/p>
&lt;ul>
&lt;li>预处理阶段：预处理器(cpp)根据以字符&lt;code>#&lt;/code>开头的命令，修改原始C程序。例如&lt;code>#include &amp;lt;stdio.h&amp;gt;&lt;/code>告诉预处理器读取系统头文件的内容，将其插入程序文本中，得到另一个C程序，以&lt;code>.i&lt;/code>为扩展名。&lt;/li>
&lt;li>编译阶段：编译器(ccl将&lt;code>hello.i&lt;/code>翻译为&lt;code>hello.s&lt;/code>，其包含了&lt;strong>汇编语言程序&lt;/strong>。&lt;/li>
&lt;li>汇编阶段：汇编器(as)将&lt;code>hello.s&lt;/code>翻译为&lt;strong>机器语言指令&lt;/strong>，将这些指令打包为&lt;strong>可重定位目标程序&lt;/strong>，将结果保存在&lt;code>hello.o&lt;/code>中，该文件为二进制文件。&lt;/li>
&lt;li>链接阶段：hello程序调用了printf函数，它是C编译器提供的标准C库中的一个函数，printf函数存在于一个名为&lt;code>printf.o&lt;/code>的单独预编译好的目标文件中，这个文件要以某种形式合并到我们的&lt;code>hello.o&lt;/code>程序中，链接器(ld)负责这种合并，合并后就得到了&lt;strong>可执行目标文件&lt;/strong>&lt;code>hello&lt;/code>，其可以被加载到内存中，由系统执行。&lt;/li>
&lt;/ul>
&lt;h2 id="编译器的工作方式">编译器的工作方式&lt;/h2>
&lt;p>有一些重要原因使得我们必须知道编译器的工作方式：&lt;/p>
&lt;ul>
&lt;li>优化程序性能。我们需要了解一些机器代码及编译器将不同C语句转化为机器代码的方式，例如一个switch语句是否总比一系列if-else语句高效。&lt;/li>
&lt;li>理解链接时出现的错误。&lt;/li>
&lt;li>避免安全漏洞。缓冲区溢出错误是大多网络和服务器安全漏洞的主要原因。&lt;/li>
&lt;/ul>
&lt;h2 id="处理器读取并解释储存在内存中的指令">处理器读取并解释储存在内存中的指令&lt;/h2>
&lt;p>要在Unix系统运行可执行目标文件hello，需要将文件名输入shell应用程序中：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">linux&amp;gt; ./hello
hello,world
linux&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="系统的硬件组成">系统的硬件组成&lt;/h3>
&lt;h4 id="总线">总线&lt;/h4>
&lt;p>贯穿整个系统，负责信息字节在各个部件之间传递。&lt;/p>
&lt;p>通常被设计为传送定长的字节块，即&lt;strong>字&lt;/strong>，字中的字节数（即字长）是基本的系统参数，如今大多数机器中字长为8字节(即64位)，4字节(32位)在逐渐被64位取代。&lt;/p>
&lt;h4 id="io设备">I/O设备&lt;/h4>
&lt;p>每个I/O设备通过&lt;strong>控制器或适配器&lt;/strong>与I/O总线相连，控制器为I/O设备本身或系统主板上的芯片组，适配器为插在主板插槽上的卡。&lt;/p>
&lt;h4 id="主存ram">主存RAM&lt;/h4>
&lt;p>临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。由一组&lt;strong>动态随机存取存储器(DRAM)&lt;strong>芯片组成。逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的&lt;/strong>地址&lt;/strong>(数组索引)，这些地址从零开始。&lt;/p>
&lt;h4 id="处理器">处理器&lt;/h4>
&lt;p>CPU是解释或执行存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备(&lt;strong>寄存器&lt;/strong>)，称为程序计数器(PC)，PC指向主存中的某条机器语言指令（即包含该指令的地址）。&lt;/p>
&lt;p>处理器在一直不停地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个简单的指令执行模型来操作的，这个模型是&lt;strong>指令集架构&lt;/strong>决定的。该模型中指令按照严格的顺序执行。执行一条指令包含一系列步骤，处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，循环操作。&lt;/p>
&lt;p>这样的简单操作并不多，主要围绕**主存、寄存器文件和ALU(算术逻辑单元)**进行。寄存器文件是一个小型存储设备，由一些单个字长的寄存器组成，ALU计算新的数据和地址值。CPU可能进行以下操作：&lt;/p>
&lt;ul>
&lt;li>加载：从主存读取一个字到寄存器&lt;/li>
&lt;li>存储：从寄存器赋值一个字到主存&lt;/li>
&lt;li>操作：将两个寄存器的内容复制到ALU，ALU对两个字进行算术运算，将结果存放到一个寄存器中&lt;/li>
&lt;li>跳转：从指令本身抽取一个字，将这个字复制到PC中&lt;/li>
&lt;/ul>
&lt;p>指令集架构：每条机器代码指令的效果&lt;/p>
&lt;p>微体系结构：处理器实际上是如何实现的&lt;/p>
&lt;h3 id="运行hello程序">运行hello程序&lt;/h3>
&lt;p>在键盘上输入&lt;code>.\hello&lt;/code>后，shell会将这些字符逐一读入寄存器，再将其存放到内存中。按下回车后，shell知道命令输入已经结束，将执行一系列指令加载hello文件，这些指令会将hello目标文件中的代码和数据从磁盘复制到主存，利用DMA(直接存储器存取)技术，可将数据不经过CPU直接从磁盘放入主存。&lt;/p>
&lt;p>目标文件hello被放入主存后，处理器就开始执行机器语言指令。&lt;/p>
&lt;h2 id="高速缓存">高速缓存&lt;/h2>
&lt;p>为了减少信息加载的时间，采用更小更快的存储设备作为数据或指令暂时的集结区域。处理器芯片上的L1高速缓存缓存的访问速度集合和访问寄存器文件一样快，容量更大的L2高速缓存通过特殊总线连接到寄处理器。高速缓存采用静态随机访问存储器（SRAM）技术实现。&lt;/p>
&lt;h2 id="存储器层次">存储器层次：&lt;/h2>
&lt;p>L0：寄存器&lt;/p>
&lt;p>L1：L1高速缓存（SRAM）&lt;/p>
&lt;p>L2：L2高速缓存（SRAM）&lt;/p>
&lt;p>L3：L3高速缓存（SRAM）&lt;/p>
&lt;p>L4：主存（DRAM）&lt;/p>
&lt;p>L5：本地磁盘&lt;/p>
&lt;p>L6：远程存储&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%BE%E4%BE%8B.PNG" alt="">&lt;/p>
&lt;p>如上图为我的电脑的三级缓存示意。&lt;/p>
&lt;h2 id="操作系统管理硬件">操作系统管理硬件&lt;/h2>
&lt;p>前面的shell程序和hello程序都依靠&lt;strong>操作系统&lt;/strong>提供的服务访问存储器。操作系统是应用程序和硬件之间的软件。&lt;/p>
&lt;p>操作系统的主要功能有：&lt;/p>
&lt;ul>
&lt;li>防止硬件被失控的应用程序滥用&lt;/li>
&lt;li>向应用程序提供简单的机制控制复杂又不同的低级硬件设备。&lt;/li>
&lt;/ul>
&lt;p>操作系统通过几个基本抽象概念：进程、虚拟内存和文件实现这些功能。&lt;/p>
&lt;p>文件是对I/O设备的抽象。&lt;/p>
&lt;p>虚拟内存是对主存和磁盘I/O设备的抽象。&lt;/p>
&lt;p>进程是对处理器、主存和磁盘I/O设备的抽象。&lt;/p>
&lt;h3 id="进程">进程&lt;/h3>
&lt;p>进程是操作系统对正在运行程序的一种抽象，一个系统可以同时运行多个进行，每个进程好像都在独占使用硬件。并发运行指的是多个不同程序进程指令交错运行。处理器通过在进程间切换来实现多个程序的并发运行，这种机制称为&lt;strong>上下文切换&lt;/strong>。&lt;/p>
&lt;p>操作系统保存跟踪进程运行所需要的所有状态信息，这种状态即为上下文。这些信息有很多，比如PC和寄存器文件的当前值。&lt;/p>
&lt;p>任何一个时刻，单处理器只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到新进程时，就会进行上下文切换。&lt;/p>
&lt;p>从一个进程到另一个进程的切换是操作系统内核（kernal）管理的。&lt;strong>内核&lt;/strong>是操作系统代码&lt;strong>常驻主存&lt;/strong>的部分。内核不是一个独立的进程，是系统管理全部进程所用的代码和数据结构的集合。&lt;/p>
&lt;h3 id="线程">线程&lt;/h3>
&lt;p>一个进程可以有多个成为线程的执行单元组成，每个线程都运行在进程的上下文中，共享同样的代码和全部数据。多线程相比多进程更容易共享数据。&lt;/p>
&lt;h3 id="虚拟内存">虚拟内存&lt;/h3>
&lt;p>虚拟内存为每个进程提供一个假象，即每个进程都在&lt;strong>独占地使用主存&lt;/strong>。每个进程看到内存都是一致的，成为虚拟地址空间。&lt;/p>
&lt;p>每个进程看到的虚拟地址由大量准确定义的&lt;strong>区&lt;/strong>构成，每个区都有专门的功能。以下从最低的地址逐步向上介绍：&lt;/p>
&lt;ul>
&lt;li>程序代码和数据：所有进程的代码是从同一固定地址开始，紧接着是和C全局变量对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。&lt;/li>
&lt;li>堆：当调用malloc和free这样的函数时，堆可以动态地扩展和收缩。&lt;/li>
&lt;li>共享库：是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。&lt;/li>
&lt;li>栈：编译器用它来实现函数调用，栈在程序执行期间可以动态扩展和收缩。&lt;/li>
&lt;li>内核虚拟内存：地址空间顶部区域是为内核保留的，不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数。&lt;/li>
&lt;/ul>
&lt;h3 id="文件">文件&lt;/h3>
&lt;p>文件就是字节序列，系统所有输入输出都是通过使用一小组成为Unix I/O的系统函数调用读写文件实现的。&lt;/p>
&lt;h2 id="系统之间利用网络通信">系统之间利用网络通信&lt;/h2>
&lt;p>网络是一个I/O设备，通过网络适配器连接到系统总线。&lt;/p>
&lt;h2 id="一些重要主题">一些重要主题&lt;/h2>
&lt;h3 id="并发和并行">并发和并行&lt;/h3>
&lt;p>并发：一个同时具有多个活动的系统&lt;/p>
&lt;p>并行：用并发使得一个系统运行得更快&lt;/p>
&lt;p>并行可以在计算机系统的多个抽象层次上运行。&lt;/p>
&lt;h4 id="线程级并发">线程级并发&lt;/h4>
&lt;h4 id="指令级并发">指令级并发&lt;/h4>
&lt;h4 id="单指令多数据并行">单指令、多数据并行&lt;/h4>
&lt;h3 id="计算机系统中抽象的重要性">计算机系统中抽象的重要性&lt;/h3>
&lt;p>文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，进程是对正在运行程序的抽象，虚拟机提供对整个计算机的抽象。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ - 2019-2021 By Jialong</description></item><item><title>cs231n——1.Nearest Neighbor Classifier</title><link>https://eternityqjl.github.io/blog2_public/posts/cs231n1-nearest-neighbor-classifier/</link><pubDate>Wed, 09 Jun 2021 17:41:44 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/cs231n1-nearest-neighbor-classifier/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/cs231n1-nearest-neighbor-classifier/ -&lt;p>图像分类规范化步骤：&lt;/p>
&lt;ul>
&lt;li>输入：输入带有不同标签的图像作为训练集&lt;/li>
&lt;li>学习：使用训练集学习每种类别的抽象特征&lt;/li>
&lt;li>评估：通过测试集评估分类器的质量。&lt;/li>
&lt;/ul>
&lt;h2 id="nearest-neighbor-classifier">Nearest Neighbor Classifier&lt;/h2>
&lt;p>CIFAR-10 dataset:&lt;/p>
&lt;ul>
&lt;li>10 classes (airplane, automobile, bird, etc)&lt;/li>
&lt;li>60,000 tiny images that are 32 pixels high and wide&lt;/li>
&lt;/ul>
&lt;p>k-NN通过将一张测试集图片与所有的训练集图片进行比较，预测结果。&lt;/p>
&lt;h3 id="l1-distance">L1 distance:&lt;/h3>
&lt;p>$$
d_{1}\left(I_{1}, I_{2}\right)=\sum_{p}\left|I_{1}^{p}-I_{2}^{p}\right|
$$&lt;/p>
&lt;p>将两张图片分别表示为$I_1, I_2$两个向量，使用L1距离来比较两张图片。&lt;/p>
&lt;p>通常使用准确率来评估分类器&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">Xtr, Ytr, Xte, Yte &lt;span style="color:#333">=&lt;/span> load_CIFAR10(&lt;span style="background-color:#fff0f0">&amp;#39;data/cifar10/&amp;#39;&lt;/span>) &lt;span style="color:#888"># a magic function we provide&lt;/span>
&lt;span style="color:#888"># flatten out all images to be one-dimensional&lt;/span>
Xtr_rows &lt;span style="color:#333">=&lt;/span> Xtr&lt;span style="color:#333">.&lt;/span>reshape(Xtr&lt;span style="color:#333">.&lt;/span>shape[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>], &lt;span style="color:#00d;font-weight:bold">32&lt;/span> &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">32&lt;/span> &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">3&lt;/span>) &lt;span style="color:#888"># Xtr_rows becomes 50000 x 3072&lt;/span>
Xte_rows &lt;span style="color:#333">=&lt;/span> Xte&lt;span style="color:#333">.&lt;/span>reshape(Xte&lt;span style="color:#333">.&lt;/span>shape[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>], &lt;span style="color:#00d;font-weight:bold">32&lt;/span> &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">32&lt;/span> &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">3&lt;/span>) &lt;span style="color:#888"># Xte_rows becomes 10000 x 3072&lt;/span>
nn &lt;span style="color:#333">=&lt;/span> NearestNeighbor() &lt;span style="color:#888"># create a Nearest Neighbor classifier class&lt;/span>
nn&lt;span style="color:#333">.&lt;/span>train(Xtr_rows, Ytr) &lt;span style="color:#888"># train the classifier on the training images and labels&lt;/span>
Yte_predict &lt;span style="color:#333">=&lt;/span> nn&lt;span style="color:#333">.&lt;/span>predict(Xte_rows) &lt;span style="color:#888"># predict labels on the test images&lt;/span>
&lt;span style="color:#888"># and now print the classification accuracy, which is the average number&lt;/span>
&lt;span style="color:#888"># of examples that are correctly predicted (i.e. label matches)&lt;/span>
&lt;span style="color:#007020">print&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#39;accuracy: &lt;/span>&lt;span style="background-color:#eee">%f&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;&lt;/span> &lt;span style="color:#333">%&lt;/span> ( np&lt;span style="color:#333">.&lt;/span>mean(Yte_predict &lt;span style="color:#333">==&lt;/span> Yte) )
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here is an implementation of a simple Nearest Neighbor classifier with the L1 distance that satisfies this template:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">numpy&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">np&lt;/span>
&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">NearestNeighbor&lt;/span>(&lt;span style="color:#007020">object&lt;/span>):
&lt;span style="color:#080;font-weight:bold">def&lt;/span> __init__(self):
&lt;span style="color:#080;font-weight:bold">pass&lt;/span>
&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">train&lt;/span>(self, X, y):
&lt;span style="background-color:#fff0f0">&amp;#34;&amp;#34;&amp;#34; X is N x D where each row is an example. Y is 1-dimension of size N &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#888"># the nearest neighbor classifier simply remembers all the training data&lt;/span>
self&lt;span style="color:#333">.&lt;/span>Xtr &lt;span style="color:#333">=&lt;/span> X
self&lt;span style="color:#333">.&lt;/span>ytr &lt;span style="color:#333">=&lt;/span> y
&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">predict&lt;/span>(self, X):
&lt;span style="background-color:#fff0f0">&amp;#34;&amp;#34;&amp;#34; X is N x D where each row is an example we wish to predict label for &amp;#34;&amp;#34;&amp;#34;&lt;/span>
num_test &lt;span style="color:#333">=&lt;/span> X&lt;span style="color:#333">.&lt;/span>shape[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>] &lt;span style="color:#888">#训练样本数量&lt;/span>
&lt;span style="color:#888"># lets make sure that the output type matches the input type&lt;/span>
Ypred &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>zeros(num_test, dtype &lt;span style="color:#333">=&lt;/span> self&lt;span style="color:#333">.&lt;/span>ytr&lt;span style="color:#333">.&lt;/span>dtype)
&lt;span style="color:#888"># loop over all test rows&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(num_test):
&lt;span style="color:#888"># find the nearest training image to the i&amp;#39;th test image&lt;/span>
&lt;span style="color:#888"># using the L1 distance (sum of absolute value differences)&lt;/span>
distances &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sum(np&lt;span style="color:#333">.&lt;/span>abs(self&lt;span style="color:#333">.&lt;/span>Xtr &lt;span style="color:#333">-&lt;/span> X[i,:]), axis &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>)
min_index &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>argmin(distances) &lt;span style="color:#888"># get the index with smallest distance&lt;/span>
Ypred[i] &lt;span style="color:#333">=&lt;/span> self&lt;span style="color:#333">.&lt;/span>ytr[min_index] &lt;span style="color:#888"># predict the label of the nearest example&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> Ypred
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用L1距离测试的准确率只有38.6%.&lt;/p>
&lt;h3 id="l2-distance">L2 distance&lt;/h3>
&lt;p>$$
d_{2}\left(I_{1}, I_{2}\right)=\sqrt{\sum_{p}\left(I_{1}^{p}-I_{2}^{p}\right)^{2}}
$$&lt;/p>
&lt;p>only replace a single line of code above:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">distances &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sqrt(np&lt;span style="color:#333">.&lt;/span>sum(np&lt;span style="color:#333">.&lt;/span>square(self&lt;span style="color:#333">.&lt;/span>Xtr &lt;span style="color:#333">-&lt;/span> X[i,:]), axis &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="k---nearest-neighbor-classifier">k - Nearest Neighbor Classifier&lt;/h2>
&lt;p>找到距离最近的k个图片，k个图片中数量最多的一个标签即为测试图片所分的类别。&lt;/p>
&lt;h2 id="validation-sets-for-hyperparameter-tuning">Validation sets for Hyperparameter tuning&lt;/h2>
&lt;p>有很多我们可以选择的距离函数，例如L1 norm, L2 norm等，这些选择称为&lt;/p>
&lt;p>Hyperparameter 。通常不能使用test set来调整Hyperparameter。Evaluate on the test set only a single time, at the very end.&lt;/p>
&lt;p>将训练集划分为一个小一些的训练集和一个验证集(validation set)。例如使用CIFAR-10数据集时将训练集分为49,000个训练集和1,000个验证集。&lt;/p>
&lt;p>验证集本质上是一个假的测试集，是用来调整Hyperparameter的。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># assume we have Xtr_rows, Ytr, Xte_rows, Yte as before&lt;/span>
&lt;span style="color:#888"># recall Xtr_rows is 50,000 x 3072 matrix&lt;/span>
Xval_rows &lt;span style="color:#333">=&lt;/span> Xtr_rows[:&lt;span style="color:#00d;font-weight:bold">1000&lt;/span>, :] &lt;span style="color:#888"># take first 1000 for validation&lt;/span>
Yval &lt;span style="color:#333">=&lt;/span> Ytr[:&lt;span style="color:#00d;font-weight:bold">1000&lt;/span>]
Xtr_rows &lt;span style="color:#333">=&lt;/span> Xtr_rows[&lt;span style="color:#00d;font-weight:bold">1000&lt;/span>:, :] &lt;span style="color:#888"># keep last 49,000 for train&lt;/span>
Ytr &lt;span style="color:#333">=&lt;/span> Ytr[&lt;span style="color:#00d;font-weight:bold">1000&lt;/span>:]
&lt;span style="color:#888"># find hyperparameters that work best on the validation set&lt;/span>
validation_accuracies &lt;span style="color:#333">=&lt;/span> []
&lt;span style="color:#080;font-weight:bold">for&lt;/span> k &lt;span style="color:#000;font-weight:bold">in&lt;/span> [&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">3&lt;/span>, &lt;span style="color:#00d;font-weight:bold">5&lt;/span>, &lt;span style="color:#00d;font-weight:bold">10&lt;/span>, &lt;span style="color:#00d;font-weight:bold">20&lt;/span>, &lt;span style="color:#00d;font-weight:bold">50&lt;/span>, &lt;span style="color:#00d;font-weight:bold">100&lt;/span>]:
&lt;span style="color:#888"># use a particular value of k and evaluation on validation data&lt;/span>
nn &lt;span style="color:#333">=&lt;/span> NearestNeighbor()
nn&lt;span style="color:#333">.&lt;/span>train(Xtr_rows, Ytr)
&lt;span style="color:#888"># here we assume a modified NearestNeighbor class that can take a k as input&lt;/span>
Yval_predict &lt;span style="color:#333">=&lt;/span> nn&lt;span style="color:#333">.&lt;/span>predict(Xval_rows, k &lt;span style="color:#333">=&lt;/span> k)
acc &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>mean(Yval_predict &lt;span style="color:#333">==&lt;/span> Yval)
&lt;span style="color:#007020">print&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#39;accuracy: &lt;/span>&lt;span style="background-color:#eee">%f&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;&lt;/span> &lt;span style="color:#333">%&lt;/span> (acc,)
&lt;span style="color:#888"># keep track of what works on the validation set&lt;/span>
validation_accuracies&lt;span style="color:#333">.&lt;/span>append((k, acc))
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cross-validation">Cross-validation&lt;/h3>
&lt;p>当训练集数量较少时，使用更为复杂的交叉验证来调整hyperparameter。我们通过迭代不同的验证集并平均计算这些验证集的结果来确定k。例如在5次迭代的交叉验证中，将训练集分为5份，使用4份训练，1份验证，然后改变验证集，迭代5次，最终使用5次的平均结果确定k。&lt;/p>
&lt;h2 id="nearest-neighbor-classifier的优缺点">Nearest Neighbor classifier的优缺点&lt;/h2>
&lt;p>验证时的时间成本较高，每个验证样本都要与每一个测试集样本进行比较，效率较低。&lt;/p>
&lt;p>Nearest Neighbor classifier在低维度训练中较为常用，但在图像分类中很少用，因为图像是高维对象，高维对象之间的距离计算式违反直觉的。&lt;/p>
&lt;h2 id="summery">Summery&lt;/h2>
&lt;ol>
&lt;li>如果数据的维数很高，可以使用降维技术，例如PCA(主成分分析), NCA(邻域成分分析) or Random Projections(随机投影).&lt;/li>
&lt;/ol>
- https://eternityqjl.github.io/blog2_public/posts/cs231n1-nearest-neighbor-classifier/ - 2019-2021 By Jialong</description></item><item><title>Python基础和numpy</title><link>https://eternityqjl.github.io/blog2_public/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</link><pubDate>Sun, 06 Jun 2021 13:04:49 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/ -&lt;h2 id="basic-of-python">Basic of Python&lt;/h2>
&lt;h3 id="basic-data-types">Basic data types&lt;/h3>
&lt;h4 id="numbers">Numbers&lt;/h4>
&lt;h4 id="bolleans">Bolleans&lt;/h4>
&lt;h4 id="strings">Strings&lt;/h4>
&lt;h3 id="containers">Containers&lt;/h3>
&lt;h4 id="lists">Lists&lt;/h4>
&lt;h4 id="slicing">Slicing&lt;/h4>
&lt;h4 id="loops">Loops&lt;/h4>
&lt;h4 id="dictionaries">Dictionaries&lt;/h4>
&lt;p>key-value&lt;/p>
&lt;h4 id="sets">Sets&lt;/h4>
&lt;p>unordered&lt;/p>
&lt;h4 id="tuples">Tuples&lt;/h4>
&lt;p>A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot.&lt;/p>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;p>&lt;code>def&lt;/code> keyword&lt;/p>
&lt;h3 id="classes">Classes&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Greeter&lt;/span>:
&lt;span style="color:#888"># Constructor&lt;/span>
&lt;span style="color:#080;font-weight:bold">def&lt;/span> __init__(self, name):
self&lt;span style="color:#333">.&lt;/span>name &lt;span style="color:#333">=&lt;/span> name &lt;span style="color:#888"># Create an instance variable&lt;/span>
&lt;span style="color:#888"># Instance method&lt;/span>
&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">greet&lt;/span>(self, loud&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#080;font-weight:bold">False&lt;/span>):
&lt;span style="color:#080;font-weight:bold">if&lt;/span> loud:
&lt;span style="color:#007020">print&lt;/span>(&lt;span style="background-color:#fff0f0">&amp;#39;HELLO, &lt;/span>&lt;span style="background-color:#eee">{}&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;&lt;/span>&lt;span style="color:#333">.&lt;/span>format(self&lt;span style="color:#333">.&lt;/span>name&lt;span style="color:#333">.&lt;/span>upper()))
&lt;span style="color:#080;font-weight:bold">else&lt;/span>:
&lt;span style="color:#007020">print&lt;/span>(&lt;span style="background-color:#fff0f0">&amp;#39;Hello, &lt;/span>&lt;span style="background-color:#eee">{}&lt;/span>&lt;span style="background-color:#fff0f0">!&amp;#39;&lt;/span>&lt;span style="color:#333">.&lt;/span>format(self&lt;span style="color:#333">.&lt;/span>name))
g &lt;span style="color:#333">=&lt;/span> Greeter(&lt;span style="background-color:#fff0f0">&amp;#39;Fred&amp;#39;&lt;/span>) &lt;span style="color:#888"># Construct an instance of the Greeter class&lt;/span>
g&lt;span style="color:#333">.&lt;/span>greet() &lt;span style="color:#888"># Call an instance method; prints &amp;#34;Hello, Fred&amp;#34;&lt;/span>
g&lt;span style="color:#333">.&lt;/span>greet(loud&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#080;font-weight:bold">True&lt;/span>) &lt;span style="color:#888"># Call an instance method; prints &amp;#34;HELLO, FRED!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="numpy">Numpy&lt;/h2>
&lt;p>Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.&lt;/p>
&lt;h3 id="arrays">Arrays&lt;/h3>
&lt;p>A numpy array is &lt;strong>a grid of values&lt;/strong>, all of the &lt;strong>same type&lt;/strong>, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.&lt;/p>
&lt;h3 id="array-indexing">Array indexing&lt;/h3>
&lt;h4 id="slicing-1">Slicing&lt;/h4>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">numpy&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">np&lt;/span>
&lt;span style="color:#888"># Create the following rank 2 array with shape (3, 4)&lt;/span>
&lt;span style="color:#888"># [[ 1 2 3 4]&lt;/span>
&lt;span style="color:#888"># [ 5 6 7 8]&lt;/span>
&lt;span style="color:#888"># [ 9 10 11 12]]&lt;/span>
a &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>,&lt;span style="color:#00d;font-weight:bold">3&lt;/span>,&lt;span style="color:#00d;font-weight:bold">4&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">5&lt;/span>,&lt;span style="color:#00d;font-weight:bold">6&lt;/span>,&lt;span style="color:#00d;font-weight:bold">7&lt;/span>,&lt;span style="color:#00d;font-weight:bold">8&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">9&lt;/span>,&lt;span style="color:#00d;font-weight:bold">10&lt;/span>,&lt;span style="color:#00d;font-weight:bold">11&lt;/span>,&lt;span style="color:#00d;font-weight:bold">12&lt;/span>]])
&lt;span style="color:#888"># Use slicing to pull out the subarray consisting of the first 2 rows&lt;/span>
&lt;span style="color:#888"># and columns 1 and 2; b is the following array of shape (2, 2):&lt;/span>
&lt;span style="color:#888"># [[2 3]&lt;/span>
&lt;span style="color:#888"># [6 7]]&lt;/span>
b &lt;span style="color:#333">=&lt;/span> a[:&lt;span style="color:#00d;font-weight:bold">2&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>:&lt;span style="color:#00d;font-weight:bold">3&lt;/span>]
&lt;span style="color:#007020">print&lt;/span>(b)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Two ways of accessing the data in the middle row of the array. Mixing integer indexing with slices yields an array of lower rank, while using only slices yields an array of the same rank as the original array:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">row_r1 &lt;span style="color:#333">=&lt;/span> a[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, :] &lt;span style="color:#888"># Rank 1 view of the second row of a &lt;/span>
row_r2 &lt;span style="color:#333">=&lt;/span> a[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>:&lt;span style="color:#00d;font-weight:bold">2&lt;/span>, :] &lt;span style="color:#888"># Rank 2 view of the second row of a&lt;/span>
row_r3 &lt;span style="color:#333">=&lt;/span> a[[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>], :] &lt;span style="color:#888"># Rank 2 view of the second row of a&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(row_r1, row_r1&lt;span style="color:#333">.&lt;/span>shape)
&lt;span style="color:#007020">print&lt;/span>(row_r2, row_r2&lt;span style="color:#333">.&lt;/span>shape)
&lt;span style="color:#007020">print&lt;/span>(row_r3, row_r3&lt;span style="color:#333">.&lt;/span>shape)
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="integer-array-indexing">Integer array indexing&lt;/h4>
&lt;p>Integer array indexing allows you to construct arbitrary arrays using the data from another array.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">a &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">3&lt;/span>, &lt;span style="color:#00d;font-weight:bold">4&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">5&lt;/span>, &lt;span style="color:#00d;font-weight:bold">6&lt;/span>]])
&lt;span style="color:#888"># An example of integer array indexing.&lt;/span>
&lt;span style="color:#888"># The returned array will have shape (3,) and &lt;/span>
&lt;span style="color:#007020">print&lt;/span>(a[[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">2&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>]])
&lt;span style="color:#888"># The above example of integer array indexing is equivalent to this:&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(np&lt;span style="color:#333">.&lt;/span>array([a[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>], a[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>], a[&lt;span style="color:#00d;font-weight:bold">2&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>]]))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>result:&lt;/p>
&lt;p>[1 4 5]&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># When using integer array indexing, you can reuse the same&lt;/span>
&lt;span style="color:#888"># element from the source array:&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(a[[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>]])
&lt;span style="color:#888"># Equivalent to the previous integer array indexing example&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(np&lt;span style="color:#333">.&lt;/span>array([a[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>], a[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>]]))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>One useful trick with integer array indexing is selecting or mutating one element from each row of a matrix:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># Create a new array from which we will select elements&lt;/span>
a &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>,&lt;span style="color:#00d;font-weight:bold">3&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">4&lt;/span>,&lt;span style="color:#00d;font-weight:bold">5&lt;/span>,&lt;span style="color:#00d;font-weight:bold">6&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">7&lt;/span>,&lt;span style="color:#00d;font-weight:bold">8&lt;/span>,&lt;span style="color:#00d;font-weight:bold">9&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">10&lt;/span>, &lt;span style="color:#00d;font-weight:bold">11&lt;/span>, &lt;span style="color:#00d;font-weight:bold">12&lt;/span>]])
&lt;span style="color:#007020">print&lt;/span>(a)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># Create an array of indices&lt;/span>
b &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">2&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>])
&lt;span style="color:#888"># Select one element from each row of a using the indices in b&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(a[np&lt;span style="color:#333">.&lt;/span>arange(&lt;span style="color:#00d;font-weight:bold">4&lt;/span>), b]) &lt;span style="color:#888"># Prints &amp;#34;[ 1 6 7 11]&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>[1 6 7 11]&lt;/p>
&lt;h4 id="boolean-array-indexing">Boolean array indexing&lt;/h4>
&lt;p>Frequently this type of indexing is used to select the elements of an array that &lt;strong>satisfy some condition&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">numpy&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">np&lt;/span>
a &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">3&lt;/span>, &lt;span style="color:#00d;font-weight:bold">4&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">5&lt;/span>, &lt;span style="color:#00d;font-weight:bold">6&lt;/span>]])
bool_idx &lt;span style="color:#333">=&lt;/span> (a &lt;span style="color:#333">&amp;gt;&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>) &lt;span style="color:#888"># Find the elements of a that are bigger than 2;&lt;/span>
&lt;span style="color:#888"># this returns a numpy array of Booleans of the same&lt;/span>
&lt;span style="color:#888"># shape as a, where each slot of bool_idx tells&lt;/span>
&lt;span style="color:#888"># whether that element of a is &amp;gt; 2.&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(bool_idx)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>[[False False]
[ True True]
[ True True]]&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># We use boolean array indexing to construct a rank 1 array&lt;/span>
&lt;span style="color:#888"># consisting of the elements of a corresponding to the True values&lt;/span>
&lt;span style="color:#888"># of bool_idx&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(a[bool_idx])
&lt;span style="color:#888"># We can do all of the above in a single concise statement:&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(a[a &lt;span style="color:#333">&amp;gt;&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>])
&lt;/code>&lt;/pre>&lt;/div>&lt;p>[3 4 5 6]
[3 4 5 6]&lt;/p>
&lt;h3 id="datatypes">Datatypes&lt;/h3>
&lt;p>Every numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">2&lt;/span>]) &lt;span style="color:#888"># Let numpy choose the datatype&lt;/span>
y &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#60e;font-weight:bold">1.0&lt;/span>, &lt;span style="color:#60e;font-weight:bold">2.0&lt;/span>]) &lt;span style="color:#888"># Let numpy choose the datatype&lt;/span>
z &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">2&lt;/span>], dtype&lt;span style="color:#333">=&lt;/span>np&lt;span style="color:#333">.&lt;/span>int64) &lt;span style="color:#888"># Force a particular datatype&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(x&lt;span style="color:#333">.&lt;/span>dtype, y&lt;span style="color:#333">.&lt;/span>dtype, z&lt;span style="color:#333">.&lt;/span>dtype)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="array-math">Array math&lt;/h3>
&lt;p>Note that unlike MATLAB, &lt;code>*&lt;/code> is elementwise multiplication, not matrix multiplication. We instead use the dot function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. dot is available both as a function in the numpy module and as an instance method of array objects:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>],[&lt;span style="color:#00d;font-weight:bold">3&lt;/span>,&lt;span style="color:#00d;font-weight:bold">4&lt;/span>]], dtype&lt;span style="color:#333">=&lt;/span>np&lt;span style="color:#333">.&lt;/span>float64)
y &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">5&lt;/span>,&lt;span style="color:#00d;font-weight:bold">6&lt;/span>],[&lt;span style="color:#00d;font-weight:bold">7&lt;/span>,&lt;span style="color:#00d;font-weight:bold">8&lt;/span>]], dtype&lt;span style="color:#333">=&lt;/span>np&lt;span style="color:#333">.&lt;/span>float64)
&lt;span style="color:#888"># Elementwise product; both produce the array&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(x &lt;span style="color:#333">*&lt;/span> y)
&lt;span style="color:#007020">print&lt;/span>(np&lt;span style="color:#333">.&lt;/span>multiply(x, y))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>[[ 5. 12.]
[21. 32.]]
[[ 5. 12.]
[21. 32.]]&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>],[&lt;span style="color:#00d;font-weight:bold">3&lt;/span>,&lt;span style="color:#00d;font-weight:bold">4&lt;/span>]])
y &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">5&lt;/span>,&lt;span style="color:#00d;font-weight:bold">6&lt;/span>],[&lt;span style="color:#00d;font-weight:bold">7&lt;/span>,&lt;span style="color:#00d;font-weight:bold">8&lt;/span>]])
v &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">9&lt;/span>,&lt;span style="color:#00d;font-weight:bold">10&lt;/span>])
w &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">11&lt;/span>, &lt;span style="color:#00d;font-weight:bold">12&lt;/span>])
&lt;span style="color:#888"># Inner product of vectors; both produce 219&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(v&lt;span style="color:#333">.&lt;/span>dot(w))
&lt;span style="color:#007020">print&lt;/span>(np&lt;span style="color:#333">.&lt;/span>dot(v, w))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>219
219&lt;/p>
&lt;p>You can also use the &lt;code>@&lt;/code> operator which is equivalent to numpy&amp;rsquo;s &lt;code>dot&lt;/code> operator.&lt;/p>
&lt;p>to transpose a matrix, simply use the T attribute of an array object:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#007020">print&lt;/span>(&lt;span style="background-color:#fff0f0">&amp;#34;transpose&lt;/span>&lt;span style="color:#666;background-color:#fff0f0;font-weight:bold">\n&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;&lt;/span>, x&lt;span style="color:#333">.&lt;/span>T)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>transpose
[[1 3]
[2 4]]&lt;/p>
&lt;h3 id="broadcasting">Broadcasting&lt;/h3>
&lt;p>Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations.&lt;/p>
&lt;p>For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># We will add the vector v to each row of the matrix x,&lt;/span>
&lt;span style="color:#888"># storing the result in the matrix y&lt;/span>
x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>,&lt;span style="color:#00d;font-weight:bold">3&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">4&lt;/span>,&lt;span style="color:#00d;font-weight:bold">5&lt;/span>,&lt;span style="color:#00d;font-weight:bold">6&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">7&lt;/span>,&lt;span style="color:#00d;font-weight:bold">8&lt;/span>,&lt;span style="color:#00d;font-weight:bold">9&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">10&lt;/span>, &lt;span style="color:#00d;font-weight:bold">11&lt;/span>, &lt;span style="color:#00d;font-weight:bold">12&lt;/span>]])
v &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>])
y &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>empty_like(x) &lt;span style="color:#888"># Create an empty matrix with the same shape as x&lt;/span>
&lt;span style="color:#888"># Add the vector v to each row of the matrix x with an explicit loop&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#00d;font-weight:bold">4&lt;/span>):
y[i, :] &lt;span style="color:#333">=&lt;/span> x[i, :] &lt;span style="color:#333">+&lt;/span> v
&lt;span style="color:#007020">print&lt;/span>(y)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>[[ 2 2 4]
[ 5 5 7]
[ 8 8 10]
[11 11 13]]&lt;/p>
&lt;p>Numpy broadcasting allows us to perform this computation without actually creating multiple copies of v. Consider this version, using broadcasting:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">numpy&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">np&lt;/span>
&lt;span style="color:#888"># We will add the vector v to each row of the matrix x,&lt;/span>
&lt;span style="color:#888"># storing the result in the matrix y&lt;/span>
x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>,&lt;span style="color:#00d;font-weight:bold">2&lt;/span>,&lt;span style="color:#00d;font-weight:bold">3&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">4&lt;/span>,&lt;span style="color:#00d;font-weight:bold">5&lt;/span>,&lt;span style="color:#00d;font-weight:bold">6&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">7&lt;/span>,&lt;span style="color:#00d;font-weight:bold">8&lt;/span>,&lt;span style="color:#00d;font-weight:bold">9&lt;/span>], [&lt;span style="color:#00d;font-weight:bold">10&lt;/span>, &lt;span style="color:#00d;font-weight:bold">11&lt;/span>, &lt;span style="color:#00d;font-weight:bold">12&lt;/span>]])
v &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>array([&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>])
y &lt;span style="color:#333">=&lt;/span> x &lt;span style="color:#333">+&lt;/span> v &lt;span style="color:#888"># Add v to each row of x using broadcasting&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(y)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The line &lt;code>y = x + v&lt;/code> works even though &lt;code>x&lt;/code> has shape &lt;code>(4, 3)&lt;/code> and &lt;code>v&lt;/code> has shape &lt;code>(3,)&lt;/code> due to broadcasting; this line works as if v actually had shape &lt;code>(4, 3)&lt;/code>, where each row was a copy of &lt;code>v&lt;/code>, and the sum was performed elementwise.&lt;/p>
&lt;h2 id="matplotlib">Matplotlib&lt;/h2>
&lt;p>Matplotlib is a plotting library. In this section give a brief introduction to the &lt;code>matplotlib.pyplot&lt;/code> module, which provides a plotting system similar to that of MATLAB.&lt;/p>
&lt;h3 id="plotting">Plotting&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">matplotlib.pyplot&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">plt&lt;/span>
&lt;span style="color:#333">%&lt;/span>matplotlib inline
&lt;span style="color:#888"># Compute the x and y coordinates for points on a sine curve&lt;/span>
x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>arange(&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">3&lt;/span> &lt;span style="color:#333">*&lt;/span> np&lt;span style="color:#333">.&lt;/span>pi, &lt;span style="color:#60e;font-weight:bold">0.1&lt;/span>)
y &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sin(x)
&lt;span style="color:#888"># Plot the points using matplotlib&lt;/span>
plt&lt;span style="color:#333">.&lt;/span>plot(x, y)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="subplots">Subplots&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888"># Compute the x and y coordinates for points on sine and cosine curves&lt;/span>
x &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>arange(&lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">3&lt;/span> &lt;span style="color:#333">*&lt;/span> np&lt;span style="color:#333">.&lt;/span>pi, &lt;span style="color:#60e;font-weight:bold">0.1&lt;/span>)
y_sin &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sin(x)
y_cos &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>cos(x)
&lt;span style="color:#888"># Set up a subplot grid that has height 2 and width 1,&lt;/span>
&lt;span style="color:#888"># and set the first such subplot as active.&lt;/span>
plt&lt;span style="color:#333">.&lt;/span>subplot(&lt;span style="color:#00d;font-weight:bold">2&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>)
&lt;span style="color:#888"># Make the first plot&lt;/span>
plt&lt;span style="color:#333">.&lt;/span>plot(x, y_sin)
plt&lt;span style="color:#333">.&lt;/span>title(&lt;span style="background-color:#fff0f0">&amp;#39;Sine&amp;#39;&lt;/span>)
&lt;span style="color:#888"># Set the second subplot as active, and make the second plot.&lt;/span>
plt&lt;span style="color:#333">.&lt;/span>subplot(&lt;span style="color:#00d;font-weight:bold">2&lt;/span>, &lt;span style="color:#00d;font-weight:bold">1&lt;/span>, &lt;span style="color:#00d;font-weight:bold">2&lt;/span>)
plt&lt;span style="color:#333">.&lt;/span>plot(x, y_cos)
plt&lt;span style="color:#333">.&lt;/span>title(&lt;span style="background-color:#fff0f0">&amp;#39;Cosine&amp;#39;&lt;/span>)
&lt;span style="color:#888"># Show the figure.&lt;/span>
plt&lt;span style="color:#333">.&lt;/span>show()
&lt;/code>&lt;/pre>&lt;/div>- https://eternityqjl.github.io/blog2_public/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/ - 2019-2021 By Jialong</description></item><item><title>WLAN基本内容和802.11ax</title><link>https://eternityqjl.github.io/blog2_public/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</link><pubDate>Thu, 03 Jun 2021 18:09:38 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/ -&lt;h2 id="wlan基础内容">WLAN基础内容&lt;/h2>
&lt;h3 id="计算机网络概念">计算机网络概念&lt;/h3>
&lt;p>在学习基本无线网络通信的过程中顺便可以来复习以下计算机网络的相关内容。&lt;/p>
&lt;p>在家庭中我们通常使用路由器联通家中的局域网和外部的广域网，路由器为网络层设备，通过IP和路由表来寻找目的地和转发数据，即为路由功能。&lt;/p>
&lt;p>交换机是数据链路层设备，通过用于在局域网内传输数据，通过MAC地址寻找目的地，数据转发通过硬件来实现，传输速度相较于上一层网络层有很大的性能提升。每个物理设备都具有一个唯一的MAC地址。&lt;/p>
&lt;p>路由器和交换机的不同在于，一个工作在网络层，另一个工作在数据链路层，交换机连接的网络必须使用相同的数据链路层协议，一般即为&lt;strong>802.3(以太网)或802.11(无线局域网)&lt;/strong>。路由器工作在网络层，因此路由器连接的网络必须使用相同的网路层协议，一般为&lt;strong>ip协议&lt;/strong>，但路由器可以连接不同的数据链路层，比如eth2和pppoe，eth2和802.11。&lt;/p>
&lt;p>我们常用的每台终端都有一个MAC地址（即网卡地址），在连接网络后路由器会为其分配一个IP；而一个路由器也拥有一个MAC地址和一个IP。交换机中只有MAC地址表，通过设备的MAC地址来确定数据的目的地。&lt;/p>
&lt;h3 id="无线局域网">无线局域网&lt;/h3>
&lt;p>WLAN即为Wireless LAN，无线局域网。无线局域网通用的标准是IEEE定义的802.11系列标准，目前共有六代（2021年），为802.11a/b/g/n/ac/ax，分别从第一代到第六代。&lt;/p>
&lt;p>Wi-Fi称为无线网络，是Wi-Fi联盟的商标，是基于802.11标准实现的无线局域网技术。&lt;/p>
&lt;p>&lt;strong>IEEE 802.11标准&lt;/strong>定义了一个媒体访问控制(MAC，即&lt;strong>数据链路层&lt;/strong>协议)和几个&lt;strong>物理层&lt;/strong>规范，为局域内的终端提供无线连接，同时还为监管机构提供了一种标准化方法，对局域网通信的一个或多个&lt;strong>频带&lt;/strong>进行管理。&lt;/p>
&lt;h3 id="24ghz和5ghz">2.4GHz和5GHz&lt;/h3>
&lt;p>2.4GHz频道列表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">频道&lt;/th>
&lt;th style="text-align:center">频率 (MHz)&lt;/th>
&lt;th style="text-align:center">大部分国家&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">2412&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">2417&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">2422&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">2427&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">5&lt;/td>
&lt;td style="text-align:center">2432&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">6&lt;/td>
&lt;td style="text-align:center">2437&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">7&lt;/td>
&lt;td style="text-align:center">2442&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">8&lt;/td>
&lt;td style="text-align:center">2447&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">9&lt;/td>
&lt;td style="text-align:center">2452&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">10&lt;/td>
&lt;td style="text-align:center">2457&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">11&lt;/td>
&lt;td style="text-align:center">2462&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">12&lt;/td>
&lt;td style="text-align:center">2467&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">13&lt;/td>
&lt;td style="text-align:center">2472&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">14&lt;/td>
&lt;td style="text-align:center">2484&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>5GHz频道列表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">频道&lt;/th>
&lt;th style="text-align:center">频率 (MHz)&lt;/th>
&lt;th style="text-align:center">中国&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">40/20 MHz[&lt;a href="https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#cite_note-15">15]&lt;/a>&lt;/td>
&lt;td style="text-align:center">40/20 MHz&lt;/td>
&lt;td style="text-align:center">20 MHz[&lt;a href="https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#cite_note-israel-19">19]&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">183&lt;/td>
&lt;td style="text-align:center">4915&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">184&lt;/td>
&lt;td style="text-align:center">4920&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">185&lt;/td>
&lt;td style="text-align:center">4925&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">187&lt;/td>
&lt;td style="text-align:center">4935&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">188&lt;/td>
&lt;td style="text-align:center">4940&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">189&lt;/td>
&lt;td style="text-align:center">4945&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">192&lt;/td>
&lt;td style="text-align:center">4960&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">196&lt;/td>
&lt;td style="text-align:center">4980&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">7&lt;/td>
&lt;td style="text-align:center">5035&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">8&lt;/td>
&lt;td style="text-align:center">5040&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">9&lt;/td>
&lt;td style="text-align:center">5045&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">11&lt;/td>
&lt;td style="text-align:center">5055&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">12&lt;/td>
&lt;td style="text-align:center">5060&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">16&lt;/td>
&lt;td style="text-align:center">5080&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">34&lt;/td>
&lt;td style="text-align:center">5170&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">36&lt;/td>
&lt;td style="text-align:center">5180&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">38&lt;/td>
&lt;td style="text-align:center">5190&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">40&lt;/td>
&lt;td style="text-align:center">5200&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">42&lt;/td>
&lt;td style="text-align:center">5210&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">44&lt;/td>
&lt;td style="text-align:center">5220&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">46&lt;/td>
&lt;td style="text-align:center">5230&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">48&lt;/td>
&lt;td style="text-align:center">5240&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">52&lt;/td>
&lt;td style="text-align:center">5260&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">56&lt;/td>
&lt;td style="text-align:center">5280&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">60&lt;/td>
&lt;td style="text-align:center">5300&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">64&lt;/td>
&lt;td style="text-align:center">5320&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">100&lt;/td>
&lt;td style="text-align:center">5500&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">104&lt;/td>
&lt;td style="text-align:center">5520&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">108&lt;/td>
&lt;td style="text-align:center">5540&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">112&lt;/td>
&lt;td style="text-align:center">5560&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">116&lt;/td>
&lt;td style="text-align:center">5580&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">120&lt;/td>
&lt;td style="text-align:center">5600&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">124&lt;/td>
&lt;td style="text-align:center">5620&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">128&lt;/td>
&lt;td style="text-align:center">5640&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">132&lt;/td>
&lt;td style="text-align:center">5660&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">136&lt;/td>
&lt;td style="text-align:center">5680&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">140&lt;/td>
&lt;td style="text-align:center">5700&lt;/td>
&lt;td style="text-align:center">否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">149&lt;/td>
&lt;td style="text-align:center">5745&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">153&lt;/td>
&lt;td style="text-align:center">5765&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">157&lt;/td>
&lt;td style="text-align:center">5785&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">161&lt;/td>
&lt;td style="text-align:center">5805&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">165&lt;/td>
&lt;td style="text-align:center">5825&lt;/td>
&lt;td style="text-align:center">是&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="wifi-680211ax">WiFi 6——802.11ax&lt;/h2>
&lt;p>IEEE 802.11ax为无线局域网标准，Wi-Fi联盟称之为Wi-Fi 6。其支持从1GHz到6GHz的所有ISM频段，包括目前使用的2.4GHz和5GHz频段，向下兼容前代的a/b/g/n/ac。&lt;/p>
&lt;p>主要有以下的先进功能：&lt;/p>
&lt;ul>
&lt;li>正交频分多址（OFDMA）&lt;/li>
&lt;li>多用户多输入多输出（MU-MIMO）&lt;/li>
&lt;li>160MHz信道（这并不是802.11ax才出现的，在5GHz下即可实现160MHz的带宽）&lt;/li>
&lt;li>1024正交幅度调制（1024-QAM）&lt;/li>
&lt;li>目标唤醒时间（TWT）&lt;/li>
&lt;li>WPA3安全标准&lt;/li>
&lt;/ul>
&lt;p>下面通过整机终端的传输速率来理解这些特性。&lt;/p>
&lt;p>&lt;strong>整机速率=空间流数 * (1/Symbol+GI) * 编码方式 * 码率 * 有效子载波数&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>空间流数：AP的天线数&lt;/li>
&lt;li>Symbol与GI：时域上每一帧需要的时间以及空隙&lt;/li>
&lt;li>编码方式：调制技术，即1个Symbol能承载的bit数量。&lt;/li>
&lt;li>码率：排除纠错码后世纪真实传输数据码占理论值的比值&lt;/li>
&lt;li>有效子载波数量：频域上的Symbol，一个子载波承载余个Symbol，例如频宽为HT80时，有效子载波数量为980个；频宽为HT160时，有效子载波数为980*2个。&lt;/li>
&lt;/ul>
&lt;h3 id="频分复用技术">频分复用技术：&lt;/h3>
&lt;p>将子载波分配给不同用户，并在OFDM中添加多址的方法来实现多用户复用信道资源。&lt;/p>
&lt;h3 id="mu-mimo技术">MU-MIMO技术：&lt;/h3>
&lt;p>多天线技术，能提高用户容量，每个用户速率更快。&lt;/p>
&lt;h4 id="dl-mu-mimo">DL MU-MIMO&lt;/h4>
&lt;p>DL MU-MIMO在802.11ac就已经引入，但只支持DL 4*4 MU-MIMO（下行）。在802.11ax种进一步增加了MU-MIMO数量，支持DL 8x8 MU-MIMO，借助 DL OFDMA技术（下行），可同时进行 MU-MIMO 传输和分配不同 RU 进行多用户多址传输，既增加了系统并发接入量，又均衡了吞吐量。&lt;/p>
&lt;h4 id="ul-mu-mimo">UL MU-MIMO&lt;/h4>
&lt;p>UL MU-MIMO（上行）是802.11ax引入的一个重要特性，与下载的SU-MIMO概念类型，都是通过发射机和接收机的多天线技术使用相同信道资源在多个空间流上同时传输数据，唯一的差别点在于 UL MU-MIMO 的多个数据流是来自多个用户。&lt;/p>
&lt;p>802.11ac 及之前的 802.11 标准都是 UL SU-MIMO，即只能接受一个用户发来的数据，多用户并发场景效率较低，802.11ax 支持 UL MU-MIMO 后，借助 UL OFDMA 技术 （上行），可同时进行 MU-MIMO 传输和分配不同 RU 进行多用户多址传输，提升多用户并发场景效率，大大降低了应用时延。&lt;/p>
&lt;h3 id="更高阶的调制技术1024-qam">更高阶的调制技术(1024-QAM)：&lt;/h3>
&lt;p>802.11ac 采用的 256-QAM 正交幅度调制，每个符号传输 8bit 数据（2^8=256），802.11ax 将采用 1024-QAM 正交幅度调制，每个符号位传输 10bit 数据（2^10=1024）。&lt;/p>
&lt;p>需要注意的是 802.11ax 中成功使用 1024-QAM 调制取决于信道条件，更密的星座点距离需要更强大的 EVM（误差矢量幅度，用于量化无线电接收器或发射器在调制精度方面的性能）和接受灵敏度功能，并且信道质量要求高于其他调制类型。&lt;/p>
&lt;h3 id="srbss-coloring">SR&amp;amp;BSS Coloring&lt;/h3>
&lt;h4 id="空分复用技术sr">空分复用技术（SR）&lt;/h4>
&lt;p>Wi-Fi 射频的传输原理是在任何指定时间内，一个信道上只允许一个用户传输数据，如果 Wi-Fi AP 和客户端在同一信道上侦听到有其他 802.11 无线电传输，则会自动进行冲突避免，推迟传输，因此每个用户都必须轮流使用。所以说信道是无线网络中非常宝贵的资源， 特别在高密场景下，信道的合理划分和利用将对整个无线网络的容量和稳定性带来较大的影响。&lt;/p>
&lt;p>802.11ac 及之前的标准，通常采用动态调整 CCA 门限的机制来改善同频信道间的干扰，通过识别同频干扰强度，动态调整 CCA 门限，忽略同频弱干扰信号实现同频并发传输， 提升系统吞吐容量。&lt;/p>
&lt;p>802.11ax 中引入了一种新的同频传输识别机制，叫 BSS Coloring 着色机制，在 PHY 报文头中添加 BSS color 字段对来自不同BSS 的数据进行“染色”，为每个通道分配一种颜色，该颜色标识一组不应干扰的基本服务集（BSS），接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一 BSS 内的干扰信号， 发送将推迟；如果颜色不同，则认为两者之间无干扰，两个 Wi-Fi 设备可同信道同频并行传输。以这种方式设计的网络，那些具有相同颜色的信道彼此相距很远，此时我们再利用动态CCA 机制将这种信号设置为不敏感，事实上它们之间也不太可能会相互干扰。&lt;/p>
&lt;h4 id="bss-coloring着色机制">BSS Coloring着色机制&lt;/h4>
&lt;p>802.11ax 中引入了一种新的同频传输识别机制，叫 BSS Coloring 着色机制，在 PHY 报文头中添加 BSS color 字段对来自不同BSS 的数据进行“染色”，为每个通道分配一种颜色，该颜色标识一组不应干扰的基本服务集（BSS），接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一 BSS 内的干扰信号， 发送将推迟；如果颜色不同，则认为两者之间无干扰，两个 Wi-Fi 设备可同信道同频并行传输。以这种方式设计的网络，那些具有相同颜色的信道彼此相距很远，此时我们再利用动态CCA 机制将这种信号设置为不敏感，事实上它们之间也不太可能会相互干扰。&lt;/p>
&lt;h3 id="扩展覆盖范围er">扩展覆盖范围（ER）&lt;/h3>
&lt;p>由于 802.11ax 标准采用的是Long OFDM symbol 发送机制，每次数据发送持续时间从原来的 3.2us 提升到 12.8us，更长的发送时间可降低终端丢包率；另外 802.11ax 最小可仅使用 2MHz 频宽进行窄带传输，有效降低频段噪声干扰，提升了终端接受灵敏度，增加了覆盖距离。&lt;/p>
&lt;h3 id="其他特性">其他特性&lt;/h3>
&lt;h4 id="支持24ghz">支持2.4GHz&lt;/h4>
&lt;p>2.4GHz 频宽窄，且仅有 3 个 20MHz 的互不干扰信道（1,6 和 11），但是有一点不可否认的是 2.4GHz 仍然是一个可用的 Wi-Fi 频段，在很多场景下依然被广泛使用，主要有以下优势：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>覆盖范围广&lt;/strong>：信号频率越低， 波长越长，绕射能力越强，穿透能力越差，信号损失衰减越小，传输距离越远。虽然 5GHz 频段可带来更高的传播速度，但信号衰减也越大，所以传输距离比 2.4GHz 要短。&lt;/li>
&lt;li>低成本&lt;/li>
&lt;/ul>
&lt;h4 id="目标唤醒时间">目标唤醒时间&lt;/h4>
&lt;p>802.11ax AP 可以和 STA 协调目标唤醒时间(TWT)功能的使用，AP 和 STA 会互相交换信息，当中将包含预计的活动持续时间，以定义让 STA 访问介质的特定时间或一组时间， 这样就可以避开多个不同 STA 之间的竞争和重叠情况。另外，支持 802.11ax 标准的 STA 可以使用 TWT 来降低能量损耗，在自身的 TWT 来临之前进入睡眠状态。AP 还可另外设定 TWT编排计划并将 TWT 值提供给 STA，这样双方之间就不需要存在个别的 TWT 协议，此操作称为“广播 TWT 操作”。&lt;/p>
&lt;h2 id="家庭无线网络配置">家庭无线网络配置&lt;/h2>
&lt;h3 id="acap">AC+AP&lt;/h3>
&lt;h3 id="mesh组网">MESH组网&lt;/h3>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://e.huawei.com/cn/material/networking/wlan/b3f46485597c4d72b43a6a27c6480646">华为Wi-Fi 6(802.11ax)技术白皮书&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/IEEE_802.11ax">wikipedia IEEE 802.11ax&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#5_GHz_(802.11a/h/j/n/ac/ax)%5B11%5D">wikipedia WLAN信道列表&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>- https://eternityqjl.github.io/blog2_public/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/ - 2019-2021 By Jialong</description></item><item><title>字符编码：Unicode, UTF-8</title><link>https://eternityqjl.github.io/blog2_public/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/</link><pubDate>Wed, 02 Jun 2021 15:29:29 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/ -&lt;h2 id="基本">基本&lt;/h2>
&lt;p>计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。通俗的说，按照何种规则将字符存储在计算机中，如&amp;rsquo;a&amp;rsquo;用什么表示，称为&amp;quot;&lt;strong>编码&lt;/strong>&amp;quot;；反之，将存储在计算机中的二进制数解析显示出来，称为&amp;quot;&lt;strong>解码&lt;/strong>&amp;quot;。&lt;/p>
&lt;p>&lt;strong>字符集(charset)&lt;/strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国文字、标点符号、图形符号、数字等。&lt;/p>
&lt;p>&lt;strong>字符编码(character Encoding)&lt;/strong>：即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。&lt;/p>
&lt;h2 id="ascii字符集和编码">ASCII字符集和编码&lt;/h2>
&lt;p>ASCII (American Standard Code for Information Interchange)是基于拉丁字母的一套电脑编码系统。主要用于显示现代英语。&lt;/p>
&lt;p>&lt;strong>ASCII字符集&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>控制字符（回车键、退格、换行键等）；&lt;/li>
&lt;li>可显示字符（英文大小写字符、阿拉伯数字和西文符号）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ASCII编码&lt;/strong>：&lt;/p>
&lt;p>将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用**8位（bits）**表示一个字符，共256字符。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">ASCII值&lt;/th>
&lt;th style="text-align:center">控制字符&lt;/th>
&lt;th style="text-align:center">ASCII值&lt;/th>
&lt;th style="text-align:center">控制字符&lt;/th>
&lt;th style="text-align:center">ASCII值&lt;/th>
&lt;th style="text-align:center">控制字符&lt;/th>
&lt;th style="text-align:center">ASCII值&lt;/th>
&lt;th style="text-align:center">控制字符&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">NUT&lt;/td>
&lt;td style="text-align:center">32&lt;/td>
&lt;td style="text-align:center">(space)&lt;/td>
&lt;td style="text-align:center">64&lt;/td>
&lt;td style="text-align:center">@&lt;/td>
&lt;td style="text-align:center">96&lt;/td>
&lt;td style="text-align:center">、&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">SOH&lt;/td>
&lt;td style="text-align:center">33&lt;/td>
&lt;td style="text-align:center">!&lt;/td>
&lt;td style="text-align:center">65&lt;/td>
&lt;td style="text-align:center">A&lt;/td>
&lt;td style="text-align:center">97&lt;/td>
&lt;td style="text-align:center">a&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">STX&lt;/td>
&lt;td style="text-align:center">34&lt;/td>
&lt;td style="text-align:center">&amp;quot;&lt;/td>
&lt;td style="text-align:center">66&lt;/td>
&lt;td style="text-align:center">B&lt;/td>
&lt;td style="text-align:center">98&lt;/td>
&lt;td style="text-align:center">b&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">ETX&lt;/td>
&lt;td style="text-align:center">35&lt;/td>
&lt;td style="text-align:center">#&lt;/td>
&lt;td style="text-align:center">67&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">99&lt;/td>
&lt;td style="text-align:center">c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">EOT&lt;/td>
&lt;td style="text-align:center">36&lt;/td>
&lt;td style="text-align:center">$&lt;/td>
&lt;td style="text-align:center">68&lt;/td>
&lt;td style="text-align:center">D&lt;/td>
&lt;td style="text-align:center">100&lt;/td>
&lt;td style="text-align:center">d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">5&lt;/td>
&lt;td style="text-align:center">ENQ&lt;/td>
&lt;td style="text-align:center">37&lt;/td>
&lt;td style="text-align:center">%&lt;/td>
&lt;td style="text-align:center">69&lt;/td>
&lt;td style="text-align:center">E&lt;/td>
&lt;td style="text-align:center">101&lt;/td>
&lt;td style="text-align:center">e&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">6&lt;/td>
&lt;td style="text-align:center">ACK&lt;/td>
&lt;td style="text-align:center">38&lt;/td>
&lt;td style="text-align:center">&amp;amp;&lt;/td>
&lt;td style="text-align:center">70&lt;/td>
&lt;td style="text-align:center">F&lt;/td>
&lt;td style="text-align:center">102&lt;/td>
&lt;td style="text-align:center">f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">7&lt;/td>
&lt;td style="text-align:center">BEL&lt;/td>
&lt;td style="text-align:center">39&lt;/td>
&lt;td style="text-align:center">,&lt;/td>
&lt;td style="text-align:center">71&lt;/td>
&lt;td style="text-align:center">G&lt;/td>
&lt;td style="text-align:center">103&lt;/td>
&lt;td style="text-align:center">g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">8&lt;/td>
&lt;td style="text-align:center">BS&lt;/td>
&lt;td style="text-align:center">40&lt;/td>
&lt;td style="text-align:center">(&lt;/td>
&lt;td style="text-align:center">72&lt;/td>
&lt;td style="text-align:center">H&lt;/td>
&lt;td style="text-align:center">104&lt;/td>
&lt;td style="text-align:center">h&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">9&lt;/td>
&lt;td style="text-align:center">HT&lt;/td>
&lt;td style="text-align:center">41&lt;/td>
&lt;td style="text-align:center">)&lt;/td>
&lt;td style="text-align:center">73&lt;/td>
&lt;td style="text-align:center">I&lt;/td>
&lt;td style="text-align:center">105&lt;/td>
&lt;td style="text-align:center">i&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">10&lt;/td>
&lt;td style="text-align:center">LF&lt;/td>
&lt;td style="text-align:center">42&lt;/td>
&lt;td style="text-align:center">*&lt;/td>
&lt;td style="text-align:center">74&lt;/td>
&lt;td style="text-align:center">J&lt;/td>
&lt;td style="text-align:center">106&lt;/td>
&lt;td style="text-align:center">j&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">11&lt;/td>
&lt;td style="text-align:center">VT&lt;/td>
&lt;td style="text-align:center">43&lt;/td>
&lt;td style="text-align:center">+&lt;/td>
&lt;td style="text-align:center">75&lt;/td>
&lt;td style="text-align:center">K&lt;/td>
&lt;td style="text-align:center">107&lt;/td>
&lt;td style="text-align:center">k&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">12&lt;/td>
&lt;td style="text-align:center">FF&lt;/td>
&lt;td style="text-align:center">44&lt;/td>
&lt;td style="text-align:center">,&lt;/td>
&lt;td style="text-align:center">76&lt;/td>
&lt;td style="text-align:center">L&lt;/td>
&lt;td style="text-align:center">108&lt;/td>
&lt;td style="text-align:center">l&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">13&lt;/td>
&lt;td style="text-align:center">CR&lt;/td>
&lt;td style="text-align:center">45&lt;/td>
&lt;td style="text-align:center">-&lt;/td>
&lt;td style="text-align:center">77&lt;/td>
&lt;td style="text-align:center">M&lt;/td>
&lt;td style="text-align:center">109&lt;/td>
&lt;td style="text-align:center">m&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">14&lt;/td>
&lt;td style="text-align:center">SO&lt;/td>
&lt;td style="text-align:center">46&lt;/td>
&lt;td style="text-align:center">.&lt;/td>
&lt;td style="text-align:center">78&lt;/td>
&lt;td style="text-align:center">N&lt;/td>
&lt;td style="text-align:center">110&lt;/td>
&lt;td style="text-align:center">n&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">15&lt;/td>
&lt;td style="text-align:center">SI&lt;/td>
&lt;td style="text-align:center">47&lt;/td>
&lt;td style="text-align:center">/&lt;/td>
&lt;td style="text-align:center">79&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">111&lt;/td>
&lt;td style="text-align:center">o&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">16&lt;/td>
&lt;td style="text-align:center">DLE&lt;/td>
&lt;td style="text-align:center">48&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">80&lt;/td>
&lt;td style="text-align:center">P&lt;/td>
&lt;td style="text-align:center">112&lt;/td>
&lt;td style="text-align:center">p&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">17&lt;/td>
&lt;td style="text-align:center">DCI&lt;/td>
&lt;td style="text-align:center">49&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">81&lt;/td>
&lt;td style="text-align:center">Q&lt;/td>
&lt;td style="text-align:center">113&lt;/td>
&lt;td style="text-align:center">q&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">18&lt;/td>
&lt;td style="text-align:center">DC2&lt;/td>
&lt;td style="text-align:center">50&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">82&lt;/td>
&lt;td style="text-align:center">R&lt;/td>
&lt;td style="text-align:center">114&lt;/td>
&lt;td style="text-align:center">r&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">19&lt;/td>
&lt;td style="text-align:center">DC3&lt;/td>
&lt;td style="text-align:center">51&lt;/td>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">83&lt;/td>
&lt;td style="text-align:center">S&lt;/td>
&lt;td style="text-align:center">115&lt;/td>
&lt;td style="text-align:center">s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">20&lt;/td>
&lt;td style="text-align:center">DC4&lt;/td>
&lt;td style="text-align:center">52&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">84&lt;/td>
&lt;td style="text-align:center">T&lt;/td>
&lt;td style="text-align:center">116&lt;/td>
&lt;td style="text-align:center">t&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">21&lt;/td>
&lt;td style="text-align:center">NAK&lt;/td>
&lt;td style="text-align:center">53&lt;/td>
&lt;td style="text-align:center">5&lt;/td>
&lt;td style="text-align:center">85&lt;/td>
&lt;td style="text-align:center">U&lt;/td>
&lt;td style="text-align:center">117&lt;/td>
&lt;td style="text-align:center">u&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">22&lt;/td>
&lt;td style="text-align:center">SYN&lt;/td>
&lt;td style="text-align:center">54&lt;/td>
&lt;td style="text-align:center">6&lt;/td>
&lt;td style="text-align:center">86&lt;/td>
&lt;td style="text-align:center">V&lt;/td>
&lt;td style="text-align:center">118&lt;/td>
&lt;td style="text-align:center">v&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">23&lt;/td>
&lt;td style="text-align:center">TB&lt;/td>
&lt;td style="text-align:center">55&lt;/td>
&lt;td style="text-align:center">7&lt;/td>
&lt;td style="text-align:center">87&lt;/td>
&lt;td style="text-align:center">W&lt;/td>
&lt;td style="text-align:center">119&lt;/td>
&lt;td style="text-align:center">w&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">24&lt;/td>
&lt;td style="text-align:center">CAN&lt;/td>
&lt;td style="text-align:center">56&lt;/td>
&lt;td style="text-align:center">8&lt;/td>
&lt;td style="text-align:center">88&lt;/td>
&lt;td style="text-align:center">X&lt;/td>
&lt;td style="text-align:center">120&lt;/td>
&lt;td style="text-align:center">x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">25&lt;/td>
&lt;td style="text-align:center">EM&lt;/td>
&lt;td style="text-align:center">57&lt;/td>
&lt;td style="text-align:center">9&lt;/td>
&lt;td style="text-align:center">89&lt;/td>
&lt;td style="text-align:center">Y&lt;/td>
&lt;td style="text-align:center">121&lt;/td>
&lt;td style="text-align:center">y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">26&lt;/td>
&lt;td style="text-align:center">SUB&lt;/td>
&lt;td style="text-align:center">58&lt;/td>
&lt;td style="text-align:center">:&lt;/td>
&lt;td style="text-align:center">90&lt;/td>
&lt;td style="text-align:center">Z&lt;/td>
&lt;td style="text-align:center">122&lt;/td>
&lt;td style="text-align:center">z&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">27&lt;/td>
&lt;td style="text-align:center">ESC&lt;/td>
&lt;td style="text-align:center">59&lt;/td>
&lt;td style="text-align:center">;&lt;/td>
&lt;td style="text-align:center">91&lt;/td>
&lt;td style="text-align:center">[&lt;/td>
&lt;td style="text-align:center">123&lt;/td>
&lt;td style="text-align:center">{&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">28&lt;/td>
&lt;td style="text-align:center">FS&lt;/td>
&lt;td style="text-align:center">60&lt;/td>
&lt;td style="text-align:center">&amp;lt;&lt;/td>
&lt;td style="text-align:center">92&lt;/td>
&lt;td style="text-align:center">/&lt;/td>
&lt;td style="text-align:center">124&lt;/td>
&lt;td style="text-align:center">|&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">29&lt;/td>
&lt;td style="text-align:center">GS&lt;/td>
&lt;td style="text-align:center">61&lt;/td>
&lt;td style="text-align:center">=&lt;/td>
&lt;td style="text-align:center">93&lt;/td>
&lt;td style="text-align:center">]&lt;/td>
&lt;td style="text-align:center">125&lt;/td>
&lt;td style="text-align:center">}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">30&lt;/td>
&lt;td style="text-align:center">RS&lt;/td>
&lt;td style="text-align:center">62&lt;/td>
&lt;td style="text-align:center">&amp;gt;&lt;/td>
&lt;td style="text-align:center">94&lt;/td>
&lt;td style="text-align:center">^&lt;/td>
&lt;td style="text-align:center">126&lt;/td>
&lt;td style="text-align:center">`&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">31&lt;/td>
&lt;td style="text-align:center">US&lt;/td>
&lt;td style="text-align:center">63&lt;/td>
&lt;td style="text-align:center">?&lt;/td>
&lt;td style="text-align:center">95&lt;/td>
&lt;td style="text-align:center">_&lt;/td>
&lt;td style="text-align:center">127&lt;/td>
&lt;td style="text-align:center">DEL&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>0-31和127位控制字符，其余为可显示字符。&lt;/p>
&lt;p>ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语。&lt;/p>
&lt;h2 id="gbxxxx字符集和编码">GBXXXX字符集和编码&lt;/h2>
&lt;p>是为了显示中文而设计的额一套编码规则。&lt;/p>
&lt;p>一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。&lt;/p>
&lt;p>在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&amp;quot;&lt;strong>全角&lt;/strong>&amp;ldquo;字符，而原来在127号以下的那些就叫&amp;rdquo;&lt;strong>半角&lt;/strong>&amp;ldquo;字符了。&lt;/p>
&lt;p>上述编码规则就是GB2312。GB2312或GB2312-80是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。&lt;/p>
&lt;p>GBK是对GB2312-80的扩展，也就是CP936字码表 (Code Page 936)的扩展（之前CP936和GB 2312-80一模一样），最早实现于Windows 95简体中文版。&lt;/p>
&lt;h2 id="unicode字符集和uft编码">Unicode字符集和UFT编码&lt;/h2>
&lt;p>Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个数字代表唯一的至少在某种语言中使用的符号。（并不是所有的数字都用上了，但是总数已经超过了65535，所以2个字节的数字是不够用的。）&lt;/p>
&lt;p>Unicode是字符集，UTF-32/16/8是三种字符编码方案。&lt;/p>
&lt;h3 id="utf-32">UTF-32&lt;/h3>
&lt;p>使用&lt;strong>4字节&lt;/strong>的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。对每个字符都使用4字节。就空间而言，是非常没有效率的。&lt;/p>
&lt;h3 id="uft-16">UFT-16&lt;/h3>
&lt;p>实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。&lt;/p>
&lt;p>如果真的需要表达那些很少使用的&amp;quot;星芒层(astral plane)&amp;ldquo;内超过这65535范围的Unicode字符，则需要使用一些诡异的技巧来实现。&lt;/p>
&lt;p>UTF-16编码最明显的优点是它在空间效率上比UTF-32高两倍，因为每个字符只需要&lt;strong>2个字节&lt;/strong>来存储（除去65535范围以外的）。&lt;/p>
&lt;h3 id="utf-8">UTF-8&lt;/h3>
&lt;p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的&lt;strong>可变长度&lt;/strong>字符编码（定长码），也是一种前缀码。可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍&lt;strong>与ASCII兼容&lt;/strong>。&lt;/p>
&lt;p>UTF-8使用一至四个字节为每个字符编码：&lt;/p>
&lt;ul>
&lt;li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。&lt;/li>
&lt;li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。&lt;/li>
&lt;li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用中文字）使用三个字节编码。&lt;/li>
&lt;li>其他极少使用的Unicode辅助平面的字符使用四字节编码。&lt;/li>
&lt;/ul>
&lt;p>UTF-8是ASCII的一个超集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。&lt;/p>- https://eternityqjl.github.io/blog2_public/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/ - 2019-2021 By Jialong</description></item><item><title>机器学习——k近邻(k-NN)算法</title><link>https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 12 May 2021 14:57:17 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/ -&lt;h2 id="基本概念及原理">基本概念及原理&lt;/h2>
&lt;p>k近邻(k-nearest neighbors)算法是一种基本分类和回归方法。&lt;/p>
&lt;p>该算法是给定一个&lt;strong>训练数据集&lt;/strong>，对新的&lt;strong>输入测试集&lt;/strong>，在训练集中找到与该测试实例&lt;strong>最邻近&lt;/strong>的k个实例，这k个实例的多数属于某个类，就把该输入实例分类到这个类中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/220px-KnnClassification.svg.png" alt="220px-KnnClassification.svg">&lt;/p>
&lt;p>有两类不同样本分别用红色三角形和蓝色正方形表示，途中绿色圆形为待分类的数据。这时我们根据k-近邻的思想进行分类。&lt;/p>
&lt;ul>
&lt;li>当k=3时，判定样本属于红色三角形这一类；&lt;/li>
&lt;li>当k=5时，判定样本属于蓝色正方形这一类。&lt;/li>
&lt;/ul>
&lt;h2 id="k的选取及特征归一化">k的选取及特征归一化&lt;/h2>
&lt;h3 id="选取k值及其影响">选取k值及其影响&lt;/h3>
&lt;p>选取较小的k值，整体模型会变得更加复杂，容易发生&lt;strong>过拟合&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>过拟合就是在训练集上准确率非常高，而在测试集上准确率低。&lt;/p>
&lt;/blockquote>
&lt;p>k太小会导致过拟合，容易将一些噪声学习到模型中。&lt;/p>
&lt;p>选取较大的k值，整体模型变得简单，因为当k等于训练样本个数时，无论输入什么测试实例，都将简单地预测它属于&lt;strong>在训练实例中最多的类&lt;/strong>，相当于没有训练模型。&lt;/p>
&lt;p>所以，模型即不能过大也不能过小，一般选取一个较小的数值，通过采取&lt;strong>交叉验证法&lt;/strong>来选取最优的k值，即通过实验调参选取。&lt;/p>
&lt;h3 id="距离的度量">距离的度量&lt;/h3>
&lt;p>我们通常使用常见的&lt;strong>欧氏距离&lt;/strong>来衡量高维空间中两个点的距离，即：
$$
L_2(x_i,x_j)=(\sum_{l=1}^{n}| x_i^{(l)}-x_j^{(l)} |)^{\frac{1}{2}}
$$
其中，$x_i=(x_i^{(1)}, x_i^{(2)},&amp;hellip;,x_i^{(n)})$，同理$x_j$。&lt;/p>
&lt;h3 id="特征归一化的必要性">特征归一化的必要性&lt;/h3>
&lt;p>如果不进行归一化，让每个特征都同等重要，就会偏向于第一维度的特征，导致多个特征并不是等价重要的，会导致距离计算错误，最终导致预测结果错误。&lt;/p>
&lt;p>进行KNN分类使用的样本特征是${ (x_{i1}, x_{i2},&amp;hellip;,x_{in}) }_{i=1}^m$，取每个轴上的最大值减去最小值得：
$$
M_j=\max_{i=1,&amp;hellip;,m}x_{ij}-\min_{i=1,&amp;hellip;,m}x_{ij}
$$
并在计算距离时将每一个坐标轴除以相应的$M_j$进行归一化，即：
$$
d((y_1,&amp;hellip;,y_n),(z_1,&amp;hellip;,z_n))=\sqrt{\sum_{j=1}^{n}(\frac{y_j}{M_j}-\frac{z_j}{M_j})^2}
$$&lt;/p>
&lt;h2 id="k-nn实现iris鸢尾花数据集聚类">k-NN实现Iris鸢尾花数据集聚类&lt;/h2>
&lt;h3 id="k-means聚类算法的实现步骤">K-Means聚类算法的实现步骤：&lt;/h3>
&lt;ul>
&lt;li>为待聚类的点随机寻找几个聚类中心(类别个数)；&lt;/li>
&lt;li>计算每个点到聚类中心的距离，将各个点归类到离该点最近的聚类中去；&lt;/li>
&lt;li>计算每个聚类中所有点的坐标平均值，并将这个平均值作为新的聚类中心，反复执行上一步和该步，直到聚类中心不再进行大范围移动或聚类迭代次数达到要求位置。&lt;/li>
&lt;/ul>
&lt;h3 id="代码实现">代码实现&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">numpy&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">np&lt;/span>
&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">pandas&lt;/span> &lt;span style="color:#080;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">pd&lt;/span>
data &lt;span style="color:#333">=&lt;/span> pd&lt;span style="color:#333">.&lt;/span>read_csv(&lt;span style="background-color:#fff0f0">&amp;#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&amp;#39;&lt;/span>, header&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#080;font-weight:bold">None&lt;/span>) &lt;span style="color:#888"># 下载iris数据集&lt;/span>
&lt;span style="color:#888">#data = pd.read_csv(&amp;#39;./data/iris.data.csv&amp;#39;, header=None)&lt;/span>
data&lt;span style="color:#333">.&lt;/span>columns &lt;span style="color:#333">=&lt;/span> [&lt;span style="background-color:#fff0f0">&amp;#39;sepal length&amp;#39;&lt;/span>, &lt;span style="background-color:#fff0f0">&amp;#39;sepal width&amp;#39;&lt;/span>, &lt;span style="background-color:#fff0f0">&amp;#39;petal length&amp;#39;&lt;/span>, &lt;span style="background-color:#fff0f0">&amp;#39;petal width&amp;#39;&lt;/span>, &lt;span style="background-color:#fff0f0">&amp;#39;species&amp;#39;&lt;/span>] &lt;span style="color:#888"># 特征及类别名称&lt;/span>
X &lt;span style="color:#333">=&lt;/span> data&lt;span style="color:#333">.&lt;/span>iloc[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>:&lt;span style="color:#00d;font-weight:bold">150&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>:&lt;span style="color:#00d;font-weight:bold">4&lt;/span>]&lt;span style="color:#333">.&lt;/span>values
y &lt;span style="color:#333">=&lt;/span> data&lt;span style="color:#333">.&lt;/span>iloc[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>:&lt;span style="color:#00d;font-weight:bold">150&lt;/span>, &lt;span style="color:#00d;font-weight:bold">4&lt;/span>]&lt;span style="color:#333">.&lt;/span>values
y[y &lt;span style="color:#333">==&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#39;Iris-setosa&amp;#39;&lt;/span>] &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span> &lt;span style="color:#888"># Iris-setosa 输出label用0表示&lt;/span>
y[y &lt;span style="color:#333">==&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#39;Iris-versicolor&amp;#39;&lt;/span>] &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span> &lt;span style="color:#888"># Iris-versicolor 输出label用1表示&lt;/span>
y[y &lt;span style="color:#333">==&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#39;Iris-virginica&amp;#39;&lt;/span>] &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span> &lt;span style="color:#888"># Iris-virginica 输出label用2表示&lt;/span>
X_setosa, y_setosa &lt;span style="color:#333">=&lt;/span> X[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>], y[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>] &lt;span style="color:#888"># Iris-setosa 4个特征&lt;/span>
X_versicolor, y_versicolor &lt;span style="color:#333">=&lt;/span> X[&lt;span style="color:#00d;font-weight:bold">50&lt;/span>:&lt;span style="color:#00d;font-weight:bold">100&lt;/span>], y[&lt;span style="color:#00d;font-weight:bold">50&lt;/span>:&lt;span style="color:#00d;font-weight:bold">100&lt;/span>] &lt;span style="color:#888"># Iris-versicolor 4个特征&lt;/span>
X_virginica, y_virginica &lt;span style="color:#333">=&lt;/span> X[&lt;span style="color:#00d;font-weight:bold">100&lt;/span>:&lt;span style="color:#00d;font-weight:bold">150&lt;/span>], y[&lt;span style="color:#00d;font-weight:bold">100&lt;/span>:&lt;span style="color:#00d;font-weight:bold">150&lt;/span>] &lt;span style="color:#888"># Iris-virginica 4个特征&lt;/span>
&lt;span style="color:#888"># training set&lt;/span>
X_setosa_train &lt;span style="color:#333">=&lt;/span> X_setosa[:&lt;span style="color:#00d;font-weight:bold">30&lt;/span>, :]
y_setosa_train &lt;span style="color:#333">=&lt;/span> y_setosa[:&lt;span style="color:#00d;font-weight:bold">30&lt;/span>]
X_versicolor_train &lt;span style="color:#333">=&lt;/span> X_versicolor[:&lt;span style="color:#00d;font-weight:bold">30&lt;/span>, :]
y_versicolor_train &lt;span style="color:#333">=&lt;/span> y_versicolor[:&lt;span style="color:#00d;font-weight:bold">30&lt;/span>]
X_virginica_train &lt;span style="color:#333">=&lt;/span> X_virginica[:&lt;span style="color:#00d;font-weight:bold">30&lt;/span>, :]
y_virginica_train &lt;span style="color:#333">=&lt;/span> y_virginica[:&lt;span style="color:#00d;font-weight:bold">30&lt;/span>]
X_train &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>vstack([X_setosa_train, X_versicolor_train, X_virginica_train])
y_train &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>hstack([y_setosa_train, y_versicolor_train, y_virginica_train])
&lt;span style="color:#888"># validation set&lt;/span>
X_setosa_val &lt;span style="color:#333">=&lt;/span> X_setosa[&lt;span style="color:#00d;font-weight:bold">30&lt;/span>:&lt;span style="color:#00d;font-weight:bold">40&lt;/span>, :]
y_setosa_val &lt;span style="color:#333">=&lt;/span> y_setosa[&lt;span style="color:#00d;font-weight:bold">30&lt;/span>:&lt;span style="color:#00d;font-weight:bold">40&lt;/span>]
X_versicolor_val &lt;span style="color:#333">=&lt;/span> X_versicolor[&lt;span style="color:#00d;font-weight:bold">30&lt;/span>:&lt;span style="color:#00d;font-weight:bold">40&lt;/span>, :]
y_versicolor_val &lt;span style="color:#333">=&lt;/span> y_versicolor[&lt;span style="color:#00d;font-weight:bold">30&lt;/span>:&lt;span style="color:#00d;font-weight:bold">40&lt;/span>]
X_virginica_val &lt;span style="color:#333">=&lt;/span> X_virginica[&lt;span style="color:#00d;font-weight:bold">30&lt;/span>:&lt;span style="color:#00d;font-weight:bold">40&lt;/span>, :]
y_virginica_val &lt;span style="color:#333">=&lt;/span> y_virginica[&lt;span style="color:#00d;font-weight:bold">30&lt;/span>:&lt;span style="color:#00d;font-weight:bold">40&lt;/span>]
X_val &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>vstack([X_setosa_val, X_versicolor_val, X_virginica_val])
y_val &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>hstack([y_setosa_val, y_versicolor_val, y_virginica_val])
&lt;span style="color:#888"># test set&lt;/span>
X_setosa_test &lt;span style="color:#333">=&lt;/span> X_setosa[&lt;span style="color:#00d;font-weight:bold">40&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>, :]
y_setosa_test &lt;span style="color:#333">=&lt;/span> y_setosa[&lt;span style="color:#00d;font-weight:bold">40&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>]
X_versicolor_test &lt;span style="color:#333">=&lt;/span> X_versicolor[&lt;span style="color:#00d;font-weight:bold">40&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>, :]
y_versicolor_test &lt;span style="color:#333">=&lt;/span> y_versicolor[&lt;span style="color:#00d;font-weight:bold">40&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>]
X_virginica_test &lt;span style="color:#333">=&lt;/span> X_virginica[&lt;span style="color:#00d;font-weight:bold">40&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>, :]
y_virginica_test &lt;span style="color:#333">=&lt;/span> y_virginica[&lt;span style="color:#00d;font-weight:bold">40&lt;/span>:&lt;span style="color:#00d;font-weight:bold">50&lt;/span>]
X_test &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>vstack([X_setosa_test, X_versicolor_test, X_virginica_test])
y_test &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>hstack([y_setosa_test, y_versicolor_test, y_virginica_test])
&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">KNearestNeighbor&lt;/span>(&lt;span style="color:#007020">object&lt;/span>):
&lt;span style="color:#080;font-weight:bold">def&lt;/span> __init__(self):
&lt;span style="color:#080;font-weight:bold">pass&lt;/span>
&lt;span style="color:#888"># 训练函数&lt;/span>
&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">train&lt;/span>(self, X, y):
self&lt;span style="color:#333">.&lt;/span>X_train &lt;span style="color:#333">=&lt;/span> X
self&lt;span style="color:#333">.&lt;/span>y_train &lt;span style="color:#333">=&lt;/span> y
&lt;span style="color:#888"># 预测函数&lt;/span>
&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">predict&lt;/span>(self, X, k&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>):
&lt;span style="color:#888"># 计算L2距离&lt;/span>
num_test &lt;span style="color:#333">=&lt;/span> X&lt;span style="color:#333">.&lt;/span>shape[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>]
num_train &lt;span style="color:#333">=&lt;/span> self&lt;span style="color:#333">.&lt;/span>X_train&lt;span style="color:#333">.&lt;/span>shape[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>]
dists &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>zeros((num_test, num_train)) &lt;span style="color:#888"># 初始化距离函数&lt;/span>
&lt;span style="color:#888"># because(X - X_train)*(X - X_train) = -2X*X_train + X*X + X_train*X_train, so&lt;/span>
d1 &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#333">-&lt;/span>&lt;span style="color:#00d;font-weight:bold">2&lt;/span> &lt;span style="color:#333">*&lt;/span> np&lt;span style="color:#333">.&lt;/span>dot(X, self&lt;span style="color:#333">.&lt;/span>X_train&lt;span style="color:#333">.&lt;/span>T) &lt;span style="color:#888"># shape (num_test, num_train)&lt;/span>
d2 &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sum(np&lt;span style="color:#333">.&lt;/span>square(X), axis&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, keepdims&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#080;font-weight:bold">True&lt;/span>) &lt;span style="color:#888"># shape (num_test, 1)&lt;/span>
d3 &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sum(np&lt;span style="color:#333">.&lt;/span>square(self&lt;span style="color:#333">.&lt;/span>X_train), axis&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>) &lt;span style="color:#888"># shape (1, num_train)&lt;/span>
dist &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>sqrt(d1 &lt;span style="color:#333">+&lt;/span> d2 &lt;span style="color:#333">+&lt;/span> d3)
&lt;span style="color:#888"># 根据K值，选择最可能属于的类别&lt;/span>
y_pred &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>zeros(num_test)
&lt;span style="color:#080;font-weight:bold">for&lt;/span> i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(num_test):
dist_k_min &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>argsort(dist[i])[:k] &lt;span style="color:#888"># 最近邻k个实例位置&lt;/span>
y_kclose &lt;span style="color:#333">=&lt;/span> self&lt;span style="color:#333">.&lt;/span>y_train[dist_k_min] &lt;span style="color:#888"># 最近邻k个实例对应的标签&lt;/span>
y_pred[i] &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>argmax(np&lt;span style="color:#333">.&lt;/span>bincount(y_kclose&lt;span style="color:#333">.&lt;/span>tolist())) &lt;span style="color:#888"># 找出k个标签中从属类别最多的作为预测类别&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> y_pred
&lt;span style="color:#080;font-weight:bold">if&lt;/span> __name__ &lt;span style="color:#333">==&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;__main__&amp;#34;&lt;/span>:
KNN &lt;span style="color:#333">=&lt;/span> KNearestNeighbor()
KNN&lt;span style="color:#333">.&lt;/span>train(X_train, y_train)
y_pred &lt;span style="color:#333">=&lt;/span> KNN&lt;span style="color:#333">.&lt;/span>predict(X_test, k&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">6&lt;/span>)
accuracy &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>mean(y_pred &lt;span style="color:#333">==&lt;/span> y_test)
&lt;span style="color:#007020">print&lt;/span>(&lt;span style="background-color:#fff0f0">&amp;#39;测试集预测准确率：&lt;/span>&lt;span style="background-color:#eee">%f&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;&lt;/span> &lt;span style="color:#333">%&lt;/span> accuracy)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果如下：&lt;/p>
&lt;pre>&lt;code>测试集预测准确率：1.000000
&lt;/code>&lt;/pre>- https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description></item><item><title>C++ Primer——CH08 IO库</title><link>https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE2%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 10 May 2021 21:04:06 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE2%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE2%E6%A0%87%E5%87%86%E5%BA%93/ -&lt;h2 id="io库">IO库&lt;/h2>
&lt;h3 id="io类">IO类&lt;/h3>
&lt;p>为了支持不同类型的IO操作，除了iostream外，标准库还定义了其他一些IO类型：&lt;/p>
&lt;ul>
&lt;li>头文件iostream：
&lt;ul>
&lt;li>istream, wistream类型，从流读取数据&lt;/li>
&lt;li>ostream, wostream类型，向流写入数据&lt;/li>
&lt;li>iostream, wiostream类型，读写流&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>头文件fstream：
&lt;ul>
&lt;li>ifstream类型，从文件读取数据&lt;/li>
&lt;li>ofstream类型，向文件写入数据&lt;/li>
&lt;li>fstream类型，读写文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>头文件sstream
&lt;ul>
&lt;li>istringstream类型：从string读取数据&lt;/li>
&lt;li>ostringstream类型：向string写入数据&lt;/li>
&lt;li>stringstream类型：读写string&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>类型前加一个w的类型是为了支持宽字符，用来操纵wchart_t类型。&lt;/p>
&lt;p>&lt;strong>IO类型之间的关系&lt;/strong>：&lt;/p>
&lt;p>类型ifstream和istringstream都继承自istream，我们可以向使用istream对象一样来使用ifstream和istringstream。&lt;/p>
&lt;h4 id="io对象无拷贝或赋值">IO对象无拷贝或赋值&lt;/h4>
&lt;p>由于不能拷贝IO对象，因此我们也不能将形参或范围类型设置为流类型，进行IO操作额函数通常以&lt;strong>引用&lt;/strong>的方式传递和范围流。读写一个IO对象会改变其状态，因此传递和范围的引用不能是const的。&lt;/p>
&lt;h4 id="条件状态">条件状态&lt;/h4>
&lt;p>IO类定义了一些函数和标志，帮助我们访问和操纵流的条件状态：&lt;/p>
&lt;pre>&lt;code>//strm为一种IO类型，即上一节给出的各个类型
strm::iostate //提供了表达条件状态的完整功能
strm::badbit //用来指出流已崩溃
strm::failbit //用来指出一个IO操作失败
strm::eofbit //用来指出流到达了文件结束
strm::goodbit //用来指出流位处于错误状态。
//其余见书
&lt;/code>&lt;/pre>&lt;h4 id="管理输出缓冲">管理输出缓冲&lt;/h4>
&lt;p>每个输出流都管理一个缓冲区。&lt;/p>
&lt;p>导致缓冲刷新的原因：&lt;/p>
&lt;ul>
&lt;li>程序正常结束，作为return的一部分操作。&lt;/li>
&lt;li>缓冲区满时，需要刷新。&lt;/li>
&lt;li>使用操纵符如endl显示刷新缓冲区。&lt;/li>
&lt;li>每个输出操作后可以用操纵夫unitbuf设置流的内部状态来清空缓冲区。&lt;/li>
&lt;li>一个输出流可能被关联到另一个输出流。&lt;/li>
&lt;/ul>
&lt;p>刷新输出缓冲区：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">cout &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;hi&amp;#34;&lt;/span> &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#888">//输出hi和一个空格，然后刷新缓冲区
&lt;/span>&lt;span style="color:#888">&lt;/span>cout &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;hi&amp;#34;&lt;/span> &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> flush; &lt;span style="color:#888">//输出hi，然后刷新缓冲区，不附加额外字符
&lt;/span>&lt;span style="color:#888">&lt;/span>cout &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;hi&amp;#34;&lt;/span> &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> ends; &lt;span style="color:#888">//输出hi和一个空字符，然后刷新缓冲区
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文件输入输出">文件输入输出&lt;/h3>
&lt;p>头文件定义了如上所示的三个类型来住处文件IO。&lt;/p>
&lt;p>除了继承自iostream类型的行为外，fstream中的定义还增加了新的成员来管理与流关联的文件：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">fstream fstrm; &lt;span style="color:#888">//创建一个未绑定的流文件fstrm; fstream是头文件fstream中定义的一个类型
&lt;/span>&lt;span style="color:#888">&lt;/span>fstream &lt;span style="color:#06b;font-weight:bold">fstrm&lt;/span>(s); &lt;span style="color:#888">//创建一个fstream并打开名为s的文件
&lt;/span>&lt;span style="color:#888">&lt;/span>fstream &lt;span style="color:#06b;font-weight:bold">fstrm&lt;/span>(s,mode); &lt;span style="color:#888">//与上一个相同，但按指定mode打开
&lt;/span>&lt;span style="color:#888">&lt;/span>fstrm.open(s) &lt;span style="color:#888">//打开名为s的文件并将文件与fstrm绑定
&lt;/span>&lt;span style="color:#888">&lt;/span>fstrm.close() &lt;span style="color:#888">//关闭与fstrm绑定的文件，返回void
&lt;/span>&lt;span style="color:#888">&lt;/span>fstrm.is_open() &lt;span style="color:#888">//返回一个bool, 指出关联的文件是否成功打开尚未关闭
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="使用文件流对象">使用文件流对象&lt;/h4>
&lt;h4 id="文件模式">文件模式&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">mode&lt;/th>
&lt;th style="text-align:center">功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">in&lt;/td>
&lt;td style="text-align:center">以读方式打开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">out&lt;/td>
&lt;td style="text-align:center">以写方式打开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">app&lt;/td>
&lt;td style="text-align:center">每次写操作前均定位到文件末尾&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ate&lt;/td>
&lt;td style="text-align:center">打开文件后立即定位到末尾&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">trunc&lt;/td>
&lt;td style="text-align:center">截断文件&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="以out模式打开文件会丢弃已有数据">以out模式打开文件会丢弃已有数据&lt;/h4>
&lt;h3 id="string流">string流&lt;/h3>
&lt;h2 id="顺序容器">顺序容器&lt;/h2>
&lt;p>一个容器就是一些特定类型对象的集合。&lt;/p>
&lt;p>顺序容器提供了&lt;strong>控制元素存储&lt;/strong>和&lt;strong>访问顺序&lt;/strong>的能力。这种顺序与元素加入容器时的位置相对应。&lt;/p>
&lt;h3 id="概述">概述&lt;/h3>
&lt;p>顺序容器都提供了&lt;strong>快速顺序访问元素&lt;/strong>的能力。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">符号&lt;/th>
&lt;th style="text-align:center">顺序容器类型(名称)&lt;/th>
&lt;th style="text-align:center">性能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">vector&lt;/td>
&lt;td style="text-align:center">可变大小数组&lt;/td>
&lt;td style="text-align:center">支持快速随机访问。在尾部之外的位置插入删除元素很慢&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">deque&lt;/td>
&lt;td style="text-align:center">双端队列&lt;/td>
&lt;td style="text-align:center">支持快速随机访问。在头尾插入删除速度很快&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">list&lt;/td>
&lt;td style="text-align:center">双向链表&lt;/td>
&lt;td style="text-align:center">只支持双向顺序访问。在list中任何位置插入删除元素都很快&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">forward_list&lt;/td>
&lt;td style="text-align:center">单项链表&lt;/td>
&lt;td style="text-align:center">只支持单项顺序访问。在forward_list中任何位置插入删除元素都很快&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">array&lt;/td>
&lt;td style="text-align:center">固定大小数组&lt;/td>
&lt;td style="text-align:center">支持快速随机访问。不能添加删除元素&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">string&lt;/td>
&lt;td style="text-align:center">与vector相似的容器，专门用于保存字符&lt;/td>
&lt;td style="text-align:center">随机访问快，在尾部插入删除速度快&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>除了固定大小的array外，其他容器都提供高效的内存管理。容器保存元素的策略对容器操作的效率有着很大影响。&lt;/p>
&lt;p>string和vector将元素保存在&lt;strong>连续的内存空间&lt;/strong>中，因此由元素的下标来计算其地址非常快速。但在这两种容器的中间位置插入和删除元素的速度非常慢，因为一次插入或删除后，需要移动插入、删除位置后的&lt;strong>所有元素&lt;/strong>以保证存储的连续。&lt;/p>
&lt;p>list和forward_list两个容器能令任何位置的添加和删除操作都很快，但这两种容器&lt;strong>不支持随机访问&lt;/strong>，因为元素保存的内存空间不连续，只能通过遍历整个容器来访问一个元素。与vector和string相比，额外内存开销也很大。&lt;/p>
&lt;p>forward_list与最好的手写单向链表数据结构性能相当，因此没有size操作，因为保存或计算大小会多出额外开销。&lt;/p>
&lt;p>deque支持快读随机访问，在该容器中间位置添加或删除元素速度很慢，但在两端很快。&lt;/p>
&lt;h3 id="容器库概览">容器库概览&lt;/h3>
&lt;p>容器类型上的操作分成了层次：&lt;/p>
&lt;ul>
&lt;li>某些操作式所有容器都提供的；&lt;/li>
&lt;li>另外一些操作仅针对顺序容器、关联容器或无序容器；&lt;/li>
&lt;li>还有一些操作只适合一小部分容器。&lt;/li>
&lt;/ul>
&lt;p>容器通过&lt;strong>尖括号&lt;/strong>指定类型。&lt;/p>
&lt;h4 id="容器操作">容器操作&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">iterator
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="迭代器">迭代器&lt;/h4>
&lt;pre>&lt;code>*iter //返回迭代器iter所指元素的引用
iter-&amp;gt;name //解引用iter并获取该元素的名为mem的成员
++iter //令iter指示容器中的下一个元素
--iter //令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code>&lt;/pre>&lt;p>一个&lt;strong>迭代器范围&lt;/strong>由一对迭代器表示，这两个迭代器被称为begin和end，begin指向容器第一个元素，end指向容器的&lt;strong>尾后元素&lt;/strong>，这种元素范围被称为&lt;strong>左闭合区间&lt;/strong>，即&lt;code>[begin, end)&lt;/code>。&lt;/p>
&lt;p>对构成范围的迭代器的要求：&lt;strong>end不在begin之前&lt;/strong>。可以通过对begin进行若干次递增，使得begin==end。&lt;/p>
&lt;h4 id="容器类型成员">容器类型成员&lt;/h4>
&lt;p>每个容器都定义了多个类型。如之前使用过的&lt;code>interator&lt;/code>、&lt;code>size_type&lt;/code>等。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">interator
const_iterator
size_type
difference_type
value_type
reference
const_reference
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="begin和end成员">begin和end成员&lt;/h4>
&lt;p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。还有不同类型的反向迭代器、const迭代器。&lt;/p>
&lt;pre>&lt;code>list&amp;lt;int&amp;gt; a = {1, 2, 3};
auto it1 = a.begin(); //list&amp;lt;int&amp;gt;::iterator
auto it2 = a.rbegin(); //反向迭代器 list&amp;lt;int&amp;gt;::reverse_iterator
auto it3 = a.cbegin(); //const迭代器 list&amp;lt;int&amp;gt;::const_iterator
&lt;/code>&lt;/pre>&lt;h4 id="容器定义和初始化">容器定义和初始化&lt;/h4>
&lt;p>每个容器类型都定义了一个默认构造函数。除了array外，其他容器的默认构造函数都会创建一个指定类型的空容器。&lt;/p>
&lt;pre>&lt;code>C c; //默认构造函数
C c1(c2) //c1初始化为c2的拷贝。两者必须是相同类型的容器
C c{a,b,c...} //c初始化为初始化列表中元素的拷贝
C c(b,e) //c初始化为迭代器b和e指定范围中元素的拷贝
&lt;/code>&lt;/pre>&lt;p>与顺序容器大小相关的构造函数：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">vector&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> ivec(&lt;span style="color:#00d;font-weight:bold">10&lt;/span>, &lt;span style="color:#333">-&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>); &lt;span style="color:#888">//10个int元素，每个都初始化为1
&lt;/span>&lt;span style="color:#888">&lt;/span>list&lt;span style="color:#333">&amp;lt;&lt;/span>string&lt;span style="color:#333">&amp;gt;&lt;/span> scev(&lt;span style="color:#00d;font-weight:bold">10&lt;/span>); &lt;span style="color:#888">//10个元素，每个都是空string
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>标准库array具有固定大小&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">array&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span>, &lt;span style="color:#00d;font-weight:bold">42&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> &lt;span style="color:#888">//类型为保存42个int的数组
&lt;/span>&lt;span style="color:#888">&lt;/span>array&lt;span style="color:#333">&amp;lt;&lt;/span>string, &lt;span style="color:#00d;font-weight:bold">10&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> &lt;span style="color:#888">//类型为保存10个string的数组
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用array时必须同时指定&lt;strong>元素类型&lt;/strong>和&lt;strong>大小&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">array&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span>&lt;span style="color:#333">&amp;gt;::&lt;/span>size_type j; &lt;span style="color:#888">//错误，未指定大小
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="赋值和swap">赋值和swap&lt;/h4>
&lt;p>赋值将左边容器中的所有元素替换为右边容器中元素的拷贝。&lt;/p>
&lt;pre>&lt;code>c1 = c2;
c = {a, b, c}
swap(c1, c2)
c1.swap(c2) //与上一个等价
//assign操作不适用于关联容器和array
seq.assign(b,e) //将seq中的元素替换为迭代器b和e所表示范围的元素
seq.assign(il) //将seq中的元素替换为初始化列表il中的元素
&lt;/code>&lt;/pre>&lt;p>assign用参数所指定的元素拷贝替换左边容器中所有元素。&lt;/p>
&lt;p>swap只是交换了两个容器内部的&lt;strong>数据结构&lt;/strong>，但例外是swap两个array会真正交换它们的元素。&lt;/p>
&lt;h4 id="容器大小操作">容器大小操作&lt;/h4>
&lt;p>成员函数&lt;code>size&lt;/code>返回容器中元素的数目；empty当size为0时返回布尔值true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。&lt;/p>
&lt;p>forward_list支持max_size和empty但不支持size。&lt;/p>
&lt;h4 id="关系运算符">关系运算符&lt;/h4>
&lt;p>每个容器类型都支持相等运算符(即&lt;code>==&lt;/code>和&lt;code>!=&lt;/code>)；除&lt;strong>无序关联容器&lt;/strong>外的所有容器都支持关系运算符(&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=)。&lt;/p>
&lt;p>关系运算符左右两边的运算对象必须是相同类型的容器，且保存元素的类型也必须相等。&lt;/p>
&lt;h3 id="顺序容器操作">顺序容器操作&lt;/h3>
&lt;p>顺序容器和关联容器的不同在于两者&lt;strong>组织元素的方式&lt;/strong>。&lt;/p>
&lt;p>除了上一节介绍的所有容器都支持的操作外，本章剩余部分将介绍顺序容器的所有操作。&lt;/p>
&lt;h4 id="向顺序容器添加元素">向顺序容器添加元素&lt;/h4>
&lt;p>向顺序容器中除了array外添加元素的操作：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">c.push_back(t) &lt;span style="color:#888">//在c的尾部创建值为t或由args创建的元素
&lt;/span>&lt;span style="color:#888">&lt;/span>c.emplace_back(args)
c.push_front(t) &lt;span style="color:#888">//在c的头部创建值为t或由args创建的元素
&lt;/span>&lt;span style="color:#888">&lt;/span>c.emplace_front(args)
c.insert(p,t) &lt;span style="color:#888">//在迭代器p指向的元素之前创建一个值为t的元素
&lt;/span>&lt;span style="color:#888">&lt;/span>c.insert(p,n,t) &lt;span style="color:#888">//在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器
&lt;/span>&lt;span style="color:#888">&lt;/span>c.insert(p,b,e) &lt;span style="color:#888">//将迭代器b和e指向范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器
&lt;/span>&lt;span style="color:#888">&lt;/span>c.insert(p,il) &lt;span style="color:#888">//il为一个花括号包围的元素值列表，将这些值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>forword_list&lt;/code>不支持&lt;code>push_back&lt;/code>和&lt;code>emplace_back&lt;/code>。&lt;/p>
&lt;p>&lt;code>vector&lt;/code>和&lt;code>string&lt;/code>不支持&lt;code>push_front&lt;/code>和&lt;code>emplace_front&lt;/code>.&lt;/p>
&lt;p>使用这些操作时要注意策略，根据不同容器的不同数据结构的特性来使用。&lt;/p>
&lt;p>emplace操作构造而不是拷贝元素，将参数传递给元素类型的构造函数，直接构造元素。&lt;/p>
&lt;h4 id="访问元素">访问元素&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">c.back() &lt;span style="color:#888">//返回c中尾元素的引用，若c为空，则函数行为未定义。
&lt;/span>&lt;span style="color:#888">&lt;/span>c.front() &lt;span style="color:#888">//范围c中首元素的引用
&lt;/span>&lt;span style="color:#888">&lt;/span>c[n] &lt;span style="color:#888">//返回c中下标为n的元素的引用，n是一个无符号整数
&lt;/span>&lt;span style="color:#888">&lt;/span>c.at(n) &lt;span style="color:#888">//返回下标为n的元素的引用，若下标越界，则返回out_of_range异常
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>at和下标操作只适用于string、vector、array和deque&lt;/p>
&lt;p>back不适用于forward_list&lt;/p>
&lt;h3 id="vector对象的增长">vector对象的增长&lt;/h3>
&lt;h3 id="额外的string操作">额外的string操作&lt;/h3>
&lt;h3 id="容器适配器">容器适配器&lt;/h3>
&lt;h2 id="泛型算法">泛型算法&lt;/h2>
&lt;p>用来操纵容器。&lt;/p>
&lt;h3 id="概述-1">概述&lt;/h3>
&lt;h3 id="基本算法">基本算法&lt;/h3>
&lt;h4 id="只读算法">只读算法&lt;/h4>
&lt;h4 id="写容器元素算法">写容器元素算法&lt;/h4>
&lt;h4 id="重排容器元素算法">重排容器元素算法&lt;/h4>
&lt;h3 id="定制操作">定制操作&lt;/h3>
&lt;h4 id="向算法传递函数">向算法传递函数&lt;/h4>
&lt;h4 id="lambda表达式">lambda表达式&lt;/h4>
&lt;h4 id="lambda捕获和返回">lambda捕获和返回&lt;/h4>
&lt;h4 id="参数绑定">参数绑定&lt;/h4>
&lt;h3 id="再探迭代器">再探迭代器&lt;/h3>
&lt;h4 id="插入迭代器">插入迭代器&lt;/h4>
&lt;h4 id="iostream迭代器">iostream迭代器&lt;/h4>
&lt;h4 id="反向迭代器">反向迭代器&lt;/h4>
&lt;h3 id="泛型算法结构">泛型算法结构&lt;/h3>
&lt;p>输入、输出、前向、双向、随机访问迭代器&lt;/p>
&lt;h3 id="特定容器算法">特定容器算法&lt;/h3>
&lt;h2 id="关联容器">关联容器&lt;/h2>
&lt;p>键值对。&lt;/p>
&lt;h2 id="动态内存">动态内存&lt;/h2>- https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE2%E6%A0%87%E5%87%86%E5%BA%93/ - 2019-2021 By Jialong</description></item><item><title>Altium Designer画图流程记录(简略)</title><link>https://eternityqjl.github.io/blog2_public/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</link><pubDate>Fri, 30 Apr 2021 22:47:47 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/ -&lt;p>之前看过博主&lt;a href="https://space.bilibili.com/384891">半夜中暑的羊&lt;/a>的原理图以及PCB绘制&lt;a href="https://www.bilibili.com/video/BV1JE41127Ks">教程&lt;/a>，收获颇丰，但是视频比较长而且分为多集，每次有些地方忘记时要去找到很不方便，因此趁着这次画一个简单转接版的机会，把视频中的内容整理成文字版，方便之后查找和复习。这里面只涉及基本的两层版的基本绘制。&lt;/p>
&lt;p>共有以下几部分内容：&lt;/p>
&lt;ol>
&lt;li>原理图库&lt;/li>
&lt;li>核心模块的原理图&lt;/li>
&lt;li>为原理图添加封装&lt;/li>
&lt;li>PCB布局&lt;/li>
&lt;li>PCB布线&lt;/li>
&lt;li>PCB敷铜&lt;/li>
&lt;li>PCB生成BOM及投板&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;h2 id="pcb各层简介">PCB各层简介&lt;/h2>
&lt;p>参考自：&lt;a href="https://blog.csdn.net/qq_29373285/article/details/85339076">PCB各层介绍&lt;/a>&lt;/p>
&lt;h3 id="mechanical-layer机械层">Mechanical layer(机械层)&lt;/h3>
&lt;p>Altium Designer提供了16个机械层，它一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。这些信息因设计公司或PCB制造厂家的要求而有所不同。另外，机械层可以附加在其它层上一起输出显示。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/MechanicalLayer.PNG" alt="MechanicalLayer">&lt;/p>
&lt;h3 id="keep-out-layer禁止布线层">Keep out layer(禁止布线层)&lt;/h3>
&lt;p>用于定义在电路板上能够有效放置元件和布线的区域。在该层绘制一个封闭区域作为布线有效区，在该区域外是不能自动布局和布线的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/KeepOutLayer.PNG" alt="KeepOutLayer">&lt;/p>
&lt;h3 id="signal-layer信号层">Signal layer(信号层)&lt;/h3>
&lt;p>信号层主要用于布置电路板上的导线。Altium Designer提供了32个信号层，包括Top layer(顶层)，Bottom layer(底层)和32个内电层。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SignalLayer.PNG" alt="SignalLayer">&lt;/p>
&lt;h3 id="internal-plane-layer内部电源接地层">Internal plane layer(内部电源/接地层)&lt;/h3>
&lt;p>Altium Designer提供了32个内部电源层/接地层。该类型的层仅用于多层板，主要用于布置电源层和接地层。我们称双层板，四层板，六层板，一般指信号层和内部电源/接地层的数目。&lt;/p>
&lt;h3 id="silkscreen-layer丝印层">Silkscreen layer(丝印层)&lt;/h3>
&lt;p>丝印层主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。Altium Designer提供了Top Overlay（顶层丝印层）和Bottom Overlay（底层丝印层）两个丝印层。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SilkscreenLayer.PNG" alt="SilkscreenLayer">&lt;/p>
&lt;h3 id="solder-mask-layer阻焊层">Solder mask layer(阻焊层)&lt;/h3>
&lt;p>在焊盘以外的各部位涂覆一层涂料，我们通常用的有绿油、蓝油等，用于阻止这些部位上锡。阻焊层用于在设计过程中&lt;strong>匹配焊盘&lt;/strong>，是&lt;strong>自动产生&lt;/strong>的。阻焊层是负片输出，阻焊层的地方不盖油，其他地方盖油。Altium Designer提供了**Top Solder(顶层)&lt;strong>和&lt;/strong>Bottom Solder(底层)**两个阻焊层。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SolderMaskLayer.PNG" alt="SolderMaskLayer">&lt;/p>
&lt;h3 id="paste-mask-layer助焊层smd贴片层">Paste mask layer(助焊层，SMD贴片层)&lt;/h3>
&lt;p>它和阻焊层的作用相似，不同的是在机器焊接时对应的表面粘贴式元件的焊盘。Altium Designer提供了Top Paste(顶层助焊层)和Bottom Paste(底层助焊层)两个助焊层。主要针对PCB板上的SMD元件。在将SMD元件贴PCB板上以前，必须在每一个SMD焊盘上先涂上锡膏，在涂锡用的钢网就一定需要这个Paste Mask文件,菲林胶片才可以加工出来。Paste Mask层的Gerber输出最重要的一点要清楚，即这个层主要针对SMD元件，同时将这个层与上面介绍的Solder Mask作一比较，弄清两者的不同作用，因为从菲林胶片图中看这两个胶片图很相似。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/PasteMaskLayer.PNG" alt="PasteMaskLayer">&lt;/p>
&lt;h3 id="multi-layer多层">Multi layer(多层)&lt;/h3>
&lt;p>电路板上焊盘和穿透式过孔要穿透整个电路板，与不同的导电图形层建立电气连接关系，因此系统专门设置了一个抽象的层—多层。一般，焊盘与过孔都要设置在多层上，如果关闭此层，焊盘与过孔就无法显示出来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/MultiLayer.PNG" alt="MultiLayer">&lt;/p>
&lt;h3 id="drill-layer钻孔层">Drill layer(钻孔层)&lt;/h3>
&lt;p>钻孔层提供电路板制造过程中的钻孔信息(如焊盘，过孔就需要钻孔)。Altium Designer提供了Drill gride(钻孔指示)和Drill drawing(钻孔)两个钻孔层。&lt;/p>
&lt;h2 id="原理图库器件画法">原理图库器件画法&lt;/h2>
&lt;p>放置矩形&lt;/p>
&lt;p>添加Pin&lt;/p>
&lt;p>设置器件的Designator（例如P?）&lt;/p>
&lt;h2 id="器件的pcb封装画法">器件的PCB封装画法&lt;/h2>
&lt;p>确定是过孔还是焊盘，然后根据坐标放置位置，最后画丝印。&lt;/p>
&lt;h2 id="批量添加封装并给各种原件命名">批量添加封装并给各种原件命名&lt;/h2>
&lt;h3 id="添加封装">添加封装&lt;/h3>
&lt;p>右键-Find Similar Objects选择相同类型的原件-右键-Properties-修改封装&lt;/p>
&lt;h3 id="批量命名">批量命名&lt;/h3>
&lt;p>执行&lt;strong>Tools-Annotation-Annotate Schematic&lt;/strong>(或快捷键&lt;strong>T A A&lt;/strong>)命令打开原理图元件命名管理器&lt;/p>
&lt;p>左上角设置命名顺序&lt;/p>
&lt;p>设置命名范围&lt;/p>
&lt;p>然后单击Update&lt;/p>
&lt;p>可以看到新的命名建议，然后执行有效角的接收更改&lt;/p>
&lt;p>依次单击Validate和Execute（保证两排绿√）&lt;/p>
&lt;p>即可完成命名&lt;/p>
&lt;h2 id="确定pcb范围并布局">确定PCB范围并布局&lt;/h2>
&lt;p>根据需要的形状和经验粗略地确定版图的位置边界，然后布局元件位置。&lt;/p>
&lt;h2 id="布线">布线&lt;/h2>
&lt;p>注意设置焊盘间的距离，jlc为7mil，以及过孔孔径。&lt;/p>
&lt;p>过孔打法：&lt;code>Alt+Shift+鼠标滚轮向上&lt;/code>&lt;/p>
&lt;h2 id="铺铜">铺铜&lt;/h2>
&lt;p>使用铺铜管理器进行铺铜：&lt;/p>
&lt;ol>
&lt;li>工具→铺铜→铺铜管理器（快捷键:TGM）&lt;/li>
&lt;li>选择来自&amp;hellip;..的新多边形（New Polygon from &amp;hellip;）→板外形（Board Outline）&lt;/li>
&lt;li>设置网络，哪一层？除去死铜&lt;/li>
&lt;li>最后点击应用，确定，这样顶层的铺地铜就铺好了！&lt;/li>
&lt;li>其他层同样按照上面的步骤进行&lt;/li>
&lt;/ol>
&lt;h2 id="设置板子边界">设置板子边界&lt;/h2>
&lt;p>首先选中Keep-Out-Layer所定义的边界&lt;/p>
&lt;p>然后：&lt;/p>
&lt;p>【Design】|【Board shape】|【Define from selected objects】&lt;/p>
&lt;p>快捷键为D+S+D+enter&lt;/p>
&lt;h2 id="其他一些快捷键">其他：一些快捷键&lt;/h2>
&lt;ul>
&lt;li>&lt;code>ctrl+D&lt;/code>: View Configuration，用来配置PCB的显示内容&lt;/li>
&lt;li>&lt;code>ctrl+M&lt;/code>：测量长度，使用&lt;code>shift+C&lt;/code>删除测量得到的线&lt;/li>
&lt;/ul>
&lt;h2 id="批量修改元件">批量修改元件&lt;/h2>
&lt;p>以命名所有电阻为例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先使用过滤器选中所有电阻&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行&lt;strong>工具——Annotation——注解&lt;/strong>（英文为&lt;strong>Tools——Annotation——Annotate Schematic&lt;/strong>，或者快捷键&lt;strong>T A A&lt;/strong>）命令打开原理图元件命名管理器&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="3d渲染图实现">3D渲染图实现&lt;/h2>
- https://eternityqjl.github.io/blog2_public/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/ - 2019-2021 By Jialong</description></item><item><title>C++回顾1——基础语法</title><link>https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</link><pubDate>Sun, 25 Apr 2021 10:08:56 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/ -&lt;p>第1部分：C++基础&lt;/p>
&lt;p>这个分类的博客主要为了记录一下我在学习C++过程中记录的知识笔记，主要参考自《C++ Primer 第5版》。&lt;/p>
&lt;p>第一部分基础部分主要包含以下内容：&lt;/p>
&lt;ul>
&lt;li>变量和基本类型&lt;/li>
&lt;li>表达式&lt;/li>
&lt;li>语句&lt;/li>
&lt;li>函数&lt;/li>
&lt;li>类&lt;/li>
&lt;/ul>
&lt;h2 id="变量和基本类型">变量和基本类型&lt;/h2>
&lt;h3 id="变量">变量&lt;/h3>
&lt;p>变量的声明和定义：&lt;/p>
&lt;p>显示声明时在变量前加上extern。&lt;/p>
&lt;p>声明只规定了变量类型和名字，定义还申请了存储空间，为变量赋一个初始值。&lt;/p>
&lt;p>可以在多个文件重复声明，但只能定义一次。&lt;/p>
&lt;h3 id="复合类型">复合类型&lt;/h3>
&lt;p>&lt;strong>引用&lt;/strong>&lt;/p>
&lt;p>左值引用，为对象起了另一个名字；将声明符写成&lt;code>&amp;amp;d&lt;/code>的形式来定义引用类型。&lt;/p>
&lt;pre>&lt;code>int ival = 1024;
int &amp;amp;refVal = ival;
int &amp;amp;refVal2;
&lt;/code>&lt;/pre>&lt;p>引用即为对象的别名，引用本身不是一个对象，只是为一个已存在的对象起的另一个名字。&lt;/p>
&lt;p>&lt;strong>指针&lt;/strong>&lt;/p>
&lt;p>指针本身就是一个对象，允许对指针赋值和拷贝，无需再定义时赋值，定义指针时将声明符写作&lt;code>*d&lt;/code>形式，d为变量名。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#339;font-weight:bold">double&lt;/span> dp, &lt;span style="color:#333">*&lt;/span>dp2; &lt;span style="color:#888">//dp2为指向double类型对象的指针
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>取地址符&lt;code>&amp;amp;&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#339;font-weight:bold">int&lt;/span> ival &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">42&lt;/span>;
&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#333">*&lt;/span>p &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#333">&amp;amp;&lt;/span>ival;&lt;span style="color:#888">//p存放ival的地址
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解引用符&lt;code>*&lt;/code>：&lt;/p>
&lt;pre>&lt;code>int ival = 42;
int *p = &amp;amp;ival;//p存放ival的地址
cout &amp;lt;&amp;lt; *p; //输出指针p所指的对象，42
&lt;/code>&lt;/pre>&lt;p>空指针：不指向任何对象，使用字面值&lt;code>nullptr&lt;/code>来初始化指针。&lt;/p>
&lt;p>给指针赋值：令他存放一个新的地址，从而指向一个新的对象。&lt;/p>
&lt;p>&lt;code>void*&lt;/code>指针：一种特殊类型的指针，可用于存放任意对象的地址。&lt;/p>
&lt;p>复合类型的声明：&lt;/p>
&lt;p>变量的定义包含一个基本数据类型和一组声明符；同一条定义中，基本数据类型只有一个，但声明符的形式可以不同，即一条语句可以定义不同类型的变量：&lt;/p>
&lt;pre>&lt;code>int i = 1024, *p = &amp;amp;i, &amp;amp;r = i;
//i是一个int数，p是一个int类型指针，r是一个int类型引用
&lt;/code>&lt;/pre>&lt;p>一般把修饰符(&lt;code>&amp;amp;,*&lt;/code>)和变量标识符写在一起。&lt;/p>
&lt;p>指向指针的指针：&lt;/p>
&lt;p>指向指针的引用：&lt;/p>
&lt;h3 id="const限定符">const限定符&lt;/h3>
&lt;p>让一种变量的值不变。congst对象必须要初始化，任何试图为const对象赋值的行为都将发生错误。&lt;/p>
&lt;p>const对象仅在文件内有效；要想让const对象像其他非常量对象一样在不同文件中工作，即在一个文件中定义const，在其他多个文件中声明并使用它，需要添加&lt;code>extern&lt;/code>关键字&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#888">//file.cpp定义并初始化了一个常量
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">extern&lt;/span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> bufSize &lt;span style="color:#333">=&lt;/span> fcn();
&lt;span style="color:#888">//file.h头文件，与file.cpp定义的bufSize是同一个
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">extern&lt;/span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> bufSize;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>const的引用&lt;/strong>&lt;/p>
&lt;p>可以把引用绑定到const对象上，但对常量的引用不能用于修改它所绑定的对象。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> ci &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1024&lt;/span>;
&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#333">&amp;amp;&lt;/span>r1 &lt;span style="color:#333">=&lt;/span> ci; &lt;span style="color:#888">//正确：引用及其对应的对象都是常量
&lt;/span>&lt;span style="color:#888">&lt;/span>r1 &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">42&lt;/span>; &lt;span style="color:#888">//错误
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#333">&amp;amp;&lt;/span>r2 &lt;span style="color:#333">=&lt;/span> ci; &lt;span style="color:#888">//错误，试图让一个非常量引用指向一个常量对象
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引用的类型必须与所引用的对象类型一致，但有例外：&lt;/p>
&lt;p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能被转换为引用的类型即可。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#333">&amp;amp;&lt;/span>r1 &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">42&lt;/span>; &lt;span style="color:#888">//正确
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>指针和const&lt;/strong>&lt;/p>
&lt;p>可以令指针指向常量或非常量，&lt;strong>指向常量的指针&lt;/strong>不能用于改变其所指对象的值，要想存放常量对象，只能使用&lt;strong>指向常量的指针&lt;/strong>：&lt;/p>
&lt;pre>&lt;code>const double pi = 3.14;
double *ptr = &amp;amp;pi; //错误：ptr是普通指针
const double *cptr = &amp;amp;pi; //正确
&lt;/code>&lt;/pre>&lt;p>&lt;strong>顶层const&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>顶层const：表示指针本身是个常量；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>底层const：表示指针所指的对象是一个常量。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>int i = 0;
int *const p1 = &amp;amp;i; //顶层const，表示指针p1本身是一个常量，不能改变p1的值
const int *p2 = &amp;amp;ci; //底层const，表示指针p2指的对象ci的地址是一个常量，p2的值可以改变，对象的值不能改变
&lt;/code>&lt;/pre>&lt;p>&lt;strong>constexpr和常量表达式&lt;/strong>&lt;/p>
&lt;p>常量表达式指值不会改变并且在编译过程就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。&lt;/p>
&lt;p>&lt;strong>constexpr变量&lt;/strong>&lt;/p>
&lt;p>C++11允许将变量声明为constexpr类型以便由编译器验证变量的值是否是一个常量表达式。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> mf &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">20&lt;/span>; &lt;span style="color:#888">//20是常量表达式
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> sz &lt;span style="color:#333">=&lt;/span> size(); &lt;span style="color:#888">//只有当size是一个constexpr函数是才是一条正确的声明语句
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>字面值类型：声明constexpr时用到的类型。算术类型、引用和指针都属于字面值类型；IO库、string类型不属于字面值类型，不能被定义为constexpr。&lt;/p>
&lt;h3 id="处理类型">处理类型&lt;/h3>
&lt;p>&lt;strong>类型别名&lt;/strong>：&lt;/p>
&lt;p>使用关键词&lt;code>typedef&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#080;font-weight:bold">typedef&lt;/span> &lt;span style="color:#339;font-weight:bold">double&lt;/span> wages; &lt;span style="color:#888">//wages是double的同义词
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另一种别名声明：&lt;/p>
&lt;pre>&lt;code>using SI = Sales_item;
&lt;/code>&lt;/pre>&lt;h2 id="字符串向量和数组">字符串、向量和数组&lt;/h2>
&lt;h3 id="命名空间和using声明">命名空间和using声明&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#080;font-weight:bold">namespace&lt;/span>&lt;span style="color:#333">::&lt;/span>name; &lt;span style="color:#888">//命名空间::名字
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个名字都需要独立的using声明；头文件不应该包含using声明&lt;/p>
&lt;h3 id="标准库类型string">标准库类型string&lt;/h3>
&lt;p>string表示可变长的字符序列&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;string&amp;gt;
using std::string;
&lt;/code>&lt;/pre>&lt;p>定义和初始化：&lt;/p>
&lt;pre>&lt;code>string s1;
string s2(s1);
string s3(&amp;quot;value&amp;quot;);
string s3 = &amp;quot;value&amp;quot;;
string s4(n, 'c'); //s4初始化为由连续的n个字符组成的串
&lt;/code>&lt;/pre>&lt;p>string对象上的操作：&lt;/p>
&lt;pre>&lt;code>os &amp;lt;&amp;lt; s //将s写道输出流os中，返回os
is &amp;gt;&amp;gt; s //从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s) //从is中读取一行赋给s，返回is
s.empty()
s.size()
s[n] //返回s中第n个字符的引用
&lt;/code>&lt;/pre>&lt;p>&lt;code>string::size_type&lt;/code>类型&lt;/p>
&lt;p>size函数返回的为上述值，是一个无符号类型的值，能存放下任何string类型对象大小。&lt;/p>
&lt;p>处理string对象中的字符：&lt;/p>
&lt;pre>&lt;code>//cctype头文件中的函数
isalnum(c) //c是数字或字母时为真
isalpha(c)
...
&lt;/code>&lt;/pre>&lt;p>使用&lt;code>for&lt;/code>处理每个字符：&lt;/p>
&lt;pre>&lt;code>string str(&amp;quot;some string&amp;quot;);
for (auto c : str)
cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/code>&lt;/pre>&lt;p>使用下标运算符&lt;code>[]&lt;/code>处理一部分字符.&lt;/p>
&lt;h3 id="标准库类型vector">标准库类型vector&lt;/h3>
&lt;p>表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，用于访问对象，因为vector容纳着其他对象，所以也被称之为&lt;strong>容器&lt;/strong>。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;vector&amp;gt;
using std::vector;
&lt;/code>&lt;/pre>&lt;p>vector是一个&lt;strong>类模板&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>模板&lt;/strong>本身不是类或函数，可以看作编译器生成类或函数编写的一份说明，编译器根据模板创建类或函数的过程称为&lt;strong>实例化&lt;/strong>，使用模板时要指出编译器应该把类或函数实例化成何种类型。需要提供那些信息由模板决定，提供信息的方式是在模板名字后面跟一对尖括号，在括号内放入信息：&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;int&amp;gt; ivec; //ivec保存int类型对象
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file; //该向量的元素是vector对象
&lt;/code>&lt;/pre>&lt;p>&lt;strong>初始化vector对象&lt;/strong>&lt;/p>
&lt;p>定义和初始化vector对象&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;T&amp;gt; v1;
vector&amp;lt;T&amp;gt; v2(v1);
vector&amp;lt;T&amp;gt; v3(n, val);
&lt;/code>&lt;/pre>&lt;p>可以默认初始化vector对象，从而创建一个指定类型的空vector。&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;string&amp;gt; svec;
&lt;/code>&lt;/pre>&lt;p>列表初始化对象：&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;string&amp;gt; v1{&amp;quot;a&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;the&amp;quot;};
&lt;/code>&lt;/pre>&lt;p>创建指定数量元素：&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;int&amp;gt; ivec(10, -1);
&lt;/code>&lt;/pre>&lt;p>值初始化：&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;int&amp;gt; ivec(10); //10个元素，每个初始值都为0
&lt;/code>&lt;/pre>&lt;p>&lt;strong>向vector对象中添加元素&lt;/strong>&lt;/p>
&lt;p>使用vector的成员函数&lt;code>push_back()&lt;/code>添加。&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;string&amp;gt; str;
string i = &amp;quot;111&amp;quot;;
str.push_back(i);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>其他vector操作&lt;/strong>&lt;/p>
&lt;pre>&lt;code>v.empty() //判断v中是否含有元素，返回布尔值
v.size() //返回v中元素个数
v.push_back(t) //向v尾端添加一个值为t的元素
v[n] //返回v中的n个位置上元素的引用
v1 = v2 //用v2中的元素拷贝替换v1中的元素
&lt;/code>&lt;/pre>&lt;p>使用下标运算符[]计算vector对象的索引，下标类型是size_type。&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;string&amp;gt; str;
string s = str[0]; //[]中的0为size_type类型
&lt;/code>&lt;/pre>&lt;p>要使用size_type必须知名它是由哪种类型定义的。vector对象的类型总是包含着元素的类型&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;int&amp;gt;::size_type //正确
vector::size_type //错误
&lt;/code>&lt;/pre>&lt;p>不能用下标形式添加元素，以下为错误示范：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">-&lt;/span> &lt;span style="color:#00d;font-weight:bold">5&lt;/span>;
vector&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> ivec;
ivec[ix] &lt;span style="color:#333">=&lt;/span> ix;
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="迭代器iterator">迭代器iterator&lt;/h3>
&lt;p>迭代器可以用来访问容器的对象。&lt;/p>
&lt;p>有迭代器的类型都拥有名为&lt;code>beign&lt;/code>和&lt;code>end&lt;/code>的成员函数，end成员返回指向容器尾元素下一位置的迭代器，即一个不存在的尾后元素。&lt;/p>
&lt;p>迭代器运算符：&lt;/p>
&lt;pre>&lt;code>*iter //返回迭代器iter所指元素的引用
iter-&amp;gt;name //解引用iter并获取该元素的名为mem的成员
++iter //令iter指示容器中的下一个元素
--iter //令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code>&lt;/pre>&lt;p>将迭代器从一个元素移动到另一个元素：&lt;/p>
&lt;p>使用&lt;code>++&lt;/code>递增运算符。&lt;/p>
&lt;p>迭代器类型：&lt;/p>
&lt;pre>&lt;code>vector&amp;lt;int&amp;gt;::iterator it; //it能读写vector&amp;lt;int&amp;gt;的元素
vector&amp;lt;int&amp;gt;::const_iterator it3; //it3只能读元素，不能写元素
&lt;/code>&lt;/pre>&lt;p>某些对vector对象的操作会使迭代器失效&lt;/p>
&lt;p>迭代器运算：移动位置&lt;/p>
&lt;pre>&lt;code>iter + n //加上一个整数仍然得到一个迭代器，迭代器指示的新位置与原来的位置相比向前移动了若干个元素
iter - n
iter += n
&lt;/code>&lt;/pre>&lt;h2 id="表达式">表达式&lt;/h2>
&lt;h3 id="成员访问运算符">成员访问运算符&lt;/h3>
&lt;p>箭头运算符与点运算符有关，表达式&lt;code>ptr-&amp;gt;mem&lt;/code>等价于&lt;code>(*ptr).mem&lt;/code>；&lt;/p>
&lt;h3 id="条件运算符">条件运算符&lt;/h3>
&lt;pre>&lt;code>cond ? expr1 : expr2;
&lt;/code>&lt;/pre>&lt;h3 id="位运算符">位运算符&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">运算符&lt;/th>
&lt;th style="text-align:center">功能&lt;/th>
&lt;th style="text-align:center">用法&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>~&lt;/code>&lt;/td>
&lt;td style="text-align:center">位求反&lt;/td>
&lt;td style="text-align:center">&lt;code>~expr&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>&amp;lt;&amp;lt;,&amp;gt;&amp;gt;&lt;/code>&lt;/td>
&lt;td style="text-align:center">左移，右移&lt;/td>
&lt;td style="text-align:center">&lt;code>expr1 &amp;lt;&amp;lt; expr2&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td style="text-align:center">位或&lt;/td>
&lt;td style="text-align:center">&lt;code>expr1 &amp;amp; expr2&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>^&lt;/code>&lt;/td>
&lt;td style="text-align:center">位异或&lt;/td>
&lt;td style="text-align:center">&lt;code>expr1 ^ expr2&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">`&lt;/td>
&lt;td style="text-align:center">`&lt;/td>
&lt;td style="text-align:center">位或&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="sizeof运算符">sizeof运算符&lt;/h3>
&lt;p>返回一条表达式或一个类型名字所占的字节数。&lt;/p>
&lt;pre>&lt;code>sizeof data;
sizeof *p; //指针所占的空间大小
&lt;/code>&lt;/pre>&lt;h3 id="逗号运算符">逗号运算符&lt;/h3>
&lt;p>含有两个运算对象，按从左向右的顺序依次求值。&lt;/p>
&lt;h2 id="语句">语句&lt;/h2>
&lt;h3 id="跳转语句">跳转语句&lt;/h3>
&lt;p>break：终止离它最近的while，do while，for或switch语句，并从这些语句之后的第一条语句开始执行。&lt;/p>
&lt;p>continue：终止最近的循环中的当前迭代并立即开始下一次迭代。&lt;/p>
&lt;h3 id="try语句块和异常处理">try语句块和异常处理&lt;/h3>
&lt;p>异常指的是一些超出了函数正常功能范围的反常行为。&lt;/p>
&lt;p>C++中异常处理机制包括：&lt;/p>
&lt;p>&lt;strong>throw表达式&lt;/strong>&lt;/p>
&lt;p>程序的异常检测部分使用throw表达式引发一个异常。表达式半酣关键词throw和紧随其后的一个表达式，其中表达式类型就是抛出的异常类型。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">if&lt;/span> (item1.isbn() &lt;span style="color:#333">!=&lt;/span> item2.isbn())
&lt;span style="color:#080;font-weight:bold">throw&lt;/span> runtime_error(&lt;span style="background-color:#fff0f0">&amp;#34;Data must refer to same ISBN&amp;#34;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该异常是runtime_error的对象，抛出异常将终止当前函数，把控制权转移给能处理该异常的代码。&lt;/p>
&lt;p>runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。&lt;/p>
&lt;p>&lt;strong>try语句块&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">try&lt;/span> {
program&lt;span style="color:#333">-&lt;/span>statements
} &lt;span style="color:#080;font-weight:bold">catch&lt;/span> (exception&lt;span style="color:#333">-&lt;/span>declaration) {
handler&lt;span style="color:#333">-&lt;/span>statements
} &lt;span style="color:#080;font-weight:bold">catch&lt;/span> (exception&lt;span style="color:#333">-&lt;/span>declaration) {
handler&lt;span style="color:#333">-&lt;/span>statements
} &lt;span style="color:#888">//...
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>跟在try块后的是一个或多个catch子句；catch子句包括三部分：关键词catch、括号内的一个对象的声明(称为异常声明)以及一个块。当选中类某个catch子句处理异常后，执行与之对应的块。&lt;/p>
&lt;h2 id="函数">函数&lt;/h2>
&lt;h3 id="函数基础">函数基础&lt;/h3>
&lt;p>&lt;strong>形参列表&lt;/strong>&lt;/p>
&lt;p>函数的形参列表可以为空，但不能省略；形参通常用都好隔开，每个形参都是含有一个声明符的声明，即使两个形参的类型相同，也必须把两个类型都写出来。&lt;/p>
&lt;pre>&lt;code>void f1() {}
void f2(void) {}
int f3(int v1, v2) //这样写是错的
int f4(int v3, int v4) //这样写正确
&lt;/code>&lt;/pre>&lt;p>&lt;strong>函数声明&lt;/strong>&lt;/p>
&lt;p>函数的声明无需函数体，用一个分号代替。&lt;/p>
&lt;p>一般在头文件中进行声明，在源文件中进行定义。&lt;/p>
&lt;p>&lt;strong>const形参和实参&lt;/strong>&lt;/p>
&lt;p>当用实参初始化形参时会忽略顶层const&lt;/p>
&lt;p>&lt;strong>数组形参&lt;/strong>&lt;/p>
&lt;p>数组的&lt;strong>不允许拷贝&lt;/strong>和使用时数组通常会将其转换成&lt;strong>指针&lt;/strong>的特殊性质对定义和使用在数组上的函数有很大影响。我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">print&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span>&lt;span style="color:#333">*&lt;/span>);
&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">print&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span>[]);
&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">print&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span>[&lt;span style="color:#00d;font-weight:bold">10&lt;/span>]); &lt;span style="color:#888">//这里的维度表示我们期望数组含有的元素数量，实际上不一定。
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的三个函数是等价的，每个函数的形参都是const int*类型。&lt;/p>
&lt;p>&lt;strong>数组引用形参&lt;/strong>：&lt;/p>
&lt;p>C++允许将变量定义为数组的引用，形参也可以是数组的引用。此时，引用形参绑定到对应实参上，也就是绑定到数组上：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">print&lt;/span>(&lt;span style="color:#339;font-weight:bold">int&lt;/span> (&lt;span style="color:#333">&amp;amp;&lt;/span>arr)[&lt;span style="color:#00d;font-weight:bold">10&lt;/span>])
{
&lt;span style="color:#080;font-weight:bold">for&lt;/span> (&lt;span style="color:#080;font-weight:bold">auto&lt;/span> &lt;span style="color:#970;font-weight:bold">elem&lt;/span> : arr)
cout &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> elem &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上为数组的引用而不是引用的数组。&lt;/p>
&lt;pre>&lt;code>f(int &amp;amp;arr[10]) //将arr声明为了引用的数组
f(int (&amp;amp;arr)[10]) //arr是具有10个整数的整形数组的引用
&lt;/code>&lt;/pre>&lt;p>&lt;strong>传递多维数组&lt;/strong>：&lt;/p>
&lt;p>多维数组实际上是数组的数组，将多维数组传递给函数实际上传递的是指向数组首元素的指针。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">print&lt;/span>(&lt;span style="color:#339;font-weight:bold">int&lt;/span> (&lt;span style="color:#333">*&lt;/span>matrix)[&lt;span style="color:#00d;font-weight:bold">10&lt;/span>], &lt;span style="color:#339;font-weight:bold">int&lt;/span> rowSize) {}
&lt;span style="color:#888">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组。
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="main处理命令行选项">main：处理命令行选项&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>(&lt;span style="color:#339;font-weight:bold">int&lt;/span> argc, &lt;span style="color:#339;font-weight:bold">char&lt;/span> &lt;span style="color:#333">*&lt;/span>argv[]) {...}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>假定main函数位于可执行文件prog之内，我们可以想程序传递下面的选项：&lt;/p>
&lt;p>prog -d -o ofile data0&lt;/p>
&lt;p>第二个形参argv是一个数组，其元素为指向c风格字符串的指针；第一个形参argc表示数组中字符串的数量。&lt;/p>
&lt;p>当实参传递给main函数后，argc的第一个元素指向程序的名字或一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。&lt;/p>
&lt;h3 id="函数重载">函数重载&lt;/h3>
&lt;p>同一作用域内的几个函数名字相同但形参列表不同，称之为&lt;strong>重载函数&lt;/strong>。&lt;/p>
&lt;p>这些函数接收的形参类型不一样，但执行的操作非常类似，调用时；编译器会根据传递的实参类型推断想要的是哪个函数。&lt;/p>
&lt;p>不允许两个函数除了返回类型外其他所有的要素都相同。&lt;/p>
&lt;p>&lt;strong>重载和const形参&lt;/strong>&lt;/p>
&lt;p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">Record &lt;span style="color:#06b;font-weight:bold">lookup&lt;/span>(Phone);
Record &lt;span style="color:#06b;font-weight:bold">lookup&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> Phone); &lt;span style="color:#888">//重复声明了Record lookup(Phone);
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果形参是某种类型的指针或引用，则通过区分指向的是&lt;strong>常量对象&lt;/strong>还是&lt;strong>非常量对象&lt;/strong>可以实现函数的重载，此时的const是底层const。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">Record &lt;span style="color:#06b;font-weight:bold">lookup&lt;/span>(Account&lt;span style="color:#333">&amp;amp;&lt;/span>); &lt;span style="color:#888">//函数作用于Account的引用
&lt;/span>&lt;span style="color:#888">&lt;/span>Record &lt;span style="color:#06b;font-weight:bold">lookup&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> Account&lt;span style="color:#333">&amp;amp;&lt;/span>); &lt;span style="color:#888">//新韩淑，作用于常量的引用
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="特殊用途语言特性">特殊用途语言特性&lt;/h3>
&lt;p>&lt;strong>默认实参&lt;/strong>&lt;/p>
&lt;p>某些函数的一种形参在函数的多次调用中都被赋予了同一个值，此时我们把这个反复出现的值称为函数的默认实参，为了实现函数既能接纳默认值，又能接受我们具体指定的值，我们定义为如下形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">typedef&lt;/span> string&lt;span style="color:#333">::&lt;/span>size_type sz;
string &lt;span style="color:#06b;font-weight:bold">screen&lt;/span>(sz ht &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">24&lt;/span>, sz wid &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">80&lt;/span>, &lt;span style="color:#339;font-weight:bold">char&lt;/span> background &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#04d;background-color:#fff0f0">&amp;#39; &amp;#39;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。&lt;/p>
&lt;p>在给定作用域中一个形参只能被赋予一次默认实参。&lt;/p>
&lt;p>&lt;strong>内联函数&lt;/strong>&lt;/p>
&lt;p>把一些规模较小的表达式定义为函数有很多好处：容易读懂、容易修改、能重复利用；但也有缺点：调用函数一般比求等价表达式的值要慢；一次函数调用包含一系列工作：先保存寄存器，在返回时恢复；可能需要拷贝实参。&lt;/p>
&lt;p>使用内联函数可以避免函数调用的开销，例如：&lt;/p>
&lt;p>把shorterString函数定义为内联函数，则如下调用：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">cout &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> shorterString(s1, s2) &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编译过程中会被展开为如下形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">cout &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> (s1.size() &lt;span style="color:#333">&amp;lt;&lt;/span> s2.size() &lt;span style="color:#333">?&lt;/span> &lt;span style="color:#970;font-weight:bold">s1&lt;/span> : s2) &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从而消除了函数运行时的开销。只需在函数的返回类型前加上&lt;code>inline&lt;/code>即可。&lt;/p>
&lt;p>内联是向编译器发出的一个请求，编译器可以忽略这个请求。&lt;/p>
&lt;p>&lt;strong>调试帮助&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>assert预处理宏&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>assert(expr);
&lt;/code>&lt;/pre>&lt;p>assert是一种预处理宏，使用一个表达式作为它的条件；对expr求值，如果为0，assert输出信息并终止程序运行；如果为1，assert什么也不做。&lt;/p>
&lt;p>assert宏定义在&lt;code>cassert&lt;/code>头文件中，由预处理器管理，无需提供using声明。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NDEBUG预处理变量&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>assert的行为依赖于名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行。&lt;/p>
&lt;p>可以使用一个&lt;code>#define&lt;/code>语句定义NDEBUG，从而关闭调试状态。&lt;/p>
&lt;p>除了使用assert之外，可以使用NDEBUG编写自己的条件调试代码，使用&lt;code>#ifndef&lt;/code>和&lt;code>#endif&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">print&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> ia[], size_t size)
{
&lt;span style="color:#579">#ifndef NDEBUG
&lt;/span>&lt;span style="color:#579">&lt;/span> cerr &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> __fun__ &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;:array size is: &amp;#34;&lt;/span> &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> size &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;span style="color:#579">#endif
&lt;/span>&lt;span style="color:#579">&lt;/span>...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>__fun__&lt;/code>为编译器定义的局部静态变量，用于存放函数名字；预处理器还定义了一些有用的名字：&lt;/p>
&lt;ul>
&lt;li>&lt;code>__FILE__&lt;/code>：存放文件名的字符串字面值&lt;/li>
&lt;li>&lt;code>__LINE__&lt;/code>：存放当前行号的整形字面值&lt;/li>
&lt;li>&lt;code>__TIME__&lt;/code>：存放文件编译时间的字符串字面值&lt;/li>
&lt;li>&lt;code>__DATA__&lt;/code>：存放文件编译日期的字符串字面值&lt;/li>
&lt;/ul>
&lt;p>可以使用这些值在错误消息中提供更多信息。&lt;/p>
&lt;h2 id="类">类&lt;/h2>
&lt;p>以一个例子来说明类&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">strut Sales_data {
&lt;span style="color:#080;font-weight:bold">public&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;span style="color:#888">//构造函数
&lt;/span>&lt;span style="color:#888">&lt;/span> Sales_data() &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">default&lt;/span>;
Sales_data(&lt;span style="color:#080;font-weight:bold">const&lt;/span> std&lt;span style="color:#333">::&lt;/span>string &lt;span style="color:#333">&amp;amp;&lt;/span>s) &lt;span style="color:#333">:&lt;/span> bookNo(s) {}
Sales_data(&lt;span style="color:#080;font-weight:bold">const&lt;/span> std&lt;span style="color:#333">::&lt;/span>string &lt;span style="color:#333">&amp;amp;&lt;/span>s, &lt;span style="color:#339;font-weight:bold">unsigned&lt;/span> n, &lt;span style="color:#339;font-weight:bold">double&lt;/span> p)&lt;span style="color:#333">:&lt;/span>
bookNo(s), units_sold(n), revenue(p&lt;span style="color:#333">*&lt;/span>n) {}
Sales_data(std&lt;span style="color:#333">::&lt;/span>istream &lt;span style="color:#333">&amp;amp;&lt;/span>);
&lt;span style="color:#888">//成员函数：
&lt;/span>&lt;span style="color:#888">&lt;/span> std&lt;span style="color:#333">::&lt;/span>string isbn() &lt;span style="color:#080;font-weight:bold">const&lt;/span> {&lt;span style="color:#080;font-weight:bold">return&lt;/span> bookNo; }
Sales_data&lt;span style="color:#333">&amp;amp;&lt;/span> combine(&lt;span style="color:#080;font-weight:bold">const&lt;/span> Sales_data&lt;span style="color:#333">&amp;amp;&lt;/span>);
&lt;span style="color:#080;font-weight:bold">private&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;span style="color:#339;font-weight:bold">double&lt;/span> avg_price() &lt;span style="color:#080;font-weight:bold">const&lt;/span>;
std&lt;span style="color:#333">::&lt;/span>string bookNo;
&lt;span style="color:#888">//类内初始值(数据成员)
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#339;font-weight:bold">unsigned&lt;/span> units_sold &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>;
&lt;span style="color:#339;font-weight:bold">double&lt;/span> revenue &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#60e;font-weight:bold">0.0&lt;/span>;
};
&lt;span style="color:#888">//在类的外部定义成员函数
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#339;font-weight:bold">double&lt;/span> Sales_data&lt;span style="color:#333">::&lt;/span>avg_price() &lt;span style="color:#080;font-weight:bold">const&lt;/span> {
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (units_sold)
&lt;span style="color:#080;font-weight:bold">return&lt;/span> revenue &lt;span style="color:#333">/&lt;/span> units_sold;
&lt;span style="color:#080;font-weight:bold">else&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>;
}
&lt;span style="color:#888">//在类的外部定义构造函数
&lt;/span>&lt;span style="color:#888">&lt;/span>Sales_data&lt;span style="color:#333">::&lt;/span>Sales_data(std&lt;span style="color:#333">::&lt;/span>istream &lt;span style="color:#333">&amp;amp;&lt;/span>is)
{
read(is, &lt;span style="color:#333">*&lt;/span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>); &lt;span style="color:#888">//从is中读取一条信息然后存入this对象中
&lt;/span>&lt;span style="color:#888">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="成员函数">成员函数&lt;/h3>
&lt;p>成员函数的&lt;strong>声明&lt;/strong>必须在&lt;strong>类的内部&lt;/strong>，它的&lt;strong>定义&lt;/strong>既可以在类的内部也可以在类的外部。作为接口的非成员函数，它的定义和声明都在类的外部。&lt;/p>
&lt;h3 id="构造函数">构造函数&lt;/h3>
&lt;p>构造函数的任务时初始化类对象的数据成员，无论何时只要类被创建就会执行构造函数。&lt;/p>
&lt;p>构造函数的名字和&lt;strong>类名&lt;/strong>相同，和其他函数不同，构造函数&lt;strong>没有返回类型&lt;/strong>；除此之外的特性类似于其他函数。&lt;/p>
&lt;p>类可以包含多个构造函数，和其他的&lt;strong>重载函数&lt;/strong>差不多，不同构造函数之间必须在参数数量或参数类型上有所区别。&lt;/p>
&lt;p>构造函数不能被声明成&lt;strong>const&lt;/strong>的。当我们创建类的一个const对象，直到构造函数完成初始化的过程，对象才能真正获得其常量属性。&lt;/p>
&lt;p>在类的外部定义构造函数：如上代码所示。&lt;/p>
&lt;p>&lt;strong>构造函数初始值列表&lt;/strong>&lt;/p>
&lt;p>就对象的数据成员而言，初始化和赋值也有区别。如果没有在构造函数的初始值列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化。&lt;/p>
&lt;p>如果成员是&lt;strong>const&lt;/strong>或&lt;strong>引用&lt;/strong>的话，必须将其初始化。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">ConstRef&lt;/span> {
&lt;span style="color:#080;font-weight:bold">public&lt;/span>&lt;span style="color:#333">:&lt;/span>
ConstRef(&lt;span style="color:#339;font-weight:bold">int&lt;/span> ii);
&lt;span style="color:#080;font-weight:bold">private&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> i;
&lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> ci;
&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#333">&amp;amp;&lt;/span>ri;
};
ConstRef&lt;span style="color:#333">::&lt;/span>ConstRef(&lt;span style="color:#339;font-weight:bold">int&lt;/span> ii)&lt;span style="color:#333">:&lt;/span> i(ii), ci(ii), ri(i) {} &lt;span style="color:#888">//显示地初始化引用和const成员
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最好避免使用某些成员初始化其他成员。&lt;/p>
&lt;p>&lt;strong>委托构造函数&lt;/strong>&lt;/p>
&lt;p>一个委托构造函数可以使用它属类的其他构造函数执行它自己的初始化过程。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Sales_data&lt;/span> {
&lt;span style="color:#080;font-weight:bold">public&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;span style="color:#888">//非委托构造函数使用对应的实参初始化成员
&lt;/span>&lt;span style="color:#888">&lt;/span> Sales_data(std&lt;span style="color:#333">::&lt;/span>string s, &lt;span style="color:#339;font-weight:bold">unsigned&lt;/span> cnt, &lt;span style="color:#339;font-weight:bold">double&lt;/span> price)&lt;span style="color:#333">:&lt;/span>
bookNo(s), units_sold(cnt), revenue(cnt&lt;span style="color:#333">*&lt;/span>price);
&lt;span style="color:#888">//其余构造函数委托给另一个构造函数
&lt;/span>&lt;span style="color:#888">&lt;/span> Sales_data()&lt;span style="color:#333">:&lt;/span> Sales_data(&lt;span style="background-color:#fff0f0">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>) {} &lt;span style="color:#888">//默认构造函数，委托给了上面输入3个变量的构造函数
&lt;/span>&lt;span style="color:#888">&lt;/span> Sales_data(std&lt;span style="color:#333">::&lt;/span>string s)&lt;span style="color:#333">:&lt;/span> Sales_data(s, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>) {}
Sales_Data(std&lt;span style="color:#333">::&lt;/span>istrean &lt;span style="color:#333">&amp;amp;&lt;/span>is)&lt;span style="color:#333">:&lt;/span> Sales_data() {read(is, &lt;span style="color:#333">*&lt;/span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>); } &lt;span style="color:#888">//委托给了默认构造函数
&lt;/span>&lt;span style="color:#888">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>聚合类&lt;/strong>&lt;/p>
&lt;p>聚合类使得用户可以直接访问其成员并且具有特殊的初始化语法形式。&lt;/p>
&lt;p>定义：&lt;/p>
&lt;ul>
&lt;li>所有成员都是public的。&lt;/li>
&lt;li>没有定义任何构造函数。&lt;/li>
&lt;li>没有类内初始值。&lt;/li>
&lt;li>没有基类，没有virtual函数。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>struct Data {
int ival;
string s;
};
&lt;/code>&lt;/pre>&lt;h3 id="访问控制与封装">访问控制与封装&lt;/h3>
&lt;p>使用**访问说明符(access specifiers)**加强类的封装：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>public&lt;/strong>说明符：定义在其之后的成员在整个程序内可被访问，public成员定义类的接口。&lt;/li>
&lt;li>&lt;strong>private&lt;/strong>说明符：定义在其后的成员可以被类的成员函数访问，但不能被使用该类的代码访问，该种封装隐藏了类的实现细节。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>struct&lt;/strong>和&lt;strong>class&lt;/strong>关键词的区别：&lt;/p>
&lt;p>我们可以用两个关键词中的任意一个定义类，唯一的区别是两者的&lt;strong>默认访问权限&lt;/strong>不太一样。&lt;/p>
&lt;ul>
&lt;li>使用&lt;code>struct&lt;/code>：定义在第一个访问说明符之前的成员是public的。&lt;/li>
&lt;li>使用&lt;code>class&lt;/code>：定义在第一个访问说明符之前的成员是private的。&lt;/li>
&lt;/ul>
&lt;h3 id="友元">友元&lt;/h3>
&lt;p>类可以允许其他类或函数访问它的非公有成员，方法是令其他类或函数称为它的友元；如果类想把&lt;strong>一个函数&lt;/strong>作为它的友元，只要增加一条以&lt;code>friend&lt;/code>关键词开头的&lt;strong>函数声明语句&lt;/strong>即可。&lt;/p>
&lt;p>友元声明只能出现在类定义的内部，但在类内出现的具体位置不限。&lt;/p>
&lt;p>友元的声明仅仅指定了&lt;strong>访问权限&lt;/strong>，并非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明。&lt;/p>
&lt;h3 id="类的作用域">类的作用域&lt;/h3>
&lt;p>在类的作用于之外，普通的数据和函数成员只能由&lt;strong>对象、引用或指针&lt;/strong>使用**成员访问运算符(&lt;code>. -&amp;gt;&lt;/code>)&lt;strong>来访问；对于类类型成员，则使用&lt;/strong>作用域运算符(&lt;code>::&lt;/code>)**访问。&lt;/p>
&lt;p>一个类就是一个作用域，所以在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">void&lt;/span> Window_mgr&lt;span style="color:#333">::&lt;/span>clear(ScreenIndex i)
{
Screen &lt;span style="color:#333">&amp;amp;&lt;/span>s &lt;span style="color:#333">=&lt;/span> screens[i];
s.contents &lt;span style="color:#333">=&lt;/span> string(s.height &lt;span style="color:#333">*&lt;/span> s.width, &lt;span style="color:#04d;background-color:#fff0f0">&amp;#39; &amp;#39;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="类的静态成员">类的静态成员&lt;/h3>
&lt;p>有时候类需要它的一些成员&lt;strong>与类本身直接相关&lt;/strong>，而不是与类的各个对象保持关联。这是我们可以通过声明静态成员，即在成员的声明前加上关键字&lt;strong>static&lt;/strong>，使得其与类关联在一起。&lt;/p>
&lt;p>静态成员可以是public或private的。&lt;/p>
&lt;p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。同样，&lt;strong>类静态成员函数&lt;/strong>也不与任何对象绑定在一起，它们不包含this指针。静态成员函数不能声明成const的，也不能在static函数体内使用this指针。&lt;/p>
&lt;p>使用类的静态成员：&lt;/p>
&lt;p>使用&lt;strong>作用域运算符&lt;/strong>直接访问静态成员：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#339;font-weight:bold">double&lt;/span> r;
r &lt;span style="color:#333">=&lt;/span> Account&lt;span style="color:#333">::&lt;/span>rate(); &lt;span style="color:#888">//Account为类名
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p>
&lt;p>定义静态成员：&lt;/p>
&lt;p>我们既可以在类内部也可以在类外部定义静态成员函数，在类外部定义时不能重复static关键词，该词只出现在类内部的声明中。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/ - 2019-2021 By Jialong</description></item><item><title>机器学习——线性回归和梯度下降</title><link>https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</link><pubDate>Fri, 23 Apr 2021 18:10:29 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/ -&lt;h2 id="线性回归linear-regression">线性回归Linear Regression&lt;/h2>
&lt;h3 id="简介">简介&lt;/h3>
&lt;p>线性回归属于监督学习，先给定一个训练集根据训练集学习出一个线性函数，然后测试这个函数训练的好不好，挑选出最好的函数（cost function最小）即可。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>因为是线性回归，所以学习到的函数为线性函数，即一次直线函数；&lt;/li>
&lt;li>因为是单变量，所以只有一个x；&lt;/li>
&lt;/ul>
&lt;p>所以能够给出&lt;strong>单变量线性回归&lt;/strong>的模型：
$$
h(x)=b+mx
$$
我们称$x$为feature，$h(x)$为hypothesis。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="代价函数cost-function">代价函数Cost Function&lt;/h3>
&lt;p>我们需要根据代价函数来确定线性回归拟合的好不好。Cost Function越小，说明线性回归地越好，最小为0，完全拟合。
$$
J(b,m)=\frac{1}{2n}(h(x^{(i)})-y^{(i)})^2
$$
如上所示为代价函数的构造，其中，$x^{(i)}$表示向量x的第i个元素，$y^{(i)}$表示向量y的第i个元素，即表示所有输入的训练集的点。$h(x)$表示已知的假设函数，n为训练集的个数。&lt;/p>
&lt;h2 id="梯度下降">梯度下降&lt;/h2>
&lt;p>梯度下降能够找出代价函数Cost Function的最小值，梯度下降的方法步骤如下所示：&lt;/p>
&lt;ol>
&lt;li>先确定向下一步的步伐大小，我们称为Learning Rate；&lt;/li>
&lt;li>任意给定初始值b, m；&lt;/li>
&lt;li>确定一个向下的方向，按预定步骤向下走，并且更新b, m；&lt;/li>
&lt;li>当下降高度(循环次数)小于某个定义的值时，停止下降。&lt;/li>
&lt;/ol>
&lt;p>循环下面的式子直到满足终止条件：
$$
b = b - \alpha\frac{\partial}{\partial b}J(b,m) \&lt;br>
m = m - \alpha\frac{\partial}{\partial m}J(b,m)
$$
上式中的$\alpha$为Learning rate，决定了下降的步伐大小；偏导数决定了下降的方向。&lt;/p>
&lt;h3 id="对cost-function运用梯度下降">对Cost Function运用梯度下降&lt;/h3>
&lt;p>$$
\mathrm{repeat \ until \ convergence}{ \&lt;br>
b:=b-\alpha \frac{1}{n}\sum_{i=1}^{n}(h(x^{(i)})-y^{(i)}) \&lt;br>
m:=m-\alpha \frac{1}{n}\sum_{i=1}^{n}(h(x^{(i)})-y^{(i)})x^{(i)} \&lt;br>
\ }
$$&lt;/p>
&lt;p>设定好初始值、循环次数、Learning Rate后即可开始拟合，最终得到结果b,m；得到拟合的线性函数。&lt;/p>
&lt;h2 id="代码实现">代码实现&lt;/h2>
&lt;h3 id="使用sklearn库中的make_regression函数生成训练数据">使用&lt;code>sklearn&lt;/code>库中的&lt;code>make_regression&lt;/code>函数生成训练数据&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#888">#generate the train data&lt;/span>
&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">geneData&lt;/span>():
points &lt;span style="color:#333">=&lt;/span> []
xSet, ySet &lt;span style="color:#333">=&lt;/span> make_regression(n_samples&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">100&lt;/span>, n_features&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, n_targets&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, noise&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">20&lt;/span>)
&lt;span style="color:#080;font-weight:bold">for&lt;/span> x,y &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">zip&lt;/span>(xSet,ySet):
x&lt;span style="color:#333">=&lt;/span>x[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>]
point &lt;span style="color:#333">=&lt;/span> [x,y]
points&lt;span style="color:#333">.&lt;/span>append(point)
&lt;span style="color:#080;font-weight:bold">return&lt;/span> points
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="定义代价函数">定义代价函数&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">costFunction&lt;/span>(b, m, points):
&lt;span style="color:#080;font-weight:bold">for&lt;/span> point &lt;span style="color:#000;font-weight:bold">in&lt;/span> points:
ErrorTotal &lt;span style="color:#333">+=&lt;/span> ((b &lt;span style="color:#333">+&lt;/span> m&lt;span style="color:#333">*&lt;/span>point[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>]) &lt;span style="color:#333">-&lt;/span> point[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>]) &lt;span style="color:#333">**&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> ErrorTotal &lt;span style="color:#333">/&lt;/span> (&lt;span style="color:#00d;font-weight:bold">2&lt;/span> &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#007020">float&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(points)))
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="定义梯度下降函数">定义梯度下降函数&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">def&lt;/span> &lt;span style="color:#06b;font-weight:bold">stepGradient&lt;/span>(b_current, m_current, b_gradient, m_gradient, points, learningRate):
N &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#007020">float&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(points))
&lt;span style="color:#080;font-weight:bold">for&lt;/span> point &lt;span style="color:#000;font-weight:bold">in&lt;/span> points:
x &lt;span style="color:#333">=&lt;/span> point[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>]
y &lt;span style="color:#333">=&lt;/span> point[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>]
b_gradient &lt;span style="color:#333">+=&lt;/span> (&lt;span style="color:#00d;font-weight:bold">2&lt;/span>&lt;span style="color:#333">/&lt;/span>N) &lt;span style="color:#333">*&lt;/span> ((b_current &lt;span style="color:#333">+&lt;/span> m_current &lt;span style="color:#333">*&lt;/span> x) &lt;span style="color:#333">-&lt;/span> y)
m_gradient &lt;span style="color:#333">+=&lt;/span> (&lt;span style="color:#00d;font-weight:bold">2&lt;/span>&lt;span style="color:#333">/&lt;/span>N) &lt;span style="color:#333">*&lt;/span> x &lt;span style="color:#333">*&lt;/span> ((b_current &lt;span style="color:#333">+&lt;/span> m_current &lt;span style="color:#333">*&lt;/span> x) &lt;span style="color:#333">-&lt;/span> y)
new_b &lt;span style="color:#333">=&lt;/span> b_current &lt;span style="color:#333">-&lt;/span> (learningRate &lt;span style="color:#333">*&lt;/span> b_gradient)
new_m &lt;span style="color:#333">=&lt;/span> m_current &lt;span style="color:#333">-&lt;/span> (learningRate &lt;span style="color:#333">*&lt;/span> m_gradient)
&lt;span style="color:#080;font-weight:bold">return&lt;/span> [new_b, new_m, b_gradient, m_gradient]
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="设置初始化参数并循环迭代最后画出结果">设置初始化参数并循环迭代，最后画出结果&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#080;font-weight:bold">if&lt;/span> __name__ &lt;span style="color:#333">==&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#39;__main__&amp;#39;&lt;/span>:
iterations &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">100&lt;/span> &lt;span style="color:#888">#迭代次数&lt;/span>
learningRate &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#60e;font-weight:bold">0.0001&lt;/span> &lt;span style="color:#888">#学习率，决定了下降的步伐大小&lt;/span>
points &lt;span style="color:#333">=&lt;/span> geneData() &lt;span style="color:#888">#生成训练集&lt;/span>
b &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span> &lt;span style="color:#888">#线性方程参数b,m的初始值&lt;/span>
m &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>
b_gradient &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span> &lt;span style="color:#888">#代价函数梯度下降结果的初始值&lt;/span>
m_gradient &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">list&lt;/span>(&lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, iterations&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>)): &lt;span style="color:#888">#循环进行梯度下降，求得结果&lt;/span>
b,m,b_gradient,m_gradient &lt;span style="color:#333">=&lt;/span> stepGradient(b,m,b_gradient,m_gradient,points,learningRate)
&lt;span style="color:#080;font-weight:bold">for&lt;/span> point &lt;span style="color:#000;font-weight:bold">in&lt;/span> points: &lt;span style="color:#888">#画出样本点&lt;/span>
plt&lt;span style="color:#333">.&lt;/span>scatter(point[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>], point[&lt;span style="color:#00d;font-weight:bold">1&lt;/span>])
&lt;span style="color:#888">#画出得到的直线&lt;/span>
t &lt;span style="color:#333">=&lt;/span> np&lt;span style="color:#333">.&lt;/span>arange(&lt;span style="color:#333">-&lt;/span>&lt;span style="color:#00d;font-weight:bold">3&lt;/span>,&lt;span style="color:#00d;font-weight:bold">3&lt;/span>,&lt;span style="color:#60e;font-weight:bold">0.01&lt;/span>)
s &lt;span style="color:#333">=&lt;/span> b &lt;span style="color:#333">+&lt;/span> m &lt;span style="color:#333">*&lt;/span> t
plt&lt;span style="color:#333">.&lt;/span>scatter(t,s,linewidths&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#60e;font-weight:bold">0.5&lt;/span>)
plt&lt;span style="color:#333">.&lt;/span>show()
&lt;span style="color:#888">#输出结果&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(&lt;span style="background-color:#fff0f0">&amp;#34;b=&lt;/span>&lt;span style="background-color:#eee">%f&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;&lt;/span>&lt;span style="color:#333">%&lt;/span>b)
&lt;span style="color:#888">#print(b)&lt;/span>
&lt;span style="color:#007020">print&lt;/span>(&lt;span style="background-color:#fff0f0">&amp;#34;m=&lt;/span>&lt;span style="background-color:#eee">%f&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;&lt;/span>&lt;span style="color:#333">%&lt;/span>m)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="结果展示">结果展示&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/Gradient_figure1.png" alt="Gradient_figure1">&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">b&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#60e;font-weight:bold">4.824787&lt;/span>
m&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#60e;font-weight:bold">46.528725&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="哲学思考">哲学思考&lt;/h2>
&lt;p>梯度下降是一个一阶最优化算法，通常也称为最陡下降法，要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度的反方向规定的步长距离点进行迭代搜索。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/ - 2019-2021 By Jialong</description></item></channel></rss>