<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 05 Jul 2022 00:25:07 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>LaTex环境配置和基本功能模块</title>
        <link>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</link>
        <pubDate>Sun, 18 Jul 2021 20:06:26 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ -&lt;h2 id=&#34;环境配置&#34;&gt;环境配置&lt;/h2&gt;
&lt;p&gt;我选择使用VS code + Tex Live作为我的LaTex写作环境，具体配置过程参考自：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/166523064&#34;&gt;Visual Studio Code (vscode)配置LaTeX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是关于使用过程中一些具体模块的讨论：&lt;/p&gt;
&lt;p&gt;部分内容参考自：&lt;a href=&#34;https://liam.page/2014/09/08/latex-introduction/&#34;&gt;一份其实很短的 LaTeX 入门文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里使用&lt;code&gt;xeLatTex&lt;/code&gt;进行编译。&lt;/p&gt;
&lt;h2 id=&#34;基本文档和中英文&#34;&gt;基本文档和中英文&lt;/h2&gt;
&lt;h3 id=&#34;基本文档&#34;&gt;基本文档&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;article&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;% 这里是导言区
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
Hello, world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tex以&lt;code&gt;%&lt;/code&gt;作为注释标记。若要输出百分号&lt;code&gt;%&lt;/code&gt;字符本身，则要在前面加上反斜杠&lt;code&gt;\&lt;/code&gt;进行转义（escape）。&lt;/p&gt;
&lt;h3 id=&#34;中英文混排&#34;&gt;中英文混排&lt;/h3&gt;
&lt;p&gt;目前XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题。至此，我们只需要使用几个简单的宏包，就能完成中文支持了。&lt;/p&gt;
&lt;p&gt;我们使用&lt;code&gt;\usepackage{}&lt;/code&gt;来调用宏包。&lt;/p&gt;
&lt;p&gt;另外，我们使用&lt;code&gt;CTex&lt;/code&gt;宏集来处理中文的版式和标点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
你好，world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与开始相比，文档类别变为&lt;code&gt;ctexart&lt;/code&gt;，并且增加了文档类选项&lt;code&gt;UTF8&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;组织文章基本内容&#34;&gt;组织文章基本内容&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;标题、作者、日期&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\title&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好，world!&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Eternity&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\today&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\maketitle&lt;/span&gt;
你好，world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码中的控制序列&lt;code&gt;\maketitle&lt;/code&gt;能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。&lt;/p&gt;
&lt;p&gt;可以通过宏包&lt;code&gt;titling&lt;/code&gt;修改上述默认格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_1.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;章节和段落&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\title&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好，world!&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Liam&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\today&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\maketitle&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\section&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好中国&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
中国在East Asia.
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello Beijing&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
北京是capital of China.
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsubsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello Dongcheng District&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\paragraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Tian&amp;#39;anmen Square&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
is in the center of Beijing
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subparagraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Chairman Mao&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
is in the center of 天安门广场。
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello 山东&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\paragraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;山东大学&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt; is one of the best university in 山东。
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文档类&lt;code&gt;article&lt;/code&gt;/&lt;code&gt;ctexart&lt;/code&gt;中定义了5个控制序列来调整文章组织结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\section{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subsection{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subsubsection{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\paragraph{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subparagraph{·}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_2.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;插入目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在控制序列&lt;code&gt;\maketitle&lt;/code&gt;加入&lt;code&gt;tableofcontents&lt;/code&gt;，编译两次观察效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_3.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;LaTeX 将一个换行当做是一个简单的空格来处理，如果需要换行另起一段，则需要用两个换行（一个空行）来实现。&lt;/p&gt;
&lt;h2 id=&#34;版面设置&#34;&gt;版面设置&lt;/h2&gt;
&lt;h3 id=&#34;页边距&#34;&gt;页边距&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;geometry&lt;/code&gt; 宏包。&lt;a href=&#34;https://texdoc.org/serve/geometry.pdf/0&#34;&gt;geometry文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;geometry&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\geometry&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;papersize=&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;20cm,15cm&lt;span style=&#34;color:#007020&#34;&gt;}}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\geometry&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;left=1cm,right=2cm,top=3cm,bottom=4cm&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;页眉页脚&#34;&gt;页眉页脚&lt;/h3&gt;
&lt;p&gt;设置页眉页脚，推荐使用 &lt;code&gt;fancyhdr&lt;/code&gt; 宏包。&lt;a href=&#34;https://texdoc.org/serve/fancyhdr.pdf/0&#34;&gt;fancyhdr文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;fancyhdr&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\pagestyle&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;fancy&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lhead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\chead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\rhead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;152xxxxxxxx&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\cfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\thepage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\rfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\headrulewidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;0.4pt&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\headwidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\textwidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\footrulewidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;0pt&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;行间距&#34;&gt;行间距&lt;/h3&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;setspace&lt;/code&gt; 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;setspace&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\onehalfspacing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;段间距&#34;&gt;段间距&lt;/h3&gt;
&lt;p&gt;我们可以通过修改长度 &lt;code&gt;\parskip&lt;/code&gt; 的值来调整段间距。例如在导言区添加以下内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\addtolength&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\parskip&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;.4em&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;希望代码中的特殊字符不被LaTex处理，并且希望有代码高亮。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;listings&lt;/code&gt;宏包来在tex中添加代码段。基本设置参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;listings&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lstset&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;
language=Matlab,
escapeinside=``, 
numbers=left,
numberstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\tiny&lt;/span&gt;,
breaklines=true, 
backgroundcolor=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;lightgray!40!white&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;,
frame=single,
framerule=0pt,
extendedchars=false, 
keywordstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;blue!70&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\bfseries&lt;/span&gt;, 
basicstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\ttfamily&lt;/span&gt;,
commentstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\ttfamily\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;green!40!black&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;, 
showstringspaces=false&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 &lt;code&gt;graphicx&lt;/code&gt; 宏包提供的 &lt;code&gt;\includegraphics&lt;/code&gt; 命令。比如你在你的 TeX 源文件同目录下，有名为 &lt;code&gt;a.jpg&lt;/code&gt; 的图片，你可以用这样的方式将它插入到输出文档中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;article&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;graphicx&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\includegraphics&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;a.jpg&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 &lt;code&gt;\includegraphics&lt;/code&gt; 控制序列的可选参数来控制。比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\includegraphics&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[width = .8\textwidth]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;a.jpg&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样图片的宽度会被缩放至&lt;strong&gt;页面宽度的百分之八十&lt;/strong&gt;，图片的总高度会按比例缩放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;\includegraphics&lt;/code&gt;还有很多其他控制序列可以选择使用，可以查看宏包选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tabular&lt;/code&gt; 环境提供了最简单的表格功能。它用 &lt;code&gt;\hline&lt;/code&gt; 命令表示横线，在列格式中用 &lt;code&gt;|&lt;/code&gt; 表示竖线；用 &lt;code&gt;&amp;amp;&lt;/code&gt; 来分列，用 &lt;code&gt;\\&lt;/code&gt; 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 &lt;code&gt;l&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;、&lt;code&gt;r&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;tabular&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;|l|c|r|&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
操作系统&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; 发行版&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; 编辑器&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Windows &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; MikTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TexMakerX &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Unix/Linux &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; teTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; Kile &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Mac OS &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; MacTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeXShop &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
通用&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeX Live &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeXworks &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;tabular&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h2 id=&#34;数学公式&#34;&gt;数学公式&lt;/h2&gt;
&lt;p&gt;在导言区添加&lt;code&gt;amsmath&lt;/code&gt;宏包来使用数学功能：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;amsmath&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;数学模式&#34;&gt;数学模式&lt;/h3&gt;
&lt;p&gt;与Markdown中相同，LaTex共有&lt;strong&gt;行内公式&lt;/strong&gt;和&lt;strong&gt;行间公式&lt;/strong&gt;两种模式。&lt;/p&gt;
&lt;p&gt;在行文中，使用 &lt;code&gt;$ ... $&lt;/code&gt; 可以插入行内公式，使用 &lt;code&gt;\[ ... \]&lt;/code&gt; 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 &lt;code&gt;equation&lt;/code&gt; 环境：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;equation&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
...
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;equation&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;无编号的行间公式也可以使用 &lt;code&gt;\begin{displaymath} ... \end{displaymath}&lt;/code&gt; 或者 &lt;code&gt;\begin{equation*} ... \end{equation*}&lt;/code&gt; 来插入，但略显麻烦。（&lt;code&gt;equation*&lt;/code&gt; 中的 &lt;code&gt;*&lt;/code&gt; 表示环境不编号）&lt;/p&gt;
&lt;p&gt;也有 plainTeX 风格的 &lt;code&gt;$$ ... $$&lt;/code&gt; 来插入不编号的行间公式。但是在 LaTeX 中这样做会改变行文的默认行间距，不推荐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标点符号&#34;&gt;标点符号&lt;/h3&gt;
&lt;p&gt;行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。&lt;/p&gt;
&lt;h3 id=&#34;多行公式&#34;&gt;多行公式&lt;/h3&gt;
&lt;p&gt;有的公式特别长，我们需要手动为他们换行；&lt;/p&gt;
&lt;p&gt;有几个公式是一组，我们需要将他们放在一起；&lt;/p&gt;
&lt;p&gt;还有些类似分段函数，我们需要给它加上一个左边的花括号。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;长公式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不对齐：无须对齐的长公式可以使用 &lt;code&gt;multline&lt;/code&gt; 环境。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;multline&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
x = a+b+c+&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
d+e+f+g
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;multline&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;如果不需要编号，可以使用 &lt;code&gt;multline*&lt;/code&gt; 环境代替。&lt;/p&gt;
&lt;p&gt;对齐：需要对齐的公式，可以使用 &lt;code&gt;aligned&lt;/code&gt; &lt;em&gt;次环境&lt;/em&gt;来实现，它必须包含在数学环境之内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\[&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{aligned}
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x &lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&amp;amp; a&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{} &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;d&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;g
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{aligned}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公式组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无需对齐的公式组可以使用 &lt;code&gt;gather&lt;/code&gt; 环境，需要对齐的公式组可以使用 &lt;code&gt;align&lt;/code&gt; 环境。他们都带有编号，如果不需要编号可以使用带&lt;code&gt;*&lt;/code&gt;的版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;gather&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
a = b+c+d &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
x = y+z
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;gather&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;align&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
a &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt;= b+c+d &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
x &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt;= y+z
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;align&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分段函数可以用&lt;code&gt;cases&lt;/code&gt;次环境来实现，它必须包含在数学环境之内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\[&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; y&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{cases}
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x,&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\quad&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; x&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\leq&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x,&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\quad&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; x&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{cases} &lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH10 泛型算法</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</link>
        <pubDate>Sun, 18 Jul 2021 09:16:32 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/ -&lt;p&gt;用来&lt;strong&gt;操纵容器&lt;/strong&gt;。泛型算法独立于任何特定容器，可用于不同类型的容器和不同类型的元素。这些算法是一些&lt;strong&gt;经典算法的公共接口&lt;/strong&gt;，例如排序和搜索。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法定义在&lt;code&gt;algorithm&lt;/code&gt;头文件中，标准库还在&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般这些算法并不直接操作容器，而是遍历由&lt;strong&gt;两个迭代器指定的一个元素范围&lt;/strong&gt;来进行操作。&lt;/p&gt;
&lt;p&gt;算法不依赖于容器，但依赖于元素类型的操作。&lt;/p&gt;
&lt;h2 id=&#34;基本算法&#34;&gt;基本算法&lt;/h2&gt;
&lt;h3 id=&#34;只读算法&#34;&gt;只读算法&lt;/h3&gt;
&lt;p&gt;只读取输入范围的元素，&lt;strong&gt;不改变元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;accumulate&lt;/code&gt;算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其定义在头文件numeric中，接受三个参数，前两个指出了需要求和元素的范围，第三个参数是和的初值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; accumulate(vec.cbegin(), vec.cend(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//对vec中元素求和，和的初值设为0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第三个参数的类型决定了函数中使用哪个&lt;strong&gt;加法运算符&lt;/strong&gt;以及&lt;strong&gt;返回值的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即序列中的元素必须与第三个参数&lt;strong&gt;匹配&lt;/strong&gt;或&lt;strong&gt;能够转换为第三个参数的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;equal&lt;/code&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确定两个序列的值是否保存相同的值，将第一个序列的每个元素与第二个序列的对应元素比较。该算法接受三个迭代器，前两个表示第一个序列的范围，第三个表示第二个序列的首元素。&lt;/p&gt;
&lt;p&gt;equal利用迭代器完成操作，因此我们可以调用equal来比较两个不同类型容器中的元素，并且元素类型也可以不同。&lt;/p&gt;
&lt;h3 id=&#34;写容器元素算法&#34;&gt;写容器元素算法&lt;/h3&gt;
&lt;p&gt;使用这类算法要保证序列原大小&lt;strong&gt;不小于&lt;/strong&gt;算法写入的元素数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fill&lt;/code&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fill接受&lt;strong&gt;一对迭代器&lt;/strong&gt;和&lt;strong&gt;一个值&lt;/strong&gt;，将这个值赋予输入序列中的每个元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;fill(vec.begin(), vec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不能在空容器上调用fill_n.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;back_inserter插入迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接受一个&lt;strong&gt;指向容器的引用&lt;/strong&gt;，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。&lt;/p&gt;
&lt;p&gt;back_inserter是一个定义在头文件iterator中的函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; vec;	&lt;span style=&#34;color:#888&#34;&gt;//空vector
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; back_inserter(vec);	&lt;span style=&#34;color:#888&#34;&gt;//通过其赋值将元素添加到vec中
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;拷贝算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;copy是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。&lt;/p&gt;
&lt;p&gt;该算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。&lt;/p&gt;
&lt;h3 id=&#34;重排容器元素算法&#34;&gt;重排容器元素算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;unique&lt;/code&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;elimDups&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;words)
{
	&lt;span style=&#34;color:#888&#34;&gt;//按字典排序words, 以便查找重复单词
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	sort(words.begin(), words.end());
	&lt;span style=&#34;color:#888&#34;&gt;//unique重排输入范围，使每个单词只出现一次
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; end_unique &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; unique(words.begin(), words.end());
	&lt;span style=&#34;color:#888&#34;&gt;//使用erase操作删除重复单词
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	words.erase(end_unique, words.end());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sort算法接受两个迭代器，表示要排序的元素范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用unique&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unique算法重排输入元素，将相邻的重复项消除，并返回一个指向不重复值范围末尾的迭代器。&lt;/p&gt;
&lt;h2 id=&#34;定制操作&#34;&gt;定制操作&lt;/h2&gt;
&lt;p&gt;很多算法会比较输入序列中的元素。默认情况下，这类算法使用&amp;lt;或==运算符完成比较。标准库还定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。&lt;/p&gt;
&lt;h3 id=&#34;向算法传递函数&#34;&gt;向算法传递函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;谓词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谓词是一个可调用的&lt;strong&gt;表达式&lt;/strong&gt;，其返回结果是一个能&lt;strong&gt;用作条件的值&lt;/strong&gt;。标准库算法使用的谓词分为：一元谓词和二元谓词。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;isShorter&lt;/span&gt;(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s1, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s2) {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; s1.size() &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; s2.size();
}
sort(words.begin(), words.end(), isShorter);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;stable_sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该排序算法可以保持等长元素间的字典序。&lt;/p&gt;
&lt;h3 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h3&gt;
&lt;h3 id=&#34;lambda捕获和返回&#34;&gt;lambda捕获和返回&lt;/h3&gt;
&lt;h3 id=&#34;参数绑定&#34;&gt;参数绑定&lt;/h3&gt;
&lt;h2 id=&#34;再探迭代器&#34;&gt;再探迭代器&lt;/h2&gt;
&lt;p&gt;除了为每个容器定义的迭代器之外，标准库还在头文件iterator中定义了额外几种迭代器，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。&lt;/li&gt;
&lt;li&gt;流迭代器：这些迭代器被绑定到输入输出流上，可用来遍历所关联的IO流&lt;/li&gt;
&lt;li&gt;反向迭代器：这些迭代器向后移动而不是向前移动&lt;/li&gt;
&lt;li&gt;移动迭代器：（13.6.2节介绍）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入迭代器&#34;&gt;插入迭代器&lt;/h3&gt;
&lt;h3 id=&#34;iostream迭代器&#34;&gt;iostream迭代器&lt;/h3&gt;
&lt;h3 id=&#34;反向迭代器&#34;&gt;反向迭代器&lt;/h3&gt;
&lt;h2 id=&#34;泛型算法结构&#34;&gt;泛型算法结构&lt;/h2&gt;
&lt;p&gt;任何算法最基本的特征是其要求迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别：&lt;/p&gt;
&lt;p&gt;输入、输出、前向、双向、随机访问迭代器&lt;/p&gt;
&lt;h2 id=&#34;特定容器算法&#34;&gt;特定容器算法&lt;/h2&gt;
&lt;p&gt;链表类型list和forward_list定义了几个成员函数形式的算法。他们定义了几个成员函数形式的算法。它们定义了独有的sort、merge、remove、reverse和unique。将以成员函数的形式使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;splice成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表类型还定义了splice算法，该算法是链表数据结构所独有的，因此不需要通用版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.splice(args)
flst.splice_after(args)
(p, lst2)	&lt;span style=&#34;color:#888&#34;&gt;//p是一个指向lst中元素的迭代器或一个指向flst首前位置的迭代器。函数将lst2所有元素移动到lst中p之前的位置或flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或lst相同，且不能是同一个链表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;(p, lst2, p2)
(p, lst2, b, e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;链表特有的操作会改变容器&lt;/strong&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 2.信息的表示和处理（部分完成）</title>
        <link>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
        <pubDate>Mon, 12 Jul 2021 21:26:27 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ -&lt;p&gt;第一部分内容：程序结构和执行&lt;/p&gt;
&lt;p&gt;我们需要用方法表示&lt;strong&gt;基本数据类型&lt;/strong&gt;，然后考虑机器级指令如何操作这样的数据，以及编译器如何将C程序翻译成这样的指令。接下来研究集中处理器的方法，使得我们能够更好地了解硬件资源如何被用来执行指令。&lt;/p&gt;
&lt;h2 id=&#34;信息存储&#34;&gt;信息存储&lt;/h2&gt;
&lt;h3 id=&#34;十六进制表示法及转换&#34;&gt;十六进制表示法及转换&lt;/h3&gt;
&lt;p&gt;二进制和十进制对描述&lt;strong&gt;位模式&lt;/strong&gt;来说都不方便，因此采用16进制数(hex)来表示位模式。&lt;/p&gt;
&lt;p&gt;C语言中16进制数以0X或0x开头，字符‘A’~‘F’既可以是大写也可以是小写。&lt;/p&gt;
&lt;p&gt;二进制和十六进制之间的转换较为简单，不再赘述。&lt;/p&gt;
&lt;p&gt;十进制和十六进制数之间的转换要反复利用乘法和除法进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从十进制到十六进制：反复用16除十进制数&lt;/li&gt;
&lt;li&gt;从十六进制到十进制：用相应的16的幂乘以每个十六进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字数据大小&#34;&gt;字数据大小&lt;/h3&gt;
&lt;p&gt;字长指明指针数据的标称大小。虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是&lt;strong&gt;虚拟地址空间的最大大小&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对一个字长为w的机器而言，虚拟地址的范围是$0$ ~$2^w-1$，程序最多访问$2^w-1$个字节。&lt;/p&gt;
&lt;p&gt;近年，很多机器都从32位字长迁移到了64位字长。大多64位字长机器可以运行32位字长机器编译的程序。32位程序和64位程序的区别在于程序是&lt;strong&gt;如何编译&lt;/strong&gt;成的，而不是运行的机器类型。&lt;/p&gt;
&lt;h3 id=&#34;寻址和字节顺序&#34;&gt;寻址和字节顺序&lt;/h3&gt;
&lt;p&gt;小端法、大端法&lt;/p&gt;
&lt;p&gt;对于跨越多个字节的程序对象，我们必须明确：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个对象的地址是什么&lt;/li&gt;
&lt;li&gt;如何在内存中排列这些字节&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，多字节对象被存储为&lt;strong&gt;连续的字节序列&lt;/strong&gt;，对象的地址为所使用字节中&lt;strong&gt;最小的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小端法：将&lt;strong&gt;最低有效字节&lt;/strong&gt;放在最前面(最小地址)存储。（例如一个二进制数最右边的8位是最低有效字节）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大端法：将&lt;strong&gt;最高有效字节&lt;/strong&gt;放在最前面(最小地址)存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多Intel兼容机使用小端模式。&lt;/p&gt;
&lt;p&gt;以下代码使用强制类型转换来访问和打印不同程序对象的字节表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;byte_pointer;	&lt;span style=&#34;color:#888&#34;&gt;//将byte_pointer定义为一个指向类型为unsigned char对象的指针
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//指针被强制类型转换为unsigned char *, 这告诉编译器程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_bytes&lt;/span&gt;(byte_pointer start, size_t len)
{&lt;span style=&#34;color:#888&#34;&gt;//按顺序显示出指针指向对象的每个字节内容，可以判断出系统使用的小端法还是大端法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	size_t i;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
		printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%.2x&amp;#34;&lt;/span&gt;, start[i]);
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
}

&lt;span style=&#34;color:#888&#34;&gt;//使用sizeof确定对象使用的字节数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_int&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示int对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_float&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示float对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt;));
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_pointer&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示void *对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;表示字符串&#34;&gt;表示字符串&lt;/h3&gt;
&lt;p&gt;对文本进行编码。&lt;/p&gt;
&lt;p&gt;ASCII编码、Unicode编码&lt;/p&gt;
&lt;p&gt;之前写过一篇相关博客：&lt;a href=&#34;http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/&#34;&gt;字符编码：Unicode, UTF-8&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;布尔代数&#34;&gt;布尔代数&lt;/h3&gt;
&lt;p&gt;四种布尔运算：&lt;/p&gt;
&lt;p&gt;与、或、非、异或&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异或：当P或Q为真但不同时为真时，异或成立；即当p=1且q=0或p=1且q=1时，p^q=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;位向量的布尔运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按位进行布尔运算。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的位级运算&#34;&gt;C语言中的位级运算&lt;/h3&gt;
&lt;p&gt;按照对应位进行布尔运算。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的逻辑运算&#34;&gt;C语言中的逻辑运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;逻辑运算和位级运算完全不同，逻辑运算认为所有非零的参数都表示TRUE，参数0表示FALSE。以下是一些表达式求值举例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;!0x41&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!0x00&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!!0x41&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;c语言中的移位运算&#34;&gt;C语言中的移位运算&lt;/h3&gt;
&lt;p&gt;左移k位：将操作数向左移动k位，丢弃掉最高的k位并在右端补k个0&lt;/p&gt;
&lt;p&gt;逻辑右移：在左端补k个0&lt;/p&gt;
&lt;p&gt;算数右移：在左端补k个最高有效位的值&lt;/p&gt;
&lt;p&gt;几乎所有编译器都对&lt;strong&gt;有符号数&lt;/strong&gt;使用&lt;strong&gt;算术右移&lt;/strong&gt;，对&lt;strong&gt;无符号数&lt;/strong&gt;使用逻辑右移。&lt;/p&gt;
&lt;h2 id=&#34;整数表示&#34;&gt;整数表示&lt;/h2&gt;
&lt;p&gt;用&lt;strong&gt;位&lt;/strong&gt;来编码整数的两种不同方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种只能表示&lt;strong&gt;非负数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;另一种能表示&lt;strong&gt;负数、零和正数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;整型数据类型&#34;&gt;整型数据类型&lt;/h3&gt;
&lt;p&gt;C语言通过&lt;strong&gt;关键字&lt;/strong&gt;来表示多种整型数据类型，这些关键字包括char、short、long，同时还能指示被表示的数字是非负数（声明为unsigned）。&lt;/p&gt;
&lt;p&gt;为不同大小分配的字节数根据程序编译为32位还是64位有所不同；根据字节分配，不同大小所能表示的值的范围是不同的。&lt;/p&gt;
&lt;p&gt;取值范围是不对称的，负数的范围比正数大1.&lt;/p&gt;
&lt;h3 id=&#34;无符号数的编码&#34;&gt;无符号数的编码&lt;/h3&gt;
&lt;p&gt;直接按照二进制进行编码即可。B2U：将二进制编码映射到一个非负整数&lt;/p&gt;
&lt;p&gt;无符号数的编码具有唯一性&lt;/p&gt;
&lt;h3 id=&#34;补码编码&#34;&gt;补码编码&lt;/h3&gt;
&lt;p&gt;(two&amp;rsquo;s-complement)。用来表示有符号数，将字的最高有效位解释为&lt;strong&gt;负权&lt;/strong&gt;，用$B2T_w$表示：
$$
B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2_i
$$
最高有效位$x_{w-1}$称为符号位，它的权重为$-2^{w-1}$，是无符号表示中权重的负数。&lt;/p&gt;
&lt;p&gt;从维向量到整数映射的举例：
$$
B2T_4([0001])=1 \
B2T_4([0101])=5 \
B2T_4([1011])=5 \
B2T_4([1111])=-1
$$
w位补码所能表示的值的范围是：$[-2^{w-1},2^{w-1}-1]$，例如长度为4的补码可以表示的范围是$[-8,7]$。与无符号数一样，在可表示的取值范围内，每个数字都唯一的w位补码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用补码来编码负数（有符号数）&lt;/strong&gt;。几乎所有现代机器目前都采用补码编码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反码：最高有效位的权是$-(2^{w-1}-1)$，其他和补码一样。&lt;/p&gt;
&lt;p&gt;原码：最高有效位是符号位，用来确定剩下的位应该取负权还是正权。&lt;/p&gt;
&lt;p&gt;这两种表示方式对于数字0都有两种不同的编码方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;有符号数和无符号数之间的转换&#34;&gt;有符号数和无符号数之间的转换&lt;/h3&gt;
&lt;p&gt;对于多数C语言的实现来说，这个问题都是从&lt;strong&gt;位级&lt;/strong&gt;角度来看的，而不是&lt;strong&gt;数&lt;/strong&gt;的角度。&lt;/p&gt;
&lt;p&gt;处理同样字长的有符号和无符号数之间相互转换的规则为：数值可能会改变，但&lt;strong&gt;位模式&lt;/strong&gt;不变。&lt;/p&gt;
&lt;p&gt;补码转换为无符号数$T2U_w(x)$，当x&amp;lt;0时值改变，计算结果为$x+2^w$，当x&amp;gt;0时值不变。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的有符号数和无符号数&#34;&gt;C语言中的有符号数和无符号数&lt;/h3&gt;
&lt;p&gt;C语言支持所有整型数据类型的有符号和无符号计算，几乎所有机器都采用&lt;strong&gt;补码&lt;/strong&gt;表示有符号数。通常大多数数字都默认是有符号的。&lt;/p&gt;
&lt;h3 id=&#34;扩展一个数字的位表示&#34;&gt;扩展一个数字的位表示&lt;/h3&gt;
&lt;p&gt;将无符号数扩展为一个更大的数据类型：只需在表示的开头添加0即可。&lt;/p&gt;
&lt;p&gt;将一个补码扩展为一个更大的数据类型：执行一个&lt;strong&gt;符号扩展&lt;/strong&gt;，即在开头添加最高有效位数字。&lt;/p&gt;
&lt;p&gt;符号扩展不改变补码表示的数字。&lt;/p&gt;
&lt;h3 id=&#34;截断数字&#34;&gt;截断数字&lt;/h3&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;为了避免出现错误或漏洞，我们&lt;strong&gt;绝不使用无符号数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;整数运算&#34;&gt;整数运算&lt;/h2&gt;
&lt;h3 id=&#34;无符号加法&#34;&gt;无符号加法&lt;/h3&gt;
&lt;p&gt;两个无符号数相加，如果完整的整数结果不能放到数据类型的字长限制中去，那么就会发生溢出，当无符号数加法发生溢出时，结果为丢弃溢出的最高位后的结果，即减去$2^w$。&lt;/p&gt;
&lt;h3 id=&#34;补码加法&#34;&gt;补码加法&lt;/h3&gt;
&lt;p&gt;分为正溢出、正常、负溢出三种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正溢出：和减去$2^w$&lt;/li&gt;
&lt;li&gt;负溢出：和加上$2^w$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;补码的非&#34;&gt;补码的非&lt;/h3&gt;
&lt;p&gt;当$x=\text{TMin}_w$时，补码的非的结果为：$\text{TMin}_w$，否则结果为$-x$&lt;/p&gt;
&lt;h3 id=&#34;无符号乘法&#34;&gt;无符号乘法&lt;/h3&gt;
&lt;p&gt;乘积可能需要$2w$位来表示，C语言中无符号被定义为产生w位值，即2w乘积结果的低2w位。将一个无符号数截断为w位等价于计算该值模$2^w$&lt;/p&gt;
&lt;h3 id=&#34;补码乘法&#34;&gt;补码乘法&lt;/h3&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;计算机的整数运算实际上是一种模运算，表示数字时的有限字长限制了可能的值的取值范围，结果运算溢出。&lt;/p&gt;
&lt;p&gt;补码提供了一种既能表示整数也能表示负数的灵活方法，同时使用了与执行无符号算术相同的位级实现。&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;h3 id=&#34;二进制小数&#34;&gt;二进制小数&lt;/h3&gt;
&lt;h3 id=&#34;ieee浮点数表示&#34;&gt;IEEE浮点数表示&lt;/h3&gt;
&lt;h3 id=&#34;舍入&#34;&gt;舍入&lt;/h3&gt;
&lt;h3 id=&#34;浮点运算&#34;&gt;浮点运算&lt;/h3&gt;
- https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>CAN总线</title>
        <link>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</link>
        <pubDate>Mon, 12 Jul 2021 18:16:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/ -&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;
&lt;p&gt;Controller Area Network&lt;/p&gt;
&lt;p&gt;CAN总线由BOSCH公司开发，是一种多主控(Multi-Master)的现场总线系统，CAN网络的消息是广播式的，即同一时刻网络上所有节点侦测的数据是一致的，是一种基于&lt;strong&gt;消息广播&lt;/strong&gt;模式的串行通信总线。&lt;/p&gt;
&lt;p&gt;CAN总线的很多优点，使得它得到了广泛的应用，如传输速度最高到1Mbps, 通信距离最远到10km，无损位仲裁机制，多主结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAN总线标准&lt;/strong&gt;规定了&lt;strong&gt;物理层&lt;/strong&gt;和&lt;strong&gt;数据链路层&lt;/strong&gt;，应用层标准由具体应用决定。&lt;/p&gt;
&lt;h2 id=&#34;can物理层&#34;&gt;CAN物理层&lt;/h2&gt;
&lt;p&gt;连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的&lt;strong&gt;差分电平信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;节点主要包括Host、控制器和收发器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;常集成有CAN控制器，&lt;strong&gt;CAN控制器&lt;/strong&gt;负责处理协议相关功能，以减轻Host的负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAN收发器&lt;/strong&gt;将控制器连接到传输媒介。通常控制器和总线收发器通过光耦或磁耦隔离，这样即使总线上过压损坏收发器，控制器和Host设备也可以得到保护。&lt;/p&gt;
&lt;p&gt;在发送数据时，CAN控制器把要发送的二进制编码通过&lt;strong&gt;CAN_Tx线&lt;/strong&gt;发送到CAN收发器，然后由收发器把这个普通的逻辑电平信号转化成&lt;strong&gt;差分信号&lt;/strong&gt;，通过&lt;strong&gt;差分线CAN_High和CAN_Low&lt;/strong&gt;输出到CAN总线网络。接收数据过程，相反。采用差分信号，可以取得更好的电磁兼容效果。因此，CAN总线物理传输媒介只需要两根线。&lt;/p&gt;
&lt;p&gt;下图为一CAN收发器应用的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_example.PNG&#34; alt=&#34;CAN总线示例&#34;&gt;&lt;/p&gt;
&lt;p&gt;高速CAN总线最高信号传输速率为1Mbps，支持最长距离40m。ISO11898-2要求在高速CAN总线两段安装&lt;strong&gt;端接电阻&lt;/strong&gt;RL（端接电阻一般为120Ω，因为电缆的特性阻抗为120 Ω，为了模拟无限远的传输线。）以消除反射。低速CAN最高速度只有125Kbps，所以ISO11898-3没有端接要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_bus_Res.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;差分信号&#34;&gt;差分信号&lt;/h3&gt;
&lt;p&gt;CAN总线采用差分信号传输，通常情况下只需要两根信号线就可以进行正常的通信。在差分信号中，逻辑0和逻辑1是用两根差分信号线的电压差来表示。&lt;/p&gt;
&lt;p&gt;当处于&lt;strong&gt;逻辑1&lt;/strong&gt;，CAN_High和CAN_Low的电压差小于0.5V时，称为&lt;strong&gt;隐性电平（Recessive）&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;当处于&lt;strong&gt;逻辑0&lt;/strong&gt;，CAN_High和CAN_Low的电压差大于0.9V，称为&lt;strong&gt;显性电平（Dominant）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CAN总线遵从“线与”机制：“显性”位可以覆 盖“隐性”位；只有所有节点都发 送“隐性”位， 总线才处于“隐性” 状态。这种“线与”机制使CAN总线呈现显性优先的特性。&lt;/p&gt;
&lt;h2 id=&#34;can数据链路层&#34;&gt;CAN数据链路层&lt;/h2&gt;
&lt;p&gt;在SPI通信中，片选、时钟信号、数据输入及数据输出这四个信号都有单独的信号线。而CAN使用的是两条差分信号线，&lt;strong&gt;只能表达一个信号&lt;/strong&gt;。简洁的物理层决定了CAN必然要配上一套更为复杂的协议。如何用一个信号通道实现同样甚至更强大的功能，答案就是对数据或操作命令进行打包。&lt;/p&gt;
&lt;h3 id=&#34;通信机制&#34;&gt;通信机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多主机(Multi-Master)&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;安全敏感的应用（如汽车动力）对通信系统的&lt;strong&gt;可靠性&lt;/strong&gt;要求很高。将总线能否正常工作归结到单一节点是非常危险的，比较合理的方案是对总线接入的&lt;strong&gt;去中心化&lt;/strong&gt;，即每个节点都有接入总线的能力。这也是CAN总线采用多主控（Multi-Master）线性拓扑结构的原因。&lt;/p&gt;
&lt;p&gt;在CAN总线上，每个节点都有往总线上发送消息的能力，而消息的发送不必遵从任何预先设定的时序，通信是&lt;strong&gt;事件驱动&lt;/strong&gt;的。只有当有新的信息传递时，CAN总线才处于忙碌的状态，这使得节点接入总线速度非常快。CAN总线理论最高数据传输速率为1Mbps，对于异步事件反应迅速，基本对于ms级别的实时应用没有任何问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻址机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;CAN总线不设定节点的地址，而是通过消息的&lt;strong&gt;标识符（Identifier）&lt;strong&gt;来区别消息。这种机制虽然会增加消息的复杂度（增加标识符），但是节点在此情况下可以无需了解其他节点的状况，而&lt;/strong&gt;相互间独立工作&lt;/strong&gt;。在总线上增加节点时仅需关注消息类型，而非系统上其他节点的状况。这种以消息标识符寻址的方式，让总线上增加节点变得更加灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线访问 CSMA/CD+AMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多路载波侦听+基于消息优先级的冲突检测和非破坏性的仲裁机制（CSMA/CD+AMP）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CSMA（Carrie Sense Multiple Access）指的是所有节点必须都等到总线处于&lt;strong&gt;空闲状态&lt;/strong&gt;时才能往总线上发送消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CD+AMP（Collision Detection + Arbitration on Message Priority）指的是如果多个节点往总线上发送消息时，具备&lt;strong&gt;最高优先级&lt;/strong&gt;的消息获得总线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非破坏性仲裁机制：通过ID仲裁，ID&lt;strong&gt;数值越小&lt;/strong&gt;，报文&lt;strong&gt;优先级越高&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;发送低优先级报文的节点退出仲裁后，在下次总线空闲时自动重发报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;高优先级的报文&lt;strong&gt;不能中断&lt;/strong&gt;低优先级报文的发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报文接受过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAN控制器大多具有根据ID过滤报文的功能，即只接收某些ID的报文。节点对接收到的报文进行过滤：比较消息ID与选择器（Accepter）中和接受过滤相关位是否相同。如果相同，接收；如果不相同，则过滤。&lt;/p&gt;
&lt;h3 id=&#34;报文种类及结构&#34;&gt;报文种类及结构&lt;/h3&gt;
&lt;p&gt;在原始数据段的前面加上&lt;strong&gt;传输起始标签、片选（识别）标签、控制标签&lt;/strong&gt;，在数据的尾段加上&lt;strong&gt;CRC校验标签、应答标签和传输结束标签&lt;/strong&gt;。把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了。&lt;/p&gt;
&lt;p&gt;各种各样的标签，起到了协同传输的作用。当整个数据包被传输到其他设备时，只要这些设备按格式去解读，就能还原出原始数据。类似这样的数据包就被称为CAN的数据帧。&lt;/p&gt;
&lt;p&gt;为了更有效的控制通信，CAN一共规定了5中类型的帧，帧也称为报文。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;帧&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;帧用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于发送单元向接收单元传输数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;远程帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于接收单元向具有相同ID的发送单元请求数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;错误帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于当检测出错误时，向其他单元通知错误的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超载帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于接收单元通知其尚未做好接受准备的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧间隔&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于将数据帧及遥控帧与前面其他帧分离开的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;数据帧&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_dataFrame.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;共分为7个段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帧起始（SOF）：标识一个数据帧的开始，固定一个显性位。用于同步，总线空闲期间的任何隐性到线性的跳变都将引起节点进行硬同步&lt;/li&gt;
&lt;li&gt;仲裁段：内容为本数据帧的ID信息&lt;/li&gt;
&lt;li&gt;控制段：r1和r0为保留位，默认设置为显性位。DLC（Data Length Code）段用二进制编码表示本报文的数据段包含多少字节，由4位组成，DLC3-DLC0，表示的数字为0-8.&lt;/li&gt;
&lt;li&gt;数据段：数据帧的核心内容，有0-8个字节长度。&lt;/li&gt;
&lt;li&gt;CRC段：报文包含了一段15位的CRC校验码，来检验是否出错。&lt;/li&gt;
&lt;li&gt;ACK段：包含确认位和界定符。在发送节点发送时为隐形位，当接收节点收到正确报文时，将其覆盖为显性。&lt;/li&gt;
&lt;li&gt;帧结束段（EOF）：由发送端发送7个隐形位表示结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步&#34;&gt;同步&lt;/h2&gt;
&lt;p&gt;CAN总线使用&lt;strong&gt;位同步&lt;/strong&gt;的方式来确保通信时序，以及对总线的电平进行正确采样。&lt;/p&gt;
&lt;h3 id=&#34;位时序&#34;&gt;位时序&lt;/h3&gt;
&lt;h3 id=&#34;同步-1&#34;&gt;同步&lt;/h3&gt;
&lt;p&gt;分为硬同步和重新同步。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;部分内容转载自：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32262127&#34;&gt;知乎-Choris-一口气从零读懂CAN总线&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>存储器详解</title>
        <link>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Sun, 04 Jul 2021 16:09:50 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ -&lt;p&gt;计算机存储器只要分为内存和外存。内存是CPU直接寻址的存储空间，访问频率快，而外存访问慢。&lt;/p&gt;
&lt;h2 id=&#34;易失性存储器随机存取存储器ram&#34;&gt;易失性存储器（随机存取存储器，RAM）&lt;/h2&gt;
&lt;p&gt;Random Access Memory，存储在其中的资料会在电力切断后消失，所以属于易失性存储器。&lt;/p&gt;
&lt;h3 id=&#34;动态随机存取存储器dram&#34;&gt;动态随机存取存储器（DRAM）&lt;/h3&gt;
&lt;p&gt;Dynamic Random Access Memory，主要的作用原理是利用电容内&lt;strong&gt;存储电荷的多寡&lt;/strong&gt;来代表一个二进制比特（bit）是1还是0。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别资料，而导致资料毁损。因此对于DRAM来说，周期性地充电是一个不可避免的条件。由于这种需要&lt;strong&gt;定时刷新&lt;/strong&gt;的特性，因此被称为“动态”存储器。&lt;/p&gt;
&lt;h3 id=&#34;静态随机存取存储器sram&#34;&gt;静态随机存取存储器（SRAM）&lt;/h3&gt;
&lt;p&gt;Static Random Access Memory，所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失。&lt;/p&gt;
&lt;p&gt;SRAM由存储矩阵、地址译码器和读/写控制电路组成，容量的扩展有两个方面：位数的扩展用芯片的并联，字数的扩展可用外加译码器控制芯片的片选输入端[2]。SRAM中的每一bit储存在由4个场效应管（M1, M2, M3, M4）构成两个交叉耦合的反相器中。另外两个场效应管（M5, M6）是储存基本单元到用于读写的位线（Bit Line）的控制开关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SRAM_Cell_(6_Transistors).svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;非易失性存储器主要为只读存储器rom&#34;&gt;非易失性存储器（主要为只读存储器，ROM）&lt;/h2&gt;
&lt;p&gt;Read-Only Memory，一旦存储资料就无法再将之改变或删除，且内容不会因为电源关闭而消失。&lt;/p&gt;
&lt;h3 id=&#34;可编程式只读存储器prom&#34;&gt;可编程式只读存储器（PROM）&lt;/h3&gt;
&lt;p&gt;Programmable read-only memory，每个比特都由熔丝或反熔丝的状态决定资料内容。这种存储器用作永久存放程序之用。常用于电子游戏机、电子词典等预存固定资料或程序的各式电子产品之上。PROM与狭义的ROM（Mask ROM）的差别在于前者可在IC制造完成后才依需要写入资料，后者的资料需在制造IC时一并制作在里面。&lt;/p&gt;
&lt;p&gt;一个典型的PROM一开始时每个比特都会是1，编程中如将该比特的熔丝（fuse）烧断则成为0，这一过程是不可逆的（即刻录后不能再改变），断电后也不会消失记忆，所以这种存储器是一种只读存储器。&lt;/p&gt;
&lt;h3 id=&#34;可擦除可编程式只读存储器eprom&#34;&gt;可擦除可编程式只读存储器（EPROM）&lt;/h3&gt;
&lt;p&gt;Erasable Programmable Read Only Memory，它是一组浮栅晶体管，被一个提供比电子电路中常用电压更高电压的电子器件分别编程。一旦编程完成后，EPROM只能用强紫外线照射来擦除。通过封装顶部能看见硅片的透明窗口，很容易识别EPROM，这个窗口同时用来进行紫外线擦除。&lt;/p&gt;
&lt;h3 id=&#34;电子抹除式可复写只读存储器eeprom&#34;&gt;电子抹除式可复写只读存储器（EEPROM）&lt;/h3&gt;
&lt;p&gt;Electrically-Erasable Programmable Read-Only Memory，是一种可以通过电子方式多次复写的半导体存储设备。相比EPROM， EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据， EEPROM 属于SPD（串行存在检测）技术的一种延伸。&lt;/p&gt;
&lt;p&gt;在民用的DDR SDRAM及其主流后续产品中，一般 EEPROM 主要用于保存内存的开发者信息、生产时间、内存信息、通信协议、既定内存频率、供电电压、供电电流、物理信息以及内存XMP等信息，并且电脑会在开机自检（Power-On Self-Test；POST）时会读取这些信息以保持电脑的正常开机。&lt;/p&gt;
&lt;h3 id=&#34;闪存flash-memory&#34;&gt;闪存（Flash Memory）&lt;/h3&gt;
&lt;p&gt;闪存是一种特殊的、以宏块抹写的EEPROM。&lt;/p&gt;
&lt;p&gt;NOR和NAND两种类型&lt;/p&gt;
&lt;h4 id=&#34;nand-flash&#34;&gt;NAND Flash&lt;/h4&gt;
&lt;p&gt;SLC(单阶存储单元)、MLC(多阶存储单元，一般指2)、TLC(三阶存储单元)、QLC&lt;/p&gt;
&lt;p&gt;现在消费级产品都是TLC&lt;/p&gt;
&lt;h4 id=&#34;移动端使用的闪存协议变化&#34;&gt;移动端使用的闪存协议变化&lt;/h4&gt;
&lt;p&gt;eMMC-UFS&lt;/p&gt;- https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH09 顺序容器</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Tue, 15 Jun 2021 15:36:20 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ -&lt;p&gt;顺序容器&lt;/p&gt;
&lt;p&gt;一个容器就是一些特定类型对象的集合。&lt;/p&gt;
&lt;p&gt;顺序容器提供了&lt;strong&gt;控制元素存储&lt;/strong&gt;和&lt;strong&gt;访问顺序&lt;/strong&gt;的能力。这种顺序与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;p&gt;关联容器与顺序容器有着根本不同，关联容器中的元素是按照&lt;strong&gt;关键词&lt;/strong&gt;来保存和访问的，即&lt;strong&gt;Key-Value&lt;/strong&gt;；与之相对的是顺序容器中的元素按照它们在容器中的位置来顺序保存和访问。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;顺序容器都提供了&lt;strong&gt;快速顺序访问元素&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;顺序容器类型(名称)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;性能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vector&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可变大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在尾部之外的位置插入删除元素很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;deque&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双端队列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在头尾插入删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双向链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持双向顺序访问。在list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forward_list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单项链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持单项顺序访问。在forward_list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;array&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。不能添加删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;与vector相似的容器，专门用于保存字符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随机访问快，在尾部插入删除速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了固定大小的array外，其他容器都提供高效的内存管理。容器保存元素的策略对容器操作的效率有着很大影响。&lt;/p&gt;
&lt;p&gt;string和vector将元素保存在&lt;strong&gt;连续的内存空间&lt;/strong&gt;中，因此由元素的下标来计算其地址非常快速。但在这两种容器的中间位置插入和删除元素的速度非常慢，因为一次插入或删除后，需要移动插入、删除位置后的&lt;strong&gt;所有元素&lt;/strong&gt;以保证存储的连续。&lt;/p&gt;
&lt;p&gt;list和forward_list两个容器能令任何位置的添加和删除操作都很快，但这两种容器&lt;strong&gt;不支持随机访问&lt;/strong&gt;，因为元素保存的内存空间不连续，只能通过遍历整个容器来访问一个元素。与vector和string相比，额外内存开销也很大。&lt;/p&gt;
&lt;p&gt;forward_list与最好的手写单向链表数据结构性能相当，因此没有size操作，因为保存或计算大小会多出额外开销。&lt;/p&gt;
&lt;p&gt;deque支持快读随机访问，在该容器中间位置添加或删除元素速度很慢，但在两端很快。&lt;/p&gt;
&lt;h2 id=&#34;容器库概览&#34;&gt;容器库概览&lt;/h2&gt;
&lt;p&gt;容器类型上的操作分成了层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些操作式所有容器都提供的；&lt;/li&gt;
&lt;li&gt;另外一些操作仅针对顺序容器、关联容器或无序容器；&lt;/li&gt;
&lt;li&gt;还有一些操作只适合一小部分容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器通过&lt;strong&gt;尖括号&lt;/strong&gt;指定类型。&lt;/p&gt;
&lt;h3 id=&#34;容器操作&#34;&gt;容器操作&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;iterator
size_type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*iter	//返回迭代器iter所指元素的引用
iter-&amp;gt;name	//解引用iter并获取该元素的名为mem的成员
++iter	//令iter指示容器中的下一个元素
--iter	//令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个&lt;strong&gt;迭代器范围&lt;/strong&gt;由一对迭代器表示，这两个迭代器被称为begin和end，begin指向容器第一个元素，end指向容器的&lt;strong&gt;尾后元素&lt;/strong&gt;，这种元素范围被称为&lt;strong&gt;左闭合区间&lt;/strong&gt;，即&lt;code&gt;[begin, end)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对构成范围的迭代器的要求：&lt;strong&gt;end不在begin之前&lt;/strong&gt;。可以通过对begin进行若干次递增，使得begin==end。&lt;/p&gt;
&lt;h3 id=&#34;容器类型成员&#34;&gt;容器类型成员&lt;/h3&gt;
&lt;p&gt;每个容器都定义了多个类型。如之前使用过的&lt;code&gt;interator&lt;/code&gt;、&lt;code&gt;size_type&lt;/code&gt;等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;interator
const_iterator
size_type
difference_type
value_type
reference
const_reference
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;iterator iter;
vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;begin和end成员&#34;&gt;begin和end成员&lt;/h3&gt;
&lt;p&gt;begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。还有不同类型的反向迭代器、const迭代器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;list&amp;lt;int&amp;gt; a = {1, 2, 3};
auto it1 = a.begin();	//list&amp;lt;int&amp;gt;::iterator
auto it2 = a.rbegin();	//反向迭代器 list&amp;lt;int&amp;gt;::reverse_iterator
auto it3 = a.cbegin();	//const迭代器 list&amp;lt;int&amp;gt;::const_iterator
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;容器定义和初始化&#34;&gt;容器定义和初始化&lt;/h3&gt;
&lt;p&gt;每个容器类型都定义了一个默认构造函数。除了array外，其他容器的默认构造函数都会创建一个指定类型的空容器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C c;	//默认构造函数
C c1(c2)	//c1初始化为c2的拷贝。两者必须是相同类型的容器
C c{a,b,c...}	//c初始化为初始化列表中元素的拷贝
C c(b,e)	//c初始化为迭代器b和e指定范围中元素的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与顺序容器（除了array）大小相关的一个构造函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ivec(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int元素，每个都初始化为1
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; scev(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个元素，每个都是空string
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标准库array具有固定大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存42个int的数组
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存10个string的数组
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用array时必须同时指定&lt;strong&gt;元素类型&lt;/strong&gt;和&lt;strong&gt;大小&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;size_type j;	&lt;span style=&#34;color:#888&#34;&gt;//错误，未指定大小
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个默认构造的array是非空的，它包含了与其大小一样多的元素，这些元素都被默认初始化。&lt;/p&gt;
&lt;h3 id=&#34;赋值和swap&#34;&gt;赋值和swap&lt;/h3&gt;
&lt;p&gt;赋值将左边容器中的所有元素替换为右边容器中元素的拷贝。如果两个容器原来大小不同，赋值运算后两者大小都与右边容器的原大小相等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; c2;	&lt;span style=&#34;color:#888&#34;&gt;//将c1替换为c2中元素的拷贝，拷贝后c1的大小与原c2相同
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {a, b, c}
swap(c1, c2)
c1.swap(c2)	&lt;span style=&#34;color:#888&#34;&gt;//与上一个等价
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//assign操作不适用于关联容器和array
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为迭代器b和e所表示范围的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(il)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为初始化列表il中的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(n,t)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为n个值为t的元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;assign用参数所指定的元素拷贝替换左边容器中所有元素。assign操作不适用于array和关联容器。&lt;/p&gt;
&lt;p&gt;swap只是交换了两个容器内部的&lt;strong&gt;数据结构&lt;/strong&gt;，但例外是swap两个array会真正交换它们的元素。&lt;/p&gt;
&lt;h3 id=&#34;容器大小操作&#34;&gt;容器大小操作&lt;/h3&gt;
&lt;p&gt;成员函数&lt;code&gt;size&lt;/code&gt;返回容器中元素的数目；&lt;code&gt;empty&lt;/code&gt;当size为0时返回布尔值true，否则返回false；&lt;code&gt;max_size&lt;/code&gt;返回一个大于或等于该类型容器所能容纳的最大元素数的值。&lt;/p&gt;
&lt;p&gt;forward_list支持&lt;code&gt;max_size&lt;/code&gt;和&lt;code&gt;empty&lt;/code&gt;但不支持size。&lt;/p&gt;
&lt;h3 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;每个容器类型都支持相等运算符(即&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;)；除&lt;strong&gt;无序关联容器&lt;/strong&gt;外的所有容器都支持关系运算符(&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=)。&lt;/p&gt;
&lt;p&gt;关系运算符左右两边的运算对象必须是&lt;strong&gt;相同类型的容器&lt;/strong&gt;，且保存&lt;strong&gt;元素的类型也必须相等&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顺序容器操作&#34;&gt;顺序容器操作&lt;/h2&gt;
&lt;p&gt;顺序容器和关联容器的不同在于两者&lt;strong&gt;组织元素的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了上一节介绍的&lt;strong&gt;所有容器都支持的操作外&lt;/strong&gt;，本章剩余部分将介绍顺序容器的所有操作。&lt;/p&gt;
&lt;h4 id=&#34;向顺序容器添加元素&#34;&gt;向顺序容器添加元素&lt;/h4&gt;
&lt;p&gt;向顺序容器中除了array外添加元素的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.push_back(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的尾部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_back(args)
c.push_front(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的头部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_front(args)
c.insert(p,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前创建一个值为t的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,n,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,b,e)			&lt;span style=&#34;color:#888&#34;&gt;//将迭代器b和e指向范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,il)			&lt;span style=&#34;color:#888&#34;&gt;//il为一个花括号包围的元素值列表，将这些值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;forword_list&lt;/code&gt;不支持&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;emplace_back&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持&lt;code&gt;push_front&lt;/code&gt;和&lt;code&gt;emplace_front&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;使用这些操作时要注意策略，根据不同容器的&lt;strong&gt;不同数据结构的特性&lt;/strong&gt;来使用。&lt;/p&gt;
&lt;p&gt;emplace操作构造而不是拷贝元素，将参数传递给元素类型的构造函数，直接构造元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_back&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了array和forward_list外，每个顺序容器都支持该操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_front&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;list、forward_list和deque容器还支持&lt;code&gt;push_front&lt;/code&gt;，此操作将元素插入容器头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器特定为止添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;insert成员匀速我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。&lt;/p&gt;
&lt;p&gt;每个insert都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。&lt;/p&gt;
&lt;p&gt;insert函数还可以接受更多参数，其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;svec.insert(svec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用emplace操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++11引入了三个新成员——emplace_front、emplace和emplace_back，这些操作&lt;strong&gt;构造&lt;/strong&gt;而不是拷贝元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.emplace_back(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;123445&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;15.99&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在c的末位构造一个Sales_data对象。&lt;/p&gt;
&lt;h4 id=&#34;访问元素&#34;&gt;访问元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.back()		&lt;span style=&#34;color:#888&#34;&gt;//返回c中尾元素的引用，若c为空，则函数行为未定义。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.front()		&lt;span style=&#34;color:#888&#34;&gt;//范围c中首元素的引用
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c[n]			&lt;span style=&#34;color:#888&#34;&gt;//返回c中下标为n的元素的引用，n是一个无符号整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.at(n)			&lt;span style=&#34;color:#888&#34;&gt;//返回下标为n的元素的引用，若下标越界，则返回out_of_range异常
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;at和下标操作只适用于string、vector、array和deque&lt;/p&gt;
&lt;p&gt;back不适用于forward_list&lt;/p&gt;
&lt;p&gt;以上访问元素的成员函数返回的都是&lt;strong&gt;引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;删除元素&#34;&gt;删除元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.pop_back()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中尾元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.pop_front()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中首元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器p所指元素，返回一个指向被删元素之后元素的迭代器；若p指向尾元素，则返回尾后迭代器；若p是尾后迭代器，则函数行为未定义
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若e本身就是尾后迭代器，则也返回尾后迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.clear()		&lt;span style=&#34;color:#888&#34;&gt;//删除c中所有元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;forward_list有特殊erase，且不支持pop_back.&lt;/p&gt;
&lt;p&gt;vector和string不支持pop_front.&lt;/p&gt;
&lt;p&gt;erase从容器中指定位置删除元素，还可以使用一对迭代器，删除一个范围内的元素。&lt;/p&gt;
&lt;h4 id=&#34;特殊的forward_list操作&#34;&gt;特殊的forward_list操作&lt;/h4&gt;
&lt;p&gt;在链表中添加或删除一个链接，会改变序列中的链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.before_begin()		&lt;span style=&#34;color:#888&#34;&gt;//返回指向链表首元素之前不存在的元素迭代器，该迭代器不能解引用。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,t)	&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的为止插入元素，t是一个对象，n是数量，b和e是一对迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)	&lt;span style=&#34;color:#888&#34;&gt;//il是一个花括号列表
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的位置插入元素，t是一个对象，n是数量，b和e是表示范围的一对迭代器，il是一个花括号列表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;emplace_after(p,args)	&lt;span style=&#34;color:#888&#34;&gt;//使用args在p指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除p指向位置之后的元素，或删除从b之后直到e之间的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(b,e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在forward_list中添加或删除元素时，我们要关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱。&lt;/p&gt;
&lt;h4 id=&#34;改变容器大小&#34;&gt;改变容器大小&lt;/h4&gt;
&lt;p&gt;可以使用resize来增大或缩小容器。&lt;strong&gt;array不支持resize&lt;/strong&gt;。若当前大小大于所要求的大小，则容器后部的元素会被删除；所当前大小小于新大小，则将新元素添加到容器后部。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ilist(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int：每个的值都是43
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;15&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将5个值为0的元素添加到ilist末尾
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;,&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将10个值为1的元素添加到ilist末尾
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;容器操作可能使迭代器失效&#34;&gt;容器操作可能使迭代器失效&lt;/h4&gt;
&lt;p&gt;根据不同容器在内存中存储的方式不同，向容器中添加或删除元素会导致不同类型的迭代器失效。&lt;/p&gt;
&lt;h2 id=&#34;vector对象的增长&#34;&gt;vector对象的增长&lt;/h2&gt;
&lt;p&gt;vector和string的实现通常会分配比新的空间需求&lt;strong&gt;更大的内存空间&lt;/strong&gt;，容器预留这些空间作为&lt;strong&gt;备份&lt;/strong&gt;，可用来保存更多的新元素，这样就不需要每次添加新元素都重新分配容器的内存空间了。&lt;/p&gt;
&lt;p&gt;以下是vector和string提供的一些管理容量的成员函数，允许我们与它的实现中内存分配部分互动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.shrink_to_fit()		&lt;span style=&#34;color:#888&#34;&gt;//将capacity减少为与size()相同大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.capacity()			&lt;span style=&#34;color:#888&#34;&gt;//不重新分配内存空间的话，c可以保存多少元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.reserve(n)			&lt;span style=&#34;color:#888&#34;&gt;//分配至少能容纳n个元素的内存空间
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;reserve不改变容器中元素数量，只影响预先分配内存空间的大小。&lt;/p&gt;
&lt;p&gt;shrink_to_fit只适用于vector、string和deque。&lt;/p&gt;
&lt;p&gt;capacity、reserve只适用于vector、string。&lt;/p&gt;
&lt;h2 id=&#34;额外的string操作&#34;&gt;额外的string操作&lt;/h2&gt;
&lt;p&gt;这些操作大部分是提供&lt;strong&gt;string类和C风格字符数组&lt;/strong&gt;之间的&lt;strong&gt;相互转换&lt;/strong&gt;，或者增加了允许我们用&lt;strong&gt;下标&lt;/strong&gt;代替迭代器。&lt;/p&gt;
&lt;h4 id=&#34;构造string的其他方法&#34;&gt;构造string的其他方法&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string s(cp, n)		//s是cp指向的数组中前n个字符的拷贝。
string s(s2, pos2)	//s是string s2从下标pos2开始的字符的拷贝。
string s(s2, pos2, len2)	//s是string s2从下标pos2开始len2个字符的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些构造函数接受一个string或一个const char*参数，还接受指定拷贝多少个字符的参数。当传递给他一个string时，还可指定一个下标指出从哪里开始拷贝。&lt;/p&gt;
&lt;p&gt;substr操作返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.substr(pos, n)	&lt;span style=&#34;color:#888&#34;&gt;//返回一个string，包含s中从pos位置开始的n个字符的拷贝。pos的默认值为0.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果开始位置超出了string的大小，则substr抛出一个&lt;code&gt;out_of_range&lt;/code&gt;异常。若开始位置加上计数值大于string的大小，则substr只会拷贝到string的末尾。&lt;/p&gt;
&lt;h4 id=&#34;改变string的其他方法&#34;&gt;改变string的其他方法&lt;/h4&gt;
&lt;p&gt;定义了额外的insert和erase版本，还定义了两个额外的成员函数append和replace。&lt;/p&gt;
&lt;p&gt;除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到指定值之前的位置：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;s.insert(s.size(), 5, &#39;!&#39;);		//在s末尾插入5个!
s.erase(s.size() - 5, 5);		//删除s的最后5个元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;append操作是在string末尾进行插入操作的一种简写。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stirng &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;s&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;C++ Primer&amp;#34;&lt;/span&gt;), s2 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; s;
s.insert(s.size(), &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; 4th Ed.&amp;#34;&lt;/span&gt;);
s2.append(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; 4th Ed.&amp;#34;&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//两种写法等价
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;replace操作是调用erase和insert的一种简写形式。&lt;/p&gt;
&lt;h4 id=&#34;string搜索&#34;&gt;string搜索&lt;/h4&gt;
&lt;p&gt;string类提供了6个不同的搜索函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.find(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.rfind(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args最后一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_first_of(args)	&lt;span style=&#34;color:#888&#34;&gt;//在s中查找args中任何一个字符第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_last_of(args)
s.find_first_not_of(args)
s.find_last_not_of(args)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;compare函数&#34;&gt;compare函数&lt;/h4&gt;
&lt;p&gt;标准库string还提供了一组compare函数，根据s是等于、大于还是小于参数指定的字符串，&lt;code&gt;s.compare&lt;/code&gt;返回0、整数或负数。类似于C标准库的strcmp函数。&lt;/p&gt;
&lt;p&gt;s.compare有6个版本的参数形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.compare(s2)						&lt;span style=&#34;color:#888&#34;&gt;//比较s和s2
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.compare(pos1, n1, s2)				&lt;span style=&#34;color:#888&#34;&gt;//将s中从pos1开始的n1个字符与s2作比较
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.compare(pos1, n1, s2, pos2, n2)
s.compare(cp)						&lt;span style=&#34;color:#888&#34;&gt;//比较s与cp指向的以空字符结尾的字符数组
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.compare(pos1, n1, cp)
s.compare(pos1, n1, cp, n2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;数值转换&#34;&gt;数值转换&lt;/h4&gt;
&lt;p&gt;string和数值之间的转换&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;to_string(val)
&lt;span style=&#34;color:#888&#34;&gt;//b表示转换用的基数，默认为10；p保存s中第一个非数值字符的下标，默认为0，即不保存下标
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stoi(s, p, b)	&lt;span style=&#34;color:#888&#34;&gt;//string to int
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stol(s, p, b)	&lt;span style=&#34;color:#888&#34;&gt;//string to long
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stoll(s, p, b)	&lt;span style=&#34;color:#888&#34;&gt;//stirng to long long
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stof(s, p)		&lt;span style=&#34;color:#888&#34;&gt;//string to float
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stod(s, p)		&lt;span style=&#34;color:#888&#34;&gt;//string to double
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stold(s, p)		&lt;span style=&#34;color:#888&#34;&gt;//string to long double
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h2&gt;
&lt;p&gt;除顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priority_queue&lt;/p&gt;
&lt;p&gt;一个适配器是一种机制，能使某种事物看起来像另一种事物。&lt;/p&gt;
&lt;p&gt;一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。&lt;/p&gt;
&lt;p&gt;例如，stack适配器接受一个顺序容器，并使其操作起来像一个stack一样。&lt;/p&gt;
&lt;p&gt;所有容器适配器&lt;strong&gt;都支持的操作和类型&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;size_type		&lt;span style=&#34;color:#888&#34;&gt;//一种类型，足够保存当前类型的最大对象的大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;value_type
container_type	&lt;span style=&#34;color:#888&#34;&gt;//实现适配器的底层容器类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A a;			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的空适配器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;a&lt;/span&gt;(c);			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的适配器，带有容器c的一个拷贝
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;关系运算符&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;等等&lt;/span&gt;
a.empty()
a.size()
swap(a,b)		&lt;span style=&#34;color:#888&#34;&gt;//交换a、b的内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;a.swap(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;定义一个适配器&#34;&gt;定义一个适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; stk(deq);	&lt;span style=&#34;color:#888&#34;&gt;//deq是一个deque&amp;lt;int&amp;gt;，从deq拷贝元素到stk
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;栈适配器&#34;&gt;栈适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; intStack;	&lt;span style=&#34;color:#888&#34;&gt;//声明一个空栈
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他一些栈操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.pop()
s.push(item)	&lt;span style=&#34;color:#888&#34;&gt;//创建一个新元素压入栈顶，该元素通过拷贝或移动item实现，或有args构造
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.emplace(args)
s.top()			&lt;span style=&#34;color:#888&#34;&gt;//返回栈顶元素，但不讲栈弹出
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;队列适配器&#34;&gt;队列适配器&lt;/h4&gt;
&lt;p&gt;queue和priority_queue适配器定义在queue头文件。&lt;/p&gt;
&lt;p&gt;标准库queue是一种FIFO的策略。底层是基于deque的。只是限制其不能进行随机访问。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 1.计算机系统漫游</title>
        <link>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link>
        <pubDate>Fri, 11 Jun 2021 12:18:22 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ -&lt;p&gt;在本书中我们将会学习到一些使用技巧，比如如何避免由于&lt;strong&gt;计算机表示数字的方式&lt;/strong&gt;引起的错误；通过一些技巧&lt;strong&gt;优化C代码&lt;/strong&gt;，以充分利用现代处理器和存储器系统的设计；了解&lt;strong&gt;编译器&lt;/strong&gt;如何实现过程调用，利用这些知识避免&lt;strong&gt;缓冲区溢出&lt;/strong&gt;错误带来的安全漏洞；学习如何识别和避免&lt;strong&gt;链接&lt;/strong&gt;时的错误；如何编写Unix Shell、动态存储分配包、Web服务器；&lt;strong&gt;并发&lt;/strong&gt;带来的希望和陷阱，对于现在的单芯片集成多个处理器核心非常重要。&lt;/p&gt;
&lt;p&gt;我们通过围绕Hello程序执行时的整个生命周期来对系统进行学习：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Hello, world&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;信息就是位上下文&#34;&gt;信息就是位+上下文&lt;/h2&gt;
&lt;p&gt;8位为一个字节。&lt;/p&gt;
&lt;p&gt;现代计算机系统使用ASCII标准来表示文本字符。即用一个&lt;strong&gt;单字节&lt;/strong&gt;大小的整数值表示一个符号。&lt;/p&gt;
&lt;p&gt;数字的机器表示是对真值的有限近似。&lt;/p&gt;
&lt;h2 id=&#34;程序被翻译为不同的格式&#34;&gt;程序被翻译为不同的格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hello.c&lt;/code&gt;中的每条C语句都会转换为一系列低级&lt;strong&gt;机器语言&lt;/strong&gt;指令。这些指令按照&lt;strong&gt;可执行目标程序&lt;/strong&gt;格式打包，以二进制磁盘文件的形式存放。&lt;/p&gt;
&lt;p&gt;编译系统：&lt;/p&gt;
&lt;p&gt;hello.c(源程序，文本) -&amp;gt; &lt;code&gt;预处理器(cpp)&lt;/code&gt; -&amp;gt; hello.i(修改了的源程序，文本) -&amp;gt; &lt;code&gt;编译器(ccl)&lt;/code&gt; -&amp;gt; hello.s(汇编程序，文本) -&amp;gt; &lt;code&gt;汇编器&lt;/code&gt; -&amp;gt; hello.o(可重定位目标程序，二进制) -&amp;gt; &lt;code&gt;链接器&lt;/code&gt; -&amp;gt; hello(可执行目标程序，二进制)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：预处理器(cpp)根据以字符&lt;code&gt;#&lt;/code&gt;开头的命令，修改原始C程序。例如&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;告诉预处理器读取系统头文件的内容，将其插入程序文本中，得到另一个C程序，以&lt;code&gt;.i&lt;/code&gt;为扩展名。&lt;/li&gt;
&lt;li&gt;编译阶段：编译器(ccl将&lt;code&gt;hello.i&lt;/code&gt;翻译为&lt;code&gt;hello.s&lt;/code&gt;，其包含了&lt;strong&gt;汇编语言程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;汇编阶段：汇编器(as)将&lt;code&gt;hello.s&lt;/code&gt;翻译为&lt;strong&gt;机器语言指令&lt;/strong&gt;，将这些指令打包为&lt;strong&gt;可重定位目标程序&lt;/strong&gt;，将结果保存在&lt;code&gt;hello.o&lt;/code&gt;中，该文件为二进制文件。&lt;/li&gt;
&lt;li&gt;链接阶段：hello程序调用了printf函数，它是C编译器提供的标准C库中的一个函数，printf函数存在于一个名为&lt;code&gt;printf.o&lt;/code&gt;的单独预编译好的目标文件中，这个文件要以某种形式合并到我们的&lt;code&gt;hello.o&lt;/code&gt;程序中，链接器(ld)负责这种合并，合并后就得到了&lt;strong&gt;可执行目标文件&lt;/strong&gt;&lt;code&gt;hello&lt;/code&gt;，其可以被加载到内存中，由系统执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器的工作方式&#34;&gt;编译器的工作方式&lt;/h2&gt;
&lt;p&gt;有一些重要原因使得我们必须知道编译器的工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化程序性能。我们需要了解一些机器代码及编译器将不同C语句转化为机器代码的方式，例如一个switch语句是否总比一系列if-else语句高效。&lt;/li&gt;
&lt;li&gt;理解链接时出现的错误。&lt;/li&gt;
&lt;li&gt;避免安全漏洞。缓冲区溢出错误是大多网络和服务器安全漏洞的主要原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;处理器读取并解释储存在内存中的指令&#34;&gt;处理器读取并解释储存在内存中的指令&lt;/h2&gt;
&lt;p&gt;要在Unix系统运行可执行目标文件hello，需要将文件名输入shell应用程序中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./hello
hello,world
linux&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h3&gt;
&lt;h4 id=&#34;总线&#34;&gt;总线&lt;/h4&gt;
&lt;p&gt;贯穿整个系统，负责信息字节在各个部件之间传递。&lt;/p&gt;
&lt;p&gt;通常被设计为传送定长的字节块，即&lt;strong&gt;字&lt;/strong&gt;，字中的字节数（即字长）是基本的系统参数，如今大多数机器中字长为8字节(即64位)，4字节(32位)在逐渐被64位取代。&lt;/p&gt;
&lt;h4 id=&#34;io设备&#34;&gt;I/O设备&lt;/h4&gt;
&lt;p&gt;每个I/O设备通过&lt;strong&gt;控制器或适配器&lt;/strong&gt;与I/O总线相连，控制器为I/O设备本身或系统主板上的芯片组，适配器为插在主板插槽上的卡。&lt;/p&gt;
&lt;h4 id=&#34;主存ram&#34;&gt;主存RAM&lt;/h4&gt;
&lt;p&gt;临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。由一组&lt;strong&gt;动态随机存取存储器(DRAM)&lt;strong&gt;芯片组成。逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的&lt;/strong&gt;地址&lt;/strong&gt;(数组索引)，这些地址从零开始。&lt;/p&gt;
&lt;h4 id=&#34;处理器&#34;&gt;处理器&lt;/h4&gt;
&lt;p&gt;CPU是解释或执行存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备(&lt;strong&gt;寄存器&lt;/strong&gt;)，称为程序计数器(PC)，PC指向主存中的某条机器语言指令（即包含该指令的地址）。&lt;/p&gt;
&lt;p&gt;处理器在一直不停地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个简单的指令执行模型来操作的，这个模型是&lt;strong&gt;指令集架构&lt;/strong&gt;决定的。该模型中指令按照严格的顺序执行。执行一条指令包含一系列步骤，处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，循环操作。&lt;/p&gt;
&lt;p&gt;这样的简单操作并不多，主要围绕**主存、寄存器文件和ALU(算术逻辑单元)**进行。寄存器文件是一个小型存储设备，由一些单个字长的寄存器组成，ALU计算新的数据和地址值。CPU可能进行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载：从主存读取一个字到寄存器&lt;/li&gt;
&lt;li&gt;存储：从寄存器赋值一个字到主存&lt;/li&gt;
&lt;li&gt;操作：将两个寄存器的内容复制到ALU，ALU对两个字进行算术运算，将结果存放到一个寄存器中&lt;/li&gt;
&lt;li&gt;跳转：从指令本身抽取一个字，将这个字复制到PC中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令集架构：每条机器代码指令的效果&lt;/p&gt;
&lt;p&gt;微体系结构：处理器实际上是如何实现的&lt;/p&gt;
&lt;h3 id=&#34;运行hello程序&#34;&gt;运行hello程序&lt;/h3&gt;
&lt;p&gt;在键盘上输入&lt;code&gt;.\hello&lt;/code&gt;后，shell会将这些字符逐一读入寄存器，再将其存放到内存中。按下回车后，shell知道命令输入已经结束，将执行一系列指令加载hello文件，这些指令会将hello目标文件中的代码和数据从磁盘复制到主存，利用DMA(直接存储器存取)技术，可将数据不经过CPU直接从磁盘放入主存。&lt;/p&gt;
&lt;p&gt;目标文件hello被放入主存后，处理器就开始执行机器语言指令。&lt;/p&gt;
&lt;h2 id=&#34;高速缓存&#34;&gt;高速缓存&lt;/h2&gt;
&lt;p&gt;为了减少信息加载的时间，采用更小更快的存储设备作为数据或指令暂时的集结区域。处理器芯片上的L1高速缓存缓存的访问速度集合和访问寄存器文件一样快，容量更大的L2高速缓存通过特殊总线连接到寄处理器。高速缓存采用静态随机访问存储器（SRAM）技术实现。&lt;/p&gt;
&lt;h2 id=&#34;存储器层次&#34;&gt;存储器层次：&lt;/h2&gt;
&lt;p&gt;L0：寄存器&lt;/p&gt;
&lt;p&gt;L1：L1高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L2：L2高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L3：L3高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L4：主存（DRAM）&lt;/p&gt;
&lt;p&gt;L5：本地磁盘&lt;/p&gt;
&lt;p&gt;L6：远程存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%BE%E4%BE%8B.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图为我的电脑的三级缓存示意。&lt;/p&gt;
&lt;h2 id=&#34;操作系统管理硬件&#34;&gt;操作系统管理硬件&lt;/h2&gt;
&lt;p&gt;前面的shell程序和hello程序都依靠&lt;strong&gt;操作系统&lt;/strong&gt;提供的服务访问存储器。操作系统是应用程序和硬件之间的软件。&lt;/p&gt;
&lt;p&gt;操作系统的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;
&lt;li&gt;向应用程序提供简单的机制控制复杂又不同的低级硬件设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统通过几个基本抽象概念：进程、虚拟内存和文件实现这些功能。&lt;/p&gt;
&lt;p&gt;文件是对I/O设备的抽象。&lt;/p&gt;
&lt;p&gt;虚拟内存是对主存和磁盘I/O设备的抽象。&lt;/p&gt;
&lt;p&gt;进程是对处理器、主存和磁盘I/O设备的抽象。&lt;/p&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;p&gt;进程是操作系统对正在运行程序的一种抽象，一个系统可以同时运行多个进行，每个进程好像都在独占使用硬件。并发运行指的是多个不同程序进程指令交错运行。处理器通过在进程间切换来实现多个程序的并发运行，这种机制称为&lt;strong&gt;上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;操作系统保存跟踪进程运行所需要的所有状态信息，这种状态即为上下文。这些信息有很多，比如PC和寄存器文件的当前值。&lt;/p&gt;
&lt;p&gt;任何一个时刻，单处理器只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到新进程时，就会进行上下文切换。&lt;/p&gt;
&lt;p&gt;从一个进程到另一个进程的切换是操作系统内核（kernal）管理的。&lt;strong&gt;内核&lt;/strong&gt;是操作系统代码&lt;strong&gt;常驻主存&lt;/strong&gt;的部分。内核不是一个独立的进程，是系统管理全部进程所用的代码和数据结构的集合。&lt;/p&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;p&gt;一个进程可以有多个成为线程的执行单元组成，每个线程都运行在进程的上下文中，共享同样的代码和全部数据。多线程相比多进程更容易共享数据。&lt;/p&gt;
&lt;h3 id=&#34;虚拟内存&#34;&gt;虚拟内存&lt;/h3&gt;
&lt;p&gt;虚拟内存为每个进程提供一个假象，即每个进程都在&lt;strong&gt;独占地使用主存&lt;/strong&gt;。每个进程看到内存都是一致的，成为虚拟地址空间。&lt;/p&gt;
&lt;p&gt;每个进程看到的虚拟地址由大量准确定义的&lt;strong&gt;区&lt;/strong&gt;构成，每个区都有专门的功能。以下从最低的地址逐步向上介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序代码和数据：所有进程的代码是从同一固定地址开始，紧接着是和C全局变量对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。&lt;/li&gt;
&lt;li&gt;堆：当调用malloc和free这样的函数时，堆可以动态地扩展和收缩。&lt;/li&gt;
&lt;li&gt;共享库：是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。&lt;/li&gt;
&lt;li&gt;栈：编译器用它来实现函数调用，栈在程序执行期间可以动态扩展和收缩。&lt;/li&gt;
&lt;li&gt;内核虚拟内存：地址空间顶部区域是为内核保留的，不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;
&lt;p&gt;文件就是字节序列，系统所有输入输出都是通过使用一小组成为Unix I/O的系统函数调用读写文件实现的。&lt;/p&gt;
&lt;h2 id=&#34;系统之间利用网络通信&#34;&gt;系统之间利用网络通信&lt;/h2&gt;
&lt;p&gt;网络是一个I/O设备，通过网络适配器连接到系统总线。&lt;/p&gt;
&lt;h2 id=&#34;一些重要主题&#34;&gt;一些重要主题&lt;/h2&gt;
&lt;h3 id=&#34;并发和并行&#34;&gt;并发和并行&lt;/h3&gt;
&lt;p&gt;并发：一个同时具有多个活动的系统&lt;/p&gt;
&lt;p&gt;并行：用并发使得一个系统运行得更快&lt;/p&gt;
&lt;p&gt;并行可以在计算机系统的多个抽象层次上运行。&lt;/p&gt;
&lt;h4 id=&#34;线程级并发&#34;&gt;线程级并发&lt;/h4&gt;
&lt;h4 id=&#34;指令级并发&#34;&gt;指令级并发&lt;/h4&gt;
&lt;h4 id=&#34;单指令多数据并行&#34;&gt;单指令、多数据并行&lt;/h4&gt;
&lt;h3 id=&#34;计算机系统中抽象的重要性&#34;&gt;计算机系统中抽象的重要性&lt;/h3&gt;
&lt;p&gt;文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，进程是对正在运行程序的抽象，虚拟机提供对整个计算机的抽象。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>cs231n——1.Nearest Neighbor Classifier</title>
        <link>https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/</link>
        <pubDate>Wed, 09 Jun 2021 17:41:44 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/ -&lt;p&gt;图像分类规范化步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：输入带有不同标签的图像作为训练集&lt;/li&gt;
&lt;li&gt;学习：使用训练集学习每种类别的抽象特征&lt;/li&gt;
&lt;li&gt;评估：通过测试集评估分类器的质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nearest-neighbor-classifier&#34;&gt;Nearest Neighbor Classifier&lt;/h2&gt;
&lt;p&gt;CIFAR-10 dataset:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10 classes (airplane, automobile, bird, etc)&lt;/li&gt;
&lt;li&gt;60,000 tiny images that are 32 pixels high and wide&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k-NN通过将一张测试集图片与所有的训练集图片进行比较，预测结果。&lt;/p&gt;
&lt;h3 id=&#34;l1-distance&#34;&gt;L1 distance:&lt;/h3&gt;
&lt;p&gt;$$
d_{1}\left(I_{1}, I_{2}\right)=\sum_{p}\left|I_{1}^{p}-I_{2}^{p}\right|
$$&lt;/p&gt;
&lt;p&gt;将两张图片分别表示为$I_1, I_2$两个向量，使用L1距离来比较两张图片。&lt;/p&gt;
&lt;p&gt;通常使用准确率来评估分类器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;Xtr, Ytr, Xte, Yte &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; load_CIFAR10(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;data/cifar10/&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#888&#34;&gt;# a magic function we provide&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# flatten out all images to be one-dimensional&lt;/span&gt;
Xtr_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xtr&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;reshape(Xtr&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#888&#34;&gt;# Xtr_rows becomes 50000 x 3072&lt;/span&gt;
Xte_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xte&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;reshape(Xte&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#888&#34;&gt;# Xte_rows becomes 10000 x 3072&lt;/span&gt;

nn &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; NearestNeighbor() &lt;span style=&#34;color:#888&#34;&gt;# create a Nearest Neighbor classifier class&lt;/span&gt;
nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;train(Xtr_rows, Ytr) &lt;span style=&#34;color:#888&#34;&gt;# train the classifier on the training images and labels&lt;/span&gt;
Yte_predict &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;predict(Xte_rows) &lt;span style=&#34;color:#888&#34;&gt;# predict labels on the test images&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# and now print the classification accuracy, which is the average number&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# of examples that are correctly predicted (i.e. label matches)&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;accuracy: &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt; ( np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;mean(Yte_predict &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; Yte) )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here is an implementation of a simple Nearest Neighbor classifier with the L1 distance that satisfies this template:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;NearestNeighbor&lt;/span&gt;(&lt;span style=&#34;color:#007020&#34;&gt;object&lt;/span&gt;):
  &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; __init__(self):
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;pass&lt;/span&gt;

  &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;train&lt;/span&gt;(self, X, y):
    &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;#34;&amp;#34; X is N x D where each row is an example. Y is 1-dimension of size N &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;# the nearest neighbor classifier simply remembers all the training data&lt;/span&gt;
    self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;Xtr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X
    self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;ytr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y

  &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;predict&lt;/span&gt;(self, X):
    &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;#34;&amp;#34; X is N x D where each row is an example we wish to predict label for &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    num_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]	&lt;span style=&#34;color:#888&#34;&gt;#训练样本数量&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;# lets make sure that the output type matches the input type&lt;/span&gt;
    Ypred &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;zeros(num_test, dtype &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;ytr&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype)

    &lt;span style=&#34;color:#888&#34;&gt;# loop over all test rows&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;range&lt;/span&gt;(num_test):
      &lt;span style=&#34;color:#888&#34;&gt;# find the nearest training image to the i&amp;#39;th test image&lt;/span&gt;
      &lt;span style=&#34;color:#888&#34;&gt;# using the L1 distance (sum of absolute value differences)&lt;/span&gt;
      distances &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sum(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;abs(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;Xtr &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; X[i,:]), axis &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)
      min_index &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;argmin(distances) &lt;span style=&#34;color:#888&#34;&gt;# get the index with smallest distance&lt;/span&gt;
      Ypred[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;ytr[min_index] &lt;span style=&#34;color:#888&#34;&gt;# predict the label of the nearest example&lt;/span&gt;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; Ypred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用L1距离测试的准确率只有38.6%.&lt;/p&gt;
&lt;h3 id=&#34;l2-distance&#34;&gt;L2 distance&lt;/h3&gt;
&lt;p&gt;$$
d_{2}\left(I_{1}, I_{2}\right)=\sqrt{\sum_{p}\left(I_{1}^{p}-I_{2}^{p}\right)^{2}}
$$&lt;/p&gt;
&lt;p&gt;only replace a single line of code above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;distances &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sqrt(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sum(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;square(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;Xtr &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; X[i,:]), axis &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;k---nearest-neighbor-classifier&#34;&gt;k - Nearest Neighbor Classifier&lt;/h2&gt;
&lt;p&gt;找到距离最近的k个图片，k个图片中数量最多的一个标签即为测试图片所分的类别。&lt;/p&gt;
&lt;h2 id=&#34;validation-sets-for-hyperparameter-tuning&#34;&gt;Validation sets for Hyperparameter tuning&lt;/h2&gt;
&lt;p&gt;有很多我们可以选择的距离函数，例如L1 norm, L2 norm等，这些选择称为&lt;/p&gt;
&lt;p&gt;Hyperparameter 。通常不能使用test set来调整Hyperparameter。Evaluate on the test set only a single time, at the very end.&lt;/p&gt;
&lt;p&gt;将训练集划分为一个小一些的训练集和一个验证集(validation set)。例如使用CIFAR-10数据集时将训练集分为49,000个训练集和1,000个验证集。&lt;/p&gt;
&lt;p&gt;验证集本质上是一个假的测试集，是用来调整Hyperparameter的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# assume we have Xtr_rows, Ytr, Xte_rows, Yte as before&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# recall Xtr_rows is 50,000 x 3072 matrix&lt;/span&gt;
Xval_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xtr_rows[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;, :] &lt;span style=&#34;color:#888&#34;&gt;# take first 1000 for validation&lt;/span&gt;
Yval &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Ytr[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;]
Xtr_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xtr_rows[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;:, :] &lt;span style=&#34;color:#888&#34;&gt;# keep last 49,000 for train&lt;/span&gt;
Ytr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Ytr[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;:]

&lt;span style=&#34;color:#888&#34;&gt;# find hyperparameters that work best on the validation set&lt;/span&gt;
validation_accuracies &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;]:

  &lt;span style=&#34;color:#888&#34;&gt;# use a particular value of k and evaluation on validation data&lt;/span&gt;
  nn &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; NearestNeighbor()
  nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;train(Xtr_rows, Ytr)
  &lt;span style=&#34;color:#888&#34;&gt;# here we assume a modified NearestNeighbor class that can take a k as input&lt;/span&gt;
  Yval_predict &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;predict(Xval_rows, k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k)
  acc &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;mean(Yval_predict &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; Yval)
  &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;accuracy: &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt; (acc,)

  &lt;span style=&#34;color:#888&#34;&gt;# keep track of what works on the validation set&lt;/span&gt;
  validation_accuracies&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;append((k, acc))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cross-validation&#34;&gt;Cross-validation&lt;/h3&gt;
&lt;p&gt;当训练集数量较少时，使用更为复杂的交叉验证来调整hyperparameter。我们通过迭代不同的验证集并平均计算这些验证集的结果来确定k。例如在5次迭代的交叉验证中，将训练集分为5份，使用4份训练，1份验证，然后改变验证集，迭代5次，最终使用5次的平均结果确定k。&lt;/p&gt;
&lt;h2 id=&#34;nearest-neighbor-classifier的优缺点&#34;&gt;Nearest Neighbor classifier的优缺点&lt;/h2&gt;
&lt;p&gt;验证时的时间成本较高，每个验证样本都要与每一个测试集样本进行比较，效率较低。&lt;/p&gt;
&lt;p&gt;Nearest Neighbor classifier在低维度训练中较为常用，但在图像分类中很少用，因为图像是高维对象，高维对象之间的距离计算式违反直觉的。&lt;/p&gt;
&lt;h2 id=&#34;summery&#34;&gt;Summery&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果数据的维数很高，可以使用降维技术，例如PCA(主成分分析), NCA(邻域成分分析) or Random Projections(随机投影).&lt;/li&gt;
&lt;/ol&gt;
- https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Python基础和numpy</title>
        <link>https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</link>
        <pubDate>Sun, 06 Jun 2021 13:04:49 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/ -&lt;h2 id=&#34;basic-of-python&#34;&gt;Basic of Python&lt;/h2&gt;
&lt;h3 id=&#34;basic-data-types&#34;&gt;Basic data types&lt;/h3&gt;
&lt;h4 id=&#34;numbers&#34;&gt;Numbers&lt;/h4&gt;
&lt;h4 id=&#34;bolleans&#34;&gt;Bolleans&lt;/h4&gt;
&lt;h4 id=&#34;strings&#34;&gt;Strings&lt;/h4&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;h4 id=&#34;lists&#34;&gt;Lists&lt;/h4&gt;
&lt;h4 id=&#34;slicing&#34;&gt;Slicing&lt;/h4&gt;
&lt;h4 id=&#34;loops&#34;&gt;Loops&lt;/h4&gt;
&lt;h4 id=&#34;dictionaries&#34;&gt;Dictionaries&lt;/h4&gt;
&lt;p&gt;key-value&lt;/p&gt;
&lt;h4 id=&#34;sets&#34;&gt;Sets&lt;/h4&gt;
&lt;p&gt;unordered&lt;/p&gt;
&lt;h4 id=&#34;tuples&#34;&gt;Tuples&lt;/h4&gt;
&lt;p&gt;A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot.&lt;/p&gt;
&lt;h3 id=&#34;functions&#34;&gt;Functions&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt; keyword&lt;/p&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Greeter&lt;/span&gt;:

    &lt;span style=&#34;color:#888&#34;&gt;# Constructor&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; __init__(self, name):
        self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;name &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; name  &lt;span style=&#34;color:#888&#34;&gt;# Create an instance variable&lt;/span&gt;

    &lt;span style=&#34;color:#888&#34;&gt;# Instance method&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;greet&lt;/span&gt;(self, loud&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;False&lt;/span&gt;):
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; loud:
          &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;HELLO, &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;format(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;name&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;upper()))
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;:
          &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;!&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;format(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;name))

g &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Greeter(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Fred&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#888&#34;&gt;# Construct an instance of the Greeter class&lt;/span&gt;
g&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;greet()            &lt;span style=&#34;color:#888&#34;&gt;# Call an instance method; prints &amp;#34;Hello, Fred&amp;#34;&lt;/span&gt;
g&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;greet(loud&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;True&lt;/span&gt;)   &lt;span style=&#34;color:#888&#34;&gt;# Call an instance method; prints &amp;#34;HELLO, FRED!&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;numpy&#34;&gt;Numpy&lt;/h2&gt;
&lt;p&gt;Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.&lt;/p&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;p&gt;A numpy array is &lt;strong&gt;a grid of values&lt;/strong&gt;, all of the &lt;strong&gt;same type&lt;/strong&gt;, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.&lt;/p&gt;
&lt;h3 id=&#34;array-indexing&#34;&gt;Array indexing&lt;/h3&gt;
&lt;h4 id=&#34;slicing-1&#34;&gt;Slicing&lt;/h4&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

&lt;span style=&#34;color:#888&#34;&gt;# Create the following rank 2 array with shape (3, 4)&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# [[ 1  2  3  4]&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#  [ 5  6  7  8]&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#  [ 9 10 11 12]]&lt;/span&gt;
a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# Use slicing to pull out the subarray consisting of the first 2 rows&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# and columns 1 and 2; b is the following array of shape (2, 2):&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# [[2 3]&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#  [6 7]]&lt;/span&gt;
b &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;]
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Two ways of accessing the data in the middle row of the array. Mixing integer indexing with slices yields an array of lower rank, while using only slices yields an array of the same rank as the original array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;row_r1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, :]    &lt;span style=&#34;color:#888&#34;&gt;# Rank 1 view of the second row of a  &lt;/span&gt;
row_r2 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, :]  &lt;span style=&#34;color:#888&#34;&gt;# Rank 2 view of the second row of a&lt;/span&gt;
row_r3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;], :]  &lt;span style=&#34;color:#888&#34;&gt;# Rank 2 view of the second row of a&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(row_r1, row_r1&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape)
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(row_r2, row_r2&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape)
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(row_r3, row_r3&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;integer-array-indexing&#34;&gt;Integer array indexing&lt;/h4&gt;
&lt;p&gt;Integer array indexing allows you to construct arbitrary arrays using the data from another array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# An example of integer array indexing.&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# The returned array will have shape (3,) and &lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# The above example of integer array indexing is equivalent to this:&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;], a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;result:&lt;/p&gt;
&lt;p&gt;[1 4 5]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# When using integer array indexing, you can reuse the same&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# element from the source array:&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# Equivalent to the previous integer array indexing example&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;], a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;One useful trick with integer array indexing is selecting or mutating one element from each row of a matrix:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# Create a new array from which we will select elements&lt;/span&gt;
a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# Create an array of indices&lt;/span&gt;
b &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])

&lt;span style=&#34;color:#888&#34;&gt;# Select one element from each row of a using the indices in b&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;), b])  &lt;span style=&#34;color:#888&#34;&gt;# Prints &amp;#34;[ 1  6  7 11]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[1 6 7 11]&lt;/p&gt;
&lt;h4 id=&#34;boolean-array-indexing&#34;&gt;Boolean array indexing&lt;/h4&gt;
&lt;p&gt;Frequently this type of indexing is used to select the elements of an array that &lt;strong&gt;satisfy some condition&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;]])

bool_idx &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (a &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;)  &lt;span style=&#34;color:#888&#34;&gt;# Find the elements of a that are bigger than 2;&lt;/span&gt;
                    &lt;span style=&#34;color:#888&#34;&gt;# this returns a numpy array of Booleans of the same&lt;/span&gt;
                    &lt;span style=&#34;color:#888&#34;&gt;# shape as a, where each slot of bool_idx tells&lt;/span&gt;
                    &lt;span style=&#34;color:#888&#34;&gt;# whether that element of a is &amp;gt; 2.&lt;/span&gt;

&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(bool_idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[[False False]
[ True  True]
[ True  True]]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# We use boolean array indexing to construct a rank 1 array&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# consisting of the elements of a corresponding to the True values&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# of bool_idx&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[bool_idx])

&lt;span style=&#34;color:#888&#34;&gt;# We can do all of the above in a single concise statement:&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[a &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[3 4 5 6]
[3 4 5 6]&lt;/p&gt;
&lt;h3 id=&#34;datatypes&#34;&gt;Datatypes&lt;/h3&gt;
&lt;p&gt;Every numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;])  &lt;span style=&#34;color:#888&#34;&gt;# Let numpy choose the datatype&lt;/span&gt;
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;2.0&lt;/span&gt;])  &lt;span style=&#34;color:#888&#34;&gt;# Let numpy choose the datatype&lt;/span&gt;
z &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], dtype&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;int64)  &lt;span style=&#34;color:#888&#34;&gt;# Force a particular datatype&lt;/span&gt;

&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype, y&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype, z&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;array-math&#34;&gt;Array math&lt;/h3&gt;
&lt;p&gt;Note that unlike MATLAB, &lt;code&gt;*&lt;/code&gt; is elementwise multiplication, not matrix multiplication. We instead use the dot function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. dot is available both as a function in the numpy module and as an instance method of array objects:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;]], dtype&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;float64)
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;]], dtype&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;float64)

&lt;span style=&#34;color:#888&#34;&gt;# Elementwise product; both produce the array&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(x &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; y)
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;multiply(x, y))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[[ 5. 12.]
[21. 32.]]
[[ 5. 12.]
[21. 32.]]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;]])
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;]])

v &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;])
w &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;])

&lt;span style=&#34;color:#888&#34;&gt;# Inner product of vectors; both produce 219&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(v&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dot(w))
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dot(v, w))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;219
219&lt;/p&gt;
&lt;p&gt;You can also use the &lt;code&gt;@&lt;/code&gt; operator which is equivalent to numpy&amp;rsquo;s &lt;code&gt;dot&lt;/code&gt; operator.&lt;/p&gt;
&lt;p&gt;to transpose a matrix, simply use the T attribute of an array object:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;transpose&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;T)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;transpose
[[1 3]
[2 4]]&lt;/p&gt;
&lt;h3 id=&#34;broadcasting&#34;&gt;Broadcasting&lt;/h3&gt;
&lt;p&gt;Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations.&lt;/p&gt;
&lt;p&gt;For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# We will add the vector v to each row of the matrix x,&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# storing the result in the matrix y&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])
v &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;empty_like(x)   &lt;span style=&#34;color:#888&#34;&gt;# Create an empty matrix with the same shape as x&lt;/span&gt;

&lt;span style=&#34;color:#888&#34;&gt;# Add the vector v to each row of the matrix x with an explicit loop&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;range&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;):
    y[i, :] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x[i, :] &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; v

&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[[ 2  2  4]
[ 5  5  7]
[ 8  8 10]
[11 11 13]]&lt;/p&gt;
&lt;p&gt;Numpy broadcasting allows us to perform this computation without actually creating multiple copies of v. Consider this version, using broadcasting:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

&lt;span style=&#34;color:#888&#34;&gt;# We will add the vector v to each row of the matrix x,&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# storing the result in the matrix y&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])
v &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; v  &lt;span style=&#34;color:#888&#34;&gt;# Add v to each row of x using broadcasting&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The line &lt;code&gt;y = x + v&lt;/code&gt; works even though &lt;code&gt;x&lt;/code&gt; has shape &lt;code&gt;(4, 3)&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; has shape &lt;code&gt;(3,)&lt;/code&gt; due to broadcasting; this line works as if v actually had shape &lt;code&gt;(4, 3)&lt;/code&gt;, where each row was a copy of &lt;code&gt;v&lt;/code&gt;, and the sum was performed elementwise.&lt;/p&gt;
&lt;h2 id=&#34;matplotlib&#34;&gt;Matplotlib&lt;/h2&gt;
&lt;p&gt;Matplotlib is a plotting library. In this section give a brief introduction to the &lt;code&gt;matplotlib.pyplot&lt;/code&gt; module, which provides a plotting system similar to that of MATLAB.&lt;/p&gt;
&lt;h3 id=&#34;plotting&#34;&gt;Plotting&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;plt&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt;matplotlib inline
&lt;span style=&#34;color:#888&#34;&gt;# Compute the x and y coordinates for points on a sine curve&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;pi, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0.1&lt;/span&gt;)
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sin(x)

&lt;span style=&#34;color:#888&#34;&gt;# Plot the points using matplotlib&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;plot(x, y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;subplots&#34;&gt;Subplots&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# Compute the x and y coordinates for points on sine and cosine curves&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;pi, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0.1&lt;/span&gt;)
y_sin &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sin(x)
y_cos &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;cos(x)

&lt;span style=&#34;color:#888&#34;&gt;# Set up a subplot grid that has height 2 and width 1,&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# and set the first such subplot as active.&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;subplot(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)

&lt;span style=&#34;color:#888&#34;&gt;# Make the first plot&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;plot(x, y_sin)
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;title(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Sine&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#888&#34;&gt;# Set the second subplot as active, and make the second plot.&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;subplot(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;)
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;plot(x, y_cos)
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;title(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Cosine&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#888&#34;&gt;# Show the figure.&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>WLAN基本内容和802.11ax</title>
        <link>https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</link>
        <pubDate>Thu, 03 Jun 2021 18:09:38 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/ -&lt;h2 id=&#34;wlan基础内容&#34;&gt;WLAN基础内容&lt;/h2&gt;
&lt;h3 id=&#34;计算机网络概念&#34;&gt;计算机网络概念&lt;/h3&gt;
&lt;p&gt;在学习基本无线网络通信的过程中顺便可以来复习以下计算机网络的相关内容。&lt;/p&gt;
&lt;p&gt;在家庭中我们通常使用路由器联通家中的局域网和外部的广域网，路由器为网络层设备，通过IP和路由表来寻找目的地和转发数据，即为路由功能。&lt;/p&gt;
&lt;p&gt;交换机是数据链路层设备，通过用于在局域网内传输数据，通过MAC地址寻找目的地，数据转发通过硬件来实现，传输速度相较于上一层网络层有很大的性能提升。每个物理设备都具有一个唯一的MAC地址。&lt;/p&gt;
&lt;p&gt;路由器和交换机的不同在于，一个工作在网络层，另一个工作在数据链路层，交换机连接的网络必须使用相同的数据链路层协议，一般即为&lt;strong&gt;802.3(以太网)或802.11(无线局域网)&lt;/strong&gt;。路由器工作在网络层，因此路由器连接的网络必须使用相同的网路层协议，一般为&lt;strong&gt;ip协议&lt;/strong&gt;，但路由器可以连接不同的数据链路层，比如eth2和pppoe，eth2和802.11。&lt;/p&gt;
&lt;p&gt;我们常用的每台终端都有一个MAC地址（即网卡地址），在连接网络后路由器会为其分配一个IP；而一个路由器也拥有一个MAC地址和一个IP。交换机中只有MAC地址表，通过设备的MAC地址来确定数据的目的地。&lt;/p&gt;
&lt;h3 id=&#34;无线局域网&#34;&gt;无线局域网&lt;/h3&gt;
&lt;p&gt;WLAN即为Wireless LAN，无线局域网。无线局域网通用的标准是IEEE定义的802.11系列标准，目前共有六代（2021年），为802.11a/b/g/n/ac/ax，分别从第一代到第六代。&lt;/p&gt;
&lt;p&gt;Wi-Fi称为无线网络，是Wi-Fi联盟的商标，是基于802.11标准实现的无线局域网技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IEEE 802.11标准&lt;/strong&gt;定义了一个媒体访问控制(MAC，即&lt;strong&gt;数据链路层&lt;/strong&gt;协议)和几个&lt;strong&gt;物理层&lt;/strong&gt;规范，为局域内的终端提供无线连接，同时还为监管机构提供了一种标准化方法，对局域网通信的一个或多个&lt;strong&gt;频带&lt;/strong&gt;进行管理。&lt;/p&gt;
&lt;h3 id=&#34;24ghz和5ghz&#34;&gt;2.4GHz和5GHz&lt;/h3&gt;
&lt;p&gt;2.4GHz频道列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频道&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频率 (MHz)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大部分国家&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2412&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2417&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2422&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2427&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2432&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2437&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2442&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2447&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2452&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2457&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2462&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2467&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2472&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;14&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2484&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;5GHz频道列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频道&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频率 (MHz)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;中国&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40/20 MHz[&lt;a href=&#34;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#cite_note-15&#34;&gt;15]&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40/20 MHz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20 MHz[&lt;a href=&#34;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#cite_note-israel-19&#34;&gt;19]&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;183&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4915&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;184&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4920&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;185&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4925&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;187&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4935&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;188&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4940&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;189&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4945&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;192&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4960&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;196&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4980&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5035&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5040&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5045&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5055&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5060&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5080&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;34&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5170&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5180&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;38&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5190&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5200&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;42&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5210&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;44&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5220&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;46&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5230&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;48&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5240&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;52&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5260&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;56&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5280&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;60&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5300&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5320&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5500&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;104&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5520&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;108&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5540&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;112&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5560&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;116&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5580&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5600&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;124&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5620&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5640&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;132&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5660&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;136&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5680&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;140&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5700&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;149&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5745&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;153&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5765&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;157&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5785&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;161&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5805&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;165&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5825&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;wifi-680211ax&#34;&gt;WiFi 6——802.11ax&lt;/h2&gt;
&lt;p&gt;IEEE 802.11ax为无线局域网标准，Wi-Fi联盟称之为Wi-Fi 6。其支持从1GHz到6GHz的所有ISM频段，包括目前使用的2.4GHz和5GHz频段，向下兼容前代的a/b/g/n/ac。&lt;/p&gt;
&lt;p&gt;主要有以下的先进功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正交频分多址（OFDMA）&lt;/li&gt;
&lt;li&gt;多用户多输入多输出（MU-MIMO）&lt;/li&gt;
&lt;li&gt;160MHz信道（这并不是802.11ax才出现的，在5GHz下即可实现160MHz的带宽）&lt;/li&gt;
&lt;li&gt;1024正交幅度调制（1024-QAM）&lt;/li&gt;
&lt;li&gt;目标唤醒时间（TWT）&lt;/li&gt;
&lt;li&gt;WPA3安全标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过整机终端的传输速率来理解这些特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整机速率=空间流数 * (1/Symbol+GI) * 编码方式 * 码率 * 有效子载波数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间流数：AP的天线数&lt;/li&gt;
&lt;li&gt;Symbol与GI：时域上每一帧需要的时间以及空隙&lt;/li&gt;
&lt;li&gt;编码方式：调制技术，即1个Symbol能承载的bit数量。&lt;/li&gt;
&lt;li&gt;码率：排除纠错码后世纪真实传输数据码占理论值的比值&lt;/li&gt;
&lt;li&gt;有效子载波数量：频域上的Symbol，一个子载波承载余个Symbol，例如频宽为HT80时，有效子载波数量为980个；频宽为HT160时，有效子载波数为980*2个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;频分复用技术&#34;&gt;频分复用技术：&lt;/h3&gt;
&lt;p&gt;将子载波分配给不同用户，并在OFDM中添加多址的方法来实现多用户复用信道资源。&lt;/p&gt;
&lt;h3 id=&#34;mu-mimo技术&#34;&gt;MU-MIMO技术：&lt;/h3&gt;
&lt;p&gt;多天线技术，能提高用户容量，每个用户速率更快。&lt;/p&gt;
&lt;h4 id=&#34;dl-mu-mimo&#34;&gt;DL MU-MIMO&lt;/h4&gt;
&lt;p&gt;DL MU-MIMO在802.11ac就已经引入，但只支持DL 4*4 MU-MIMO（下行）。在802.11ax种进一步增加了MU-MIMO数量，支持DL 8x8 MU-MIMO，借助 DL OFDMA技术（下行），可同时进行 MU-MIMO 传输和分配不同 RU 进行多用户多址传输，既增加了系统并发接入量，又均衡了吞吐量。&lt;/p&gt;
&lt;h4 id=&#34;ul-mu-mimo&#34;&gt;UL MU-MIMO&lt;/h4&gt;
&lt;p&gt;UL MU-MIMO（上行）是802.11ax引入的一个重要特性，与下载的SU-MIMO概念类型，都是通过发射机和接收机的多天线技术使用相同信道资源在多个空间流上同时传输数据，唯一的差别点在于 UL MU-MIMO 的多个数据流是来自多个用户。&lt;/p&gt;
&lt;p&gt;802.11ac 及之前的 802.11 标准都是 UL SU-MIMO，即只能接受一个用户发来的数据，多用户并发场景效率较低，802.11ax 支持 UL MU-MIMO 后，借助 UL OFDMA 技术 （上行），可同时进行 MU-MIMO 传输和分配不同 RU 进行多用户多址传输，提升多用户并发场景效率，大大降低了应用时延。&lt;/p&gt;
&lt;h3 id=&#34;更高阶的调制技术1024-qam&#34;&gt;更高阶的调制技术(1024-QAM)：&lt;/h3&gt;
&lt;p&gt;802.11ac 采用的 256-QAM 正交幅度调制，每个符号传输 8bit 数据（2^8=256），802.11ax 将采用 1024-QAM 正交幅度调制，每个符号位传输 10bit 数据（2^10=1024）。&lt;/p&gt;
&lt;p&gt;需要注意的是 802.11ax 中成功使用 1024-QAM 调制取决于信道条件，更密的星座点距离需要更强大的 EVM（误差矢量幅度，用于量化无线电接收器或发射器在调制精度方面的性能）和接受灵敏度功能，并且信道质量要求高于其他调制类型。&lt;/p&gt;
&lt;h3 id=&#34;srbss-coloring&#34;&gt;SR&amp;amp;BSS Coloring&lt;/h3&gt;
&lt;h4 id=&#34;空分复用技术sr&#34;&gt;空分复用技术（SR）&lt;/h4&gt;
&lt;p&gt;Wi-Fi 射频的传输原理是在任何指定时间内，一个信道上只允许一个用户传输数据，如果 Wi-Fi AP 和客户端在同一信道上侦听到有其他 802.11 无线电传输，则会自动进行冲突避免，推迟传输，因此每个用户都必须轮流使用。所以说信道是无线网络中非常宝贵的资源， 特别在高密场景下，信道的合理划分和利用将对整个无线网络的容量和稳定性带来较大的影响。&lt;/p&gt;
&lt;p&gt;802.11ac 及之前的标准，通常采用动态调整 CCA 门限的机制来改善同频信道间的干扰，通过识别同频干扰强度，动态调整 CCA 门限，忽略同频弱干扰信号实现同频并发传输， 提升系统吞吐容量。&lt;/p&gt;
&lt;p&gt;802.11ax 中引入了一种新的同频传输识别机制，叫 BSS Coloring 着色机制，在 PHY 报文头中添加 BSS color 字段对来自不同BSS 的数据进行“染色”，为每个通道分配一种颜色，该颜色标识一组不应干扰的基本服务集（BSS），接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一 BSS 内的干扰信号， 发送将推迟；如果颜色不同，则认为两者之间无干扰，两个 Wi-Fi 设备可同信道同频并行传输。以这种方式设计的网络，那些具有相同颜色的信道彼此相距很远，此时我们再利用动态CCA 机制将这种信号设置为不敏感，事实上它们之间也不太可能会相互干扰。&lt;/p&gt;
&lt;h4 id=&#34;bss-coloring着色机制&#34;&gt;BSS Coloring着色机制&lt;/h4&gt;
&lt;p&gt;802.11ax 中引入了一种新的同频传输识别机制，叫 BSS Coloring 着色机制，在 PHY 报文头中添加 BSS color 字段对来自不同BSS 的数据进行“染色”，为每个通道分配一种颜色，该颜色标识一组不应干扰的基本服务集（BSS），接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一 BSS 内的干扰信号， 发送将推迟；如果颜色不同，则认为两者之间无干扰，两个 Wi-Fi 设备可同信道同频并行传输。以这种方式设计的网络，那些具有相同颜色的信道彼此相距很远，此时我们再利用动态CCA 机制将这种信号设置为不敏感，事实上它们之间也不太可能会相互干扰。&lt;/p&gt;
&lt;h3 id=&#34;扩展覆盖范围er&#34;&gt;扩展覆盖范围（ER）&lt;/h3&gt;
&lt;p&gt;由于 802.11ax 标准采用的是Long OFDM symbol 发送机制，每次数据发送持续时间从原来的 3.2us 提升到 12.8us，更长的发送时间可降低终端丢包率；另外 802.11ax 最小可仅使用 2MHz 频宽进行窄带传输，有效降低频段噪声干扰，提升了终端接受灵敏度，增加了覆盖距离。&lt;/p&gt;
&lt;h3 id=&#34;其他特性&#34;&gt;其他特性&lt;/h3&gt;
&lt;h4 id=&#34;支持24ghz&#34;&gt;支持2.4GHz&lt;/h4&gt;
&lt;p&gt;2.4GHz 频宽窄，且仅有 3 个 20MHz 的互不干扰信道（1,6 和 11），但是有一点不可否认的是 2.4GHz 仍然是一个可用的 Wi-Fi 频段，在很多场景下依然被广泛使用，主要有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;覆盖范围广&lt;/strong&gt;：信号频率越低， 波长越长，绕射能力越强，穿透能力越差，信号损失衰减越小，传输距离越远。虽然 5GHz 频段可带来更高的传播速度，但信号衰减也越大，所以传输距离比 2.4GHz 要短。&lt;/li&gt;
&lt;li&gt;低成本&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;目标唤醒时间&#34;&gt;目标唤醒时间&lt;/h4&gt;
&lt;p&gt;802.11ax AP 可以和 STA 协调目标唤醒时间(TWT)功能的使用，AP 和 STA 会互相交换信息，当中将包含预计的活动持续时间，以定义让 STA 访问介质的特定时间或一组时间， 这样就可以避开多个不同 STA 之间的竞争和重叠情况。另外，支持 802.11ax 标准的 STA 可以使用 TWT 来降低能量损耗，在自身的 TWT 来临之前进入睡眠状态。AP 还可另外设定 TWT编排计划并将 TWT 值提供给 STA，这样双方之间就不需要存在个别的 TWT 协议，此操作称为“广播 TWT 操作”。&lt;/p&gt;
&lt;h2 id=&#34;家庭无线网络配置&#34;&gt;家庭无线网络配置&lt;/h2&gt;
&lt;h3 id=&#34;acap&#34;&gt;AC+AP&lt;/h3&gt;
&lt;h3 id=&#34;mesh组网&#34;&gt;MESH组网&lt;/h3&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://e.huawei.com/cn/material/networking/wlan/b3f46485597c4d72b43a6a27c6480646&#34;&gt;华为Wi-Fi 6(802.11ax)技术白皮书&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/IEEE_802.11ax&#34;&gt;wikipedia IEEE 802.11ax&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#5_GHz_(802.11a/h/j/n/ac/ax)%5B11%5D&#34;&gt;wikipedia WLAN信道列表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;- https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 