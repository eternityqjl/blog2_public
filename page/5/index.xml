<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sun, 17 Jul 2022 13:32:48 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>计算机网络学习日志（五）——链路层</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
        <pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ -&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;将运行链路层协议的设备称为&lt;strong&gt;节点&lt;/strong&gt;，把沿通信链路连接相邻节点的通信信道称为&lt;strong&gt;链路&lt;/strong&gt;。经过特定链路时，节点将数据包封装在&lt;strong&gt;链路层帧&lt;/strong&gt;中，将该帧传送到链路中。&lt;/p&gt;
&lt;p&gt;链路层提供的服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;成帧&lt;/strong&gt;：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路接入&lt;/strong&gt;：**媒体访问控制协议(MAC)**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠交付&lt;/strong&gt;：链路层通过&lt;em&gt;确认和重传&lt;/em&gt;提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;差错检验和纠正&lt;/strong&gt;：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链路层协议的实现位置：&lt;strong&gt;网络适配器&lt;/strong&gt;（也成为网卡）来实现。&lt;/p&gt;
&lt;h2 id=&#34;差错检测和纠正技术&#34;&gt;差错检测和纠正技术&lt;/h2&gt;
&lt;p&gt;差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。&lt;/p&gt;
&lt;p&gt;这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。&lt;/p&gt;
&lt;h3 id=&#34;奇偶校验&#34;&gt;奇偶校验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;单个奇偶校验位&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/oneByteEvenParity.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为&lt;strong&gt;50%&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二维奇偶校验&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/twoDEvenParity.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;接收方&lt;/strong&gt;检测和纠正差错的能力被称为&lt;strong&gt;前向纠错（Forward Error Correction，FEC）&lt;/strong&gt;。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。&lt;/p&gt;
&lt;h3 id=&#34;检验和&#34;&gt;检验和&lt;/h3&gt;
&lt;p&gt;将d比特数据当作一个k比特的整数序列处理。&lt;strong&gt;因特网检验和&lt;/strong&gt;是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果&lt;em&gt;是否全为1比特&lt;/em&gt;来检验。如果这些比特中存在0比特，则出现差错。&lt;/p&gt;
&lt;p&gt;检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。&lt;/p&gt;
&lt;h3 id=&#34;循环冗余检测crc&#34;&gt;循环冗余检测（CRC）&lt;/h3&gt;
&lt;p&gt;冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。&lt;/p&gt;
&lt;p&gt;考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为&lt;strong&gt;G&lt;/strong&gt;。我们要求G的最高位有效比特为1.&lt;/p&gt;
&lt;p&gt;对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。&lt;/p&gt;
&lt;p&gt;用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。&lt;/p&gt;
&lt;h2 id=&#34;多路访问链路和协议&#34;&gt;多路访问链路和协议&lt;/h2&gt;
&lt;p&gt;网络链路的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。&lt;/li&gt;
&lt;li&gt;广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。&lt;/p&gt;
&lt;p&gt;因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。&lt;/p&gt;
&lt;p&gt;我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。&lt;/p&gt;
&lt;h3 id=&#34;信道划分协议&#34;&gt;信道划分协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;时分多路复用（TDM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设一个支持N个节点的信道传输速率为R bps。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/TDM.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDM将时间划分为&lt;strong&gt;时间帧（Frame）&lt;/strong&gt;，并进一步把每个时间帧划分为N个&lt;strong&gt;时隙（slot）&lt;/strong&gt;，把每个时隙分配给N个节点中的一个。&lt;/li&gt;
&lt;li&gt;无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。&lt;/li&gt;
&lt;li&gt;TDM消除了碰撞且非常公平，但存在以下缺点：
&lt;ul&gt;
&lt;li&gt;节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。&lt;/li&gt;
&lt;li&gt;节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;频分多路复用（FDM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/FDM.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FDM将R bps信道划分为不同频段，每个频段有R/N带宽，并把每个频率分配给N个节点中的一个。&lt;/li&gt;
&lt;li&gt;与TDM有相同的优点和缺点：
&lt;ul&gt;
&lt;li&gt;避免了碰撞，公平划分了带宽，但每个节点只能使用R/N的带宽，即使它是唯一一个有分组发送的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;码分多址（CDMA）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码分多址（Code Division Multiple Access）对每个节点分配一种不同的&lt;strong&gt;编码&lt;/strong&gt;，每个节点用其&lt;strong&gt;唯一的编码&lt;/strong&gt;来对发送的数据进行编码，CMDA有一种特性，即不同的节点能同时传输，并且各自的接收方仍能正确接受发送方编码的数据比特，而不在乎其他节点的干扰传输。&lt;/p&gt;
&lt;h3 id=&#34;随机接入协议&#34;&gt;随机接入协议&lt;/h3&gt;
&lt;p&gt;随机接入协议中，每个传输节点总以&lt;strong&gt;信道的全部速率&lt;/strong&gt;发送，当有碰撞时，涉及碰撞的每个节点重复发送它的帧，直到该帧无碰撞地通过。当一个节点经历一次碰撞时，不必重发该帧，在重发前等待一个&lt;strong&gt;随机时延&lt;/strong&gt;，涉及碰撞的每个节点独立地选择随机时延。&lt;/p&gt;
&lt;p&gt;以下为一些最常用的随机接入协议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时隙ALOHA&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;假设条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有帧由L比特组成。&lt;/li&gt;
&lt;li&gt;时间被划分为L/R秒的时隙。&lt;/li&gt;
&lt;li&gt;节点只在时隙起点开始传输帧。&lt;/li&gt;
&lt;li&gt;节点是同步的，每个节点都知道时隙何时开始。&lt;/li&gt;
&lt;li&gt;如果一个时隙中有两个或多个帧碰撞，则所有节点在该时隙结束前检测到该碰撞事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另p为一个概率，即一个在0和1之间的数，在每个节点中，时隙ALOHA的操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传送它。&lt;/li&gt;
&lt;li&gt;若没有碰撞，则节点成功传送帧，无需重传。&lt;/li&gt;
&lt;li&gt;若有碰撞，则该节点在时隙结束前检测到该碰撞，以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当具有多个活跃节点时，经计算，该协议的&lt;strong&gt;最大效率仅为37%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具有碰撞检测的载波侦听多路访问（CSMA/CD）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;载波侦听：一个节点在传输前先听信道；如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。&lt;/li&gt;
&lt;li&gt;碰撞检测：当一个传输节点传输时一直在侦听此信道，如果它检测到另一个节点正在传输干扰帧，它就停止传输。在重复“侦听-当空闲时传输”循环之前等待一段随机时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;轮流协议&#34;&gt;轮流协议&lt;/h3&gt;
&lt;p&gt;轮流协议能够实现当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轮询协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有节点之一指定为&lt;strong&gt;主节点&lt;/strong&gt;，主节点以循环的方式&lt;strong&gt;轮询&lt;/strong&gt;每个节点。例如，主节点向节点1发送一个报文，告诉它能够传输的帧的最多数量，在节点1传输了一些帧后，主节点告诉节点2它能传输的帧的最多数量。以此循环的方式轮询每个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;令牌传递协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该协议中没有主节点，有一个称为**令牌(token)**的小的特殊帧在节点间以某种固定次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时才持有这个令牌，否则它立即向下一个节点转发该令牌。令牌传递是分散的，有很高的效率。&lt;/p&gt;
&lt;h2 id=&#34;交换局域网&#34;&gt;交换局域网&lt;/h2&gt;
&lt;h3 id=&#34;链路层寻址和地址解析协议arp&#34;&gt;链路层寻址和地址解析协议（ARP）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;链路层地址在主机或路由器的**适配器(网络接口)**中，所以具有多个网络接口的主机和路由器将有与之相关联的多个链路层地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路层交换机&lt;/strong&gt;并不具有与他们的接口相关联的链路层地址，因为链路层交换机的任务是在&lt;strong&gt;主机与路由器之间承载数据报&lt;/strong&gt;，主机或路由器不必将帧寻址到其之间的交换机，交换机透明地执行该项任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的适配器都有不同的MAC地址，这由IEEE来分配管理。&lt;/p&gt;
&lt;p&gt;某适配器要向目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插入帧中，将该帧发送到局域网中；当适配器接收到一个MAC地址时将其与自己的MAC地址进行比较，检查是否匹配，如果匹配则提取出封装的数据包并沿协议栈向上传送，如果不匹配则丢弃该帧。&lt;/p&gt;
&lt;p&gt;有时发送适配器要让局域网中&lt;strong&gt;所有其他适配器&lt;/strong&gt;接受并处理他发送的帧，发送适配器在该帧的目的地址字段插入一个特殊MAC&lt;strong&gt;广播地址&lt;/strong&gt;，对于使用6字节地址的局域网来说，广播地址为48个1组成的字符串，即以16进制表示为&lt;strong&gt;FF-FF-FF-FF-FF-FF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址解析协议（ARP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARP是用来转换网络层&lt;strong&gt;IP地址&lt;/strong&gt;和链路层&lt;strong&gt;MAC地址&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;假设发送主机要向目的主机发送IP数据报，源要向其适配器提供数据报和目的主机的MAC地址，此后源适配器才构造一个包含目的MAC地址的帧发送到局域网中。&lt;/p&gt;
&lt;p&gt;发送主机使用ARP确定目的主机IP地址对应的MAC地址。发送主机向其ARP模块发送目的主机的IP，ARP将IP解析为一个MAC地址。&lt;/p&gt;
&lt;p&gt;每台主机或路由器的内存中有一个&lt;strong&gt;ARP表&lt;/strong&gt;，该表包含了IP地址到MAC地址的映射关系。
&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/ARP%E8%A1%A8.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果发送方ARP表中&lt;strong&gt;没有目的主机的表项&lt;/strong&gt;，则发送方构造一个&lt;strong&gt;ARP分组&lt;/strong&gt;（分组包括发送和接收IP地址以及MAC地址），并指示适配器用&lt;strong&gt;MAC广播地址&lt;/strong&gt;来发送这个分组，适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将帧传送进入子网，包含该ARP查询的帧能够被子网中的&lt;strong&gt;所有其他适配器&lt;/strong&gt;接收到，每个适配器都把该分组向上传递给ARP模块，ARP模块检查其IP地址是否与ARP分组中的目的IP匹配，若匹配则给查询主机发送回一个带有所希望映射的响应ARP分组，然后查询主机更新它的ARP表，然后发送它的IP数据报。&lt;/p&gt;
&lt;p&gt;查询ARP报文是在&lt;strong&gt;广播帧&lt;/strong&gt;中发送的，响应ARP报文是在一个&lt;strong&gt;标准帧&lt;/strong&gt;中发送的。&lt;/p&gt;
&lt;p&gt;最好把ARP看成跨越链路层和网络层边界两边的协议，因为其既包含IP地址又包含MAC地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送数据报到子网以外&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从一个子网将数据包发送到路由器，在从路由器发送到下一个子网的目的适配器，中间需要经过路由器的两个适配器，其中查询MAC地址的过程都是通过ARP来实现的。&lt;/p&gt;
&lt;h3 id=&#34;以太网&#34;&gt;以太网&lt;/h3&gt;
&lt;p&gt;一种广泛部署的有线局域网。&lt;/p&gt;
&lt;p&gt;以太网的安装使用星形拓扑结构，位于中心的是交换机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网帧结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/Ethernet_frame_structure.PNG&#34; alt=&#34;以太网帧结构&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data(数据字段)&lt;/strong&gt;：46-1500字节，这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节，如果IP数据报超过1500字节，主机就要将该数据报分片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dest. address(目的地址)&lt;/strong&gt;：6字节，包含了目的适配器的MAC地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source address(源地址)&lt;/strong&gt;：6字节，包含了传输该帧到局域网上的适配器的MAC地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tyep(类型字段)&lt;/strong&gt;：2字节，类型字段允许以太网复用多种网络协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRC&lt;/strong&gt;：4字节，使接收适配器检测帧中是否引入了差错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Preamble(前同步码)&lt;/strong&gt;：8字节，前7字节的值都是10101010；最后一个字节是10101011。前同步码的前7字节用于唤醒接收适配器，将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特（第一个出现的两个连续的1）警告接收适配器，重要的内容就要来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以太网技术都向网络层提供&lt;strong&gt;无连接&lt;/strong&gt;服务。当适配器A向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并把帧发送到局域网上，没有先与适配器B握手。&lt;/p&gt;
&lt;p&gt;以太网技术都向网络层提供&lt;strong&gt;不可靠&lt;/strong&gt;服务。当适配器B收到来自适配器A的一个帧时，对该帧执行CRC校验，但当该帧通过CRC校验时不发送确认帧，当该帧没有通过CRC校验时也不发送否定确认帧。当某帧没有通过CRC校验时适配器B只是丢弃该帧，A并不知道它传输的帧是否到达B且通过校验，意味着传递到网络层的数据报流有间隙。&lt;/p&gt;
&lt;p&gt;丢弃以太网帧后存在了间隙，主机B上的应用可以通过运输层看到这个间隙。当使用UDP协议时，B中的应用会看到这个间隙；当使用TCP协议时，B中的TCP将不会确认包含在丢弃帧中的数据，从而引起主机A的TCP重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网技术的发展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同速率的以太网：10BASE-T、10BASE-2、100BASE-T、1000BASE-LX和10GBASE-T；第一部分数字代表该标准的速率：10、100、1000、10G；BASE指基带以太网，意味着物理媒体仅承载以太网流量；最后一部分指代物理媒介本身，T指双绞铜线。这些技术指标已经被IEEE 802.3 CSMA/CD标准化。&lt;/p&gt;
&lt;h3 id=&#34;链路层交换机&#34;&gt;链路层交换机&lt;/h3&gt;
&lt;p&gt;交换机的任务是接收入链路层帧并将它们转发到出链路。交换机对子网的主机和路由器是&lt;strong&gt;透明&lt;/strong&gt;的，某主机/路由器向另一个主机/路由器寻址一个帧，顺利地将该帧发送进局域网，并不知道交换机将会接收帧并将它转发到另一个节点。交换机的输出接口设有&lt;strong&gt;缓存&lt;/strong&gt;，防止输入输出链路速率存在差别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换机转发和过滤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤：决定一个帧应该转发到某个接口还是应当将其丢弃。&lt;/li&gt;
&lt;li&gt;转发：决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交换机的过滤和转发借助于&lt;strong&gt;交换机表&lt;/strong&gt;完成。交换机表包含某局域网上某些主机和路由器的表项。&lt;/p&gt;
&lt;p&gt;一个表项包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个MAC地址&lt;/li&gt;
&lt;li&gt;通向该MAC地址的交换机接口&lt;/li&gt;
&lt;li&gt;表项放置在表中的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当交换机的表是完整的时，无需任何广播就向着目的地转发帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交换机的表是自动、动态和自治地建立的，这种能力通过以下方式实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机表初始为空&lt;/li&gt;
&lt;li&gt;对于在接口接收到的每个入帧，该交换机在其表中存储：该帧源地址字段的MAC地址，该帧的到达接口，当前时间。&lt;/li&gt;
&lt;li&gt;如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交换机是&lt;strong&gt;即插即用设备&lt;/strong&gt;，它们不需要网络管理员或用户的干预，也是双工的，可以同时发送和接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路层交换机的性质&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除碰撞：交换机缓存帧并且不会在网段上同时传输多余一个帧。&lt;/li&gt;
&lt;li&gt;异质的链路：交换机将链路彼此隔离，因此局域网中的不同链路能够以不同速率运行并且能够在不同媒体上运行。&lt;/li&gt;
&lt;li&gt;管理：易于进行网络管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟局域网vlan&#34;&gt;虚拟局域网（VLAN）&lt;/h3&gt;
&lt;p&gt;能够限制局域网广播流量；可以将交换机拆分，提高使用效率；能够更加方便地管理用户。&lt;/p&gt;
&lt;p&gt;不同VLAN之间需要通过路由器进行通信，因为VLAN将不同VLAN相互阻隔，一个VLAN中的设备无法直接通过目的MAC地址直接找到目的主机，而是需要通过路由器通过上层的IP进行查找。&lt;/p&gt;
&lt;h2 id=&#34;数据中心网络&#34;&gt;数据中心网络&lt;/h2&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Linux基础知识</title>
        <link>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <pubDate>Thu, 29 Jul 2021 08:44:21 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ -&lt;h2 id=&#34;系统启动过程&#34;&gt;系统启动过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内核的引导：BIOS开机自检，然后读入/boot目录的内核文件&lt;/li&gt;
&lt;li&gt;运行init：init进程是所有进程的起点，运行级别确定&lt;/li&gt;
&lt;li&gt;系统初始化：&lt;code&gt;rc.sysinit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建立终端&lt;/li&gt;
&lt;li&gt;用户登录系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统目录结构&#34;&gt;系统目录结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;：bin是二进制文件的缩写，存放着最常用的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/boot&lt;/code&gt;：存放启动时的核心文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt;：dev是Device的缩写，存放Linux的外部设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt;：Etcetera的缩写，用来存放所有系统管理所需的配置文件和子目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/home&lt;/code&gt;：主目录，Linux中，每个用户都有一个自己的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib&lt;/code&gt;：Library的缩写，存放着系统最基本的动态连接共享库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/media&lt;/code&gt;：自动识别一些设备，将其挂载到这个目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt;：该目录为了让用户临时挂载别的文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/opt&lt;/code&gt;：optional的缩写，给主机额外安装软件所设置的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc&lt;/code&gt;：Processes进程的缩写，是一种虚拟文件系统，存放着当前内核运行状态的一系列特殊文件。该目录不再硬盘上，而是在内存中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/root&lt;/code&gt;：系统管理员主目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt;：temporary的缩写，用来存放临时目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt;：unix shared resources共享资源的缩写，用户的很多应用程序和文件存放于此，类似于windows下的program files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/bin&lt;/code&gt;：系统用户使用的应用程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/src&lt;/code&gt;：内核源代码默认的存放目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var&lt;/code&gt;：variable的缩写，存放着不断扩充着的东西，将经常被修改的目录放在这个目录下，包括各种日志文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件基本属性&#34;&gt;文件基本属性&lt;/h2&gt;
&lt;p&gt;Linux系统是一种多用户系统，不同用户有不同权限。&lt;/p&gt;
&lt;p&gt;通常使用以下命令来修文件和目录的权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chown(change ownerp)：修改所属用户与组&lt;/li&gt;
&lt;li&gt;chmod(change mode)：修改用户的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Linux中使用&lt;code&gt;ll&lt;/code&gt;或&lt;code&gt;ls -l&lt;/code&gt;来显示一个文件的属性以及文件所属的用户和组。&lt;/p&gt;
&lt;p&gt;第一个字符代表这个文件的类型，是目录、文件或连接文件等等：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;d&lt;/code&gt;为目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt;为文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;l&lt;/code&gt;为链接文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;为可存储的接口设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt;为串行端口设备&lt;/p&gt;
&lt;p&gt;接下来的字符以三个为一组，为&lt;code&gt;rwx&lt;/code&gt;三个参数的组合，&lt;code&gt;r&lt;/code&gt;代表可读，&lt;code&gt;w&lt;/code&gt;代表可写，&lt;code&gt;x&lt;/code&gt;代表可执行，从前到后分别代表user、group、everyone的权限，如果没有权限，则用&lt;code&gt;-&lt;/code&gt;表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于root用户，文件权限不起作用。&lt;/p&gt;
&lt;h3 id=&#34;chgrp改变文件属组&#34;&gt;chgrp：改变文件属组&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chgrp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-R&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属组名 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;-R&lt;/code&gt;：recursion，递归，改变目录下所有文件的属性&lt;/p&gt;
&lt;h3 id=&#34;chown更改文件属主也可以同时更改文件属组&#34;&gt;chown：更改文件属主，也可以同时更改文件属组&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chown &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-R&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属主名 文件名
chown &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-r&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属主名:属组名 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;chmod更改文件的9个属性&#34;&gt;chmod：更改文件的9个属性&lt;/h3&gt;
&lt;p&gt;9个权限分别为&lt;strong&gt;owner/group/others(拥有者/组/其他)&lt;/strong&gt; 三种身份各有自己的 &lt;strong&gt;read/write/execute&lt;/strong&gt; 权限。&lt;/p&gt;
&lt;p&gt;第一种方法使用数字来表示，各权限的分数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r：4&lt;/li&gt;
&lt;li&gt;w：2&lt;/li&gt;
&lt;li&gt;x：1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： &lt;strong&gt;-rwxrwx&amp;mdash;&lt;/strong&gt; 分数则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;owner = rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;group = rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;others= &amp;mdash; = 0+0+0 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以等一下我们设定权限的变更时，该文件的权限数字就是 &lt;strong&gt;770&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;第二种方法是使用符号类型改变权限，这里不详细介绍。&lt;/p&gt;
&lt;h2 id=&#34;文件与目录管理&#34;&gt;文件与目录管理&lt;/h2&gt;
&lt;h3 id=&#34;处理目录常用命令&#34;&gt;处理目录常用命令：&lt;/h3&gt;
&lt;p&gt;ls（list files）：列出目录和文件名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a：全部文件，联通隐藏文件&lt;/li&gt;
&lt;li&gt;-d：仅列出目录本身&lt;/li&gt;
&lt;li&gt;-l：长数据串列出，包含文件属性与权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cd（change directory）：切换目录&lt;/p&gt;
&lt;p&gt;pwd（print work directory）：显示当前目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-P：显示出实际的路径，而不是连结（link）路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mkdir（make directory）：创建一个新目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-m：配置文件的权限&lt;/li&gt;
&lt;li&gt;-p：可以递归创建多级目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rmdir（remove directory）：删除一个空目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-p：连同上一级的空目录一起删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cp（copy file）：复制文件或目录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-adfilprsu&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 来源档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; 目标档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;destination&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
cp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; source1 source2 ... directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-a：相当于-pdr&lt;/li&gt;
&lt;li&gt;-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身&lt;/li&gt;
&lt;li&gt;-f：force，若目标文件已存在且无法开启，则移除后再尝试一次&lt;/li&gt;
&lt;li&gt;-i：若目标档已存在时，在覆盖时会先询问&lt;/li&gt;
&lt;li&gt;-p：连同文件属性一起复制过去&lt;/li&gt;
&lt;li&gt;-f：递归持续复制，用于目录的复制&lt;/li&gt;
&lt;li&gt;-s：复制成为符号连结档(symbolic link)&lt;/li&gt;
&lt;li&gt;-u：若destination比source旧才升级destination&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rm（remove）：删除文件或目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-f：force&lt;/li&gt;
&lt;li&gt;-r：递归删除，常用在目录的删除&lt;/li&gt;
&lt;li&gt;-i：互动模式，删除前会询问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mv（move file）：移动文件与目录，或修改文件、目录名称&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mv &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-fiu&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 来源档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; 目标档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;destination&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
mv &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; source1 source2 ... directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-f：force&lt;/li&gt;
&lt;li&gt;-i：若目标文件 (destination) 已经存在时，就会询问是否覆盖&lt;/li&gt;
&lt;li&gt;-u：目标文件已经存在，且 source 比较新，才会升级 (update)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件内容查看&#34;&gt;文件内容查看&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cat：从第一行开始显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tac：从最后一行开始显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nl：显示行号并列出文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;more：一页一页显示和翻动文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空白键 (space)：代表向下翻一页；&lt;/li&gt;
&lt;li&gt;Enter     ：代表向下翻『一行』；&lt;/li&gt;
&lt;li&gt;/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；&lt;/li&gt;
&lt;li&gt;:f      ：立刻显示出档名以及目前显示的行数；&lt;/li&gt;
&lt;li&gt;q       ：代表立刻离开 more ，不再显示该文件内容。&lt;/li&gt;
&lt;li&gt;b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;head：取出文件前面几行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;head &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-n number&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tail：取出文件后面几行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;tail &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-n number&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h2&gt;
&lt;p&gt;常用的三个命令：df、du、fdisk&lt;/p&gt;
&lt;p&gt;df：列出文件系统的整体磁盘使用量&lt;/p&gt;
&lt;p&gt;du：检查磁盘空间使用量&lt;/p&gt;
&lt;p&gt;fdisk：用于磁盘分区&lt;/p&gt;
&lt;h2 id=&#34;配置wsl2开发环境&#34;&gt;配置WSL2开发环境&lt;/h2&gt;
&lt;h3 id=&#34;cc&#34;&gt;C/C++&lt;/h3&gt;
&lt;p&gt;见&lt;a href=&#34;https://code.visualstudio.com/docs/cpp/config-wsl&#34;&gt;Using C++ and WSL in VS Code&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;p&gt;使用脚本安装Anaconda&lt;/p&gt;
- https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络各层级理解</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</link>
        <pubDate>Fri, 23 Jul 2021 12:59:05 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ -&lt;p&gt;一年多前按照层级详细学习了计算机网络的有关内容，包括从应用层、传输层、网络层、数据链路层到物理层的详细信息，并且也学习了一些其他硬件通信协议，比如CAN控制器局域网、SPI等等。在之后的应用和实践中经常对不同层级的网络和网络设备产生疑惑，例如路由器和交换机到底是什么关系？为什么要通过IP地址和MAC地址划分网络层和数据链路层？这里将会详细说明各层网络的具体作用来加深理解和体会。&lt;/p&gt;
&lt;h2 id=&#34;应用层&#34;&gt;应用层&lt;/h2&gt;
&lt;p&gt;应用层是计算机网络体系结构中最高层，意味着这是&lt;strong&gt;和人进行交互&lt;/strong&gt;的层次。&lt;/p&gt;
&lt;p&gt;应用层是计算机网络与用户进行交互的&lt;strong&gt;接口&lt;/strong&gt;或界面，直接向用户提供服务；包括Web、E-mail、DNS、DHCP、FTP等等。&lt;/p&gt;
&lt;p&gt;应用层要解决的主要问题就是如何为用户提供&lt;strong&gt;高效、可靠、满意&lt;/strong&gt;的服务，工程师要根据不同业务场景使用不同技术方法解决这些问题，比如使用多线程、高并发的Web框架，分布式处理等等。&lt;/p&gt;
&lt;h2 id=&#34;传输层&#34;&gt;传输层&lt;/h2&gt;
&lt;p&gt;负责&lt;strong&gt;端到端（进程之间）&lt;strong&gt;的通信。位于两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种&lt;/strong&gt;网络应用进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;端到端的传输分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟传输连接的建立&lt;/li&gt;
&lt;li&gt;源端用户数据沿着传输连接传送到目的端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个数据传输过程中传输层需要完成以下基本功能：传输层寻址、传输连接建立、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和多路分解、崩溃恢复。&lt;/p&gt;
&lt;h2 id=&#34;网络层&#34;&gt;网络层&lt;/h2&gt;
&lt;p&gt;也被称为中转层。他很重要也很复杂，既要解决不同网络的节点通信的路由和协议识别问题，又要通过路由选择策略解决网络拥塞问题。&lt;/p&gt;
&lt;p&gt;网络层主要是为了解决不同网络之间&lt;strong&gt;数据传输和转发&lt;/strong&gt;问题。&lt;/p&gt;
&lt;h2 id=&#34;数据链路层&#34;&gt;数据链路层&lt;/h2&gt;
&lt;p&gt;在原始的、有差错的物理传输线路的基础上，采用差错检测、差错控制和流量控制等方法，将有差错的物理线路改成逻辑上无差错的数据链路，为上一层（网络层）提供高质量服务。&lt;/p&gt;
&lt;p&gt;数据链路层主要是为了&lt;strong&gt;控制数据传输&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;物理层&#34;&gt;物理层&lt;/h2&gt;
&lt;p&gt;位于体系结构最底层，负责在物理介质上位数据链路层提供&lt;strong&gt;原始比特流&lt;/strong&gt;传输的&lt;strong&gt;物理链接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;物理层解决的问题就是&lt;strong&gt;数据传输&lt;/strong&gt;，所有数据到达物理层都会变成二进制的载波信号。&lt;/p&gt;
&lt;h2 id=&#34;交换机和路由器&#34;&gt;交换机和路由器&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&#34;http://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/#wlan%e5%9f%ba%e7%a1%80%e5%86%85%e5%ae%b9&#34;&gt;WLAN基本内容和802.11ax&lt;/a&gt;中的内容。&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>LaTex环境配置和基本功能模块</title>
        <link>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</link>
        <pubDate>Sun, 18 Jul 2021 20:06:26 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ -&lt;h2 id=&#34;环境配置&#34;&gt;环境配置&lt;/h2&gt;
&lt;p&gt;我选择使用VS code + Tex Live作为我的LaTex写作环境，具体配置过程参考自：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/166523064&#34;&gt;Visual Studio Code (vscode)配置LaTeX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是关于使用过程中一些具体模块的讨论：&lt;/p&gt;
&lt;p&gt;部分内容参考自：&lt;a href=&#34;https://liam.page/2014/09/08/latex-introduction/&#34;&gt;一份其实很短的 LaTeX 入门文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里使用&lt;code&gt;xeLatTex&lt;/code&gt;进行编译。&lt;/p&gt;
&lt;h2 id=&#34;基本文档和中英文&#34;&gt;基本文档和中英文&lt;/h2&gt;
&lt;h3 id=&#34;基本文档&#34;&gt;基本文档&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;article&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;% 这里是导言区
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
Hello, world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tex以&lt;code&gt;%&lt;/code&gt;作为注释标记。若要输出百分号&lt;code&gt;%&lt;/code&gt;字符本身，则要在前面加上反斜杠&lt;code&gt;\&lt;/code&gt;进行转义（escape）。&lt;/p&gt;
&lt;h3 id=&#34;中英文混排&#34;&gt;中英文混排&lt;/h3&gt;
&lt;p&gt;目前XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题。至此，我们只需要使用几个简单的宏包，就能完成中文支持了。&lt;/p&gt;
&lt;p&gt;我们使用&lt;code&gt;\usepackage{}&lt;/code&gt;来调用宏包。&lt;/p&gt;
&lt;p&gt;另外，我们使用&lt;code&gt;CTex&lt;/code&gt;宏集来处理中文的版式和标点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
你好，world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与开始相比，文档类别变为&lt;code&gt;ctexart&lt;/code&gt;，并且增加了文档类选项&lt;code&gt;UTF8&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;组织文章基本内容&#34;&gt;组织文章基本内容&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;标题、作者、日期&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\title&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好，world!&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Eternity&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\today&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\maketitle&lt;/span&gt;
你好，world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码中的控制序列&lt;code&gt;\maketitle&lt;/code&gt;能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。&lt;/p&gt;
&lt;p&gt;可以通过宏包&lt;code&gt;titling&lt;/code&gt;修改上述默认格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_1.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;章节和段落&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\title&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好，world!&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Liam&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\today&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\maketitle&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\section&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好中国&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
中国在East Asia.
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello Beijing&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
北京是capital of China.
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsubsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello Dongcheng District&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\paragraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Tian&amp;#39;anmen Square&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
is in the center of Beijing
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subparagraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Chairman Mao&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
is in the center of 天安门广场。
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello 山东&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\paragraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;山东大学&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt; is one of the best university in 山东。
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文档类&lt;code&gt;article&lt;/code&gt;/&lt;code&gt;ctexart&lt;/code&gt;中定义了5个控制序列来调整文章组织结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\section{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subsection{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subsubsection{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\paragraph{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subparagraph{·}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_2.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;插入目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在控制序列&lt;code&gt;\maketitle&lt;/code&gt;加入&lt;code&gt;tableofcontents&lt;/code&gt;，编译两次观察效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_3.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;LaTeX 将一个换行当做是一个简单的空格来处理，如果需要换行另起一段，则需要用两个换行（一个空行）来实现。&lt;/p&gt;
&lt;h2 id=&#34;版面设置&#34;&gt;版面设置&lt;/h2&gt;
&lt;h3 id=&#34;页边距&#34;&gt;页边距&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;geometry&lt;/code&gt; 宏包。&lt;a href=&#34;https://texdoc.org/serve/geometry.pdf/0&#34;&gt;geometry文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;geometry&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\geometry&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;papersize=&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;20cm,15cm&lt;span style=&#34;color:#007020&#34;&gt;}}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\geometry&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;left=1cm,right=2cm,top=3cm,bottom=4cm&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;页眉页脚&#34;&gt;页眉页脚&lt;/h3&gt;
&lt;p&gt;设置页眉页脚，推荐使用 &lt;code&gt;fancyhdr&lt;/code&gt; 宏包。&lt;a href=&#34;https://texdoc.org/serve/fancyhdr.pdf/0&#34;&gt;fancyhdr文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;fancyhdr&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\pagestyle&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;fancy&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lhead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\chead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\rhead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;152xxxxxxxx&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\cfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\thepage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\rfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\headrulewidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;0.4pt&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\headwidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\textwidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\footrulewidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;0pt&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;行间距&#34;&gt;行间距&lt;/h3&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;setspace&lt;/code&gt; 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;setspace&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\onehalfspacing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;段间距&#34;&gt;段间距&lt;/h3&gt;
&lt;p&gt;我们可以通过修改长度 &lt;code&gt;\parskip&lt;/code&gt; 的值来调整段间距。例如在导言区添加以下内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\addtolength&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\parskip&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;.4em&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;希望代码中的特殊字符不被LaTex处理，并且希望有代码高亮。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;listings&lt;/code&gt;宏包来在tex中添加代码段。基本设置参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;listings&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lstset&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;
language=Matlab,
escapeinside=``, 
numbers=left,
numberstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\tiny&lt;/span&gt;,
breaklines=true, 
backgroundcolor=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;lightgray!40!white&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;,
frame=single,
framerule=0pt,
extendedchars=false, 
keywordstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;blue!70&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\bfseries&lt;/span&gt;, 
basicstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\ttfamily&lt;/span&gt;,
commentstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\ttfamily\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;green!40!black&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;, 
showstringspaces=false&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 &lt;code&gt;graphicx&lt;/code&gt; 宏包提供的 &lt;code&gt;\includegraphics&lt;/code&gt; 命令。比如你在你的 TeX 源文件同目录下，有名为 &lt;code&gt;a.jpg&lt;/code&gt; 的图片，你可以用这样的方式将它插入到输出文档中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;article&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;graphicx&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\includegraphics&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;a.jpg&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 &lt;code&gt;\includegraphics&lt;/code&gt; 控制序列的可选参数来控制。比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\includegraphics&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[width = .8\textwidth]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;a.jpg&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样图片的宽度会被缩放至&lt;strong&gt;页面宽度的百分之八十&lt;/strong&gt;，图片的总高度会按比例缩放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;\includegraphics&lt;/code&gt;还有很多其他控制序列可以选择使用，可以查看宏包选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tabular&lt;/code&gt; 环境提供了最简单的表格功能。它用 &lt;code&gt;\hline&lt;/code&gt; 命令表示横线，在列格式中用 &lt;code&gt;|&lt;/code&gt; 表示竖线；用 &lt;code&gt;&amp;amp;&lt;/code&gt; 来分列，用 &lt;code&gt;\\&lt;/code&gt; 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 &lt;code&gt;l&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;、&lt;code&gt;r&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;tabular&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;|l|c|r|&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
操作系统&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; 发行版&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; 编辑器&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Windows &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; MikTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TexMakerX &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Unix/Linux &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; teTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; Kile &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Mac OS &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; MacTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeXShop &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
通用&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeX Live &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeXworks &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;tabular&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h2 id=&#34;数学公式&#34;&gt;数学公式&lt;/h2&gt;
&lt;p&gt;在导言区添加&lt;code&gt;amsmath&lt;/code&gt;宏包来使用数学功能：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;amsmath&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;数学模式&#34;&gt;数学模式&lt;/h3&gt;
&lt;p&gt;与Markdown中相同，LaTex共有&lt;strong&gt;行内公式&lt;/strong&gt;和&lt;strong&gt;行间公式&lt;/strong&gt;两种模式。&lt;/p&gt;
&lt;p&gt;在行文中，使用 &lt;code&gt;$ ... $&lt;/code&gt; 可以插入行内公式，使用 &lt;code&gt;\[ ... \]&lt;/code&gt; 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 &lt;code&gt;equation&lt;/code&gt; 环境：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;equation&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
...
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;equation&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;无编号的行间公式也可以使用 &lt;code&gt;\begin{displaymath} ... \end{displaymath}&lt;/code&gt; 或者 &lt;code&gt;\begin{equation*} ... \end{equation*}&lt;/code&gt; 来插入，但略显麻烦。（&lt;code&gt;equation*&lt;/code&gt; 中的 &lt;code&gt;*&lt;/code&gt; 表示环境不编号）&lt;/p&gt;
&lt;p&gt;也有 plainTeX 风格的 &lt;code&gt;$$ ... $$&lt;/code&gt; 来插入不编号的行间公式。但是在 LaTeX 中这样做会改变行文的默认行间距，不推荐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标点符号&#34;&gt;标点符号&lt;/h3&gt;
&lt;p&gt;行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。&lt;/p&gt;
&lt;h3 id=&#34;多行公式&#34;&gt;多行公式&lt;/h3&gt;
&lt;p&gt;有的公式特别长，我们需要手动为他们换行；&lt;/p&gt;
&lt;p&gt;有几个公式是一组，我们需要将他们放在一起；&lt;/p&gt;
&lt;p&gt;还有些类似分段函数，我们需要给它加上一个左边的花括号。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;长公式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不对齐：无须对齐的长公式可以使用 &lt;code&gt;multline&lt;/code&gt; 环境。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;multline&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
x = a+b+c+&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
d+e+f+g
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;multline&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;如果不需要编号，可以使用 &lt;code&gt;multline*&lt;/code&gt; 环境代替。&lt;/p&gt;
&lt;p&gt;对齐：需要对齐的公式，可以使用 &lt;code&gt;aligned&lt;/code&gt; &lt;em&gt;次环境&lt;/em&gt;来实现，它必须包含在数学环境之内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\[&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{aligned}
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x &lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&amp;amp; a&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{} &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;d&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;g
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{aligned}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公式组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无需对齐的公式组可以使用 &lt;code&gt;gather&lt;/code&gt; 环境，需要对齐的公式组可以使用 &lt;code&gt;align&lt;/code&gt; 环境。他们都带有编号，如果不需要编号可以使用带&lt;code&gt;*&lt;/code&gt;的版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;gather&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
a = b+c+d &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
x = y+z
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;gather&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;align&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
a &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt;= b+c+d &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
x &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt;= y+z
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;align&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分段函数可以用&lt;code&gt;cases&lt;/code&gt;次环境来实现，它必须包含在数学环境之内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\[&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; y&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{cases}
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x,&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\quad&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; x&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\leq&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x,&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\quad&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; x&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{cases} &lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH10 泛型算法</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</link>
        <pubDate>Sun, 18 Jul 2021 09:16:32 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/ -&lt;p&gt;用来&lt;strong&gt;操纵容器&lt;/strong&gt;。泛型算法独立于任何特定容器，可用于不同类型的容器和不同类型的元素。这些算法是一些&lt;strong&gt;经典算法的公共接口&lt;/strong&gt;，例如排序和搜索。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法定义在&lt;code&gt;algorithm&lt;/code&gt;头文件中，标准库还在&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般这些算法并不直接操作容器，而是遍历由&lt;strong&gt;两个迭代器指定的一个元素范围&lt;/strong&gt;来进行操作。&lt;/p&gt;
&lt;p&gt;算法不依赖于容器，但依赖于元素类型的操作。&lt;/p&gt;
&lt;h2 id=&#34;基本算法&#34;&gt;基本算法&lt;/h2&gt;
&lt;h3 id=&#34;只读算法&#34;&gt;只读算法&lt;/h3&gt;
&lt;p&gt;只读取输入范围的元素，&lt;strong&gt;不改变元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;accumulate&lt;/code&gt;算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其定义在头文件numeric中，接受三个参数，前两个指出了需要求和元素的范围，第三个参数是和的初值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; accumulate(vec.cbegin(), vec.cend(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//对vec中元素求和，和的初值设为0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第三个参数的类型决定了函数中使用哪个&lt;strong&gt;加法运算符&lt;/strong&gt;以及&lt;strong&gt;返回值的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即序列中的元素必须与第三个参数&lt;strong&gt;匹配&lt;/strong&gt;或&lt;strong&gt;能够转换为第三个参数的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;equal&lt;/code&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确定两个序列的值是否保存相同的值，将第一个序列的每个元素与第二个序列的对应元素比较。该算法接受三个迭代器，前两个表示第一个序列的范围，第三个表示第二个序列的首元素。&lt;/p&gt;
&lt;p&gt;equal利用迭代器完成操作，因此我们可以调用equal来比较两个不同类型容器中的元素，并且元素类型也可以不同。&lt;/p&gt;
&lt;h3 id=&#34;写容器元素算法&#34;&gt;写容器元素算法&lt;/h3&gt;
&lt;p&gt;使用这类算法要保证序列原大小&lt;strong&gt;不小于&lt;/strong&gt;算法写入的元素数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fill&lt;/code&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fill接受&lt;strong&gt;一对迭代器&lt;/strong&gt;和&lt;strong&gt;一个值&lt;/strong&gt;，将这个值赋予输入序列中的每个元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;fill(vec.begin(), vec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不能在空容器上调用fill_n.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;back_inserter插入迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接受一个&lt;strong&gt;指向容器的引用&lt;/strong&gt;，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。&lt;/p&gt;
&lt;p&gt;back_inserter是一个定义在头文件iterator中的函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; vec;	&lt;span style=&#34;color:#888&#34;&gt;//空vector
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; back_inserter(vec);	&lt;span style=&#34;color:#888&#34;&gt;//通过其赋值将元素添加到vec中
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;拷贝算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;copy是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。&lt;/p&gt;
&lt;p&gt;该算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。&lt;/p&gt;
&lt;h3 id=&#34;重排容器元素算法&#34;&gt;重排容器元素算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;unique&lt;/code&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;elimDups&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;words)
{
	&lt;span style=&#34;color:#888&#34;&gt;//按字典排序words, 以便查找重复单词
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	sort(words.begin(), words.end());
	&lt;span style=&#34;color:#888&#34;&gt;//unique重排输入范围，使每个单词只出现一次
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; end_unique &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; unique(words.begin(), words.end());
	&lt;span style=&#34;color:#888&#34;&gt;//使用erase操作删除重复单词
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	words.erase(end_unique, words.end());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sort算法接受两个迭代器，表示要排序的元素范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用unique&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unique算法重排输入元素，将相邻的重复项消除，并返回一个指向不重复值范围末尾的迭代器。&lt;/p&gt;
&lt;h2 id=&#34;定制操作&#34;&gt;定制操作&lt;/h2&gt;
&lt;p&gt;很多算法会比较输入序列中的元素。默认情况下，这类算法使用&amp;lt;或==运算符完成比较。标准库还定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。&lt;/p&gt;
&lt;h3 id=&#34;向算法传递函数&#34;&gt;向算法传递函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;谓词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谓词是一个可调用的&lt;strong&gt;表达式&lt;/strong&gt;，其返回结果是一个能&lt;strong&gt;用作条件的值&lt;/strong&gt;。标准库算法使用的谓词分为：一元谓词和二元谓词。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;isShorter&lt;/span&gt;(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s1, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s2) {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; s1.size() &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; s2.size();
}
sort(words.begin(), words.end(), isShorter);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;stable_sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该排序算法可以保持等长元素间的字典序。&lt;/p&gt;
&lt;h3 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h3&gt;
&lt;h3 id=&#34;lambda捕获和返回&#34;&gt;lambda捕获和返回&lt;/h3&gt;
&lt;h3 id=&#34;参数绑定&#34;&gt;参数绑定&lt;/h3&gt;
&lt;h2 id=&#34;再探迭代器&#34;&gt;再探迭代器&lt;/h2&gt;
&lt;p&gt;除了为每个容器定义的迭代器之外，标准库还在头文件iterator中定义了额外几种迭代器，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。&lt;/li&gt;
&lt;li&gt;流迭代器：这些迭代器被绑定到输入输出流上，可用来遍历所关联的IO流&lt;/li&gt;
&lt;li&gt;反向迭代器：这些迭代器向后移动而不是向前移动&lt;/li&gt;
&lt;li&gt;移动迭代器：（13.6.2节介绍）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入迭代器&#34;&gt;插入迭代器&lt;/h3&gt;
&lt;h3 id=&#34;iostream迭代器&#34;&gt;iostream迭代器&lt;/h3&gt;
&lt;h3 id=&#34;反向迭代器&#34;&gt;反向迭代器&lt;/h3&gt;
&lt;h2 id=&#34;泛型算法结构&#34;&gt;泛型算法结构&lt;/h2&gt;
&lt;p&gt;任何算法最基本的特征是其要求迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别：&lt;/p&gt;
&lt;p&gt;输入、输出、前向、双向、随机访问迭代器&lt;/p&gt;
&lt;h2 id=&#34;特定容器算法&#34;&gt;特定容器算法&lt;/h2&gt;
&lt;p&gt;链表类型list和forward_list定义了几个成员函数形式的算法。他们定义了几个成员函数形式的算法。它们定义了独有的sort、merge、remove、reverse和unique。将以成员函数的形式使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;splice成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表类型还定义了splice算法，该算法是链表数据结构所独有的，因此不需要通用版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.splice(args)
flst.splice_after(args)
(p, lst2)	&lt;span style=&#34;color:#888&#34;&gt;//p是一个指向lst中元素的迭代器或一个指向flst首前位置的迭代器。函数将lst2所有元素移动到lst中p之前的位置或flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或lst相同，且不能是同一个链表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;(p, lst2, p2)
(p, lst2, b, e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;链表特有的操作会改变容器&lt;/strong&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 2.信息的表示和处理（部分完成）</title>
        <link>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
        <pubDate>Mon, 12 Jul 2021 21:26:27 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ -&lt;p&gt;第一部分内容：程序结构和执行&lt;/p&gt;
&lt;p&gt;我们需要用方法表示&lt;strong&gt;基本数据类型&lt;/strong&gt;，然后考虑机器级指令如何操作这样的数据，以及编译器如何将C程序翻译成这样的指令。接下来研究集中处理器的方法，使得我们能够更好地了解硬件资源如何被用来执行指令。&lt;/p&gt;
&lt;h2 id=&#34;信息存储&#34;&gt;信息存储&lt;/h2&gt;
&lt;h3 id=&#34;十六进制表示法及转换&#34;&gt;十六进制表示法及转换&lt;/h3&gt;
&lt;p&gt;二进制和十进制对描述&lt;strong&gt;位模式&lt;/strong&gt;来说都不方便，因此采用16进制数(hex)来表示位模式。&lt;/p&gt;
&lt;p&gt;C语言中16进制数以0X或0x开头，字符‘A’~‘F’既可以是大写也可以是小写。&lt;/p&gt;
&lt;p&gt;二进制和十六进制之间的转换较为简单，不再赘述。&lt;/p&gt;
&lt;p&gt;十进制和十六进制数之间的转换要反复利用乘法和除法进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从十进制到十六进制：反复用16除十进制数&lt;/li&gt;
&lt;li&gt;从十六进制到十进制：用相应的16的幂乘以每个十六进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字数据大小&#34;&gt;字数据大小&lt;/h3&gt;
&lt;p&gt;字长指明指针数据的标称大小。虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是&lt;strong&gt;虚拟地址空间的最大大小&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对一个字长为w的机器而言，虚拟地址的范围是$0$ ~$2^w-1$，程序最多访问$2^w-1$个字节。&lt;/p&gt;
&lt;p&gt;近年，很多机器都从32位字长迁移到了64位字长。大多64位字长机器可以运行32位字长机器编译的程序。32位程序和64位程序的区别在于程序是&lt;strong&gt;如何编译&lt;/strong&gt;成的，而不是运行的机器类型。&lt;/p&gt;
&lt;h3 id=&#34;寻址和字节顺序&#34;&gt;寻址和字节顺序&lt;/h3&gt;
&lt;p&gt;小端法、大端法&lt;/p&gt;
&lt;p&gt;对于跨越多个字节的程序对象，我们必须明确：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个对象的地址是什么&lt;/li&gt;
&lt;li&gt;如何在内存中排列这些字节&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，多字节对象被存储为&lt;strong&gt;连续的字节序列&lt;/strong&gt;，对象的地址为所使用字节中&lt;strong&gt;最小的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小端法：将&lt;strong&gt;最低有效字节&lt;/strong&gt;放在最前面(最小地址)存储。（例如一个二进制数最右边的8位是最低有效字节）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大端法：将&lt;strong&gt;最高有效字节&lt;/strong&gt;放在最前面(最小地址)存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多Intel兼容机使用小端模式。&lt;/p&gt;
&lt;p&gt;以下代码使用强制类型转换来访问和打印不同程序对象的字节表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;byte_pointer;	&lt;span style=&#34;color:#888&#34;&gt;//将byte_pointer定义为一个指向类型为unsigned char对象的指针
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//指针被强制类型转换为unsigned char *, 这告诉编译器程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_bytes&lt;/span&gt;(byte_pointer start, size_t len)
{&lt;span style=&#34;color:#888&#34;&gt;//按顺序显示出指针指向对象的每个字节内容，可以判断出系统使用的小端法还是大端法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	size_t i;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
		printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%.2x&amp;#34;&lt;/span&gt;, start[i]);
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
}

&lt;span style=&#34;color:#888&#34;&gt;//使用sizeof确定对象使用的字节数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_int&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示int对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_float&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示float对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt;));
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_pointer&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示void *对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;表示字符串&#34;&gt;表示字符串&lt;/h3&gt;
&lt;p&gt;对文本进行编码。&lt;/p&gt;
&lt;p&gt;ASCII编码、Unicode编码&lt;/p&gt;
&lt;p&gt;之前写过一篇相关博客：&lt;a href=&#34;http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/&#34;&gt;字符编码：Unicode, UTF-8&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;布尔代数&#34;&gt;布尔代数&lt;/h3&gt;
&lt;p&gt;四种布尔运算：&lt;/p&gt;
&lt;p&gt;与、或、非、异或&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异或：当P或Q为真但不同时为真时，异或成立；即当p=1且q=0或p=1且q=1时，p^q=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;位向量的布尔运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按位进行布尔运算。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的位级运算&#34;&gt;C语言中的位级运算&lt;/h3&gt;
&lt;p&gt;按照对应位进行布尔运算。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的逻辑运算&#34;&gt;C语言中的逻辑运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;逻辑运算和位级运算完全不同，逻辑运算认为所有非零的参数都表示TRUE，参数0表示FALSE。以下是一些表达式求值举例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;!0x41&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!0x00&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!!0x41&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;c语言中的移位运算&#34;&gt;C语言中的移位运算&lt;/h3&gt;
&lt;p&gt;左移k位：将操作数向左移动k位，丢弃掉最高的k位并在右端补k个0&lt;/p&gt;
&lt;p&gt;逻辑右移：在左端补k个0&lt;/p&gt;
&lt;p&gt;算数右移：在左端补k个最高有效位的值&lt;/p&gt;
&lt;p&gt;几乎所有编译器都对&lt;strong&gt;有符号数&lt;/strong&gt;使用&lt;strong&gt;算术右移&lt;/strong&gt;，对&lt;strong&gt;无符号数&lt;/strong&gt;使用逻辑右移。&lt;/p&gt;
&lt;h2 id=&#34;整数表示&#34;&gt;整数表示&lt;/h2&gt;
&lt;p&gt;用&lt;strong&gt;位&lt;/strong&gt;来编码整数的两种不同方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种只能表示&lt;strong&gt;非负数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;另一种能表示&lt;strong&gt;负数、零和正数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;整型数据类型&#34;&gt;整型数据类型&lt;/h3&gt;
&lt;p&gt;C语言通过&lt;strong&gt;关键字&lt;/strong&gt;来表示多种整型数据类型，这些关键字包括char、short、long，同时还能指示被表示的数字是非负数（声明为unsigned）。&lt;/p&gt;
&lt;p&gt;为不同大小分配的字节数根据程序编译为32位还是64位有所不同；根据字节分配，不同大小所能表示的值的范围是不同的。&lt;/p&gt;
&lt;p&gt;取值范围是不对称的，负数的范围比正数大1.&lt;/p&gt;
&lt;h3 id=&#34;无符号数的编码&#34;&gt;无符号数的编码&lt;/h3&gt;
&lt;p&gt;直接按照二进制进行编码即可。B2U：将二进制编码映射到一个非负整数&lt;/p&gt;
&lt;p&gt;无符号数的编码具有唯一性&lt;/p&gt;
&lt;h3 id=&#34;补码编码&#34;&gt;补码编码&lt;/h3&gt;
&lt;p&gt;(two&amp;rsquo;s-complement)。用来表示有符号数，将字的最高有效位解释为&lt;strong&gt;负权&lt;/strong&gt;，用$B2T_w$表示：
$$
B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2_i
$$
最高有效位$x_{w-1}$称为符号位，它的权重为$-2^{w-1}$，是无符号表示中权重的负数。&lt;/p&gt;
&lt;p&gt;从维向量到整数映射的举例：
$$
B2T_4([0001])=1 \
B2T_4([0101])=5 \
B2T_4([1011])=5 \
B2T_4([1111])=-1
$$
w位补码所能表示的值的范围是：$[-2^{w-1},2^{w-1}-1]$，例如长度为4的补码可以表示的范围是$[-8,7]$。与无符号数一样，在可表示的取值范围内，每个数字都唯一的w位补码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用补码来编码负数（有符号数）&lt;/strong&gt;。几乎所有现代机器目前都采用补码编码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反码：最高有效位的权是$-(2^{w-1}-1)$，其他和补码一样。&lt;/p&gt;
&lt;p&gt;原码：最高有效位是符号位，用来确定剩下的位应该取负权还是正权。&lt;/p&gt;
&lt;p&gt;这两种表示方式对于数字0都有两种不同的编码方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;有符号数和无符号数之间的转换&#34;&gt;有符号数和无符号数之间的转换&lt;/h3&gt;
&lt;p&gt;对于多数C语言的实现来说，这个问题都是从&lt;strong&gt;位级&lt;/strong&gt;角度来看的，而不是&lt;strong&gt;数&lt;/strong&gt;的角度。&lt;/p&gt;
&lt;p&gt;处理同样字长的有符号和无符号数之间相互转换的规则为：数值可能会改变，但&lt;strong&gt;位模式&lt;/strong&gt;不变。&lt;/p&gt;
&lt;p&gt;补码转换为无符号数$T2U_w(x)$，当x&amp;lt;0时值改变，计算结果为$x+2^w$，当x&amp;gt;0时值不变。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的有符号数和无符号数&#34;&gt;C语言中的有符号数和无符号数&lt;/h3&gt;
&lt;p&gt;C语言支持所有整型数据类型的有符号和无符号计算，几乎所有机器都采用&lt;strong&gt;补码&lt;/strong&gt;表示有符号数。通常大多数数字都默认是有符号的。&lt;/p&gt;
&lt;h3 id=&#34;扩展一个数字的位表示&#34;&gt;扩展一个数字的位表示&lt;/h3&gt;
&lt;p&gt;将无符号数扩展为一个更大的数据类型：只需在表示的开头添加0即可。&lt;/p&gt;
&lt;p&gt;将一个补码扩展为一个更大的数据类型：执行一个&lt;strong&gt;符号扩展&lt;/strong&gt;，即在开头添加最高有效位数字。&lt;/p&gt;
&lt;p&gt;符号扩展不改变补码表示的数字。&lt;/p&gt;
&lt;h3 id=&#34;截断数字&#34;&gt;截断数字&lt;/h3&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;为了避免出现错误或漏洞，我们&lt;strong&gt;绝不使用无符号数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;整数运算&#34;&gt;整数运算&lt;/h2&gt;
&lt;h3 id=&#34;无符号加法&#34;&gt;无符号加法&lt;/h3&gt;
&lt;p&gt;两个无符号数相加，如果完整的整数结果不能放到数据类型的字长限制中去，那么就会发生溢出，当无符号数加法发生溢出时，结果为丢弃溢出的最高位后的结果，即减去$2^w$。&lt;/p&gt;
&lt;h3 id=&#34;补码加法&#34;&gt;补码加法&lt;/h3&gt;
&lt;p&gt;分为正溢出、正常、负溢出三种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正溢出：和减去$2^w$&lt;/li&gt;
&lt;li&gt;负溢出：和加上$2^w$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;补码的非&#34;&gt;补码的非&lt;/h3&gt;
&lt;p&gt;当$x=\text{TMin}_w$时，补码的非的结果为：$\text{TMin}_w$，否则结果为$-x$&lt;/p&gt;
&lt;h3 id=&#34;无符号乘法&#34;&gt;无符号乘法&lt;/h3&gt;
&lt;p&gt;乘积可能需要$2w$位来表示，C语言中无符号被定义为产生w位值，即2w乘积结果的低2w位。将一个无符号数截断为w位等价于计算该值模$2^w$&lt;/p&gt;
&lt;h3 id=&#34;补码乘法&#34;&gt;补码乘法&lt;/h3&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;计算机的整数运算实际上是一种模运算，表示数字时的有限字长限制了可能的值的取值范围，结果运算溢出。&lt;/p&gt;
&lt;p&gt;补码提供了一种既能表示整数也能表示负数的灵活方法，同时使用了与执行无符号算术相同的位级实现。&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;h3 id=&#34;二进制小数&#34;&gt;二进制小数&lt;/h3&gt;
&lt;h3 id=&#34;ieee浮点数表示&#34;&gt;IEEE浮点数表示&lt;/h3&gt;
&lt;h3 id=&#34;舍入&#34;&gt;舍入&lt;/h3&gt;
&lt;h3 id=&#34;浮点运算&#34;&gt;浮点运算&lt;/h3&gt;
- https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>CAN总线</title>
        <link>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</link>
        <pubDate>Mon, 12 Jul 2021 18:16:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/ -&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;
&lt;p&gt;Controller Area Network&lt;/p&gt;
&lt;p&gt;CAN总线由BOSCH公司开发，是一种多主控(Multi-Master)的现场总线系统，CAN网络的消息是广播式的，即同一时刻网络上所有节点侦测的数据是一致的，是一种基于&lt;strong&gt;消息广播&lt;/strong&gt;模式的串行通信总线。&lt;/p&gt;
&lt;p&gt;CAN总线的很多优点，使得它得到了广泛的应用，如传输速度最高到1Mbps, 通信距离最远到10km，无损位仲裁机制，多主结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAN总线标准&lt;/strong&gt;规定了&lt;strong&gt;物理层&lt;/strong&gt;和&lt;strong&gt;数据链路层&lt;/strong&gt;，应用层标准由具体应用决定。&lt;/p&gt;
&lt;h2 id=&#34;can物理层&#34;&gt;CAN物理层&lt;/h2&gt;
&lt;p&gt;连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的&lt;strong&gt;差分电平信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;节点主要包括Host、控制器和收发器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;常集成有CAN控制器，&lt;strong&gt;CAN控制器&lt;/strong&gt;负责处理协议相关功能，以减轻Host的负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAN收发器&lt;/strong&gt;将控制器连接到传输媒介。通常控制器和总线收发器通过光耦或磁耦隔离，这样即使总线上过压损坏收发器，控制器和Host设备也可以得到保护。&lt;/p&gt;
&lt;p&gt;在发送数据时，CAN控制器把要发送的二进制编码通过&lt;strong&gt;CAN_Tx线&lt;/strong&gt;发送到CAN收发器，然后由收发器把这个普通的逻辑电平信号转化成&lt;strong&gt;差分信号&lt;/strong&gt;，通过&lt;strong&gt;差分线CAN_High和CAN_Low&lt;/strong&gt;输出到CAN总线网络。接收数据过程，相反。采用差分信号，可以取得更好的电磁兼容效果。因此，CAN总线物理传输媒介只需要两根线。&lt;/p&gt;
&lt;p&gt;下图为一CAN收发器应用的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_example.PNG&#34; alt=&#34;CAN总线示例&#34;&gt;&lt;/p&gt;
&lt;p&gt;高速CAN总线最高信号传输速率为1Mbps，支持最长距离40m。ISO11898-2要求在高速CAN总线两段安装&lt;strong&gt;端接电阻&lt;/strong&gt;RL（端接电阻一般为120Ω，因为电缆的特性阻抗为120 Ω，为了模拟无限远的传输线。）以消除反射。低速CAN最高速度只有125Kbps，所以ISO11898-3没有端接要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_bus_Res.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;差分信号&#34;&gt;差分信号&lt;/h3&gt;
&lt;p&gt;CAN总线采用差分信号传输，通常情况下只需要两根信号线就可以进行正常的通信。在差分信号中，逻辑0和逻辑1是用两根差分信号线的电压差来表示。&lt;/p&gt;
&lt;p&gt;当处于&lt;strong&gt;逻辑1&lt;/strong&gt;，CAN_High和CAN_Low的电压差小于0.5V时，称为&lt;strong&gt;隐性电平（Recessive）&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;当处于&lt;strong&gt;逻辑0&lt;/strong&gt;，CAN_High和CAN_Low的电压差大于0.9V，称为&lt;strong&gt;显性电平（Dominant）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CAN总线遵从“线与”机制：“显性”位可以覆 盖“隐性”位；只有所有节点都发 送“隐性”位， 总线才处于“隐性” 状态。这种“线与”机制使CAN总线呈现显性优先的特性。&lt;/p&gt;
&lt;h2 id=&#34;can数据链路层&#34;&gt;CAN数据链路层&lt;/h2&gt;
&lt;p&gt;在SPI通信中，片选、时钟信号、数据输入及数据输出这四个信号都有单独的信号线。而CAN使用的是两条差分信号线，&lt;strong&gt;只能表达一个信号&lt;/strong&gt;。简洁的物理层决定了CAN必然要配上一套更为复杂的协议。如何用一个信号通道实现同样甚至更强大的功能，答案就是对数据或操作命令进行打包。&lt;/p&gt;
&lt;h3 id=&#34;通信机制&#34;&gt;通信机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多主机(Multi-Master)&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;安全敏感的应用（如汽车动力）对通信系统的&lt;strong&gt;可靠性&lt;/strong&gt;要求很高。将总线能否正常工作归结到单一节点是非常危险的，比较合理的方案是对总线接入的&lt;strong&gt;去中心化&lt;/strong&gt;，即每个节点都有接入总线的能力。这也是CAN总线采用多主控（Multi-Master）线性拓扑结构的原因。&lt;/p&gt;
&lt;p&gt;在CAN总线上，每个节点都有往总线上发送消息的能力，而消息的发送不必遵从任何预先设定的时序，通信是&lt;strong&gt;事件驱动&lt;/strong&gt;的。只有当有新的信息传递时，CAN总线才处于忙碌的状态，这使得节点接入总线速度非常快。CAN总线理论最高数据传输速率为1Mbps，对于异步事件反应迅速，基本对于ms级别的实时应用没有任何问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻址机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;CAN总线不设定节点的地址，而是通过消息的&lt;strong&gt;标识符（Identifier）&lt;strong&gt;来区别消息。这种机制虽然会增加消息的复杂度（增加标识符），但是节点在此情况下可以无需了解其他节点的状况，而&lt;/strong&gt;相互间独立工作&lt;/strong&gt;。在总线上增加节点时仅需关注消息类型，而非系统上其他节点的状况。这种以消息标识符寻址的方式，让总线上增加节点变得更加灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线访问 CSMA/CD+AMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多路载波侦听+基于消息优先级的冲突检测和非破坏性的仲裁机制（CSMA/CD+AMP）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CSMA（Carrie Sense Multiple Access）指的是所有节点必须都等到总线处于&lt;strong&gt;空闲状态&lt;/strong&gt;时才能往总线上发送消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CD+AMP（Collision Detection + Arbitration on Message Priority）指的是如果多个节点往总线上发送消息时，具备&lt;strong&gt;最高优先级&lt;/strong&gt;的消息获得总线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非破坏性仲裁机制：通过ID仲裁，ID&lt;strong&gt;数值越小&lt;/strong&gt;，报文&lt;strong&gt;优先级越高&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;发送低优先级报文的节点退出仲裁后，在下次总线空闲时自动重发报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;高优先级的报文&lt;strong&gt;不能中断&lt;/strong&gt;低优先级报文的发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报文接受过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAN控制器大多具有根据ID过滤报文的功能，即只接收某些ID的报文。节点对接收到的报文进行过滤：比较消息ID与选择器（Accepter）中和接受过滤相关位是否相同。如果相同，接收；如果不相同，则过滤。&lt;/p&gt;
&lt;h3 id=&#34;报文种类及结构&#34;&gt;报文种类及结构&lt;/h3&gt;
&lt;p&gt;在原始数据段的前面加上&lt;strong&gt;传输起始标签、片选（识别）标签、控制标签&lt;/strong&gt;，在数据的尾段加上&lt;strong&gt;CRC校验标签、应答标签和传输结束标签&lt;/strong&gt;。把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了。&lt;/p&gt;
&lt;p&gt;各种各样的标签，起到了协同传输的作用。当整个数据包被传输到其他设备时，只要这些设备按格式去解读，就能还原出原始数据。类似这样的数据包就被称为CAN的数据帧。&lt;/p&gt;
&lt;p&gt;为了更有效的控制通信，CAN一共规定了5中类型的帧，帧也称为报文。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;帧&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;帧用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于发送单元向接收单元传输数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;远程帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于接收单元向具有相同ID的发送单元请求数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;错误帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于当检测出错误时，向其他单元通知错误的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超载帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于接收单元通知其尚未做好接受准备的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧间隔&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于将数据帧及遥控帧与前面其他帧分离开的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;数据帧&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_dataFrame.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;共分为7个段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帧起始（SOF）：标识一个数据帧的开始，固定一个显性位。用于同步，总线空闲期间的任何隐性到线性的跳变都将引起节点进行硬同步&lt;/li&gt;
&lt;li&gt;仲裁段：内容为本数据帧的ID信息&lt;/li&gt;
&lt;li&gt;控制段：r1和r0为保留位，默认设置为显性位。DLC（Data Length Code）段用二进制编码表示本报文的数据段包含多少字节，由4位组成，DLC3-DLC0，表示的数字为0-8.&lt;/li&gt;
&lt;li&gt;数据段：数据帧的核心内容，有0-8个字节长度。&lt;/li&gt;
&lt;li&gt;CRC段：报文包含了一段15位的CRC校验码，来检验是否出错。&lt;/li&gt;
&lt;li&gt;ACK段：包含确认位和界定符。在发送节点发送时为隐形位，当接收节点收到正确报文时，将其覆盖为显性。&lt;/li&gt;
&lt;li&gt;帧结束段（EOF）：由发送端发送7个隐形位表示结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步&#34;&gt;同步&lt;/h2&gt;
&lt;p&gt;CAN总线使用&lt;strong&gt;位同步&lt;/strong&gt;的方式来确保通信时序，以及对总线的电平进行正确采样。&lt;/p&gt;
&lt;h3 id=&#34;位时序&#34;&gt;位时序&lt;/h3&gt;
&lt;h3 id=&#34;同步-1&#34;&gt;同步&lt;/h3&gt;
&lt;p&gt;分为硬同步和重新同步。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;部分内容转载自：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32262127&#34;&gt;知乎-Choris-一口气从零读懂CAN总线&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>存储器详解</title>
        <link>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Sun, 04 Jul 2021 16:09:50 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ -&lt;p&gt;计算机存储器只要分为内存和外存。内存是CPU直接寻址的存储空间，访问频率快，而外存访问慢。&lt;/p&gt;
&lt;h2 id=&#34;易失性存储器随机存取存储器ram&#34;&gt;易失性存储器（随机存取存储器，RAM）&lt;/h2&gt;
&lt;p&gt;Random Access Memory，存储在其中的资料会在电力切断后消失，所以属于易失性存储器。&lt;/p&gt;
&lt;h3 id=&#34;动态随机存取存储器dram&#34;&gt;动态随机存取存储器（DRAM）&lt;/h3&gt;
&lt;p&gt;Dynamic Random Access Memory，主要的作用原理是利用电容内&lt;strong&gt;存储电荷的多寡&lt;/strong&gt;来代表一个二进制比特（bit）是1还是0。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别资料，而导致资料毁损。因此对于DRAM来说，周期性地充电是一个不可避免的条件。由于这种需要&lt;strong&gt;定时刷新&lt;/strong&gt;的特性，因此被称为“动态”存储器。&lt;/p&gt;
&lt;h3 id=&#34;静态随机存取存储器sram&#34;&gt;静态随机存取存储器（SRAM）&lt;/h3&gt;
&lt;p&gt;Static Random Access Memory，所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失。&lt;/p&gt;
&lt;p&gt;SRAM由存储矩阵、地址译码器和读/写控制电路组成，容量的扩展有两个方面：位数的扩展用芯片的并联，字数的扩展可用外加译码器控制芯片的片选输入端[2]。SRAM中的每一bit储存在由4个场效应管（M1, M2, M3, M4）构成两个交叉耦合的反相器中。另外两个场效应管（M5, M6）是储存基本单元到用于读写的位线（Bit Line）的控制开关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SRAM_Cell_(6_Transistors).svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;非易失性存储器主要为只读存储器rom&#34;&gt;非易失性存储器（主要为只读存储器，ROM）&lt;/h2&gt;
&lt;p&gt;Read-Only Memory，一旦存储资料就无法再将之改变或删除，且内容不会因为电源关闭而消失。&lt;/p&gt;
&lt;h3 id=&#34;可编程式只读存储器prom&#34;&gt;可编程式只读存储器（PROM）&lt;/h3&gt;
&lt;p&gt;Programmable read-only memory，每个比特都由熔丝或反熔丝的状态决定资料内容。这种存储器用作永久存放程序之用。常用于电子游戏机、电子词典等预存固定资料或程序的各式电子产品之上。PROM与狭义的ROM（Mask ROM）的差别在于前者可在IC制造完成后才依需要写入资料，后者的资料需在制造IC时一并制作在里面。&lt;/p&gt;
&lt;p&gt;一个典型的PROM一开始时每个比特都会是1，编程中如将该比特的熔丝（fuse）烧断则成为0，这一过程是不可逆的（即刻录后不能再改变），断电后也不会消失记忆，所以这种存储器是一种只读存储器。&lt;/p&gt;
&lt;h3 id=&#34;可擦除可编程式只读存储器eprom&#34;&gt;可擦除可编程式只读存储器（EPROM）&lt;/h3&gt;
&lt;p&gt;Erasable Programmable Read Only Memory，它是一组浮栅晶体管，被一个提供比电子电路中常用电压更高电压的电子器件分别编程。一旦编程完成后，EPROM只能用强紫外线照射来擦除。通过封装顶部能看见硅片的透明窗口，很容易识别EPROM，这个窗口同时用来进行紫外线擦除。&lt;/p&gt;
&lt;h3 id=&#34;电子抹除式可复写只读存储器eeprom&#34;&gt;电子抹除式可复写只读存储器（EEPROM）&lt;/h3&gt;
&lt;p&gt;Electrically-Erasable Programmable Read-Only Memory，是一种可以通过电子方式多次复写的半导体存储设备。相比EPROM， EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据， EEPROM 属于SPD（串行存在检测）技术的一种延伸。&lt;/p&gt;
&lt;p&gt;在民用的DDR SDRAM及其主流后续产品中，一般 EEPROM 主要用于保存内存的开发者信息、生产时间、内存信息、通信协议、既定内存频率、供电电压、供电电流、物理信息以及内存XMP等信息，并且电脑会在开机自检（Power-On Self-Test；POST）时会读取这些信息以保持电脑的正常开机。&lt;/p&gt;
&lt;h3 id=&#34;闪存flash-memory&#34;&gt;闪存（Flash Memory）&lt;/h3&gt;
&lt;p&gt;闪存是一种特殊的、以宏块抹写的EEPROM。&lt;/p&gt;
&lt;p&gt;NOR和NAND两种类型&lt;/p&gt;
&lt;h4 id=&#34;nand-flash&#34;&gt;NAND Flash&lt;/h4&gt;
&lt;p&gt;SLC(单阶存储单元)、MLC(多阶存储单元，一般指2)、TLC(三阶存储单元)、QLC&lt;/p&gt;
&lt;p&gt;现在消费级产品都是TLC&lt;/p&gt;
&lt;h4 id=&#34;移动端使用的闪存协议变化&#34;&gt;移动端使用的闪存协议变化&lt;/h4&gt;
&lt;p&gt;eMMC-UFS&lt;/p&gt;- https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH09 顺序容器</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Tue, 15 Jun 2021 15:36:20 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ -&lt;p&gt;顺序容器&lt;/p&gt;
&lt;p&gt;一个容器就是一些特定类型对象的集合。&lt;/p&gt;
&lt;p&gt;顺序容器提供了&lt;strong&gt;控制元素存储&lt;/strong&gt;和&lt;strong&gt;访问顺序&lt;/strong&gt;的能力。这种顺序与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;p&gt;关联容器与顺序容器有着根本不同，关联容器中的元素是按照&lt;strong&gt;关键词&lt;/strong&gt;来保存和访问的，即&lt;strong&gt;Key-Value&lt;/strong&gt;；与之相对的是顺序容器中的元素按照它们在容器中的位置来顺序保存和访问。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;顺序容器都提供了&lt;strong&gt;快速顺序访问元素&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;顺序容器类型(名称)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;性能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vector&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可变大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在尾部之外的位置插入删除元素很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;deque&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双端队列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在头尾插入删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双向链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持双向顺序访问。在list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forward_list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单项链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持单项顺序访问。在forward_list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;array&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。不能添加删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;与vector相似的容器，专门用于保存字符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随机访问快，在尾部插入删除速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了固定大小的array外，其他容器都提供高效的内存管理。容器保存元素的策略对容器操作的效率有着很大影响。&lt;/p&gt;
&lt;p&gt;string和vector将元素保存在&lt;strong&gt;连续的内存空间&lt;/strong&gt;中，因此由元素的下标来计算其地址非常快速。但在这两种容器的中间位置插入和删除元素的速度非常慢，因为一次插入或删除后，需要移动插入、删除位置后的&lt;strong&gt;所有元素&lt;/strong&gt;以保证存储的连续。&lt;/p&gt;
&lt;p&gt;list和forward_list两个容器能令任何位置的添加和删除操作都很快，但这两种容器&lt;strong&gt;不支持随机访问&lt;/strong&gt;，因为元素保存的内存空间不连续，只能通过遍历整个容器来访问一个元素。与vector和string相比，额外内存开销也很大。&lt;/p&gt;
&lt;p&gt;forward_list与最好的手写单向链表数据结构性能相当，因此没有size操作，因为保存或计算大小会多出额外开销。&lt;/p&gt;
&lt;p&gt;deque支持快读随机访问，在该容器中间位置添加或删除元素速度很慢，但在两端很快。&lt;/p&gt;
&lt;h2 id=&#34;容器库概览&#34;&gt;容器库概览&lt;/h2&gt;
&lt;p&gt;容器类型上的操作分成了层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些操作式所有容器都提供的；&lt;/li&gt;
&lt;li&gt;另外一些操作仅针对顺序容器、关联容器或无序容器；&lt;/li&gt;
&lt;li&gt;还有一些操作只适合一小部分容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器通过&lt;strong&gt;尖括号&lt;/strong&gt;指定类型。&lt;/p&gt;
&lt;h3 id=&#34;容器操作&#34;&gt;容器操作&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;iterator
size_type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*iter	//返回迭代器iter所指元素的引用
iter-&amp;gt;name	//解引用iter并获取该元素的名为mem的成员
++iter	//令iter指示容器中的下一个元素
--iter	//令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个&lt;strong&gt;迭代器范围&lt;/strong&gt;由一对迭代器表示，这两个迭代器被称为begin和end，begin指向容器第一个元素，end指向容器的&lt;strong&gt;尾后元素&lt;/strong&gt;，这种元素范围被称为&lt;strong&gt;左闭合区间&lt;/strong&gt;，即&lt;code&gt;[begin, end)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对构成范围的迭代器的要求：&lt;strong&gt;end不在begin之前&lt;/strong&gt;。可以通过对begin进行若干次递增，使得begin==end。&lt;/p&gt;
&lt;h3 id=&#34;容器类型成员&#34;&gt;容器类型成员&lt;/h3&gt;
&lt;p&gt;每个容器都定义了多个类型。如之前使用过的&lt;code&gt;interator&lt;/code&gt;、&lt;code&gt;size_type&lt;/code&gt;等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;interator
const_iterator
size_type
difference_type
value_type
reference
const_reference
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;iterator iter;
vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;begin和end成员&#34;&gt;begin和end成员&lt;/h3&gt;
&lt;p&gt;begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。还有不同类型的反向迭代器、const迭代器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;list&amp;lt;int&amp;gt; a = {1, 2, 3};
auto it1 = a.begin();	//list&amp;lt;int&amp;gt;::iterator
auto it2 = a.rbegin();	//反向迭代器 list&amp;lt;int&amp;gt;::reverse_iterator
auto it3 = a.cbegin();	//const迭代器 list&amp;lt;int&amp;gt;::const_iterator
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;容器定义和初始化&#34;&gt;容器定义和初始化&lt;/h3&gt;
&lt;p&gt;每个容器类型都定义了一个默认构造函数。除了array外，其他容器的默认构造函数都会创建一个指定类型的空容器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C c;	//默认构造函数
C c1(c2)	//c1初始化为c2的拷贝。两者必须是相同类型的容器
C c{a,b,c...}	//c初始化为初始化列表中元素的拷贝
C c(b,e)	//c初始化为迭代器b和e指定范围中元素的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与顺序容器（除了array）大小相关的一个构造函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ivec(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int元素，每个都初始化为1
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; scev(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个元素，每个都是空string
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标准库array具有固定大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存42个int的数组
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存10个string的数组
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用array时必须同时指定&lt;strong&gt;元素类型&lt;/strong&gt;和&lt;strong&gt;大小&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;size_type j;	&lt;span style=&#34;color:#888&#34;&gt;//错误，未指定大小
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个默认构造的array是非空的，它包含了与其大小一样多的元素，这些元素都被默认初始化。&lt;/p&gt;
&lt;h3 id=&#34;赋值和swap&#34;&gt;赋值和swap&lt;/h3&gt;
&lt;p&gt;赋值将左边容器中的所有元素替换为右边容器中元素的拷贝。如果两个容器原来大小不同，赋值运算后两者大小都与右边容器的原大小相等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; c2;	&lt;span style=&#34;color:#888&#34;&gt;//将c1替换为c2中元素的拷贝，拷贝后c1的大小与原c2相同
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {a, b, c}
swap(c1, c2)
c1.swap(c2)	&lt;span style=&#34;color:#888&#34;&gt;//与上一个等价
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//assign操作不适用于关联容器和array
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为迭代器b和e所表示范围的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(il)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为初始化列表il中的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(n,t)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为n个值为t的元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;assign用参数所指定的元素拷贝替换左边容器中所有元素。assign操作不适用于array和关联容器。&lt;/p&gt;
&lt;p&gt;swap只是交换了两个容器内部的&lt;strong&gt;数据结构&lt;/strong&gt;，但例外是swap两个array会真正交换它们的元素。&lt;/p&gt;
&lt;h3 id=&#34;容器大小操作&#34;&gt;容器大小操作&lt;/h3&gt;
&lt;p&gt;成员函数&lt;code&gt;size&lt;/code&gt;返回容器中元素的数目；&lt;code&gt;empty&lt;/code&gt;当size为0时返回布尔值true，否则返回false；&lt;code&gt;max_size&lt;/code&gt;返回一个大于或等于该类型容器所能容纳的最大元素数的值。&lt;/p&gt;
&lt;p&gt;forward_list支持&lt;code&gt;max_size&lt;/code&gt;和&lt;code&gt;empty&lt;/code&gt;但不支持size。&lt;/p&gt;
&lt;h3 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;每个容器类型都支持相等运算符(即&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;)；除&lt;strong&gt;无序关联容器&lt;/strong&gt;外的所有容器都支持关系运算符(&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=)。&lt;/p&gt;
&lt;p&gt;关系运算符左右两边的运算对象必须是&lt;strong&gt;相同类型的容器&lt;/strong&gt;，且保存&lt;strong&gt;元素的类型也必须相等&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顺序容器操作&#34;&gt;顺序容器操作&lt;/h2&gt;
&lt;p&gt;顺序容器和关联容器的不同在于两者&lt;strong&gt;组织元素的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了上一节介绍的&lt;strong&gt;所有容器都支持的操作外&lt;/strong&gt;，本章剩余部分将介绍顺序容器的所有操作。&lt;/p&gt;
&lt;h4 id=&#34;向顺序容器添加元素&#34;&gt;向顺序容器添加元素&lt;/h4&gt;
&lt;p&gt;向顺序容器中除了array外添加元素的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.push_back(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的尾部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_back(args)
c.push_front(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的头部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_front(args)
c.insert(p,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前创建一个值为t的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,n,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,b,e)			&lt;span style=&#34;color:#888&#34;&gt;//将迭代器b和e指向范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,il)			&lt;span style=&#34;color:#888&#34;&gt;//il为一个花括号包围的元素值列表，将这些值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;forword_list&lt;/code&gt;不支持&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;emplace_back&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持&lt;code&gt;push_front&lt;/code&gt;和&lt;code&gt;emplace_front&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;使用这些操作时要注意策略，根据不同容器的&lt;strong&gt;不同数据结构的特性&lt;/strong&gt;来使用。&lt;/p&gt;
&lt;p&gt;emplace操作构造而不是拷贝元素，将参数传递给元素类型的构造函数，直接构造元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_back&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了array和forward_list外，每个顺序容器都支持该操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_front&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;list、forward_list和deque容器还支持&lt;code&gt;push_front&lt;/code&gt;，此操作将元素插入容器头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器特定为止添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;insert成员匀速我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。&lt;/p&gt;
&lt;p&gt;每个insert都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。&lt;/p&gt;
&lt;p&gt;insert函数还可以接受更多参数，其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;svec.insert(svec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用emplace操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++11引入了三个新成员——emplace_front、emplace和emplace_back，这些操作&lt;strong&gt;构造&lt;/strong&gt;而不是拷贝元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.emplace_back(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;123445&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;15.99&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在c的末位构造一个Sales_data对象。&lt;/p&gt;
&lt;h4 id=&#34;访问元素&#34;&gt;访问元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.back()		&lt;span style=&#34;color:#888&#34;&gt;//返回c中尾元素的引用，若c为空，则函数行为未定义。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.front()		&lt;span style=&#34;color:#888&#34;&gt;//范围c中首元素的引用
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c[n]			&lt;span style=&#34;color:#888&#34;&gt;//返回c中下标为n的元素的引用，n是一个无符号整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.at(n)			&lt;span style=&#34;color:#888&#34;&gt;//返回下标为n的元素的引用，若下标越界，则返回out_of_range异常
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;at和下标操作只适用于string、vector、array和deque&lt;/p&gt;
&lt;p&gt;back不适用于forward_list&lt;/p&gt;
&lt;p&gt;以上访问元素的成员函数返回的都是&lt;strong&gt;引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;删除元素&#34;&gt;删除元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.pop_back()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中尾元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.pop_front()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中首元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器p所指元素，返回一个指向被删元素之后元素的迭代器；若p指向尾元素，则返回尾后迭代器；若p是尾后迭代器，则函数行为未定义
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若e本身就是尾后迭代器，则也返回尾后迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.clear()		&lt;span style=&#34;color:#888&#34;&gt;//删除c中所有元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;forward_list有特殊erase，且不支持pop_back.&lt;/p&gt;
&lt;p&gt;vector和string不支持pop_front.&lt;/p&gt;
&lt;p&gt;erase从容器中指定位置删除元素，还可以使用一对迭代器，删除一个范围内的元素。&lt;/p&gt;
&lt;h4 id=&#34;特殊的forward_list操作&#34;&gt;特殊的forward_list操作&lt;/h4&gt;
&lt;p&gt;在链表中添加或删除一个链接，会改变序列中的链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.before_begin()		&lt;span style=&#34;color:#888&#34;&gt;//返回指向链表首元素之前不存在的元素迭代器，该迭代器不能解引用。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,t)	&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的为止插入元素，t是一个对象，n是数量，b和e是一对迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)	&lt;span style=&#34;color:#888&#34;&gt;//il是一个花括号列表
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的位置插入元素，t是一个对象，n是数量，b和e是表示范围的一对迭代器，il是一个花括号列表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;emplace_after(p,args)	&lt;span style=&#34;color:#888&#34;&gt;//使用args在p指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除p指向位置之后的元素，或删除从b之后直到e之间的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(b,e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在forward_list中添加或删除元素时，我们要关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱。&lt;/p&gt;
&lt;h4 id=&#34;改变容器大小&#34;&gt;改变容器大小&lt;/h4&gt;
&lt;p&gt;可以使用resize来增大或缩小容器。&lt;strong&gt;array不支持resize&lt;/strong&gt;。若当前大小大于所要求的大小，则容器后部的元素会被删除；所当前大小小于新大小，则将新元素添加到容器后部。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ilist(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int：每个的值都是43
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;15&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将5个值为0的元素添加到ilist末尾
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;,&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将10个值为1的元素添加到ilist末尾
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;容器操作可能使迭代器失效&#34;&gt;容器操作可能使迭代器失效&lt;/h4&gt;
&lt;p&gt;根据不同容器在内存中存储的方式不同，向容器中添加或删除元素会导致不同类型的迭代器失效。&lt;/p&gt;
&lt;h2 id=&#34;vector对象的增长&#34;&gt;vector对象的增长&lt;/h2&gt;
&lt;p&gt;vector和string的实现通常会分配比新的空间需求&lt;strong&gt;更大的内存空间&lt;/strong&gt;，容器预留这些空间作为&lt;strong&gt;备份&lt;/strong&gt;，可用来保存更多的新元素，这样就不需要每次添加新元素都重新分配容器的内存空间了。&lt;/p&gt;
&lt;p&gt;以下是vector和string提供的一些管理容量的成员函数，允许我们与它的实现中内存分配部分互动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.shrink_to_fit()		&lt;span style=&#34;color:#888&#34;&gt;//将capacity减少为与size()相同大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.capacity()			&lt;span style=&#34;color:#888&#34;&gt;//不重新分配内存空间的话，c可以保存多少元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.reserve(n)			&lt;span style=&#34;color:#888&#34;&gt;//分配至少能容纳n个元素的内存空间
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;reserve不改变容器中元素数量，只影响预先分配内存空间的大小。&lt;/p&gt;
&lt;p&gt;shrink_to_fit只适用于vector、string和deque。&lt;/p&gt;
&lt;p&gt;capacity、reserve只适用于vector、string。&lt;/p&gt;
&lt;h2 id=&#34;额外的string操作&#34;&gt;额外的string操作&lt;/h2&gt;
&lt;p&gt;这些操作大部分是提供&lt;strong&gt;string类和C风格字符数组&lt;/strong&gt;之间的&lt;strong&gt;相互转换&lt;/strong&gt;，或者增加了允许我们用&lt;strong&gt;下标&lt;/strong&gt;代替迭代器。&lt;/p&gt;
&lt;h4 id=&#34;构造string的其他方法&#34;&gt;构造string的其他方法&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string s(cp, n)		//s是cp指向的数组中前n个字符的拷贝。
string s(s2, pos2)	//s是string s2从下标pos2开始的字符的拷贝。
string s(s2, pos2, len2)	//s是string s2从下标pos2开始len2个字符的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些构造函数接受一个string或一个const char*参数，还接受指定拷贝多少个字符的参数。当传递给他一个string时，还可指定一个下标指出从哪里开始拷贝。&lt;/p&gt;
&lt;p&gt;substr操作返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.substr(pos, n)	&lt;span style=&#34;color:#888&#34;&gt;//返回一个string，包含s中从pos位置开始的n个字符的拷贝。pos的默认值为0.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果开始位置超出了string的大小，则substr抛出一个&lt;code&gt;out_of_range&lt;/code&gt;异常。若开始位置加上计数值大于string的大小，则substr只会拷贝到string的末尾。&lt;/p&gt;
&lt;h4 id=&#34;改变string的其他方法&#34;&gt;改变string的其他方法&lt;/h4&gt;
&lt;p&gt;定义了额外的insert和erase版本，还定义了两个额外的成员函数append和replace。&lt;/p&gt;
&lt;p&gt;除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到指定值之前的位置：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;s.insert(s.size(), 5, &#39;!&#39;);		//在s末尾插入5个!
s.erase(s.size() - 5, 5);		//删除s的最后5个元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;append操作是在string末尾进行插入操作的一种简写。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stirng &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;s&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;C++ Primer&amp;#34;&lt;/span&gt;), s2 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; s;
s.insert(s.size(), &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; 4th Ed.&amp;#34;&lt;/span&gt;);
s2.append(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; 4th Ed.&amp;#34;&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//两种写法等价
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;replace操作是调用erase和insert的一种简写形式。&lt;/p&gt;
&lt;h4 id=&#34;string搜索&#34;&gt;string搜索&lt;/h4&gt;
&lt;p&gt;string类提供了6个不同的搜索函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.find(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.rfind(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args最后一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_first_of(args)	&lt;span style=&#34;color:#888&#34;&gt;//在s中查找args中任何一个字符第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_last_of(args)
s.find_first_not_of(args)
s.find_last_not_of(args)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;compare函数&#34;&gt;compare函数&lt;/h4&gt;
&lt;p&gt;标准库string还提供了一组compare函数，根据s是等于、大于还是小于参数指定的字符串，&lt;code&gt;s.compare&lt;/code&gt;返回0、整数或负数。类似于C标准库的strcmp函数。&lt;/p&gt;
&lt;p&gt;s.compare有6个版本的参数形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.compare(s2)						&lt;span style=&#34;color:#888&#34;&gt;//比较s和s2
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.compare(pos1, n1, s2)				&lt;span style=&#34;color:#888&#34;&gt;//将s中从pos1开始的n1个字符与s2作比较
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.compare(pos1, n1, s2, pos2, n2)
s.compare(cp)						&lt;span style=&#34;color:#888&#34;&gt;//比较s与cp指向的以空字符结尾的字符数组
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.compare(pos1, n1, cp)
s.compare(pos1, n1, cp, n2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;数值转换&#34;&gt;数值转换&lt;/h4&gt;
&lt;p&gt;string和数值之间的转换&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;to_string(val)
&lt;span style=&#34;color:#888&#34;&gt;//b表示转换用的基数，默认为10；p保存s中第一个非数值字符的下标，默认为0，即不保存下标
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stoi(s, p, b)	&lt;span style=&#34;color:#888&#34;&gt;//string to int
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stol(s, p, b)	&lt;span style=&#34;color:#888&#34;&gt;//string to long
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stoll(s, p, b)	&lt;span style=&#34;color:#888&#34;&gt;//stirng to long long
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stof(s, p)		&lt;span style=&#34;color:#888&#34;&gt;//string to float
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stod(s, p)		&lt;span style=&#34;color:#888&#34;&gt;//string to double
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;stold(s, p)		&lt;span style=&#34;color:#888&#34;&gt;//string to long double
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h2&gt;
&lt;p&gt;除顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priority_queue&lt;/p&gt;
&lt;p&gt;一个适配器是一种机制，能使某种事物看起来像另一种事物。&lt;/p&gt;
&lt;p&gt;一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。&lt;/p&gt;
&lt;p&gt;例如，stack适配器接受一个顺序容器，并使其操作起来像一个stack一样。&lt;/p&gt;
&lt;p&gt;所有容器适配器&lt;strong&gt;都支持的操作和类型&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;size_type		&lt;span style=&#34;color:#888&#34;&gt;//一种类型，足够保存当前类型的最大对象的大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;value_type
container_type	&lt;span style=&#34;color:#888&#34;&gt;//实现适配器的底层容器类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A a;			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的空适配器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;a&lt;/span&gt;(c);			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的适配器，带有容器c的一个拷贝
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;关系运算符&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;等等&lt;/span&gt;
a.empty()
a.size()
swap(a,b)		&lt;span style=&#34;color:#888&#34;&gt;//交换a、b的内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;a.swap(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;定义一个适配器&#34;&gt;定义一个适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; stk(deq);	&lt;span style=&#34;color:#888&#34;&gt;//deq是一个deque&amp;lt;int&amp;gt;，从deq拷贝元素到stk
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;栈适配器&#34;&gt;栈适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; intStack;	&lt;span style=&#34;color:#888&#34;&gt;//声明一个空栈
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他一些栈操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.pop()
s.push(item)	&lt;span style=&#34;color:#888&#34;&gt;//创建一个新元素压入栈顶，该元素通过拷贝或移动item实现，或有args构造
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.emplace(args)
s.top()			&lt;span style=&#34;color:#888&#34;&gt;//返回栈顶元素，但不讲栈弹出
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;队列适配器&#34;&gt;队列适配器&lt;/h4&gt;
&lt;p&gt;queue和priority_queue适配器定义在queue头文件。&lt;/p&gt;
&lt;p&gt;标准库queue是一种FIFO的策略。底层是基于deque的。只是限制其不能进行随机访问。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 1.计算机系统漫游</title>
        <link>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link>
        <pubDate>Fri, 11 Jun 2021 12:18:22 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ -&lt;p&gt;在本书中我们将会学习到一些使用技巧，比如如何避免由于&lt;strong&gt;计算机表示数字的方式&lt;/strong&gt;引起的错误；通过一些技巧&lt;strong&gt;优化C代码&lt;/strong&gt;，以充分利用现代处理器和存储器系统的设计；了解&lt;strong&gt;编译器&lt;/strong&gt;如何实现过程调用，利用这些知识避免&lt;strong&gt;缓冲区溢出&lt;/strong&gt;错误带来的安全漏洞；学习如何识别和避免&lt;strong&gt;链接&lt;/strong&gt;时的错误；如何编写Unix Shell、动态存储分配包、Web服务器；&lt;strong&gt;并发&lt;/strong&gt;带来的希望和陷阱，对于现在的单芯片集成多个处理器核心非常重要。&lt;/p&gt;
&lt;p&gt;我们通过围绕Hello程序执行时的整个生命周期来对系统进行学习：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Hello, world&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;信息就是位上下文&#34;&gt;信息就是位+上下文&lt;/h2&gt;
&lt;p&gt;8位为一个字节。&lt;/p&gt;
&lt;p&gt;现代计算机系统使用ASCII标准来表示文本字符。即用一个&lt;strong&gt;单字节&lt;/strong&gt;大小的整数值表示一个符号。&lt;/p&gt;
&lt;p&gt;数字的机器表示是对真值的有限近似。&lt;/p&gt;
&lt;h2 id=&#34;程序被翻译为不同的格式&#34;&gt;程序被翻译为不同的格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hello.c&lt;/code&gt;中的每条C语句都会转换为一系列低级&lt;strong&gt;机器语言&lt;/strong&gt;指令。这些指令按照&lt;strong&gt;可执行目标程序&lt;/strong&gt;格式打包，以二进制磁盘文件的形式存放。&lt;/p&gt;
&lt;p&gt;编译系统：&lt;/p&gt;
&lt;p&gt;hello.c(源程序，文本) -&amp;gt; &lt;code&gt;预处理器(cpp)&lt;/code&gt; -&amp;gt; hello.i(修改了的源程序，文本) -&amp;gt; &lt;code&gt;编译器(ccl)&lt;/code&gt; -&amp;gt; hello.s(汇编程序，文本) -&amp;gt; &lt;code&gt;汇编器&lt;/code&gt; -&amp;gt; hello.o(可重定位目标程序，二进制) -&amp;gt; &lt;code&gt;链接器&lt;/code&gt; -&amp;gt; hello(可执行目标程序，二进制)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：预处理器(cpp)根据以字符&lt;code&gt;#&lt;/code&gt;开头的命令，修改原始C程序。例如&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;告诉预处理器读取系统头文件的内容，将其插入程序文本中，得到另一个C程序，以&lt;code&gt;.i&lt;/code&gt;为扩展名。&lt;/li&gt;
&lt;li&gt;编译阶段：编译器(ccl将&lt;code&gt;hello.i&lt;/code&gt;翻译为&lt;code&gt;hello.s&lt;/code&gt;，其包含了&lt;strong&gt;汇编语言程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;汇编阶段：汇编器(as)将&lt;code&gt;hello.s&lt;/code&gt;翻译为&lt;strong&gt;机器语言指令&lt;/strong&gt;，将这些指令打包为&lt;strong&gt;可重定位目标程序&lt;/strong&gt;，将结果保存在&lt;code&gt;hello.o&lt;/code&gt;中，该文件为二进制文件。&lt;/li&gt;
&lt;li&gt;链接阶段：hello程序调用了printf函数，它是C编译器提供的标准C库中的一个函数，printf函数存在于一个名为&lt;code&gt;printf.o&lt;/code&gt;的单独预编译好的目标文件中，这个文件要以某种形式合并到我们的&lt;code&gt;hello.o&lt;/code&gt;程序中，链接器(ld)负责这种合并，合并后就得到了&lt;strong&gt;可执行目标文件&lt;/strong&gt;&lt;code&gt;hello&lt;/code&gt;，其可以被加载到内存中，由系统执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器的工作方式&#34;&gt;编译器的工作方式&lt;/h2&gt;
&lt;p&gt;有一些重要原因使得我们必须知道编译器的工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化程序性能。我们需要了解一些机器代码及编译器将不同C语句转化为机器代码的方式，例如一个switch语句是否总比一系列if-else语句高效。&lt;/li&gt;
&lt;li&gt;理解链接时出现的错误。&lt;/li&gt;
&lt;li&gt;避免安全漏洞。缓冲区溢出错误是大多网络和服务器安全漏洞的主要原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;处理器读取并解释储存在内存中的指令&#34;&gt;处理器读取并解释储存在内存中的指令&lt;/h2&gt;
&lt;p&gt;要在Unix系统运行可执行目标文件hello，需要将文件名输入shell应用程序中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./hello
hello,world
linux&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h3&gt;
&lt;h4 id=&#34;总线&#34;&gt;总线&lt;/h4&gt;
&lt;p&gt;贯穿整个系统，负责信息字节在各个部件之间传递。&lt;/p&gt;
&lt;p&gt;通常被设计为传送定长的字节块，即&lt;strong&gt;字&lt;/strong&gt;，字中的字节数（即字长）是基本的系统参数，如今大多数机器中字长为8字节(即64位)，4字节(32位)在逐渐被64位取代。&lt;/p&gt;
&lt;h4 id=&#34;io设备&#34;&gt;I/O设备&lt;/h4&gt;
&lt;p&gt;每个I/O设备通过&lt;strong&gt;控制器或适配器&lt;/strong&gt;与I/O总线相连，控制器为I/O设备本身或系统主板上的芯片组，适配器为插在主板插槽上的卡。&lt;/p&gt;
&lt;h4 id=&#34;主存ram&#34;&gt;主存RAM&lt;/h4&gt;
&lt;p&gt;临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。由一组&lt;strong&gt;动态随机存取存储器(DRAM)&lt;strong&gt;芯片组成。逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的&lt;/strong&gt;地址&lt;/strong&gt;(数组索引)，这些地址从零开始。&lt;/p&gt;
&lt;h4 id=&#34;处理器&#34;&gt;处理器&lt;/h4&gt;
&lt;p&gt;CPU是解释或执行存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备(&lt;strong&gt;寄存器&lt;/strong&gt;)，称为程序计数器(PC)，PC指向主存中的某条机器语言指令（即包含该指令的地址）。&lt;/p&gt;
&lt;p&gt;处理器在一直不停地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个简单的指令执行模型来操作的，这个模型是&lt;strong&gt;指令集架构&lt;/strong&gt;决定的。该模型中指令按照严格的顺序执行。执行一条指令包含一系列步骤，处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，循环操作。&lt;/p&gt;
&lt;p&gt;这样的简单操作并不多，主要围绕**主存、寄存器文件和ALU(算术逻辑单元)**进行。寄存器文件是一个小型存储设备，由一些单个字长的寄存器组成，ALU计算新的数据和地址值。CPU可能进行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载：从主存读取一个字到寄存器&lt;/li&gt;
&lt;li&gt;存储：从寄存器赋值一个字到主存&lt;/li&gt;
&lt;li&gt;操作：将两个寄存器的内容复制到ALU，ALU对两个字进行算术运算，将结果存放到一个寄存器中&lt;/li&gt;
&lt;li&gt;跳转：从指令本身抽取一个字，将这个字复制到PC中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令集架构：每条机器代码指令的效果&lt;/p&gt;
&lt;p&gt;微体系结构：处理器实际上是如何实现的&lt;/p&gt;
&lt;h3 id=&#34;运行hello程序&#34;&gt;运行hello程序&lt;/h3&gt;
&lt;p&gt;在键盘上输入&lt;code&gt;.\hello&lt;/code&gt;后，shell会将这些字符逐一读入寄存器，再将其存放到内存中。按下回车后，shell知道命令输入已经结束，将执行一系列指令加载hello文件，这些指令会将hello目标文件中的代码和数据从磁盘复制到主存，利用DMA(直接存储器存取)技术，可将数据不经过CPU直接从磁盘放入主存。&lt;/p&gt;
&lt;p&gt;目标文件hello被放入主存后，处理器就开始执行机器语言指令。&lt;/p&gt;
&lt;h2 id=&#34;高速缓存&#34;&gt;高速缓存&lt;/h2&gt;
&lt;p&gt;为了减少信息加载的时间，采用更小更快的存储设备作为数据或指令暂时的集结区域。处理器芯片上的L1高速缓存缓存的访问速度集合和访问寄存器文件一样快，容量更大的L2高速缓存通过特殊总线连接到寄处理器。高速缓存采用静态随机访问存储器（SRAM）技术实现。&lt;/p&gt;
&lt;h2 id=&#34;存储器层次&#34;&gt;存储器层次：&lt;/h2&gt;
&lt;p&gt;L0：寄存器&lt;/p&gt;
&lt;p&gt;L1：L1高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L2：L2高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L3：L3高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L4：主存（DRAM）&lt;/p&gt;
&lt;p&gt;L5：本地磁盘&lt;/p&gt;
&lt;p&gt;L6：远程存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%BE%E4%BE%8B.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图为我的电脑的三级缓存示意。&lt;/p&gt;
&lt;h2 id=&#34;操作系统管理硬件&#34;&gt;操作系统管理硬件&lt;/h2&gt;
&lt;p&gt;前面的shell程序和hello程序都依靠&lt;strong&gt;操作系统&lt;/strong&gt;提供的服务访问存储器。操作系统是应用程序和硬件之间的软件。&lt;/p&gt;
&lt;p&gt;操作系统的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;
&lt;li&gt;向应用程序提供简单的机制控制复杂又不同的低级硬件设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统通过几个基本抽象概念：进程、虚拟内存和文件实现这些功能。&lt;/p&gt;
&lt;p&gt;文件是对I/O设备的抽象。&lt;/p&gt;
&lt;p&gt;虚拟内存是对主存和磁盘I/O设备的抽象。&lt;/p&gt;
&lt;p&gt;进程是对处理器、主存和磁盘I/O设备的抽象。&lt;/p&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;p&gt;进程是操作系统对正在运行程序的一种抽象，一个系统可以同时运行多个进行，每个进程好像都在独占使用硬件。并发运行指的是多个不同程序进程指令交错运行。处理器通过在进程间切换来实现多个程序的并发运行，这种机制称为&lt;strong&gt;上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;操作系统保存跟踪进程运行所需要的所有状态信息，这种状态即为上下文。这些信息有很多，比如PC和寄存器文件的当前值。&lt;/p&gt;
&lt;p&gt;任何一个时刻，单处理器只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到新进程时，就会进行上下文切换。&lt;/p&gt;
&lt;p&gt;从一个进程到另一个进程的切换是操作系统内核（kernal）管理的。&lt;strong&gt;内核&lt;/strong&gt;是操作系统代码&lt;strong&gt;常驻主存&lt;/strong&gt;的部分。内核不是一个独立的进程，是系统管理全部进程所用的代码和数据结构的集合。&lt;/p&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;p&gt;一个进程可以有多个成为线程的执行单元组成，每个线程都运行在进程的上下文中，共享同样的代码和全部数据。多线程相比多进程更容易共享数据。&lt;/p&gt;
&lt;h3 id=&#34;虚拟内存&#34;&gt;虚拟内存&lt;/h3&gt;
&lt;p&gt;虚拟内存为每个进程提供一个假象，即每个进程都在&lt;strong&gt;独占地使用主存&lt;/strong&gt;。每个进程看到内存都是一致的，成为虚拟地址空间。&lt;/p&gt;
&lt;p&gt;每个进程看到的虚拟地址由大量准确定义的&lt;strong&gt;区&lt;/strong&gt;构成，每个区都有专门的功能。以下从最低的地址逐步向上介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序代码和数据：所有进程的代码是从同一固定地址开始，紧接着是和C全局变量对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。&lt;/li&gt;
&lt;li&gt;堆：当调用malloc和free这样的函数时，堆可以动态地扩展和收缩。&lt;/li&gt;
&lt;li&gt;共享库：是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。&lt;/li&gt;
&lt;li&gt;栈：编译器用它来实现函数调用，栈在程序执行期间可以动态扩展和收缩。&lt;/li&gt;
&lt;li&gt;内核虚拟内存：地址空间顶部区域是为内核保留的，不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;
&lt;p&gt;文件就是字节序列，系统所有输入输出都是通过使用一小组成为Unix I/O的系统函数调用读写文件实现的。&lt;/p&gt;
&lt;h2 id=&#34;系统之间利用网络通信&#34;&gt;系统之间利用网络通信&lt;/h2&gt;
&lt;p&gt;网络是一个I/O设备，通过网络适配器连接到系统总线。&lt;/p&gt;
&lt;h2 id=&#34;一些重要主题&#34;&gt;一些重要主题&lt;/h2&gt;
&lt;h3 id=&#34;并发和并行&#34;&gt;并发和并行&lt;/h3&gt;
&lt;p&gt;并发：一个同时具有多个活动的系统&lt;/p&gt;
&lt;p&gt;并行：用并发使得一个系统运行得更快&lt;/p&gt;
&lt;p&gt;并行可以在计算机系统的多个抽象层次上运行。&lt;/p&gt;
&lt;h4 id=&#34;线程级并发&#34;&gt;线程级并发&lt;/h4&gt;
&lt;h4 id=&#34;指令级并发&#34;&gt;指令级并发&lt;/h4&gt;
&lt;h4 id=&#34;单指令多数据并行&#34;&gt;单指令、多数据并行&lt;/h4&gt;
&lt;h3 id=&#34;计算机系统中抽象的重要性&#34;&gt;计算机系统中抽象的重要性&lt;/h3&gt;
&lt;p&gt;文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，进程是对正在运行程序的抽象，虚拟机提供对整个计算机的抽象。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 