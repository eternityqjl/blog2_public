<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jialong's Blog</title><link>https://eternityqjl.github.io/blog2_public/</link><description>Recent content on Jialong's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2019-2021 By Jialong</copyright><lastBuildDate>Fri, 13 Aug 2021 16:15:00 +0800</lastBuildDate><atom:link href="https://eternityqjl.github.io/blog2_public/index.xml" rel="self" type="application/rss+xml"/><item><title>串行通信协议详解：SPI、I2C、UART、JTAG</title><link>https://eternityqjl.github.io/blog2_public/posts/%E4%B8%B2%E5%8F%A3/</link><pubDate>Fri, 05 Feb 2021 18:20:54 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E4%B8%B2%E5%8F%A3/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E4%B8%B2%E5%8F%A3/ -&lt;p>SPI、I2C、UART：串行通信协议&lt;/p>
&lt;p>COM口：串行通信端口，是物理接口形式（硬件），一般有4针杜邦头和D型9针插头两种。可以有很多种协议&lt;/p>
&lt;p>TTL、RS-232指的是电平标准&lt;/p>
&lt;p>TTL电平：低电平为0，高电平为1&lt;/p>
&lt;p>RS-232电平：正电平(+15V)为0，负电平(-15V)为1&lt;/p>
&lt;p>最近在画PCB研究几个MCU的时候遇到引脚连接方面的一些问题，对于MCU进行串行通信传输数据的过程不太了解，因此写一篇博客来学习一下这些通信协议。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="一些概念">一些概念&lt;/h2>
&lt;h3 id="同步synchronous和异步asynchronous">同步(Synchronous)和异步(Asynchronous)&lt;/h3>
&lt;p>&lt;strong>同步&lt;/strong>就是整个处理过程顺序执行，当各个过程都执行完毕后，返回结果。这是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序。&lt;/p>
&lt;p>&lt;strong>异步&lt;/strong>：是只发送了调用的命令，调用者无需等待被调用的方法完全执行完毕，可以继续执行下面的流程，是一种并行处理的方式。比如页面数据架子啊的过程，不需要等待所有数据获取后再显示页面。&lt;/p>
&lt;p>二者的区别就在于同步需要等待，异步不需要等待。&lt;/p>
&lt;h3 id="全双工和半双工">全双工和半双工&lt;/h3>
&lt;p>&lt;strong>全双工&lt;/strong>是指可以&lt;strong>同时&lt;/strong>进行&lt;strong>双向信号&lt;/strong>传输。&lt;/p>
&lt;p>&lt;strong>半双工&lt;/strong>是指可以及进行&lt;strong>双向信号传输&lt;/strong>但&lt;strong>同一时刻只能向一个&lt;/strong>方向传输。&lt;/p>
&lt;h2 id="spi协议">SPI协议&lt;/h2>
&lt;p>串行外设接口总线（Serial Peripheral Interface Bus，SPI）是一种用于芯片通信的&lt;strong>同步&lt;/strong>串行通信接口规范，设备之间使用&lt;strong>全双工&lt;/strong>模式通信，采用一对一或一对多的主从模式。一般用于短距离通信。&lt;/p>
&lt;h3 id="spi物理层接口">SPI物理层接口&lt;/h3>
&lt;p>SPI总线共规定了4个逻辑信号接口：&lt;/p>
&lt;ul>
&lt;li>SCLK/SCK（Serial Clock）：&lt;strong>时钟&lt;/strong>信号线，由主机产生，决定了SPI的通信速率。&lt;/li>
&lt;li>MOSI（Master Output, Slave Input）：&lt;strong>主机输出从机输入&lt;/strong>信号，数据由&lt;strong>主机&lt;/strong>发出。&lt;/li>
&lt;li>MISO（Master Input, Slave Output）：&lt;strong>从机输出主机输入&lt;/strong>信号，数据由&lt;strong>从机&lt;/strong>发出。&lt;/li>
&lt;li>nSS（Slave Select）：&lt;strong>片选&lt;/strong>信号：用于选取SPI从设备，每个从设备独立拥有该条nSS信号线，占据主机的一个引脚，从设备的其他总线是并联到主机的。从设备的nSS引脚被置拉低时表明该从设备被主机选中。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SPI_%E4%B8%80%E5%AF%B9%E4%B8%80.PNG" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SPI_%E4%B8%80%E5%AF%B9%E5%A4%9A.PNG" alt="">&lt;/p>
&lt;p>（图片来自维基百科&lt;a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%91%A8%E9%82%8A%E4%BB%8B%E9%9D%A2">序列周边接口&lt;/a>）&lt;/p>
&lt;h3 id="spi协议层">SPI协议层&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SPI_photo_1.png" alt="">&lt;/p>
&lt;p>（图片来自&lt;a href="https://blog.csdn.net/qq_29344757/article/details/76855350">SPI通讯协议介绍&lt;/a>）&lt;/p>
&lt;p>如图为SPI的通信时序图，nSS、SCK、MOSI信号均由主机产生，MISO信号由从机产生。当nSS为低电平时信号有效。每个时钟周期MOSI和MISO传输一位数据。偶数边采样。&lt;/p>
&lt;h4 id="通信起始结束信号">通信起始/结束信号&lt;/h4>
&lt;p>nSS信号由高电平变为低电平即为通信的起始，由低电平变为高电平即为通信的结束。&lt;/p>
&lt;h4 id="有效数据的采集">有效数据的采集&lt;/h4>
&lt;p>上图中SCK为偶数边沿时数据得到有效采样，此时MISO和MOSI的数据有效，高电平表示1，低电平表示0，其他时刻的数据无效。&lt;/p>
&lt;p>数据传输时高位在先还是低位在先SPI协议并未规定，需要双方自行约定，一般采用高位在先（MSB）方式传输。&lt;/p>
&lt;blockquote>
&lt;p>两个概念：&lt;/p>
&lt;ul>
&lt;li>时钟极性（CPOL）：通信设备处于空闲状态（SPI开始通信前，即nSS无效）时，SCK的状态。
&lt;ul>
&lt;li>CPOL = 0：SCK在空闲时为低电平&lt;/li>
&lt;li>CPOL = 1：SCK在空闲时为高电平&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>时钟相位（CPHA）：数据的采样时刻位于SCK的偶数边还是奇数边。
&lt;ul>
&lt;li>CPHA = 0：在SCK的奇数边沿采样&lt;/li>
&lt;li>CPHA = 1：在SCK的偶数边沿采样&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>所以，数据的采样时刻并非由上升沿/下降沿所决定；在采样时刻，MOSI和MISO信号不能进行高低电平的变换。&lt;/p>
&lt;p>所以，SPI有如下4种工作模式：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">工作模式&lt;/th>
&lt;th style="text-align:center">CPOL&lt;/th>
&lt;th style="text-align:center">CPHA&lt;/th>
&lt;th style="text-align:center">空闲时的SCK时钟&lt;/th>
&lt;th style="text-align:center">采样时钟&lt;/th>
&lt;th style="text-align:center">是否常用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">低&lt;/td>
&lt;td style="text-align:center">奇数次边沿&lt;/td>
&lt;td style="text-align:center">Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">低&lt;/td>
&lt;td style="text-align:center">偶数次边沿&lt;/td>
&lt;td style="text-align:center">N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">高&lt;/td>
&lt;td style="text-align:center">奇数次边沿&lt;/td>
&lt;td style="text-align:center">Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">高&lt;/td>
&lt;td style="text-align:center">偶数次边沿&lt;/td>
&lt;td style="text-align:center">N&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="mathrmi2mathrmc协议">$\mathrm{I}^2\mathrm{C}$协议&lt;/h2>
&lt;p>$\mathrm{I}^2\mathrm{C}$（Inter-Integrated Circuit）集成电路总线，是飞利浦设计的一种简单的双向两线&lt;strong>同步串行&lt;/strong>总线，为全双工，是为了实现有效的IC之间的控制；是一种串行通信总线，为了让嵌入式设备连接低速设备。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/I2C_trans.PNG" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/1024px-I2C.svg.png" alt="">&lt;/p>
&lt;p>$\mathrm{I}^2\mathrm{C}$只需要两个接口即可通信：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>SDA（Serial Data）&lt;/strong>：串行数据接口&lt;/li>
&lt;li>&lt;strong>SCL（Serial Clock）&lt;/strong>：串行时钟&lt;/li>
&lt;/ul>
&lt;p>SDA和SCL都是双向线路，都通过一个电流源或上拉电阻接到正的电源电压，总线&lt;strong>空闲&lt;/strong>时，这两条线路都是&lt;strong>高电平&lt;/strong>。&lt;/p>
&lt;p>$\mathrm{I}^2\mathrm{C}$总线支持任何IC生产过程。两线在连接到总线的器件间传递信息。每个器件都有一个唯一的地址识别，而且都可以作为一个发送器或接收器。&lt;/p>
&lt;p>$\mathrm{I}^2\mathrm{C}$总线是一个&lt;strong>多主机&lt;/strong>的总线，即可以连接多于一个能控制总线的器件到总线。如果两个或多个主机同时尝试初始化传输数据，为了避免产生混乱，发展出了一个&lt;strong>仲裁&lt;/strong>的过程。&lt;/p>
&lt;p>$\mathrm{I}^2\mathrm{C}$的参考设计使用了一个7比特长度的地址空间，但是保留了16个地址，所以一组总线最多可以和112个节点通信。但连接到总线的接口数量其实是由总线电容是400pF的限制决定的（这里不深入了解）。&lt;/p>
&lt;p>$\mathrm{I}^2\mathrm{C}$有几种常见的传输模式，标准模式（100kbps）、低速模式（10kbps），时钟频率可以被降为0，即可以暂停通信。&lt;/p>
&lt;h2 id="uart串口">UART串口&lt;/h2>
&lt;h3 id="简介">简介&lt;/h3>
&lt;p>通用&lt;strong>异步&lt;/strong>收发传输器（异步串行通信口）（Universal Asynchronous Receiver/Transmitter），是一种&lt;strong>串行、异步、全双工&lt;/strong>的通信协议。他的工作原理是把数据的字节按照比特顺序发送，另一端的UART把比特组装为字节。&lt;/p>
&lt;p>串行通信是指利用一条传输线将数据一位位地顺序传送，也可以用两个信号线组成全双工通信，如rs232。特点是通信线路简单，利用简单的线缆就可实现通信，降低成本，适用于远距离通信，但传输速度慢的应用场合。&lt;/p>
&lt;h3 id="数据帧">数据帧&lt;/h3>
&lt;p>每个字符表示为一个帧(10bit)，异步通信以一个字符为传输单位；两个UART设备之间通信不需要时钟线，需要在两个UART设备上指定相同的传输速率(&lt;strong>波特率，bps&lt;/strong>)，以及&lt;strong>空闲位、起始位、校验位、结束位&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>空闲位(1bit)：高电平，指没有数据传输。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>起始位(1bit)：低电平。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据位(8bit or 7bit)：一般先传输最低位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>（可选）奇偶校验位(1bit)：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>无校验&lt;/li>
&lt;li>奇校验：如果数据位中1的数目是偶数，则校验位为1；如果1的数目是奇数，则校验位为0&lt;/li>
&lt;li>偶校验：如果数据位中1的数目是偶数，则校验位为0；如果1的数目是奇数，则校验位为1&lt;/li>
&lt;li>mark parity / parity：校验位时钟为1/0。（不常用）&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>结束位(1bit)：高电平。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="jtag边界扫描">JTAG边界扫描&lt;/h2>
&lt;p>JTAG主要用于验证设计和测试印刷电路板。&lt;/p>
&lt;h3 id="电气特性">电气特性&lt;/h3>
&lt;p>JTAG的接口是将4/5个接口连接到芯片上，电路板上的很多芯片可以将其JTAG接口通过Daisy Chain（菊花链）的方式连在一起，这样我们就可以访问一块印刷电路板上的所有芯片。&lt;/p>
&lt;p>连接引脚为：&lt;/p>
&lt;ul>
&lt;li>TDI（Test Data Input）：测试数据输入&lt;/li>
&lt;li>TDO（Test Data Output）：测试数据输出&lt;/li>
&lt;li>TCK（Test Clock Input）：测试时钟&lt;/li>
&lt;li>TMS（Test Model Selection）：测试模式选择&lt;/li>
&lt;li>TRST（测试复位）可选&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/Jtag_chain.svg.jpg" alt="">&lt;/p>
&lt;p>（图片来自维基百科&lt;a href="https://zh.wikipedia.org/wiki/JTAG">JTAG&lt;/a>）&lt;/p>
&lt;p>由于只有一条数据线，所以通信使用的协议应为串行传输；时钟从TCK引脚引入；配置通过TMS引脚采用状态机的方式一次操作一位来实现；TRST引脚是可选的相对待测逻辑低电平有效复位开关，通常为异步，有时也为同步。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E4%B8%B2%E5%8F%A3/ - 2019-2021 By Jialong</description></item><item><title>《算法（第4版）》学习笔记——（一）排序</title><link>https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 23 Jul 2020 14:59:12 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/ -&lt;h2 id="初级排序算法">初级排序算法&lt;/h2>
&lt;h3 id="选择排序">选择排序&lt;/h3>
&lt;h4 id="算法描述">算法描述&lt;/h4>
&lt;p>首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。&lt;/p>
&lt;h4 id="代码实现">代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Selection&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#888">//将a按照升序排列
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> N &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> 0&lt;span style="color:#333">;&lt;/span> i &lt;span style="color:#333">&amp;lt;&lt;/span> N&lt;span style="color:#333">;&lt;/span> i&lt;span style="color:#333">++)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> min &lt;span style="color:#333">=&lt;/span> i&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> i &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">;&lt;/span> j &lt;span style="color:#333">&amp;lt;&lt;/span> N&lt;span style="color:#333">;&lt;/span> j&lt;span style="color:#333">++)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>less&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">[&lt;/span>j&lt;span style="color:#333">],&lt;/span> a&lt;span style="color:#333">[&lt;/span>min&lt;span style="color:#333">]))&lt;/span>
min &lt;span style="color:#333">=&lt;/span> j&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> i &lt;span style="color:#333">,&lt;/span>min&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="性能分析">性能分析&lt;/h4>
&lt;ul>
&lt;li>对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。&lt;/li>
&lt;li>该算法运行时间与输入无关，数据的移动是最少的。&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h3 id="插入排序">插入排序&lt;/h3>
&lt;h4 id="算法描述-1">算法描述&lt;/h4>
&lt;p>插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。&lt;/p>
&lt;h4 id="代码实现-1">代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Insertion&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> N &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> 1&lt;span style="color:#333">;&lt;/span> i &lt;span style="color:#333">&amp;lt;&lt;/span> N&lt;span style="color:#333">;&lt;/span> i&lt;span style="color:#333">++)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#888">//将相邻两个元素向左依次交换最终使得索引左侧的元素全部向右移动一位
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> i&lt;span style="color:#333">;&lt;/span> j &lt;span style="color:#333">&amp;gt;&lt;/span> 0 &lt;span style="color:#333">&amp;amp;&amp;amp;&lt;/span> less&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">[&lt;/span>j&lt;span style="color:#333">],&lt;/span> a&lt;span style="color:#333">[&lt;/span>j &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">]);&lt;/span> j&lt;span style="color:#333">--)&lt;/span>
exch &lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">,&lt;/span> j &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="性能分析-1">性能分析&lt;/h4>
&lt;p>对随机排列长度为$N$且主键不重复的数组，平均插入排序需要$N^2/4$次比较和$N^2/4$次交换。&lt;/p>
&lt;p>&lt;strong>部分有序数组&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>数组中每个元素距离它的最终位置都不远&lt;/li>
&lt;li>一个有序大数组接一个小数组&lt;/li>
&lt;li>数组中只有几个元素的位置不正确&lt;/li>
&lt;/ul>
&lt;p>插入排序对这样的部分有序数组非常有效。&lt;/p>
&lt;h3 id="希尔排序">希尔排序&lt;/h3>
&lt;h4 id="算法描述-2">算法描述&lt;/h4>
&lt;p>交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序数组排序。&lt;/p>
&lt;p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组被称为&lt;strong>h有序数组&lt;/strong>，即h个相互独立的有序数组编织在一起组成的一个数组&lt;/p>
&lt;h4 id="代码实现-2">代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Shell&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">srot&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> N &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> h &lt;span style="color:#333">=&lt;/span> 1&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>h &lt;span style="color:#333">&amp;lt;&lt;/span> N &lt;span style="color:#333">/&lt;/span> 3&lt;span style="color:#333">)&lt;/span> h &lt;span style="color:#333">=&lt;/span> 3 &lt;span style="color:#333">*&lt;/span> h &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>h &lt;span style="color:#333">&amp;gt;&lt;/span> 1&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> h&lt;span style="color:#333">;&lt;/span> i &lt;span style="color:#333">&amp;lt;&lt;/span> N&lt;span style="color:#333">;&lt;/span> i&lt;span style="color:#333">++)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> i&lt;span style="color:#333">;&lt;/span> j &lt;span style="color:#333">&amp;gt;=&lt;/span> h &lt;span style="color:#333">&amp;amp;&amp;amp;&lt;/span> less&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">[&lt;/span>j&lt;span style="color:#333">],&lt;/span> a&lt;span style="color:#333">[&lt;/span>j &lt;span style="color:#333">-&lt;/span> h&lt;span style="color:#333">]);&lt;/span> j &lt;span style="color:#333">-=&lt;/span> h&lt;span style="color:#333">)&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">,&lt;/span> j &lt;span style="color:#333">-&lt;/span> h&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
h &lt;span style="color:#333">=&lt;/span> h &lt;span style="color:#333">/&lt;/span> 3&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该希尔算法使用了序列$1/2(3^k-1)$，即序列${ 1,4,13 }$，称为&lt;strong>增量序列&lt;/strong>。&lt;/p>
&lt;h4 id="性能分析-2">性能分析&lt;/h4>
&lt;p>希尔排序权衡了子数组的规模和有序性，希尔排序比插入排序和选择排序快得多，并且数组越大优势越大。&lt;/p>
&lt;h2 id="归并排序">归并排序&lt;/h2>
&lt;p>&lt;strong>归并&lt;/strong>即将两个有序的数组归并成一个更大的有序数组。&lt;/p>
&lt;h3 id="原地归并">原地归并&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">merge&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> lo&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> mid&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> hi&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> lo&lt;span style="color:#333">,&lt;/span> j &lt;span style="color:#333">=&lt;/span> mid &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> k &lt;span style="color:#333">=&lt;/span> lo&lt;span style="color:#333">;&lt;/span> k &lt;span style="color:#333">&amp;lt;=&lt;/span> hi&lt;span style="color:#333">;&lt;/span> k&lt;span style="color:#333">++)&lt;/span>
aux&lt;span style="color:#333">[&lt;/span>k&lt;span style="color:#333">]&lt;/span> &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">[&lt;/span>k&lt;span style="color:#333">];&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> k &lt;span style="color:#333">=&lt;/span> lo&lt;span style="color:#333">;&lt;/span> k &lt;span style="color:#333">&amp;lt;=&lt;/span> hi&lt;span style="color:#333">;&lt;/span> k&lt;span style="color:#333">++)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>i &lt;span style="color:#333">&amp;gt;&lt;/span> mid&lt;span style="color:#333">)&lt;/span> a&lt;span style="color:#333">[&lt;/span>k&lt;span style="color:#333">]&lt;/span> &lt;span style="color:#333">=&lt;/span> aux&lt;span style="color:#333">[&lt;/span>j&lt;span style="color:#333">++];&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>j &lt;span style="color:#333">&amp;gt;&lt;/span> hi&lt;span style="color:#333">)&lt;/span> a&lt;span style="color:#333">[&lt;/span>k&lt;span style="color:#333">]&lt;/span> &lt;span style="color:#333">=&lt;/span> aux&lt;span style="color:#333">[&lt;/span>i&lt;span style="color:#333">++];&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>less&lt;span style="color:#333">(&lt;/span>aux&lt;span style="color:#333">[&lt;/span>j&lt;span style="color:#333">],&lt;/span> aux&lt;span style="color:#333">[&lt;/span>i&lt;span style="color:#333">]))&lt;/span> a&lt;span style="color:#333">[&lt;/span>k&lt;span style="color:#333">]&lt;/span> &lt;span style="color:#333">=&lt;/span> aux&lt;span style="color:#333">[&lt;/span>j&lt;span style="color:#333">++];&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> a&lt;span style="color:#333">[&lt;/span>k&lt;span style="color:#333">]&lt;/span> &lt;span style="color:#333">=&lt;/span> aux&lt;span style="color:#333">[&lt;/span>i&lt;span style="color:#333">++];&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="自顶向下的归并排序">自顶向下的归并排序&lt;/h3>
&lt;h4 id="算法描述-3">算法描述&lt;/h4>
&lt;p>对子数组a[lo..hi]进行排序，先将其分为$\mathrm{a}[\mathrm{lo..mid}]$和$\mathrm{a[mid+1..hi]}$两部分，分别通过递归调用将其单独排序，最后将有序的子数组归并为最终的排序结果。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Merge&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> Comparable&lt;span style="color:#333">[]&lt;/span> aux&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
aux &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> Comparable&lt;span style="color:#333">[&lt;/span>a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span>&lt;span style="color:#333">];&lt;/span>
sort&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> 0&lt;span style="color:#333">,&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span> &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> lo&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> hi&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>hi &lt;span style="color:#333">&amp;lt;=&lt;/span> lo&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#080;font-weight:bold">return&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> mid &lt;span style="color:#333">=&lt;/span> lo &lt;span style="color:#333">+&lt;/span> &lt;span style="color:#333">(&lt;/span>hi &lt;span style="color:#333">-&lt;/span> lo&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#333">/&lt;/span> 2&lt;span style="color:#333">;&lt;/span>
sort &lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> mid&lt;span style="color:#333">);&lt;/span>
sort &lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> mid &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">,&lt;/span> hi&lt;span style="color:#333">);&lt;/span>
merge&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> mid&lt;span style="color:#333">,&lt;/span> hi&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="性能分析-3">性能分析&lt;/h4>
&lt;p>对于长度为$N$的任意数组，自顶向下的归并排序需要$1/2N\lg N$至$N\lg N$次比较，最多需要访问数组$6N\lg N$次。&lt;/p>
&lt;p>所以可知道归并排序所需要的时间与$N\lg N$成正比，主要缺点是辅助数组所使用的额外空间和N的大小成正比。&lt;/p>
&lt;h3 id="自底向上的归并排序">自底向上的归并排序&lt;/h3>
&lt;h4 id="算法描述-4">算法描述&lt;/h4>
&lt;p>先归并那些微型数组，然后再成对地归并得到的子数组。首先进行两两归并（把每个元素当作一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并为一个有4个元素的数组），然后是八八归并，以此类推。&lt;/p>
&lt;h4 id="代码实现-3">代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">MergeBU&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> Comparable&lt;span style="color:#333">[]&lt;/span> aux&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span> &lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> N &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span>&lt;span style="color:#333">;&lt;/span>
aux &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> Comparable&lt;span style="color:#333">[&lt;/span>N&lt;span style="color:#333">];&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> sz &lt;span style="color:#333">=&lt;/span> 1&lt;span style="color:#333">;&lt;/span> sz &lt;span style="color:#333">&amp;lt;&lt;/span> N&lt;span style="color:#333">;&lt;/span> sz &lt;span style="color:#333">=&lt;/span> sz &lt;span style="color:#333">+&lt;/span> sz&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> lo &lt;span style="color:#333">=&lt;/span> 0&lt;span style="color:#333">;&lt;/span> lo &lt;span style="color:#333">&amp;lt;&lt;/span> N &lt;span style="color:#333">-&lt;/span> sz&lt;span style="color:#333">;&lt;/span> lo &lt;span style="color:#333">+=&lt;/span> sz &lt;span style="color:#333">+&lt;/span> sz&lt;span style="color:#333">)&lt;/span>
merge&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> lo &lt;span style="color:#333">+&lt;/span> sz &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">,&lt;/span> Math&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">min&lt;/span>&lt;span style="color:#333">(&lt;/span>lo &lt;span style="color:#333">+&lt;/span> sz &lt;span style="color:#333">+&lt;/span> sz &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">,&lt;/span> N &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">));&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="性能分析-4">性能分析&lt;/h4>
&lt;p>对于长度为$N$的任意数组，自底向上的归并排序需要$1/2N\lg N$至$N\lg N$次比较，最多访问数组$6N\lg N$次。&lt;/p>
&lt;h2 id="快速排序">快速排序&lt;/h2>
&lt;h3 id="快速排序的切分">快速排序的切分&lt;/h3>
&lt;p>根据切分点&lt;code>j&lt;/code>对数组进行切分，切分后的数组满足：&lt;/p>
&lt;ul>
&lt;li>&lt;code>a[lo]&lt;/code>到&lt;code>a[j-1]&lt;/code>中的所有元素都不大于&lt;code>a[j]&lt;/code>&lt;/li>
&lt;li>&lt;code>a[j+1]&lt;/code>到&lt;code>a[hi]&lt;/code>中的所有元素都不小于&lt;code>a[j]&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#888">//切分
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#06b;font-weight:bold">partition&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> lo&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> hi&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> lo&lt;span style="color:#333">,&lt;/span> j &lt;span style="color:#333">=&lt;/span> hi &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">;&lt;/span>
Comparable v &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">[&lt;/span>lo&lt;span style="color:#333">];&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#080;font-weight:bold">true&lt;/span>&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>less&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">[++&lt;/span>i&lt;span style="color:#333">],&lt;/span> v&lt;span style="color:#333">))&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>i &lt;span style="color:#333">==&lt;/span> hi&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#080;font-weight:bold">break&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>less&lt;span style="color:#333">(&lt;/span>v&lt;span style="color:#333">,&lt;/span> a&lt;span style="color:#333">[--&lt;/span>j&lt;span style="color:#333">]))&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>j &lt;span style="color:#333">==&lt;/span> lo&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#080;font-weight:bold">break&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>i &lt;span style="color:#333">&amp;gt;=&lt;/span> j&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#080;font-weight:bold">break&lt;/span>&lt;span style="color:#333">;&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> i&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> j&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="基本快速排序算法">基本快速排序算法&lt;/h3>
&lt;h4 id="算法描述-5">算法描述&lt;/h4>
&lt;p>通过递归地调用切分来进行排序。&lt;/p>
&lt;h4 id="代码实现-4">代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Quick&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
StdRandom&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">shuffle&lt;/span>&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">);&lt;/span> &lt;span style="color:#888">//将输入乱序，消除堆输入的依赖
&lt;/span>&lt;span style="color:#888">&lt;/span> sort&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> 0&lt;span style="color:#333">,&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span> &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span> &lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> lo&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> hi&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>hi &lt;span style="color:#333">&amp;lt;=&lt;/span> lo&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#080;font-weight:bold">return&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> partition&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> hi&lt;span style="color:#333">);&lt;/span>
sort&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> j &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">);&lt;/span>
sort&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> j &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">,&lt;/span> hi&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="性能分析-5">性能分析&lt;/h4>
&lt;p>将长度为$N$的无重复数组排序，快速排序平均需要$2N\lg N$次比较，即$1/6N\lg N$次交换。&lt;/p>
&lt;h3 id="三向切分快速排序">三向切分快速排序&lt;/h3>
&lt;p>在含有大量重复元素时使用该方法。将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。&lt;/p>
&lt;h4 id="代码实现-5">代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Quick3way&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> lo&lt;span style="color:#333">,&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> hi&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>hi &lt;span style="color:#333">&amp;lt;=&lt;/span> lo&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#080;font-weight:bold">return&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> lt &lt;span style="color:#333">=&lt;/span> lo&lt;span style="color:#333">,&lt;/span> i &lt;span style="color:#333">=&lt;/span> lo &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">;&lt;/span> gt &lt;span style="color:#333">=&lt;/span> hi&lt;span style="color:#333">;&lt;/span>
Comparable v &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">[&lt;/span>lo&lt;span style="color:#333">];&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>i &lt;span style="color:#333">&amp;lt;=&lt;/span> gt&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> cmp &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">[&lt;/span>i&lt;span style="color:#333">].&lt;/span>&lt;span style="color:#00c">compareTo&lt;/span>&lt;span style="color:#333">(&lt;/span>v&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span>&lt;span style="color:#333">(&lt;/span>cmp &lt;span style="color:#333">&amp;lt;&lt;/span> 0&lt;span style="color:#333">)&lt;/span> exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lt&lt;span style="color:#333">++,&lt;/span> i&lt;span style="color:#333">++);&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>cmp &lt;span style="color:#333">&amp;gt;&lt;/span> 0&lt;span style="color:#333">)&lt;/span> exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> i&lt;span style="color:#333">,&lt;/span> gt&lt;span style="color:#333">--);&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> i&lt;span style="color:#333">++;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
sort&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> lo&lt;span style="color:#333">,&lt;/span> lt &lt;span style="color:#333">-&lt;/span> 1&lt;span style="color:#333">);&lt;/span>
sort&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> gt &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">,&lt;/span> hi&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="优先队列">优先队列&lt;/h2>
&lt;p>优先队列这种&lt;em>数据结构&lt;/em>应支持两种操作：&lt;/p>
&lt;ul>
&lt;li>删除最大元素&lt;/li>
&lt;li>插入元素&lt;/li>
&lt;/ul>
&lt;h3 id="初级实现有序数组无序数组链表">初级实现：有序数组、无序数组、链表&lt;/h3>
&lt;p>这些初级实现中，插入元素和删除最大元素的操作在最坏的情况下需要&lt;strong>线性时间&lt;/strong>来完成，无法满足我们的性能要求。接下来使用&lt;strong>堆&lt;/strong>来实现使这两种操作能更快地执行。&lt;/p>
&lt;h3 id="基于堆的优先队列">基于堆的优先队列&lt;/h3>
&lt;h4 id="堆的定义">堆的定义&lt;/h4>
&lt;p>数据结构&lt;strong>二叉堆&lt;/strong>满足：每个元素大于等于两个特定位置的元素，这些位置的元素又要大于等于数组中的另外两个元素，这样的数据结构可以通过有序的完全二叉树来表示。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E6%9C%89%E5%BA%8F%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="">&lt;/p>
&lt;p>在一个堆中，位置$k$的节点的父节点的位置为$k/2$，而它的两个子节点的位置为$2k$和$2k+1$。&lt;/p>
&lt;p>我们可以通过计算数组的索引在树中上下移动：从$a[k]$向上一层就令$k=k/2$，向下一层则令$k=2k/2k+1$。&lt;/p>
&lt;h4 id="堆的算法">堆的算法&lt;/h4>
&lt;p>&lt;strong>由下至上的堆有序化（上浮swim）&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">swim&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> k&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>k &lt;span style="color:#333">&amp;gt;&lt;/span> 1 &lt;span style="color:#333">&amp;amp;&amp;amp;&lt;/span> less&lt;span style="color:#333">(&lt;/span>k&lt;span style="color:#333">/&lt;/span>2&lt;span style="color:#333">,&lt;/span> k&lt;span style="color:#333">))&lt;/span>
&lt;span style="color:#333">{&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>k&lt;span style="color:#333">/&lt;/span>2&lt;span style="color:#333">,&lt;/span> k&lt;span style="color:#333">);&lt;/span>
k &lt;span style="color:#333">=&lt;/span> k&lt;span style="color:#333">/&lt;/span>2&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>由上至下的堆有序化（下沉sink）&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sink&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> k&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>2&lt;span style="color:#333">*&lt;/span>k &lt;span style="color:#333">&amp;lt;=&lt;/span> N&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> 2&lt;span style="color:#333">*&lt;/span>k&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>j &lt;span style="color:#333">&amp;lt;&lt;/span> N &lt;span style="color:#333">&amp;amp;&amp;amp;&lt;/span> less&lt;span style="color:#333">(&lt;/span>j&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">+&lt;/span>1&lt;span style="color:#333">))&lt;/span> j&lt;span style="color:#333">++;&lt;/span> &lt;span style="color:#888">//选择父节点的两个子节点中较大的作为交换对象
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(!&lt;/span>less&lt;span style="color:#333">(&lt;/span>k&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">))&lt;/span> &lt;span style="color:#080;font-weight:bold">break&lt;/span>&lt;span style="color:#333">;&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>k&lt;span style="color:#333">,&lt;/span> j&lt;span style="color:#333">);&lt;/span>
k &lt;span style="color:#333">=&lt;/span> j&lt;span style="color:#333">;&lt;/span> &lt;span style="color:#888">//将交换后子节点的位置作为父节点，循环进行下一次交换,继续下沉
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="基于堆的优先队列的代码实现">基于堆的优先队列的代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">MaxPQ&lt;/span>&lt;span style="color:#333">&amp;lt;&lt;/span>Key &lt;span style="color:#080;font-weight:bold">extends&lt;/span> Comparable&lt;span style="color:#333">&amp;lt;&lt;/span>key&lt;span style="color:#333">&amp;gt;&amp;gt;&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> Key&lt;span style="color:#333">[]&lt;/span> pq&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> N &lt;span style="color:#333">=&lt;/span> 0&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#06b;font-weight:bold">MaxPQ&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> maxN&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
pq &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#333">(&lt;/span>Key&lt;span style="color:#333">[])&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> Comparable&lt;span style="color:#333">[&lt;/span>maxN &lt;span style="color:#333">+&lt;/span> 1&lt;span style="color:#333">];&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#339;font-weight:bold">boolean&lt;/span> &lt;span style="color:#06b;font-weight:bold">isEmpty&lt;/span>&lt;span style="color:#333">()&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> N &lt;span style="color:#333">==&lt;/span> 0&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#06b;font-weight:bold">size&lt;/span>&lt;span style="color:#333">()&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> N&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">insert&lt;/span>&lt;span style="color:#333">(&lt;/span>Key v&lt;span style="color:#333">)&lt;/span> &lt;span style="color:#888">//在数组的末尾输入，然后进行上浮swim操作
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#333">{&lt;/span>
pq&lt;span style="color:#333">[++&lt;/span>N&lt;span style="color:#333">]&lt;/span> &lt;span style="color:#333">=&lt;/span> v&lt;span style="color:#333">;&lt;/span>
swim&lt;span style="color:#333">(&lt;/span>N&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">};&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> Key &lt;span style="color:#06b;font-weight:bold">delMax&lt;/span>&lt;span style="color:#333">()&lt;/span>
&lt;span style="color:#333">{&lt;/span>
Key max &lt;span style="color:#333">=&lt;/span> pq&lt;span style="color:#333">[&lt;/span>1&lt;span style="color:#333">];&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>1&lt;span style="color:#333">,&lt;/span> N&lt;span style="color:#333">--);&lt;/span>
pq&lt;span style="color:#333">[&lt;/span>N&lt;span style="color:#333">++]&lt;/span> &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">null&lt;/span>&lt;span style="color:#333">;&lt;/span>
sink&lt;span style="color:#333">(&lt;/span>1&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">return&lt;/span> max&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="基于堆的优先队列性能分析">基于堆的优先队列性能分析&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.PNG" alt="">&lt;/p>
&lt;h3 id="堆排序">堆排序&lt;/h3>
&lt;h4 id="堆的构造">堆的构造&lt;/h4>
&lt;p>高效的构造堆的方法是从右向左用&lt;code>sink()&lt;/code>函数构造子堆。数组的每个位置都是一个子堆的根结点，如果一个结点的两个子结点都已经是堆了，那么在该结点上调用&lt;code>sink()&lt;/code>可以将它们变成一个堆。我们只需要扫描一半的元素，因为可以跳过大小为1的子堆。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E5%A0%86%E7%9A%84%E6%9E%84%E9%80%A0.png" alt="">&lt;/p>
&lt;h4 id="下沉排序">下沉排序&lt;/h4>
&lt;p>将堆中的最大元素删去，然后将其放入堆缩小后数组中空出的位置。&lt;/p>
&lt;h4 id="堆排序代码实现">堆排序代码实现&lt;/h4>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">sort&lt;/span>&lt;span style="color:#333">(&lt;/span>Comparable&lt;span style="color:#333">[]&lt;/span> a&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#339;font-weight:bold">int&lt;/span> N &lt;span style="color:#333">=&lt;/span> a&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">length&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">for&lt;/span> &lt;span style="color:#333">(&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> k &lt;span style="color:#333">=&lt;/span> N&lt;span style="color:#333">/&lt;/span>2&lt;span style="color:#333">;&lt;/span> k &lt;span style="color:#333">&amp;gt;=&lt;/span> 1&lt;span style="color:#333">;&lt;/span> k&lt;span style="color:#333">--)&lt;/span> &lt;span style="color:#888">//构造堆
&lt;/span>&lt;span style="color:#888">&lt;/span> sink&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> k&lt;span style="color:#333">,&lt;/span> N&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(&lt;/span>N &lt;span style="color:#333">&amp;gt;&lt;/span> 1&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
exch&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> 1&lt;span style="color:#333">,&lt;/span> N&lt;span style="color:#333">--);&lt;/span> &lt;span style="color:#888">//堆排序，按递减顺序循环取出所有的最大值，最后得到排序结果。
&lt;/span>&lt;span style="color:#888">&lt;/span> sink&lt;span style="color:#333">(&lt;/span>a&lt;span style="color:#333">,&lt;/span> 1&lt;span style="color:#333">,&lt;/span> N&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="堆排序性能分析">堆排序性能分析&lt;/h4>
&lt;p>将$N$个元素排序，堆排序只需要少于$(2N\lg N+2N)$次比较以及一半的交换次数。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/ - 2019-2021 By Jialong</description></item><item><title>Dijkstra双栈——算术表达式求值</title><link>https://eternityqjl.github.io/blog2_public/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link><pubDate>Tue, 21 Jul 2020 20:15:08 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/ -&lt;h2 id="算数表达式">算数表达式&lt;/h2>
&lt;p>这里的算术表达式支持常见的二元运算符&lt;code>+-*/&lt;/code>以及接受一个参数的平方根运算符&lt;code>sqrt&lt;/code>。这里我们假定表达式中未省略所有的括号。&lt;/p>
&lt;h2 id="计算方法">计算方法&lt;/h2>
&lt;ul>
&lt;li>将操作数压入&lt;strong>操作数栈&lt;/strong>&lt;/li>
&lt;li>将运算符压入&lt;strong>运算符栈&lt;/strong>&lt;/li>
&lt;li>忽略左括号&lt;/li>
&lt;li>遇到右括号时，弹出一个运算符，弹出需要数量的操作数进行运算，然后将得到的结果再压入操作数栈。&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h2 id="代码实现">代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#080;font-weight:bold">package&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">edu.princeton.cs.algs4&lt;/span>&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Evaluate&lt;/span> &lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>&lt;span style="color:#333">(&lt;/span>String&lt;span style="color:#333">[]&lt;/span> args&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
Stack&lt;span style="color:#333">&amp;lt;&lt;/span>String&lt;span style="color:#333">&amp;gt;&lt;/span> ops &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> Stack&lt;span style="color:#333">&amp;lt;&lt;/span>String&lt;span style="color:#333">&amp;gt;();&lt;/span>
Stack&lt;span style="color:#333">&amp;lt;&lt;/span>Double&lt;span style="color:#333">&amp;gt;&lt;/span> vals &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> Stack&lt;span style="color:#333">&amp;lt;&lt;/span>Double&lt;span style="color:#333">&amp;gt;();&lt;/span>
&lt;span style="color:#080;font-weight:bold">while&lt;/span> &lt;span style="color:#333">(!&lt;/span>StdIn&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">isEmpty&lt;/span>&lt;span style="color:#333">())&lt;/span>
&lt;span style="color:#333">{&lt;/span>
&lt;span style="color:#888">//读取字符，如果是运算符则压入运算符栈ops
&lt;/span>&lt;span style="color:#888">&lt;/span> String s &lt;span style="color:#333">=&lt;/span> StdIn&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">readString&lt;/span>&lt;span style="color:#333">();&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;(&amp;#34;&lt;/span>&lt;span style="color:#333">));&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;+&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> ops&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;-&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> ops&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;*&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> ops&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> ops&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;sqrt&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> ops&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#888">//如果字符为)，则弹出运算符和操作数，计算结果并压入操作数栈vals
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span>
&lt;span style="color:#333">{&lt;/span>
String op &lt;span style="color:#333">=&lt;/span> ops&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">();&lt;/span>
&lt;span style="color:#339;font-weight:bold">double&lt;/span> v &lt;span style="color:#333">=&lt;/span> vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">();&lt;/span>
&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>op&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;+&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> v &lt;span style="color:#333">=&lt;/span> vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">()&lt;/span> &lt;span style="color:#333">+&lt;/span> v&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>op&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;-&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> v &lt;span style="color:#333">=&lt;/span> vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">()&lt;/span> &lt;span style="color:#333">-&lt;/span> v&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>op&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;*&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> v &lt;span style="color:#333">=&lt;/span> vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">()&lt;/span> &lt;span style="color:#333">*&lt;/span> v&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>op&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> v &lt;span style="color:#333">=&lt;/span> vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">()&lt;/span> &lt;span style="color:#333">/&lt;/span> v&lt;span style="color:#333">;&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span> &lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#333">(&lt;/span>op&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">equals&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;sqrt&amp;#34;&lt;/span>&lt;span style="color:#333">))&lt;/span> v &lt;span style="color:#333">=&lt;/span> Math&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">sqrt&lt;/span>&lt;span style="color:#333">(&lt;/span>v&lt;span style="color:#333">);&lt;/span>
vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>v&lt;span style="color:#333">);&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#888">//如果字符既非运算符又非括号，将其作为double值压入操作数栈vals
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#080;font-weight:bold">else&lt;/span> vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">push&lt;/span>&lt;span style="color:#333">(&lt;/span>Double&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">parseDouble&lt;/span>&lt;span style="color:#333">(&lt;/span>s&lt;span style="color:#333">));&lt;/span>
&lt;span style="color:#333">}&lt;/span>
StdOut&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">println&lt;/span>&lt;span style="color:#333">(&lt;/span>vals&lt;span style="color:#333">.&lt;/span>&lt;span style="color:#00c">pop&lt;/span>&lt;span style="color:#333">());&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>- https://eternityqjl.github.io/blog2_public/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/ - 2019-2021 By Jialong</description></item><item><title>计算机网络学习日志（二）——运输层</title><link>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</link><pubDate>Wed, 06 May 2020 21:27:10 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/ -&lt;h2 id="概述和运输层服务">概述和运输层服务&lt;/h2>
&lt;p>运输层协议在不同主机上的应用进程之间提供了&lt;strong>逻辑通信&lt;/strong>，这并非物理上的实际通信。在发送端，运输层将从应用程序接收到的报文转换成运输层分组，该分组称为&lt;strong>运输层报文段&lt;/strong>，实现方法是将应用报文划分为一个个小的块，为每个块加上运输层首部生成运输层报文段，然后在端系统中传递给网络层，网络层将其封装成网络层分组，向目的地发送。&lt;/p>
&lt;p>因特网由TCP和UDP两种运输层协议。&lt;/p>
&lt;h3 id="运输层和网络层的关系">运输层和网络层的关系&lt;/h3>
&lt;p>网络层提供了&lt;strong>主机&lt;/strong>之间的逻辑通信，而运输层为运行在不同主机上的&lt;strong>进程&lt;/strong>之间提供了逻辑通信。&lt;/p>
&lt;p>运输层协议至工作在端系统中，同时网络中的路由器既不处理也不识别运输层加在应用层报文的任何信息。运输层协议能提供的服务常常受制于底层网络层协议，例如，如果网络层协议无法为主机之间发送的运输层报文段提供时延和带宽保证，运输层协议可就无法为&lt;strong>进程之间&lt;/strong>发送的应用程序报文提供时延和带宽保证。&lt;/p>
&lt;h3 id="运输层概述">运输层概述&lt;/h3>
&lt;p>首先定义两个名词的意义：&lt;/p>
&lt;ul>
&lt;li>报文段：运输层分组，即TCP和UDP的分组&lt;/li>
&lt;li>数据报：网络层分组&lt;/li>
&lt;/ul>
&lt;p>网络层的IP被称为不可靠服务。&lt;/p>
&lt;h2 id="多路复用与多路分解">多路复用与多路分解&lt;/h2>
&lt;p>在目的主机中，运输层从紧邻其下的网络层接受报文段，并将这些报文段中的数据交付给在主机上运行的对应应用程序进程。&lt;/p>
&lt;p>&lt;strong>多路分解&lt;/strong>是指将运输层报文中的数据正确交付给正确的&lt;strong>套接字&lt;/strong>的工作。&lt;/p>
&lt;p>&lt;strong>多路复用&lt;/strong>是指在源主机中从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层。&lt;/p>
&lt;p>运输层多路复用的要求：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>套接字有唯一标识&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个报文段有特殊字段来指示该报文段所要交付到的套接字&lt;/p>
&lt;ul>
&lt;li>特殊字段：源端口号字段、目的端口号字段&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>0~1023范围的端口称为&lt;em>周知端口号&lt;/em>，是受限的，它们分配给周知应用层协议来使用&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="无连接运输udp">无连接运输：UDP&lt;/h2>
&lt;p>UDP从应用程序得到数据，附加上用于多路复用/分解服务和目的地端口字段号，以及两个其他字段，然后将形成的报文交给网络层，网络层将运输层报文封装到一个一个IP数据报中，然后尽力交付给目的主机。&lt;/p>
&lt;p>UDP被称为&lt;strong>无连接&lt;/strong>运输是因为在发送报文段之前，发送方和接收方的运输层实体之间没有握手。&lt;/p>
&lt;p>一些应用相比于TCP更适合于使用UDP的原因：&lt;/p>
&lt;ul>
&lt;li>关于发送什么数据以及何时发送的&lt;strong>应用层控制&lt;/strong>更为精细&lt;/li>
&lt;li>无需建立连接，开始传输数据前不需要握手&lt;/li>
&lt;li>无连接状态。TCP中要实现可靠数据传输服务并提供拥塞控制，状态信息是必须的。&lt;/li>
&lt;li>分组首部占用空间小。每个TCP报文段有20个字节的首部开销，UDP仅有8个字节。&lt;/li>
&lt;/ul>
&lt;h3 id="udp报文段结构">UDP报文段结构&lt;/h3>
&lt;p>&lt;img src="http://blog.eternityqjl.top/UDP.svg" alt="">&lt;/p>
&lt;h3 id="udp检验和">UDP检验和&lt;/h3>
&lt;p>检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生变化。&lt;/p>
&lt;p>提供差错检验的原因是不能保证源和目的之间的所有链路都提供了差错检测。&lt;/p>
&lt;p>虽然UDP提供了差错检验，但是它对于差错恢复无能为力，它只是丢弃受损的报文段。&lt;/p>
&lt;h2 id="可靠数据传输原理">可靠数据传输原理&lt;/h2>
&lt;p>&lt;strong>可靠数据传输协议&lt;/strong>是用来实现一种服务的抽象：数据可以通过一条可靠的信道进行传输。可靠传输协议的下层也许是不可靠的，如TCP是在不可靠的端到端网络层(IP)之上实现的可靠数据传输协议。我们目前可将较低层直接视为不可靠的点对点信道。&lt;/p>
&lt;h3 id="构造可靠数据传输协议">构造可靠数据传输协议&lt;/h3>
&lt;p>&lt;strong>rdt1.0：经完全可靠信道的可靠数据传输&lt;/strong>&lt;/p>
&lt;p>此时的底层信道完全可靠，接收端不需要提供任何反馈信息给发送方。&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/rdt1.svg" alt="rdt1">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>有限状态机(Finite-State Machine, FSM)&lt;/strong>：表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
&lt;ul>
&lt;li>FSM描述图中箭头指示了协议从一个状态便签到另一个状态&lt;/li>
&lt;li>横线上方：引起变迁的事件&lt;/li>
&lt;li>横线下方：事件发生时所采取的动作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>发送方和接收方有各自的FSM&lt;/p>
&lt;p>rdt1.0的发送端通过&lt;code>rdt_send(data)&lt;/code>事件接受来自叫高层的数据，产生一个包含该数据的分组(由&lt;code>make_pkt(data)&lt;/code>动作产生)，并将分组发送到信道中。&lt;/p>
&lt;p>接收端通过&lt;code>rdt_rcv(packet)&lt;/code>从底层信道接受一个分组，从分组中取出数据(由&lt;code>extract(packet, data)&lt;/code>动作完成)，并将数据上传给叫高层(通过&lt;code>deliver_data(data)&lt;/code>完成)。&lt;/p>
&lt;p>&lt;strong>rdt2.0：经具有比特差错信道的可靠数据传输&lt;/strong>&lt;/p>
&lt;p>底层信道更为实际的模型是可能受损的模型，这样的比特差错通常出现在网络的物理部件中，&lt;strong>自动重传请求协议(Automatic Repeat reQueat, ARQ)&lt;/strong>：&lt;/p>
&lt;p>使用&lt;strong>肯定确认&lt;/strong>与&lt;strong>否定确认&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>差错检测：第五章会详细说明具体机制&lt;/li>
&lt;li>接收方反馈：接收方向发送方回送**ACK(肯定确认)&lt;strong>或是&lt;/strong>NAK(否定确认)**分组，理论上只需要1比特。&lt;/li>
&lt;li>重传：接收方接收到有差错分组，发送方将重传该分组&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://blog.eternityqjl.top/rdt2.svg" alt="rdt2">&lt;/p>
&lt;p>rdt2.0的发送端由两个状态，左边的状态中，发送端协议正在等待来自上层传递的数据，当事件&lt;code>rdt_send(data)&lt;/code>出现时，发送方将产生一个带有检验和的分组(sndpkt)，然后发送该分组。右边的状态中，发送方协议等待来自接收方的ACK或NAK分组。如果收到ACK分组，则知道已经正确发送，协议返回到右侧的等待上层数据的状态；如果收到NAK分组，则协议重新上传一个分组并继续等待会送的ACK或NAK。&lt;/p>
&lt;p>当发送方处于右侧的等待状态时，不能从上层获得更多的数据，只有收到ACK分组并离开该状态时才能开始获得上层的数据，所以，rdt2.0这样的协议又被称为&lt;strong>停等&lt;/strong>协议。&lt;/p>
&lt;hr>
&lt;p>rdt2.0有一个致命的缺陷，没有考虑到ACK或NAK分组受损的可能性。&lt;/p>
&lt;p>一种解决方法是，当发送方收到含糊不清的ACK或NAK分组时，只需&lt;strong>重传&lt;/strong>当前数据分组即可。这种方法在发送方到接收方的信道中引入了&lt;strong>冗余分组&lt;/strong>，但问题在于接收方不知道它上次所发送的ACK或NAK分组是否被正确收到，因此它不知道当前接收到的分组是新的还是一个重传。&lt;/p>
&lt;p>解决该问题的方法是在数据分组中添加一新字段，让发送方对其数据分组进行&lt;strong>编号&lt;/strong>，即将发送数据分组的&lt;strong>序号&lt;/strong>放在该字段，此时接收方只需要检查序号即可确定收到的分组是否一次重传。这里只需要使用1比特的序号就够了，如果当前是正在重传一个分组，则接收到的分组序号与最近的收到的分组序号相同；如果是一个新的分组，则序号与前一个相比发生了变化。&lt;/p>
&lt;p>&lt;strong>rtd2.1&lt;/strong>&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/rdt2_1_send.svg" alt="rdt2_1_send">&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/rdt2_1_rcv.svg" alt="rdt2_1_rcv">&lt;/p>
&lt;p>rdt2.1是解决了上述rdt2.0问题后的新的协议，发送方和接收方的状态数都是之前的两倍，因为协议状态必须反映出此时发送方正在发送的分组或是接收方希望收到的分组的序号是0还是1。&lt;/p>
&lt;p>&lt;strong>rdt3.0：经具有比特差错的丢包信道的可靠数据传输&lt;/strong>&lt;/p>
&lt;p>现在假定除了比特受损外，底层信道还会丢包，比特受损已经可以通过前面rdt2中的重传解决，而解决丢包需要增加一种新的协议机制。&lt;/p>
&lt;p>假定发送方传输一个数据分组，该分组或者接受方对于该分组的ACK发生了丢失，这两种情况下发送方都收不到响应，发送方需要等一段时间以便确定分组已经丢失，然后重传该分组。注意，如果一个分组经历了一个很大的时延，发送方也可能重传该分组，这就导致引入了&lt;strong>冗余数据分组&lt;/strong>，而前面的rdt2.1协议已经能通过序号的功能来处理这种情况。&lt;/p>
&lt;p>这个等待时间值需要通过一个&lt;strong>倒计数定时器&lt;/strong>来确定，在给定时间量过期后，可中断发送方，所以发送方需要做到：&lt;/p>
&lt;ul>
&lt;li>每次发送一个分组时便启动一个定时器。&lt;/li>
&lt;li>响应定时器中断(采取适当动作)。&lt;/li>
&lt;li>终止定时器。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://blog.eternityqjl.top/rdt3.svg" alt="rdt3">&lt;/p>
&lt;p>分组序号在0和1之间交替，所以rdt3.0又被称为比特交替协议。&lt;/p>
&lt;h3 id="流水线可靠数据传输">流水线可靠数据传输&lt;/h3>
&lt;p>rdt3.0是一个功能正确的协议，但它的性能并不高，这里的核心问题在于它的停等协议。&lt;/p>
&lt;p>在停等协议下，信道的利用率非常低，具体过程见书。&lt;/p>
&lt;p>解决这个问题的方法是：&lt;strong>不以停等方式运行&lt;/strong>，&lt;/p>
&lt;p>(RTT: Round-Trip Time)&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/%E6%B5%81%E6%B0%B4%E7%BA%BF.svg" alt="流水线">&lt;/p>
&lt;p>允许发送方方多个分组而无需等待确认，这种技术被称为&lt;strong>流水线&lt;/strong>，流水线对可靠数据传输协议回带来以下影响：&lt;/p>
&lt;ul>
&lt;li>必须增加序号的范围&lt;/li>
&lt;li>协议的发送方和接收方不得不缓存多个分组&lt;/li>
&lt;li>解决流水线差错恢复有两种基本方法：回退N步(Go-Back-N, GBN)、选择重传(Selective Repeat, SR)&lt;/li>
&lt;/ul>
&lt;h3 id="回退n步go-back-n-gbn">回退N步(Go-Back-N, GBN)&lt;/h3>
&lt;p>GBN协议中，允许发送方发送多个分组不需等待确认的原则受限于在流水线中未确认的分组数不能超过某个最大允许数N。&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/GBN.svg" alt="GBN">&lt;/p>
&lt;ul>
&lt;li>基序号(base)：最早未确认分组的序号&lt;/li>
&lt;li>下一个序号(nextseqnum)：最小未使用序号(下一个待发分组序号)&lt;/li>
&lt;/ul>
&lt;p>如上图所示，可以将序号范围分割成4段：&lt;/p>
&lt;ul>
&lt;li>[0, base - 1]段内的序号对应已发送并确认的分组&lt;/li>
&lt;li>[base, nextseqnum - 1]：已发送但未被确认的分组&lt;/li>
&lt;li>[nextseqnum, base + N - 1]：对应立即要被发送的分组(如果有数据来自上层的话)&lt;/li>
&lt;li>大于等于base + N的序号不能使用，直到当前流水线中未被确认的分组已得到确认&lt;/li>
&lt;/ul>
&lt;p>所以，N常被称为&lt;strong>窗口长度&lt;/strong>，GBN也常被称为&lt;strong>滑动窗口协议(sliding-window protocol)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>扩展FSM&lt;/strong>：基于ACK、无NAK的GBN协议的发送方和接收方描述。&lt;/p>
&lt;p>(FSM: Finite-State Machine, 有限状态机)&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/ExtendedFSM.svg" alt="ExtendedFSM">&lt;/p>
&lt;p>GBN发送方必须响应三种类型事件：&lt;/p>
&lt;ul>
&lt;li>&lt;em>上层的调用&lt;/em>。当上层调用rdt_send()时，发送方首先检查发送窗口是否已满。如果未满，则产生一个分组并更新变量；如果已满，则发送方将数据返回给上层，隐式地指示窗口已满，过一会儿再试。实际中发送方更可能缓存这些数据或使用同步机制(仅当窗口不满时才允许上层调用rdt_send())。&lt;/li>
&lt;li>&lt;em>收到一个ACK&lt;/em>。对序号为n的分组的确认采取&lt;strong>累计确认&lt;/strong>，表明接收方已正确收到序号为n的之前(包括n)的所有分组。&lt;/li>
&lt;li>&lt;em>超时事件&lt;/em>。发生超时时，发送方重传所有已发送但还未被确认过的分组。&lt;/li>
&lt;/ul>
&lt;p>GBN协议中，接收方丢弃所有的失序分组，即不需要缓存任何失序分组，因为如果分组丢失，发送方会重传丢失的分组和之后的分组。&lt;/p>
&lt;h3 id="选择重传sr">选择重传(SR)&lt;/h3>
&lt;p>GBN解决了停等协议中的信道利用率的问题但GBN本身也存在着一些性能问题，当窗口长度和带宽时延都很大时，单个分组的差错就能引起GBN重传大量分组，但许多分组没有必要重传。&lt;/p>
&lt;p>选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。这种方式要求接收方逐个地确认正确接收地分组&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/SR%E6%93%8D%E4%BD%9C.svg" alt="SR操作">&lt;/p>
&lt;p>?对于SR协议而言，窗口长度必须小于或等于序号空间大小的一半&lt;/p>
&lt;h2 id="面向连接的运输tcp">面向连接的运输：TCP&lt;/h2>
&lt;h3 id="tcp连接">TCP连接&lt;/h3>
&lt;p>TCP被称为时&lt;strong>面向连接的&lt;/strong>是因为一个进程向另一个进程发送数据之前，这两个进程必须先相互握手，即相互发送一些预备报文来建立确保数据传输的参数。&lt;/p>
&lt;p>这样的连接不是一条端到端的连接电路，而是&lt;strong>逻辑连接&lt;/strong>，这种链接仅仅存在于两个通信端系统的TCP程序中。TCP协议只在端系统中运行，不在中间的网络元素中运行，中间路由看不到TCP连接，只能看到数据报。&lt;/p>
&lt;p>TCP连接提供的是&lt;strong>全双工&lt;/strong>服务，进程之间的TCP连接可以双向传输数据；TCP是&lt;strong>点对点&lt;/strong>连接，只能在一个发送方和一个接收方之间传输。&lt;/p>
&lt;p>&lt;strong>TCP建立连接的过程&lt;/strong>：&lt;/p>
&lt;p>客户首先发送一个特殊TCP报文段，服务器用另一个特殊报文段响应，最后客户再用第三个特殊报文段作为响应，这种建立连接的过程通常被称为&lt;strong>三次握手&lt;/strong>。第三个报文段可以承载有效荷载(可以包含应用层数据)，前两个不行。&lt;/p>
&lt;p>建立连接后，两个应用程序进程之间就可以相互方数据了。&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/TCP%E7%BC%93%E5%AD%98.svg" alt="TCP缓存">&lt;/p>
&lt;p>客户进程通过套接字传递数据流，数据一旦通过套接字，就由客户中运行的TCP控制，TCP将这些数据引入&lt;strong>发送缓存&lt;/strong>，并不时地从发送缓存中取出一块数据并将数据传递到网络层。TCP从缓存中取出并放入报文段中的数据数量受到**最大报文段长度(Maximum Segment Size, MSS)**的限制，MSS的典型值为1460字节。&lt;/p>
&lt;h3 id="tcp报文段结构">TCP报文段结构&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/TCPsegmentStructure.svg" alt="">&lt;/p>
&lt;p>TCP报文由&lt;strong>首部字段&lt;/strong>和一个&lt;strong>数据字段&lt;/strong>组成。首部一般是20字节，比UDP多12字节。&lt;/p>
&lt;p>&lt;strong>TCP报文段首部&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>源端口号&lt;/strong>和&lt;strong>目的端口号&lt;/strong>：被用于多路复用和多路分解。&lt;/li>
&lt;li>32比特的&lt;strong>序号字段&lt;/strong>和32比特的&lt;strong>确认号字段&lt;/strong>：用来实现可靠传输服务（是以字节来计算，不是按段来计算）&lt;/li>
&lt;li>4比特的&lt;strong>首部长度字段&lt;/strong>：指示TCP首部长度&lt;/li>
&lt;li>6比特的&lt;strong>标志字段&lt;/strong>：
&lt;ul>
&lt;li>ACK比特用于确认字段中的值是有效的&lt;/li>
&lt;li>RST、SYN、FIN比特用于连接的建立和拆除&lt;/li>
&lt;li>CWR、ECE比特在明确拥塞报告中使用&lt;/li>
&lt;li>URG比特用来指示报文段中被发送端的上层实体置为紧急的数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>16比特的&lt;strong>接收窗口字段&lt;/strong>：用于指示接收方愿意接收的字节数量&lt;/li>
&lt;li>16比特的&lt;strong>检验和字段&lt;/strong>&lt;/li>
&lt;li>16比特的&lt;strong>紧急数据指针字段&lt;/strong>&lt;/li>
&lt;li>选项字段：用于发送方和接收方协商最大报文段长度&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>序号和确认号&lt;/strong>：&lt;/p>
&lt;p>这两个字段是TCP可靠传输服务的关键&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一个报文的序号&lt;/strong>是该报文段首字节的字节流编号&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>例如，数据流由一个包含500,000字节的文件组成，其MSS为1000字节，则TCP将为该数据流创建500个报文段，第一个报文段分配的序号是0，第二个报文段的序号是1000，以此类推。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>主机A填充进报文段的&lt;strong>确认号&lt;/strong>是主机A期望从主机B收到的&lt;strong>下一个字节的序号&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>例如，主机A已经收到来自B的编号为0~255的所有字节，它打算发一个报文段给B期望收到256以及之后的所有字节，于是它就在报文段的确认号字段填上256&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>累计确认&lt;/strong>：假设主机A已经先后收到了主机B发送的两个报文段（分别为字节0~535和字节900~1000的报文段），由于一些原因并未收到中间的536~899的报文段，为了完整地建立主机B地数据流，仍在等待字节536及之后的字节，因此A给B发送地下一个报文地确认号字段中包含536，因此TCP只确认该流中第一个丢失字节为止的字节。&lt;/li>
&lt;/ul>
&lt;h3 id="往返时间的估计与超时">往返时间的估计与超时&lt;/h3>
&lt;p>&lt;strong>估计往返时间&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SampleRTT&lt;/code>：从报文段被发出（交给IP）到收到该报文段的确认之间的时间量，多数TCP只在某个时刻做一次&lt;code>SampleRTT&lt;/code>的测量，不是为每个发送的报文都做测量。&lt;/p>
&lt;blockquote>
&lt;p>问题：为什么TCP仅为传输一次的报文段测量&lt;code>SampleRTT&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>随着网络状态课端系统负载的变化，报文段的SampleRTT在不断地变化，为了找到一个典型地RTT，要采取一种方法对SampleRTT取平均，TCP会根据以下赋值公式来更新EstimatedRTT：
$$
EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT \&lt;br>
在[RFC6298]标准中推荐的a值为0.125
$$
上述的这种计算平均的方法被称为&lt;em>指数加权移动平均&lt;/em>，这个加权平均最最近的样本赋予的权值要大于对旧样本赋予的权值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一种方式：测量RTT的变化。[RFC6298]定义了&lt;em>RTT偏差DevRTT&lt;/em>：
$$
DevRTT = (1 - \beta) * DevRTT + \beta * |SampleRTT - EstimatedRTT| \&lt;br>
\beta 的推荐值为0.25
$$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设置和管理重传超时间隔&lt;/strong>：&lt;/p>
&lt;p>确认超时间隔的值：
$$
TimeoutInterval = EstimatedRTT + 4 * DevRTT \&lt;br>
推荐的TimeoutInterval初始值为1秒
$$&lt;/p>
&lt;h3 id="可靠数据传输">可靠数据传输&lt;/h3>
&lt;h3 id="流量控制接收窗口字段">流量控制（接收窗口字段）&lt;/h3>
&lt;p>一条TCP连接的每一侧的主机都为该连接设置了&lt;strong>接收缓存&lt;/strong>，当TCP连接收到正确的、按序的字节后，就会将数据放入缓存，应用程序就会从该缓存中根据实际情况读取数据，接收方可能不会立即读取刚刚放入缓存中的数据，他可能忙于别的服务。因此，可能由于发送方发送得太多太快，接收方读取得太慢导致&lt;strong>缓存溢出&lt;/strong>。&lt;/p>
&lt;p>所以，TCP为其应用程序提供了&lt;strong>流量控制服务&lt;/strong>，来防止接收方的缓存溢出，该服务是一个速度匹配服务，即将发送方的发送速率与接收方的读取速率相匹配。&lt;/p>
&lt;blockquote>
&lt;p>注意，TCP发送方也可能由于IP网络的拥塞而被遏制，这种形式的对于发送方的控制被称为&lt;strong>拥塞控制&lt;/strong>，它与流量控制是两个完全不相同的概念，它们是针对完全不同的原因而采取的措施。&lt;/p>
&lt;/blockquote>
&lt;p>TCP通过让发送方维护一个&lt;strong>接收窗口&lt;/strong>的变量来进行流量控制，接收窗口用来给发送方指示接收方剩余的缓存空间数量，TCP是双全工的，因此两端的发送方都各自维护一个接收窗口。&lt;/p>
&lt;p>假设主机A通过一条TCP连接向主机B发送一个文件，B为该连接分配了一个接收缓存，用&lt;code>RecBuffer&lt;/code>来表示其大小，定义以下的变量：&lt;/p>
&lt;ul>
&lt;li>&lt;code>LastByteRead&lt;/code>：主机B的应用程序从缓存中读取的数据流的最后一个字节的编号&lt;/li>
&lt;li>&lt;code>LastByteRcved&lt;/code>：从网络中到达并且已经放入B的缓存中的数据流的最后一个字节的编号&lt;/li>
&lt;/ul>
&lt;p>所以为了不使缓存溢出，下式必须成立：
$$
LastByteRcved - LastByteRead \le RcvBuffer
$$
接收窗口用&lt;code>rwnd&lt;/code>来表示，根据缓存可用空间大小来设置：
$$
rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]
$$
主机A要轮流跟踪两个变量：&lt;code>LastByteSent&lt;/code>和&lt;code>LastByteAcked&lt;/code>，分别指发送到连接中的数据流的最后一个字节的编号和已经确认接收的数据流的最后一个字节的编号， 因此，两者的差就代表了主机A发送到连接中但还未被确认的数据量，只要将这个数据量控制在值&lt;code>rwnd&lt;/code>以内，就不会使B的接收缓存溢出。&lt;/p>
&lt;blockquote>
&lt;p>注意一种特殊情况，假设B的缓存已满即rwnd=0，B将这个消息发送给A后，假设B没有任何的数据要发送给A，此时B的应用程序将通过不断读取数据来清空缓存，TCP并不向主机A发送带有rwnd新值的报文段，这样，A不知道B的接收缓存有新的空间，因为A被阻塞不能发送数据。解决这个问题的方法是：TCP规定当B的接收缓存为0时，A继续发送只有一个字数据的报文，这些报文段将会被B确认，最终缓存开始清空，返回一个具有新rwnd值的报文段。&lt;/p>
&lt;/blockquote>
&lt;h3 id="tcp连接管理">TCP连接管理&lt;/h3>
&lt;p>该节中将详细说明建立和拆除一条TCP连接的全过程。&lt;/p>
&lt;p>&lt;strong>3次握手建立TCP连接&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>第一步：客户端的TCP首先向服务端TCP发送一个特殊TCP报文段，该报文段不含任何应用层的数据，仅将首部中的一个标志位（&lt;code>SYN&lt;/code>比特）置为1，因此给报文段被称为&lt;em>SYN报文段&lt;/em>。此外客户会随机选择一个&lt;em>初始序号（client_isn）&lt;/em>，将此编号放入起始SYN报文段的序号字段中。最后该报文段被封装在一个IP数据报中，发送给服务器。&lt;/li>
&lt;li>第二步：包含TCP SYN报文段的IP数据包到达服务器后，服务器会从中提取TCP SYN报文段，为该TCP连接分配缓存和变量，并向客户TCP发送允许连接的报文段（该报文段被称为&lt;em>SYNACK报文段&lt;/em>）。该报文段不包含应用层数据，但首部中包含了3个重要信息：
&lt;ul>
&lt;li>SYN比特被置为1&lt;/li>
&lt;li>该TCP报文段首部的确认号字段被置为client_isn + 1&lt;/li>
&lt;li>服务器选择自己的初始序号（server_isn）并将其置放到报文首部的序号字段中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第三步：收到SYNACK报文段后，客户也要为该连接分配缓存和变量，然后客户主机向服务器发送另一个报文段，该报文段对连接进行确认（通过将TCP报文段首部的确认字段置为server_isn + 1来完成），因为连接已经建立，所以SYN比特被置为0，这个报文可以携带应用层数据。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>4次挥手终止TCP连接的过程&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="http://blog.eternityqjl.top/TCP%E7%BB%88%E6%AD%A2%E8%BF%9E%E6%8E%A5.svg" alt="TCP终止连接">&lt;/p>
&lt;p>如图，客户进程发出一个关闭连接的命令，这会引起客户TCP向服务器TCP发送一个特殊TCP报文段，该报文让其首部中的&lt;code>FIN比特&lt;/code>标志位置为1.&lt;/p>
&lt;p>服务器接收该报文段后，向发送方返回一个确认报文段。&lt;/p>
&lt;p>然后，服务器发送自己的终止报文段，其中&lt;code>FIN比特&lt;/code>被置为1.&lt;/p>
&lt;p>最终客户对这个服务器的终止报文段进行确认，此时两台主机上的资源（缓存和变量）都被释放。&lt;/p>
&lt;blockquote>
&lt;p>SYN洪泛攻击&lt;/p>
&lt;p>客户（攻击者）发送大量TCP SYN报文段，而不完成第三次握手的步骤，这种情况下服务器不断为这些&lt;em>半开连接&lt;/em>分配资源导致服务器的连接资源被消耗殆尽。&lt;/p>
&lt;p>解决方法是使用&lt;strong>SYN cookie&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>当服务器收到一个SYN报文段时，并不知道它是合法用户还是SYN洪泛攻击，所以服务器不会为其生成半开连接。相反，服务器生成一个&lt;em>初始TCP序列号&lt;/em>，该序列号是SYN报文段的源和目的IP地址与端口号以及仅有该服务器知道的一个秘密数组成的一个复杂函数，该序列号被称为&lt;em>cookie&lt;/em>。服务器并不记忆该cookie或对应于SYN的其他状态信息。&lt;/li>
&lt;li>若客户合法，它将返回一个ACK报文段，服务器借助cookie验证该ACK于前面发送的某些SYN是否对应。对于合法ACK，其确认字段的值等于SYNACK报文段的序号值（此时为cookie值）加1，以此为依据，如果二者相等，服务器认为该ACK对应于较早的SYN报文段，它是合法的，服务器将生成一个具有套接字的全开连接。&lt;/li>
&lt;li>另一方面，如果客户没有返回ACK报文段，初始SYN并未对服务器产生影响，因为服务器没有为它分配资源。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>几个特殊通信连接的情况&lt;/strong>：&lt;/p>
&lt;p>namp端口扫描工具对一台主机的目的端口6789发送一个特殊的TCP SYN报文段，有3中可能的输出：&lt;/p>
&lt;ul>
&lt;li>源主机从目标主机接收到一个TCPACK报文段，意味着目标主机上一个应用程序使用TCP端口67889运行，nmap返回打开。&lt;/li>
&lt;li>源主机从目标主机接收到一个TCP RST报文段，意味着目标主机没有运行一个使用TCP端口6789的应用程序，但知道发送的报文段没有被中间的任何防火墙阻挡。&lt;/li>
&lt;li>源主机什么也没收到，意味着很可能被防火墙阻挡。&lt;/li>
&lt;/ul>
&lt;h2 id="拥塞控制原理">拥塞控制原理&lt;/h2>
&lt;h3 id="拥塞控制方法">拥塞控制方法&lt;/h3>
&lt;p>&lt;strong>端到端拥塞控制&lt;/strong>&lt;/p>
&lt;p>该控制方法中，网络层没有为运输层拥塞控制提供显式帮助。端系统必须通过对网络行为的观察来推断网络拥塞1&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/ - 2019-2021 By Jialong</description></item><item><title>TLS（HTTPS）协议</title><link>https://eternityqjl.github.io/blog2_public/posts/tls/</link><pubDate>Sun, 19 Apr 2020 16:15:26 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/tls/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/tls/ -&lt;h2 id="1-ssltls简介">1. SSL/TLS简介&lt;/h2>
&lt;p>&lt;strong>TLS&lt;/strong>（&lt;strong>T&lt;/strong>ransport &lt;strong>L&lt;/strong>ayer &lt;strong>S&lt;/strong>ecurity，&lt;strong>传输层安全协议&lt;/strong>），以及它的前身&lt;strong>SSL&lt;/strong>（&lt;strong>S&lt;/strong>ecure &lt;strong>S&lt;/strong>ockets &lt;strong>L&lt;/strong>ayer，&lt;strong>安全套接层&lt;/strong>）是一种安全协议。Netscape公司在1994年推出HTTPS协议，使用SSL进行加密，这是SSL的起源。1999年公布了第一版的TLS协议，类似于SLLv3，只是对其做出了一些更改。&lt;/p>
&lt;p>SSL协议处在计算机网络中的应用层和运输层之间，它不依赖于平台和运行程序的协议。&lt;/p>
&lt;p>&lt;strong>几个知名的使用SSL加密的协议&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>HTTP over SSL (HTTPS)&lt;/strong>&lt;/p>
&lt;p>简称为HTTPS，它的产生是为了加密网页，HTTP是第一个使用SSL保障安全的应用层协议。HTTPS在RFC2818被标准化，HTTPS工作在443端口，HTTP默认工作在80端口。&lt;/p>
&lt;p>&lt;strong>Email over SSL&lt;/strong>&lt;/p>
&lt;p>类似于HTTP over SSL，协议如下：&lt;/p>
&lt;ul>
&lt;li>SMTP、IMAP能够支持SSL&lt;/li>
&lt;li>SMTP over TLS在标准文档RFC2487中&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h2 id="2-ssl原理详解">2. SSL原理详解&lt;/h2>
&lt;h3 id="20-基本运行过程">2.0 基本运行过程&lt;/h3>
&lt;p>SSL/TLS协议是采用&lt;strong>公钥加密法&lt;/strong>实现的，客户端先向服务器端索要公钥，用公钥加密信息，服务器收到密文后，用自己的私钥解密；二者协商生成”对话密钥“，采用该”对话密钥“进行加密通信。&lt;/p>
&lt;h3 id="21-ssl建立的总过程">2.1 SSL建立的总过程&lt;/h3>
&lt;p>客户端向服务器索要并验证公钥，双方协商生成”对话密钥“的过程又称为”握手阶段“，该阶段涉及&lt;strong>四次握手&lt;/strong>通信，且该阶段的通信都是明文的。以下一一来分析。&lt;/p>
&lt;h4 id="1-客户端发出请求clienthello">1. 客户端发出请求（ClientHello）&lt;/h4>
&lt;p>该步客户端（通常为浏览器）向服务器提供以下信息：&lt;/p>
&lt;ul>
&lt;li>支持的协议&lt;strong>版本（Version）&lt;/strong>，如TLSv1.0&lt;/li>
&lt;li>一个客户端生成的&lt;strong>随机数（Random）&lt;/strong>，之后用于生成”对话密钥“&lt;/li>
&lt;li>&lt;strong>会话ID（Session id）&lt;/strong>：
&lt;ul>
&lt;li>如果客户端第一次连接到服务器，那么该字段为空。&lt;/li>
&lt;li>如果该字段不为空，则说明以前与服务器有连接，在此期间，服务器使用Session ID映射对称密钥，并将Session ID存储在客户端浏览器中，为映射设置一个时间限，如果浏览器将来连接到同一台服务器，它将发送Session ID，服务器对映射的Session ID进行验证，并使用以前用过的对称密钥来恢复会话，该情况下不需要握手，也成为&lt;strong>SSL会话恢复&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>支持的&lt;strong>加密套件（Cipher Suites）&lt;/strong>，这是由客户按优先级排列的，但完全由服务器决定发送与否。服务器会从客户端发送的加密套件中选择一种作为共同的加密套件，如RSA公钥加密。&lt;/li>
&lt;li>支持的&lt;strong>压缩方法&lt;/strong>，这是为了减少带宽。从TLS 1.3开始，协议禁用了TLS压缩，因为使用压缩时攻击可以捕获到用HTTP头发送的参数，该攻击可以劫持Cookie。&lt;/li>
&lt;li>扩展包。&lt;/li>
&lt;/ul>
&lt;h4 id="2-服务器回应serverhello">2. 服务器回应（ServerHello）&lt;/h4>
&lt;p>该步骤包含以下内容：&lt;/p>
&lt;ul>
&lt;li>确认使用的&lt;strong>版本&lt;/strong>，如TLSv1.0，如果浏览器与服务器支持的版本不一致，服务器会关闭加密通信。&lt;/li>
&lt;li>一个服务器生成的&lt;strong>随机数&lt;/strong>，之后用于生成”对话密钥“&lt;/li>
&lt;li>确认使用的&lt;strong>加密套件&lt;/strong>&lt;/li>
&lt;li>&lt;strong>会话ID&lt;/strong>（Session ID）：
&lt;ul>
&lt;li>服务器将约定的Session参数存储在TLS缓存中，并生成与之对应的Session ID，它将与ServerHello一起发送到客户端。客户端可以写入约定的参数到此Session ID，并给定到期时间，客户端将在ClientHello中包含该ID。如果客户端再次连接到该服务器，服务器可以检查与Session ID对应的缓存参数，并重用他们而无需再次握手。这可以节省大量计算成本。&lt;/li>
&lt;li>但在谷歌等大流量应用程序中这种方法存在缺点，每天有数百万人连接到服务器，服务器必须使用Session ID保留所有Session参数的TLS缓存，这是一笔巨大的开销。为解决该问题，在扩展包中加入&lt;strong>Session Tickets&lt;/strong>，在这里客户端可以在ClientHello中指定它是否支持Session Tickets，然后服务器将创建一个新的Session Tickets，并使用只有服务器知道的经过私钥加密的Session参数，该参数存储在客户端中，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>扩展包&lt;/strong>&lt;/li>
&lt;li>&lt;strong>服务器证书&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>当服务器需要确认客户端身份时，就会再包含一个请求，要求客户端提供”客户端证书“。例如金融机构只允许认证客户连入自己的网络，回向正式用户提供USB密钥（U盾），里面包含一张客户端证书。&lt;/p>
&lt;h4 id="3-客户端回应">3. 客户端回应&lt;/h4>
&lt;p>客户端收到服务器回应后首先验证服务器的证书，如果证书存在问题，如证书过期、由非可信机构颁布、或证书域名与实际域名不一致，会想客户端访问者发出警告，询问是否继续通信。&lt;/p>
&lt;p>证书没有问题则客户端会从中取出公钥然后发送以下信息：&lt;/p>
&lt;ul>
&lt;li>一个&lt;strong>随机数（pre-master-key)&lt;/strong>；该随机数用服务器公钥加密，防止被窃听。&lt;/li>
&lt;li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。&lt;/li>
&lt;li>客户端结束握手通知，该项同时也是前面发送所有内容的哈希值，用来供服务器验证。&lt;/li>
&lt;/ul>
&lt;p>上面第一项的随机数是握手阶段出现的第三个随机数，称“pre-master-key”，之后客户端和服务器就同时有了3个随机数，接着用双方事先商定的加密方法各自生成本次会话用的同一把“会话密钥”。&lt;/p>
&lt;blockquote>
&lt;p>pre-master-key与前面服务器和客户端在Hello阶段产生的两个随机数结合在一起生成了Master Secret。&lt;/p>
&lt;/blockquote>
&lt;h4 id="4-服务器的最后回应">4. 服务器的最后回应&lt;/h4>
&lt;p>服务器收到客户端第三个随机数pre-master-key后，计算生成本次会话使用的“会话密钥”，然后向客户端发送以下信息：&lt;/p>
&lt;ul>
&lt;li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。&lt;/li>
&lt;li>服务器握手结束通知，该项同时也是前面发送的所有内容的哈希值，用来供客户端验证。&lt;/li>
&lt;/ul>
&lt;p>至此整个握手阶段就结束了，接下来客户端与服务器进入加密通信，就是完全使用普通的HTTP协议，只是使用了“会话密钥”加密内容。&lt;/p>
&lt;h3 id="22-ssl协议的结构体系">2.2 SSL协议的结构体系&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SSL%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_1.png" alt="">&lt;/p>
&lt;p>SSL体系结构包含两个协议子层，底层为&lt;strong>SSL记录协议层&lt;/strong>；高层为&lt;strong>SSL握手协议层&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>SSL记录协议层&lt;/strong>：记录协议为高层协议提供基本的安全服务，如数据封装、压缩、加密等基本功能。所以我们可以知道，所有的传输数据都被封装在记录中。&lt;/li>
&lt;li>&lt;strong>SSL握手协议层&lt;/strong>包括：
&lt;ul>
&lt;li>SSL握手协议：协调客户和服务器的状态，是双方能达到状态的同步&lt;/li>
&lt;li>SSL密码参数修改协议：更新用于当前连接的密码组。&lt;/li>
&lt;li>SSL告警协议：发现异常时为对等方传递警告&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3-参考">3. 参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">SSL/TLS协议详解|曹世宏的博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述|阮一峰&lt;/a>&lt;/li>
&lt;/ul>
- https://eternityqjl.github.io/blog2_public/posts/tls/ - 2019-2021 By Jialong</description></item><item><title>PDF转换为SVG</title><link>https://eternityqjl.github.io/blog2_public/posts/convertpdftosvg/</link><pubDate>Wed, 08 Apr 2020 00:15:48 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/convertpdftosvg/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/convertpdftosvg/ -&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近在写笔记文档和实验报告的时候遇到一些处理资料图片的问题，PDF电子书或文档中的插图一般为矢量图，自己写笔记如果需要引用这些插图时，一般会直接截图，截图为JEPG或PNG格式，并非矢量图，会在新的文档中出现失真。所以为了解决这个问题，我使用&lt;strong>Adobe Acrobat&lt;/strong>和&lt;strong>inkscape&lt;/strong>两个软件将PDF中的矢量图导出为&lt;strong>SVG&lt;/strong>格式的矢量图。以下为具体步骤：&lt;/p>
&lt;h2 id="在adobe-acrobat中选择编辑pdf选项">在&lt;code>Adobe Acrobat&lt;/code>中选择&lt;code>编辑PDF&lt;/code>选项&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_1.JPG" alt="">&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="选择裁剪页面">选择&lt;code>裁剪页面&lt;/code>&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_2.JPG" alt="">&lt;/p>
&lt;h2 id="框选所需图片的区域">框选所需图片的区域&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_3.JPG" alt="">&lt;/p>
&lt;h2 id="双击框选的区域按如下所示设置">双击框选的区域，按如下所示设置&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_4.JPG" alt="">&lt;/p>
&lt;h2 id="选择组织页面">选择&lt;code>组织页面&lt;/code>&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_5.JPG" alt="">&lt;/p>
&lt;h2 id="选定裁切后的页面">选定裁切后的页面&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_6.JPG" alt="">&lt;/p>
&lt;h2 id="右击后选择打印页面">右击后选择&lt;code>打印页面&lt;/code>&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_7.png" alt="">&lt;/p>
&lt;h2 id="设置页面按照pdf页面大小选择纸张来源这样选择后最终导出的图片范围才是裁切时所选范围然后打印">设置页面：按照PDF页面大小选择纸张来源，这样选择后最终导出的图片范围才是裁切时所选范围。然后打印。&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_8.JPG" alt="">&lt;/p>
&lt;h2 id="用inkscape打开刚才打印的pdf文件注意导入时设置为第一项从popplercairo导入类似于ps中的栅格化这样才能保证图中的字体不发生改变">用&lt;code>inkscape&lt;/code>打开刚才打印的PDF文件，注意，导入时设置为第一项&lt;code>从Poppler/Cairo导入&lt;/code>，类似于PS中的栅格化，这样才能保证图中的字体不发生改变&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_9.JPG" alt="">&lt;/p>
&lt;h2 id="选择文件rightarrow文档属性设置自定义尺寸为缩放页面到内容rightarrow缩放页面到绘图或选区">选择&lt;code>文件&lt;/code>$\rightarrow$&lt;code>文档属性&lt;/code>，设置自定义尺寸为&lt;code>缩放页面到内容&lt;/code>$\rightarrow$&lt;code>缩放页面到绘图或选区&lt;/code>&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_10_0.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_10.JPG" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_11.png" alt="">&lt;/p>
&lt;h2 id="文件rightarrow另存为选择自己所需的格式我一般选svg">&lt;code>文件&lt;/code>$\rightarrow$&lt;code>另存为&lt;/code>，选择自己所需的格式，我一般选&lt;code>SVG&lt;/code>&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_12.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/convertingPDFtoSVG_13.JPG" alt="">&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/convertpdftosvg/ - 2019-2021 By Jialong</description></item><item><title>第一次使用LaTex——问题整理</title><link>https://eternityqjl.github.io/blog2_public/posts/latex-problems1/</link><pubDate>Sun, 29 Mar 2020 00:14:06 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/latex-problems1/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/latex-problems1/ -&lt;h2 id="0前言">0.前言&lt;/h2>
&lt;p>第一次使用Tex语言完整地完成了一篇实验报告的构建排版，这过程中遇到了各种各样的问题，有些问题虽然解决了，但在原理方面还是一知半解，之后再遇到还希望能多看文档。这篇博客是来记录第一次编写过程中遇到的一些问题。&lt;/p>
&lt;p>这是第一次实验报告导出的&lt;a href="http://blog.eternityqjl.top/SS_test1.pdf">pdf文档&lt;/a>封面展示：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SS_test1_cover.jpg" alt="">&lt;/p>
&lt;p>这是&lt;a href="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SS_test1.tex">tex源代码&lt;/a>。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="章节标题的特殊符号">章节标题的特殊符号&lt;/h2>
&lt;p>当我在章节标题的大括号内输入行内公式时出现了错误，查找后发现pdf书签中不能使用特殊符号，需要用命令&lt;code>\texorpdfstring{}{}&lt;/code>分别定义在TEX文档输出的代码和PDF书签处的纯文本形式，第一个括号&lt;code>{}&lt;/code>中填写tex文档代码，第二个括号&lt;code>{}&lt;/code>填写文本形式的书签，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#888">%1.1
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">\subsection&lt;/span>&lt;span style="color:#00c">[第3题（1）]&lt;/span>&lt;span style="color:#007020">{&lt;/span>第3题（1）求&lt;span style="color:#080;font-weight:bold">\texorpdfstring&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="background-color:#fff0f0">$&lt;/span>&lt;span style="color:#007020">x_&lt;/span>&lt;span style="color:#60e;font-weight:bold">1&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)=&lt;/span>&lt;span style="color:#60e;font-weight:bold">1&lt;/span>&lt;span style="color:#007020">.&lt;/span>&lt;span style="color:#60e;font-weight:bold">5&lt;/span>&lt;span style="color:#007020">e^{&lt;/span>&lt;span style="color:#333">-&lt;/span>&lt;span style="color:#60e;font-weight:bold">2&lt;/span>&lt;span style="color:#007020">t}u&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)&lt;/span>&lt;span style="background-color:#fff0f0">$&lt;/span>&lt;span style="color:#007020">}{&lt;/span>x1&lt;span style="color:#007020">}&lt;/span>，
&lt;span style="color:#080;font-weight:bold">\texorpdfstring&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="background-color:#fff0f0">$&lt;/span>&lt;span style="color:#007020">x_&lt;/span>&lt;span style="color:#60e;font-weight:bold">2&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)=&lt;/span>&lt;span style="color:#007020">cos&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#60e;font-weight:bold">2&lt;/span>&lt;span style="color:#333">)[&lt;/span>&lt;span style="color:#007020">u&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)-&lt;/span>&lt;span style="color:#007020">u&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">-&lt;/span>&lt;span style="color:#60e;font-weight:bold">2&lt;/span>&lt;span style="color:#333">)]&lt;/span>&lt;span style="background-color:#fff0f0">$&lt;/span>&lt;span style="color:#007020">}{&lt;/span>x2&lt;span style="color:#007020">}&lt;/span>的卷积积分
&lt;span style="color:#080;font-weight:bold">\texorpdfstring&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="background-color:#fff0f0">$&lt;/span>&lt;span style="color:#007020">y_&lt;/span>&lt;span style="color:#60e;font-weight:bold">1&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)=&lt;/span>&lt;span style="color:#007020">x_&lt;/span>&lt;span style="color:#60e;font-weight:bold">1&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)*&lt;/span>&lt;span style="color:#007020">x_&lt;/span>&lt;span style="color:#60e;font-weight:bold">2&lt;/span>&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">t&lt;/span>&lt;span style="color:#333">)&lt;/span>&lt;span style="background-color:#fff0f0">$&lt;/span>&lt;span style="color:#007020">}{&lt;/span>y1&lt;span style="color:#007020">}&lt;/span>。 &lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="代码段的设置">代码段的设置&lt;/h2>
&lt;p>在文章中添加代码段需要用到&lt;code>listings&lt;/code>宏包，代码段的基本设置参数如下所示：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="http://texdoc.net/texmf-dist/doc/latex/listings/listings.pdf">listings宏包文档&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>listings&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\lstset&lt;/span>&lt;span style="color:#007020">{&lt;/span>
language=Matlab,
escapeinside=``,
numbers=left,
numberstyle=&lt;span style="color:#080;font-weight:bold">\tiny&lt;/span>,
breaklines=true,
backgroundcolor=&lt;span style="color:#080;font-weight:bold">\color&lt;/span>&lt;span style="color:#007020">{&lt;/span>lightgray!40!white&lt;span style="color:#007020">}&lt;/span>,
frame=single,
framerule=0pt,
extendedchars=false,
keywordstyle=&lt;span style="color:#080;font-weight:bold">\color&lt;/span>&lt;span style="color:#007020">{&lt;/span>blue!70&lt;span style="color:#007020">}&lt;/span>&lt;span style="color:#080;font-weight:bold">\bfseries&lt;/span>,
basicstyle=&lt;span style="color:#080;font-weight:bold">\ttfamily&lt;/span>,
commentstyle=&lt;span style="color:#080;font-weight:bold">\ttfamily\color&lt;/span>&lt;span style="color:#007020">{&lt;/span>green!40!black&lt;span style="color:#007020">}&lt;/span>,
showstringspaces=false&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时，设置代码段颜色高亮时需要用到&lt;code>xcolor&lt;/code>宏包。&lt;/p>
&lt;p>注意以下几点问题：&lt;/p>
&lt;ul>
&lt;li>代码段中最好不要出现中文，如果必须要使用中文，需要用逃逸字符` `将中文包括起来，如上面的基本参数中的escapeinside=` ` 所示。&lt;/li>
&lt;li>如果代码段中出现tex语言的特殊符号，需要使用转义字符&lt;code>\&lt;/code>，如&lt;code>#&lt;/code>就需要转换为&lt;code>\#&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>如果想要改变代码段中的字体，需要用到&lt;code>fontspec&lt;/code>宏包，这个宏包需要用&lt;code>XeLaTex&lt;/code>或&lt;code>LuaLaTex&lt;/code>进行编译，由于我的实验报告封面使用的有些元素在使用这两者编译时无法识别，我这次就没使用，下次写实验报告一定仔细研究一下，实现这个功能。&lt;/p>
&lt;h2 id="数学公式中的align">数学公式中的align&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://tex.stackexchange.com/questions/372384/erroneous-nesting-of-equation-structures-message-i-cant-see-whats-wrong">“Erroneous nesting of equation structures” message- I can&amp;rsquo;t see what&amp;rsquo;s wrong?&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>数学公式中需要写等号对齐的公式段是不需要写&lt;code>$$...$$&lt;/code>或者&lt;code>begin{equation}...end{equation}&lt;/code>，直接将公式写在&lt;code>begin{align}...end{align}&lt;/code>的中间即可，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>align&lt;span style="color:#007020">}&lt;/span>
y&lt;span style="color:#007020">_&lt;/span>2[n]
&lt;span style="color:#007020">&amp;amp;&lt;/span>=x&lt;span style="color:#007020">_&lt;/span>3[n]*x&lt;span style="color:#007020">_&lt;/span>4[n] &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#007020">&amp;amp;&lt;/span>=((-&lt;span style="color:#080;font-weight:bold">\frac&lt;/span>&lt;span style="color:#007020">{&lt;/span>2&lt;span style="color:#007020">}{&lt;/span>3&lt;span style="color:#007020">}&lt;/span>)&lt;span style="color:#007020">^&lt;/span>n u[n-1])*((-1)&lt;span style="color:#007020">^{&lt;/span>n+1&lt;span style="color:#007020">}&lt;/span>u[n-1]-(-2)&lt;span style="color:#007020">^{&lt;/span>n-2&lt;span style="color:#007020">}&lt;/span>u[n-2]) &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#007020">&amp;amp;&lt;/span>=&lt;span style="color:#080;font-weight:bold">\sum&lt;/span>&lt;span style="color:#007020">_{&lt;/span>k=-&lt;span style="color:#080;font-weight:bold">\infty&lt;/span>&lt;span style="color:#007020">}^{&lt;/span>+&lt;span style="color:#080;font-weight:bold">\infty&lt;/span>&lt;span style="color:#007020">}&lt;/span>(-&lt;span style="color:#080;font-weight:bold">\frac&lt;/span>&lt;span style="color:#007020">{&lt;/span>2&lt;span style="color:#007020">}{&lt;/span>3&lt;span style="color:#007020">}&lt;/span>)&lt;span style="color:#007020">^&lt;/span>k u[k-1]((-1)&lt;span style="color:#007020">^{&lt;/span>n-k+1&lt;span style="color:#007020">}&lt;/span>u[n-k+1]-(-2)&lt;span style="color:#007020">^{&lt;/span>n-k-2&lt;span style="color:#007020">}&lt;/span>u[n-k-2]) &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#007020">&amp;amp;&lt;/span>=&lt;span style="color:#080;font-weight:bold">\sum&lt;/span>&lt;span style="color:#007020">_{&lt;/span>k=1&lt;span style="color:#007020">}^{&lt;/span>+&lt;span style="color:#080;font-weight:bold">\infty&lt;/span>&lt;span style="color:#007020">}&lt;/span>(-&lt;span style="color:#080;font-weight:bold">\frac&lt;/span>&lt;span style="color:#007020">{&lt;/span>2&lt;span style="color:#007020">}{&lt;/span>3&lt;span style="color:#007020">}&lt;/span>)&lt;span style="color:#007020">^&lt;/span>k ((-1)&lt;span style="color:#007020">^{&lt;/span>n-k+1&lt;span style="color:#007020">}&lt;/span>u[n-k+1]-(-2)&lt;span style="color:#007020">^{&lt;/span>n-k-2&lt;span style="color:#007020">}&lt;/span>u[n-k-2]) &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#007020">&amp;amp;&lt;/span>=
&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>cases&lt;span style="color:#007020">}&lt;/span>
0, &lt;span style="color:#080;font-weight:bold">\ &lt;/span>n&amp;lt;0 &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\sum&lt;/span>&lt;span style="color:#007020">_{&lt;/span>k=1&lt;span style="color:#007020">}^{&lt;/span>+&lt;span style="color:#080;font-weight:bold">\infty&lt;/span>&lt;span style="color:#007020">}&lt;/span>(-&lt;span style="color:#080;font-weight:bold">\frac&lt;/span>&lt;span style="color:#007020">{&lt;/span>2&lt;span style="color:#007020">}{&lt;/span>3&lt;span style="color:#007020">}&lt;/span>)&lt;span style="color:#007020">^&lt;/span>k (-1)&lt;span style="color:#007020">^{&lt;/span>n-k+1&lt;span style="color:#007020">}&lt;/span>u[n-k+1], &lt;span style="color:#080;font-weight:bold">\ &lt;/span>0 &lt;span style="color:#080;font-weight:bold">\leq&lt;/span> n &lt;span style="color:#080;font-weight:bold">\leq&lt;/span> 2 &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\sum&lt;/span>&lt;span style="color:#007020">_{&lt;/span>k=1&lt;span style="color:#007020">}^{&lt;/span>+&lt;span style="color:#080;font-weight:bold">\infty&lt;/span>&lt;span style="color:#007020">}&lt;/span>(-&lt;span style="color:#080;font-weight:bold">\frac&lt;/span>&lt;span style="color:#007020">{&lt;/span>2&lt;span style="color:#007020">}{&lt;/span>3&lt;span style="color:#007020">}&lt;/span>)&lt;span style="color:#007020">^&lt;/span>k ((-1)&lt;span style="color:#007020">^{&lt;/span>n-k+1&lt;span style="color:#007020">}&lt;/span>u[n-k+1]-(-2)&lt;span style="color:#007020">^{&lt;/span>n-k-2&lt;span style="color:#007020">}&lt;/span>u[n-k-2]),&lt;span style="color:#080;font-weight:bold">\ &lt;/span>n&amp;gt;2
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>cases&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>align&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://blog.eternityqjl.top/equationSample.JPG" alt="">&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/latex-problems1/ - 2019-2021 By Jialong</description></item><item><title>信号与系统学习笔记——Chapter01 信号与系统</title><link>https://eternityqjl.github.io/blog2_public/posts/signalsystem-ch01/</link><pubDate>Sat, 14 Mar 2020 13:59:44 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/signalsystem-ch01/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/signalsystem-ch01/ -&lt;h2 id="13-指数信号与正弦信号">1.3 指数信号与正弦信号&lt;/h2>
&lt;h3 id="131-连续时间复指数信号与正弦信号">1.3.1 连续时间复指数信号与正弦信号&lt;/h3>
&lt;p>连续时间复指数信号有如下形式：
$$
x(t)=Ce^{at}
$$&lt;/p>
&lt;h4 id="实指数信号">实指数信号&lt;/h4>
&lt;p>上式中的$C$和$a$都为实数的信号。&lt;/p>
&lt;h4 id="周期复指数信号和正弦信号">周期复指数信号和正弦信号&lt;/h4>
&lt;p>第二种重要的信号为将上式$a$限制为纯虚数的信号（&lt;strong>复指数信号&lt;/strong>）：
$$
x(t)=e^{jw_0t}
$$
当基波周期$T_0 = \left| \frac {2\pi} {w_0} \right|$时，该信号是周期信号。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>与该信号相关的另一种信号是&lt;strong>正弦信号&lt;/strong>：
$$
x(t)=A\cos(w_0t+\phi)
$$
利用&lt;strong>欧拉公式&lt;/strong>，可以将复指数信号用与其相同几波周期的正弦信号来表示：
$$
e^{jw_0t}=\cos w_0t + j\sin w_0t
$$
$w_0$称为基波频率。&lt;/p>
&lt;p>上述复指数信号和正弦信号都是&lt;strong>具有无限能量&lt;/strong>但&lt;strong>有有限平均功率&lt;/strong>的信号。&lt;/p>
&lt;p>计算证明：
$$
E_{period}=\int_{o}^{T_0} \left| e^{jw_0t} \right|^2 \mathrm{d}t = \int_{o}^{T_0} 1 \cdot \mathrm{d}t = T_0 \&lt;br>
P_{period}= \frac {1}{T_0} E_{period}=1
$$&lt;/p>
&lt;h4 id="一般复指数信号">一般复指数信号&lt;/h4>
&lt;p>一复指数信号$Ce^{at}$，将复数$C$和$a$分别用指数式（极坐标）和代数式（笛卡尔坐标）表示：
$$
C = \left| C \right| e^{j \theta} \&lt;br>
a = r + j\omega_0
$$
代入得：
$$
\begin{align}
Ce^{at}
&amp;amp; = \left| C \right| e^{j\theta} e^{(r+jw_0)t} \&lt;br>
&amp;amp; = \left| C \right| e^{rt} e^{j(w_0t+\theta)} \&lt;br>
&amp;amp; = \left| C \right| e^{rt} \cos(w_0t+\theta) + j\left| C \right| e^{rt} \sin(w_0t+\theta)
\end{align}
$$
若$r=0$，则复指数信号的实部和虚部都是&lt;strong>正弦&lt;/strong>；若$r&amp;gt;0$，则实部和虚部是一个&lt;strong>呈指数增长&lt;/strong>的正弦信号；若$r&amp;lt;0$，则二者都是一个&lt;strong>呈指数衰减&lt;/strong>的正弦信号，该信号被称为阻尼正弦震荡。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/increasingSineSignal.png" alt="">&lt;/p>
&lt;h3 id="132-离散时间复指数信号与正弦信号">1.3.2 离散时间复指数信号与正弦信号&lt;/h3>
&lt;p>一种重要的离散时间信号是&lt;strong>复指数信号&lt;/strong>或&lt;strong>序列&lt;/strong>，定义为：
$$
x[n]=C\alpha ^n
$$
其中的$C$和$\alpha$一般为复数，若另$\alpha = e^{\beta}$，则有另外一种表达方式：
$$
x[n]=C e^{\beta n}
$$
从形式上看第二个式子与前面的连续时间复指数信号更相似，但在离散时间的情况下，第一种更为方便使用。&lt;/p>
&lt;h4 id="实指数信号-1">实指数信号&lt;/h4>
&lt;p>$C$和$\alpha$都为实数，有以下特性：&lt;/p>
&lt;ul>
&lt;li>若$\left| \alpha \right| &amp;gt; 1$，信号随n指数增长，若$\left| \alpha \right| &amp;lt; 1$，信号随n指数衰减。&lt;/li>
&lt;li>$\left| \alpha \right|$为正值时，信号的所有值都为整数，$\left| \alpha \right|$为负值时，信号的符号在正负之间交替变化。&lt;/li>
&lt;/ul>
&lt;h4 id="正弦信号">正弦信号&lt;/h4>
&lt;h4 id="一般复指数信号-1">一般复指数信号&lt;/h4>
&lt;h3 id="133-离散时间复指数序列的周期性质">1.3.3 离散时间复指数序列的周期性质&lt;/h3>
&lt;p>这里讨论的关于离散时间复指数序列的性质都是相对于连续时间信号的不同之处。&lt;/p>
&lt;h4 id="频率性质">频率性质&lt;/h4>
&lt;p>对于频率为$w_0+2\pi$的离散时间复指数信号：
$$
e^{j(w_0+2\pi)n} = e^{j2\pi n}+e^{jw_0 n} = e^{jw_0 n}
$$
上式表明，频率为$w_0+2\pi$的离散时间复指数信号与频率为$w_0$的信号完全相同。所以离散时间复指数信号的频率只需要在一个$2\pi$间隔内选择，一般在$0\leqslant w_0 \leqslant 2\pi$或$-\pi \leqslant w_0 \leqslant \pi$中选择。&lt;/p>
&lt;p>离散时间复指数信号的低频部分（变化慢的地方）位于$w_0$在0，$2\pi$及其他$\pi$的偶数倍值附近；高频部分位于$w_0$在$\pm \pi$及其他$\pi$的奇数倍附近。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/discreteTimeSignal.JPG" alt="">&lt;/p>
&lt;h4 id="周期性质">周期性质&lt;/h4>
&lt;p>为了使得信号$e^{jw_0n}$是周期的，必须有：
$$
e^{jw_0(n+N)} = e^{jw_0n}
$$
这等效于：
$$
e^{jw_0N} = 1 \Leftrightarrow w_0N = 2\pi m \Leftrightarrow \frac{w_0}{2\pi} = \frac{m}{N}
$$
$m$为整数。同时，若$\frac{w_0}{2\pi}$是一个有理数，该信号就是周期的，否则就不是周期的。上式如果$N$和$m$没有公因子，那么$N$九尾基波周期。&lt;/p>
&lt;h4 id="连续时间和离散时间信号的比较">连续时间和离散时间信号的比较&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/compare_discrete%2526continus.JPG" alt="">&lt;/p>
&lt;h2 id="14-单位冲激与单位阶跃函数">1.4 单位冲激与单位阶跃函数&lt;/h2>
&lt;h3 id="141-离散时间单位脉冲和单位阶跃序列">1.4.1 离散时间单位脉冲和单位阶跃序列&lt;/h3>
&lt;p>最简单的离散时间信号之一就是&lt;strong>单位脉冲&lt;/strong>（或&lt;strong>单位样本&lt;/strong>），定义为：
$$
\delta[n] =
\begin{cases}
0, \quad n \ne 0 \&lt;br>
1, \quad n = 0
\end{cases}
$$
另一个基本离散时间信号为&lt;strong>单位阶跃&lt;/strong>，定义为：
$$
u[n] =
\begin{cases}
0, \quad n &amp;lt; 0 \&lt;br>
1, \quad n \geqslant 0
\end{cases}
$$
以上两个离散时间信号存在着密切的关系：&lt;/p>
&lt;ul>
&lt;li>单位脉冲是单位阶跃的&lt;strong>一次差分&lt;/strong>，即$\delta[n] = u[n] - u[n-1]$&lt;/li>
&lt;li>离散时间阶跃是单位样本的&lt;strong>求和函数&lt;/strong>：$u[n] = \sum_{m = - \infty}^{n} \delta[m]$&lt;/li>
&lt;/ul>
&lt;h3 id="142-连续时间单位阶跃和单位冲激函数">1.4.2 连续时间单位阶跃和单位冲激函数&lt;/h3>
&lt;p>连续时间&lt;strong>单位阶跃函数&lt;/strong>定义为：
$$
u(t)=
\begin{cases}
0, \quad t&amp;lt;0 \&lt;br>
1, \quad t&amp;gt;0
\end{cases}
$$
单位阶跃在$t=0$这一单处不连续。&lt;/p>
&lt;p>连续时间单位阶跃是连续时间单位冲激的&lt;strong>积分函数&lt;/strong>：
$$
u(t) = \int_{-\infty}^{t} \delta(\tau) \mathrm{d}\tau
$$
同时可以看出，连续时间单位冲激可以看成连续时间单位阶跃的**一次微分**：
$$
\delta(t) = \frac{\mathrm{d}u(t)}{\mathrm{d}t}
$$
严格来说$u(t)$是不可微的，可以把上式近似为一个在较短时间$\Delta$内完成&lt;/p>
&lt;h2 id="15-连续时间和离散时间系统">1.5 连续时间和离散时间系统&lt;/h2>
&lt;ul>
&lt;li>连续时间系统：$x(t) \rightarrow y(t)$&lt;/li>
&lt;li>离散时间系统：$x[n] \rightarrow y[n]$&lt;/li>
&lt;/ul>
&lt;p>我们的任务是要鉴别一类系统，透彻地了解一类系统的行为，在很多的实践中重要的系统都通过这一类系统来建模。本书重点关注的线性时不变系统这一特殊类别的系统就属于上述分类特性的一类。&lt;/p>
&lt;h3 id="151-系统的互联">1.5.1 系统的互联&lt;/h3>
&lt;h4 id="串联级联">串联（级联）&lt;/h4>
&lt;p>eg：音频系统：无线电接收机$\rightarrow$唱片播放器$\rightarrow$扬声器&lt;/p>
&lt;h4 id="并联">并联&lt;/h4>
&lt;h4 id="反馈互联">反馈互联&lt;/h4>
&lt;p>eg：数字控制的一架飞机&lt;/p>
&lt;h3 id="152-基本系统性质">1.5.2 基本系统性质&lt;/h3>
&lt;h4 id="记忆系统和无记忆系统">记忆系统和无记忆系统&lt;/h4>
&lt;p>如果对自变量的每一个值，一个系统的输出仅仅取决于&lt;strong>该时刻的输入&lt;/strong>，这个系统就称为&lt;strong>无记忆&lt;/strong>系统。例如，如下的表达式：
$$
y[n]=(2x[n]-x^2[n])^2
$$
是一个无记忆系统，任何特定时刻$n_0$的输出$y[n]$只取决于该时刻的输入$x[n]$。&lt;/p>
&lt;p>&lt;strong>恒等系统&lt;/strong>（即输出等于输入）是一种最简单的无记忆系统。&lt;/p>
&lt;p>&lt;strong>离散时间记忆系统&lt;/strong>的一个例子就是&lt;strong>累加器&lt;/strong>：
$$
y[n]=\sum_{k=-\infty}^{n} x[k]
$$
第二个离散时间记忆系统的例子是一个**延迟单元**：
$$
y[n] = x[n - 1]
$$
一个**连续时间记忆系统**的例子是**一个电容器**，将电流作为输入，电压作为输出，那么有：
$$
y(t)= \frac{1}{C} \int_{-\infty}^{t} x(\tau) \mathrm{d} \tau
$$
其中的$C$为电容值。&lt;/p>
&lt;p>一个系统中记忆的概念相应于该系统具有&lt;strong>保留或储存不是当前时刻输入信息的功能&lt;/strong>，在许多实际系统中，记忆是直接与能量储存相关联的。&lt;/p>
&lt;h4 id="可逆性与可逆系统">可逆性与可逆系统&lt;/h4>
&lt;p>一个系统如果在不同输入下导致不同输出，就称该系统是&lt;strong>可逆的&lt;/strong>。一个系统可逆则一定有一个&lt;strong>逆系统&lt;/strong>存在，逆系统与原系统&lt;strong>级联&lt;/strong>后，会产生一个输出$w[n]$等于一个系统的输入$x[n]$。&lt;/p>
&lt;p>可逆连续时间系统的一个例子：
$$
y(t)=2x(t)
$$
该可逆系统的逆系统为：
$$
w(t)=\frac{1}{2}y(t)
$$
一个&lt;strong>不可逆&lt;/strong>系统的例子如下：
$$
y[n]=0
$$
该系统对任何输入序列产生的都是零输出序列。&lt;/p>
&lt;p>另外一个例子：
$$
y(t)=x^2(t)
$$
这种情况无法根据输出确定输入的正负。&lt;/p>
&lt;h4 id="因果性">因果性&lt;/h4>
&lt;p>如果一个系统&lt;strong>在任何时刻的输出&lt;/strong>只取决于&lt;strong>现在的输入以及过去的输入&lt;/strong>，该系统就称为&lt;strong>因果系统&lt;/strong>。这样的系统也被称为&lt;strong>不可预测系统&lt;/strong>，系统的输出值无法预测未来的输入值。&lt;/p>
&lt;p>所有的无记忆系统都是因果的，因为输出仅仅对当前输入值作出响应。&lt;/p>
&lt;blockquote>
&lt;p>检验系统的因果性时要仔细看系统的输入——输出关系，举两个特殊例子：&lt;/p>
&lt;ul>
&lt;li>$y[n]=x[-n]$，该系统当输入时间为负值是，输出就与输入的将来值有关，所以该系统不是因果系统。所以检验时要仔细检验在&lt;strong>全部时间&lt;/strong>上的输入——输出关系。&lt;/li>
&lt;li>$y(t)=x(t)\cos(t+1)$，检验因果性时要&lt;strong>把输入信号的影响仔细地与系统定义中的其他函数的影响分开&lt;/strong>，该系统的输出等于同一时刻的输入乘以一个随时间变化的数，所以可以写作$y(t)=x(t)g(t)$，是因果的。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="稳定性">稳定性&lt;/h4>
&lt;p>一个&lt;strong>稳定系统&lt;/strong>在小的输入下的响应不会&lt;strong>发散&lt;/strong>，这是稳定性的最直观理解。&lt;/p>
&lt;h4 id="时不变性">时不变性&lt;/h4>
&lt;p>系统的特性和行为不随时间而变，该系统就是时不变的。即如果在一个输入信号上有一个时移，在输出信号中产生同样的时移，那么这个系统就是时不变的。&lt;/p>
&lt;p>具体而言，若$y[n]$是离散时间时不变系统在输入为$x[n]$是的输出，当输入为$x[x-x_0]$时，输出为为$y[x-x_0]$，连续时间情况也是相同的道理。&lt;/p>
&lt;h4 id="线性">线性&lt;/h4>
&lt;p>如果某个输入信号是由几个信号的&lt;strong>加权和&lt;/strong>组成，那么输出也就是系统对这组信号中每一个响应的加权和。&lt;/p>
&lt;p>令$y_1(t)$是一个连续时间系统对输入$x_1(t)$的响应，$y_2(t)$是对输入$x_2(t)$的一个输出，那么一个线性系统就应该有：&lt;/p>
&lt;ul>
&lt;li>$y_1(t)+y_2(t)$是对$x_1(t)+x_2(t)$的响应&lt;/li>
&lt;li>$ay_1(t)$是对$ax_1(t)$的响应，$a$为任意常数&lt;/li>
&lt;/ul>
&lt;p>以上两个性质称为&lt;strong>可加性&lt;/strong>和&lt;strong>齐次性&lt;/strong>。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/signalsystem-ch01/ - 2019-2021 By Jialong</description></item><item><title>数字签名和数字证书</title><link>https://eternityqjl.github.io/blog2_public/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</link><pubDate>Fri, 06 Dec 2019 19:42:38 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/ -&lt;p>理解本文的基础是公钥密码加密，即非对称加密，比如其中一种非对称加密算法RSA。&lt;/p>
&lt;p>非对称加密使用一对密钥，一个为公钥Pub，另一个为私钥Priv&lt;/p>
&lt;p>明文P经过公钥Pub使用RSA加密算法混淆后变成了密文M，密文M无法用公钥Pub解开，只能用私钥Priv解开&lt;/p>
&lt;p>同样的，明文P经过私钥Priv使用RSA加密算法混淆后变成了密文N，密文N只能用公钥Pub解开&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="1信息安全">1.信息安全&lt;/h2>
&lt;p>在信息安全中共有3个需要解决的问题：&lt;/p>
&lt;ul>
&lt;li>保密性：保证信息在传输时不被泄露&lt;/li>
&lt;li>完整性：信息在传输时不被篡改&lt;/li>
&lt;li>有效性：信息的使用者是合法的&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>公钥密码&lt;/strong>能解决保密性的问题&lt;/p>
&lt;p>&lt;strong>数字签名&lt;/strong>能解决完整性和有效性的问题&lt;/p>
&lt;h2 id="2数字签名digital-signature">2.数字签名(Digital Signature)&lt;/h2>
&lt;p>真实世界中，签名是为了表示某些内容是签名者写的或者他所认可的。计算机中，数字签名也有着相似的含义，数字签名用来证实&lt;strong>消息&lt;/strong>是某个特定的人发送的，即有效性；同时还能证明消息没有被篡改，即完整性。这些是怎么实现的呢？这就是接下来要介绍有关于数字签名的内容。&lt;/p>
&lt;p>数字签名是公钥密码加密的逆向应用：&lt;/p>
&lt;p>用&lt;strong>私钥&lt;/strong>加密消息，用&lt;strong>公钥&lt;/strong>解密消息。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>签名&lt;/strong>：用私钥加密的消息，只有拥有私钥的用户可以生成签名，这也确保了数字签名的发送者是该用户。&lt;/li>
&lt;li>&lt;strong>验证签名&lt;/strong>：即用公钥解密签名，因为公钥是公开的，所以任何人都可以验证签名。&lt;/li>
&lt;/ul>
&lt;h3 id="21-生成签名">2.1 生成签名&lt;/h3>
&lt;p>一般不直接对消息进行签名，而是对消息进行哈希计算后的得到的哈希值进行签名。&lt;/p>
&lt;blockquote>
&lt;p>HASH算法是密码学的基础，其中最重要的两条性质是&lt;strong>不可逆&lt;/strong>和&lt;strong>无冲突&lt;/strong>，&lt;/p>
&lt;ul>
&lt;li>不可逆：当你知道x的HASH值时，无法求出x&lt;/li>
&lt;li>无冲突：你知道x，但无法求出一个y使得x与y的HASH值相同&lt;/li>
&lt;/ul>
&lt;p>这两个性质&lt;strong>在数学上都是不成立的&lt;/strong>，理论上由无穷多不同的原始值，它们的HASH值都相同。但求逆和求冲突在计算上不可能实现，穷尽人类所有的计算资源都做不到。&lt;/p>
&lt;/blockquote>
&lt;p>生成签名的步骤如下：&lt;/p>
&lt;ul>
&lt;li>对消息进行哈希计算，得到哈希值&lt;/li>
&lt;li>利用私钥对哈希值进行加密，生成签名&lt;/li>
&lt;li>将签名附在消息后，一起发送&lt;/li>
&lt;/ul>
&lt;h3 id="22-验证签名">2.2 验证签名&lt;/h3>
&lt;ul>
&lt;li>收到签名后，提取消息中的签名&lt;/li>
&lt;li>用公钥对签名进行解密，得到哈希值1&lt;/li>
&lt;li>对消息中的正文进行哈希计算，得到哈希值2&lt;/li>
&lt;li>比较哈希值1和2，如果相同，则验证成功&lt;/li>
&lt;/ul>
&lt;p>注：前面提到，哈希值的计算不可逆，因此才能以这种方式验证签名。&lt;/p>
&lt;h2 id="3数字证书digital-certificate">3.数字证书(Digital Certificate)&lt;/h2>
&lt;p>数字证书是对&lt;strong>公钥&lt;/strong>进行数字签名，是为了对&lt;strong>公钥的合法性&lt;/strong>提供证明，如果公钥的合法性得不到证明，则就存在中间人攻击的风险。&lt;/p>
&lt;blockquote>
&lt;p>中间人攻击（&lt;strong>M&lt;/strong>an-&lt;strong>i&lt;/strong>n-&lt;strong>t&lt;/strong>he-&lt;strong>m&lt;/strong>iddle-attack）：&lt;/p>
&lt;p>攻击者与通讯的两端分别建立滴露的联系，并交换所受到的数据。即中间人通过截获两端通讯使用的公钥，并将双方的两个公钥都更改为自己的公钥来达到截获消息的目的。&lt;/p>
&lt;p>详情可以参考维基百科：&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>我们对于签名的验证需要使用公钥，而公钥的真实合法性就是通过数字证书来的。&lt;strong>证书&lt;/strong>中包含：&lt;strong>公钥、公钥的数字签名、公钥拥有者的信息&lt;/strong>。如果证书验证成功，则代表该公钥是合法的。&lt;/p>
&lt;p>但是，验证证书中的数字签名需要另一个公钥，该公钥的合法性又怎样保证呢？该问题可以无限地循环下去，那岂不是解决不了了？我们相信银行是一个可信的机构，可以放心地把钱存在里面，那么同样存在一个可信机构来颁发证书和提供公钥，我们相信这个机构提供的密钥是合法的。&lt;/p>
&lt;p>这种机构称为&lt;strong>认证机构(Certification Authority, CA)&lt;/strong>，CA认定“公钥确实属于某个私钥的拥有者”，并能生成公钥的数字签名的组织或机构。&lt;/p>
&lt;h3 id="31-如何生成证书">3.1 如何生成证书？&lt;/h3>
&lt;blockquote>
&lt;p>证书即为公钥、公钥的数字签名、一些其他服务器信息的集合&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>服务器将&lt;strong>公钥A&lt;/strong>交给CA&lt;/li>
&lt;li>CA通过哈希计算生成公钥A的哈希值，然后用自己的&lt;strong>私钥B&lt;/strong>给&lt;strong>公钥A的哈希值&lt;/strong>加密，生成&lt;strong>数字签名A&lt;/strong>&lt;/li>
&lt;li>CA把公钥A、数字签名A、一些服务器信息整合，生成证书，发回给服务器&lt;/li>
&lt;/ol>
&lt;h3 id="32-如何验证证书">3.2 如何验证证书？&lt;/h3>
&lt;ol>
&lt;li>客户端得到证书&lt;/li>
&lt;li>客户端通过CA得到证书的&lt;strong>公钥B&lt;/strong>&lt;/li>
&lt;li>客户端用&lt;strong>公钥B&lt;/strong>对证书中的&lt;strong>数字签名A&lt;/strong>解密，得到哈希值&lt;/li>
&lt;li>客户端对&lt;strong>公钥A&lt;/strong>进行哈希值计算&lt;/li>
&lt;li>将两个哈希值对比，如果相同，则证书合法&lt;/li>
&lt;/ol>
&lt;p>公钥B和上述私钥B是配对的，分别用于解密和加密证书。&lt;/p>
&lt;h3 id="33-证书作废">3.3 证书作废&lt;/h3>
&lt;p>用户的私钥丢失或者被盗时，认证机构需要对证书进行作废，制作一张证书作废清单(Certificate Revocation List, CRL)&lt;/p>
&lt;p>在验证证书是否有效的时候除了看合法的认证机构签名、是否在有效期内，还需要查询认证机构最新的CRL。&lt;/p>
&lt;h2 id="4应用">4.应用&lt;/h2>
&lt;p>HTTPS协议，详见之后有关SSL/TLS的博客。&lt;/p>
&lt;h2 id="5参考">5.参考&lt;/h2>
&lt;p>&lt;a href="https://www.jianshu.com/p/9db57e761255">什么是数字签名和证书?&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/20820286">什么是哈希算法？&lt;/a>&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/ - 2019-2021 By Jialong</description></item><item><title>写在2019年的最后一个月的开始</title><link>https://eternityqjl.github.io/blog2_public/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/</link><pubDate>Sun, 01 Dec 2019 22:06:08 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/ -&lt;p>转眼间2019年就要结束了，依稀记得2019年的刚开始我还在发空间动态说自己又买了一本日历，然而&amp;hellip;明年就不买了吧，我并没有记得经常去看日历，更别说去每天一张一张地撕它。这一年里经历了非常多的事情，从学习、生活、关于未来的各方各面，我都发生了极大的改变，这源于我不断变化的想法，目标总是飘忽不定，我思考过，也经常迷茫，现在也是。&lt;/p>
&lt;p>在写下这些话的时间里，我其实是非常难过和害怕的，这一个周末似乎没干什么事情就又要浑浑噩噩地结束了，直到现在还有一个DDL等着我，明早截止，我还没做完，间歇性拖延症晚期这件事情，一直发生在我身上，毫不夸张地说，我可以不间歇地拖延整整24小时，这过程中总想着做些什么、改变些什么，但除了睡觉，大部分时间眼睛都盯在手机屏幕上，尽管我知道这样做一点儿也不好，但结果还是发生了。我知道学习的重要性，也会去为了一个想要实现的东西不断地思考并找到解决方法，就比如搭建网站这件事情，前前后后花了很多的时间也学习了很多相关知识，基本掌握了中间的原理，结果在我预想的时间之前很久就做出来了，结果还是超乎预期的好。说实话，完成一件能看的到结果的事情能给人的心理带来很大的快感的愉悦，但愉悦过后，又只剩下了迷茫和拖延，并且在为了找到下一个实践目标而苦苦挣扎着。有时候大脑盯着手机屏幕看一些信息的时候，知道这是自己不想接收和浪费时间的，但就是控制不住自己去点开看，这样的人性的弱点也造就了很多的商机，造就了很多企业和公司的成功。&lt;/p>
&lt;p>说点儿别的。在关于情感和人际交往方面，我可能是一个与绝大多数人都不一样的人，在情感上，我很少与他人或者是在公开场合表露（包括我的社交媒体，我发现，自己现在很少在社交媒体上表露自己的情感，更多的是分享一些自己的兴趣爱好，比如我热爱的摄影，因而，我也就把自己的空间对所有人开放了，微信这个东西另当别论，说实话，我挺讨厌这个软件的），但我还是知道自己想要的是什么，纵然我在过去的一年里总是带着一些自卑的情感，很久没有与他人进行深入内心的交谈，KY的与陌生人打电话活动也错过了很多次，每次都是在想和别人深入交流的时候才想起来，结果肯定是已经结束了，今后还是要多多关注，想想能与一同关注KY的人打电话是一件挺幸福的事情，也希望自己能早日找到灵魂伴侣。在人际交往方面，我尝试过学校的很多社团和活动，最终无一例外全都放弃了，我觉得也挺好，这也证明了我确实不喜欢过多的浮于表面和拉帮结派建造复杂人际关系的事情，做好自己就最好了，能认识几个朋友还是随缘了，人也并不需要那么多看上去像是朋友的朋友。&lt;/p>
&lt;p>扯了这么多，还是回到最重要的学习和事业上吧。12月希望自己能好好学习学校的课程知识，好好地应对一下考试。明年下半年就要大三了，这学期结束以后要为成为一个前端工程师立一些目标，毕竟就快要毕业了，还是希望自己能去做自己喜欢的工作，上研究生这件事就暂时不考虑了，我在经历了一些事情以后对于读研这件事一点儿也不感兴趣了，做好自己就好了。&lt;/p>
&lt;p>以上。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/ - 2019-2021 By Jialong</description></item></channel></rss>