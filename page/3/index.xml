<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Fri, 03 Dec 2021 11:21:29 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH09 顺序容器</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Tue, 15 Jun 2021 15:36:20 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ -&lt;p&gt;顺序容器&lt;/p&gt;
&lt;p&gt;一个容器就是一些特定类型对象的集合。&lt;/p&gt;
&lt;p&gt;顺序容器提供了&lt;strong&gt;控制元素存储&lt;/strong&gt;和&lt;strong&gt;访问顺序&lt;/strong&gt;的能力。这种顺序与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;p&gt;关联容器与顺序容器有着根本不同，关联容器中的元素是按照&lt;strong&gt;关键词&lt;/strong&gt;来保存和访问的，即&lt;strong&gt;Key-Value&lt;/strong&gt;；与之相对的是顺序容器中的元素按照它们在容器中的位置来顺序保存和访问。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;顺序容器都提供了&lt;strong&gt;快速顺序访问元素&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;顺序容器类型(名称)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;性能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vector&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可变大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在尾部之外的位置插入删除元素很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;deque&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双端队列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在头尾插入删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双向链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持双向顺序访问。在list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forward_list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单项链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持单项顺序访问。在forward_list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;array&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。不能添加删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;与vector相似的容器，专门用于保存字符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随机访问快，在尾部插入删除速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了固定大小的array外，其他容器都提供高效的内存管理。容器保存元素的策略对容器操作的效率有着很大影响。&lt;/p&gt;
&lt;p&gt;string和vector将元素保存在&lt;strong&gt;连续的内存空间&lt;/strong&gt;中，因此由元素的下标来计算其地址非常快速。但在这两种容器的中间位置插入和删除元素的速度非常慢，因为一次插入或删除后，需要移动插入、删除位置后的&lt;strong&gt;所有元素&lt;/strong&gt;以保证存储的连续。&lt;/p&gt;
&lt;p&gt;list和forward_list两个容器能令任何位置的添加和删除操作都很快，但这两种容器&lt;strong&gt;不支持随机访问&lt;/strong&gt;，因为元素保存的内存空间不连续，只能通过遍历整个容器来访问一个元素。与vector和string相比，额外内存开销也很大。&lt;/p&gt;
&lt;p&gt;forward_list与最好的手写单向链表数据结构性能相当，因此没有size操作，因为保存或计算大小会多出额外开销。&lt;/p&gt;
&lt;p&gt;deque支持快读随机访问，在该容器中间位置添加或删除元素速度很慢，但在两端很快。&lt;/p&gt;
&lt;h2 id=&#34;容器库概览&#34;&gt;容器库概览&lt;/h2&gt;
&lt;p&gt;容器类型上的操作分成了层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些操作式所有容器都提供的；&lt;/li&gt;
&lt;li&gt;另外一些操作仅针对顺序容器、关联容器或无序容器；&lt;/li&gt;
&lt;li&gt;还有一些操作只适合一小部分容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器通过&lt;strong&gt;尖括号&lt;/strong&gt;指定类型。&lt;/p&gt;
&lt;h3 id=&#34;容器操作&#34;&gt;容器操作&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;iterator
size_type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*iter	//返回迭代器iter所指元素的引用
iter-&amp;gt;name	//解引用iter并获取该元素的名为mem的成员
++iter	//令iter指示容器中的下一个元素
--iter	//令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个&lt;strong&gt;迭代器范围&lt;/strong&gt;由一对迭代器表示，这两个迭代器被称为begin和end，begin指向容器第一个元素，end指向容器的&lt;strong&gt;尾后元素&lt;/strong&gt;，这种元素范围被称为&lt;strong&gt;左闭合区间&lt;/strong&gt;，即&lt;code&gt;[begin, end)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对构成范围的迭代器的要求：&lt;strong&gt;end不在begin之前&lt;/strong&gt;。可以通过对begin进行若干次递增，使得begin==end。&lt;/p&gt;
&lt;h3 id=&#34;容器类型成员&#34;&gt;容器类型成员&lt;/h3&gt;
&lt;p&gt;每个容器都定义了多个类型。如之前使用过的&lt;code&gt;interator&lt;/code&gt;、&lt;code&gt;size_type&lt;/code&gt;等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;interator
const_iterator
size_type
difference_type
value_type
reference
const_reference
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;iterator iter;
vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;begin和end成员&#34;&gt;begin和end成员&lt;/h3&gt;
&lt;p&gt;begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。还有不同类型的反向迭代器、const迭代器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;list&amp;lt;int&amp;gt; a = {1, 2, 3};
auto it1 = a.begin();	//list&amp;lt;int&amp;gt;::iterator
auto it2 = a.rbegin();	//反向迭代器 list&amp;lt;int&amp;gt;::reverse_iterator
auto it3 = a.cbegin();	//const迭代器 list&amp;lt;int&amp;gt;::const_iterator
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;容器定义和初始化&#34;&gt;容器定义和初始化&lt;/h3&gt;
&lt;p&gt;每个容器类型都定义了一个默认构造函数。除了array外，其他容器的默认构造函数都会创建一个指定类型的空容器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C c;	//默认构造函数
C c1(c2)	//c1初始化为c2的拷贝。两者必须是相同类型的容器
C c{a,b,c...}	//c初始化为初始化列表中元素的拷贝
C c(b,e)	//c初始化为迭代器b和e指定范围中元素的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与顺序容器（除了array）大小相关的一个构造函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ivec(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int元素，每个都初始化为1
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; scev(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个元素，每个都是空string
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标准库array具有固定大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存42个int的数组
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存10个string的数组
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用array时必须同时指定&lt;strong&gt;元素类型&lt;/strong&gt;和&lt;strong&gt;大小&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;size_type j;	&lt;span style=&#34;color:#888&#34;&gt;//错误，未指定大小
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个默认构造的array是非空的，它包含了与其大小一样多的元素，这些元素都被默认初始化。&lt;/p&gt;
&lt;h3 id=&#34;赋值和swap&#34;&gt;赋值和swap&lt;/h3&gt;
&lt;p&gt;赋值将左边容器中的所有元素替换为右边容器中元素的拷贝。如果两个容器原来大小不同，赋值运算后两者大小都与右边容器的原大小相等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; c2;	&lt;span style=&#34;color:#888&#34;&gt;//将c1替换为c2中元素的拷贝，拷贝后c1的大小与原c2相同
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {a, b, c}
swap(c1, c2)
c1.swap(c2)	&lt;span style=&#34;color:#888&#34;&gt;//与上一个等价
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//assign操作不适用于关联容器和array
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为迭代器b和e所表示范围的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(il)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为初始化列表il中的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(n,t)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为n个值为t的元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;assign用参数所指定的元素拷贝替换左边容器中所有元素。assign操作不适用于array和关联容器。&lt;/p&gt;
&lt;p&gt;swap只是交换了两个容器内部的&lt;strong&gt;数据结构&lt;/strong&gt;，但例外是swap两个array会真正交换它们的元素。&lt;/p&gt;
&lt;h3 id=&#34;容器大小操作&#34;&gt;容器大小操作&lt;/h3&gt;
&lt;p&gt;成员函数&lt;code&gt;size&lt;/code&gt;返回容器中元素的数目；&lt;code&gt;empty&lt;/code&gt;当size为0时返回布尔值true，否则返回false；&lt;code&gt;max_size&lt;/code&gt;返回一个大于或等于该类型容器所能容纳的最大元素数的值。&lt;/p&gt;
&lt;p&gt;forward_list支持&lt;code&gt;max_size&lt;/code&gt;和&lt;code&gt;empty&lt;/code&gt;但不支持size。&lt;/p&gt;
&lt;h3 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;每个容器类型都支持相等运算符(即&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;)；除&lt;strong&gt;无序关联容器&lt;/strong&gt;外的所有容器都支持关系运算符(&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=)。&lt;/p&gt;
&lt;p&gt;关系运算符左右两边的运算对象必须是&lt;strong&gt;相同类型的容器&lt;/strong&gt;，且保存&lt;strong&gt;元素的类型也必须相等&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顺序容器操作&#34;&gt;顺序容器操作&lt;/h2&gt;
&lt;p&gt;顺序容器和关联容器的不同在于两者&lt;strong&gt;组织元素的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了上一节介绍的&lt;strong&gt;所有容器都支持的操作外&lt;/strong&gt;，本章剩余部分将介绍顺序容器的所有操作。&lt;/p&gt;
&lt;h4 id=&#34;向顺序容器添加元素&#34;&gt;向顺序容器添加元素&lt;/h4&gt;
&lt;p&gt;向顺序容器中除了array外添加元素的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.push_back(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的尾部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_back(args)
c.push_front(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的头部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_front(args)
c.insert(p,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前创建一个值为t的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,n,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,b,e)			&lt;span style=&#34;color:#888&#34;&gt;//将迭代器b和e指向范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,il)			&lt;span style=&#34;color:#888&#34;&gt;//il为一个花括号包围的元素值列表，将这些值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;forword_list&lt;/code&gt;不支持&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;emplace_back&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持&lt;code&gt;push_front&lt;/code&gt;和&lt;code&gt;emplace_front&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;使用这些操作时要注意策略，根据不同容器的&lt;strong&gt;不同数据结构的特性&lt;/strong&gt;来使用。&lt;/p&gt;
&lt;p&gt;emplace操作构造而不是拷贝元素，将参数传递给元素类型的构造函数，直接构造元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_back&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了array和forward_list外，每个顺序容器都支持该操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_front&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;list、forward_list和deque容器还支持&lt;code&gt;push_front&lt;/code&gt;，此操作将元素插入容器头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器特定为止添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;insert成员匀速我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。&lt;/p&gt;
&lt;p&gt;每个insert都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。&lt;/p&gt;
&lt;p&gt;insert函数还可以接受更多参数，其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;svec.insert(svec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用emplace操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++11引入了三个新成员——emplace_front、emplace和emplace_back，这些操作&lt;strong&gt;构造&lt;/strong&gt;而不是拷贝元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.emplace_back(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;123445&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;15.99&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在c的末位构造一个Sales_data对象。&lt;/p&gt;
&lt;h4 id=&#34;访问元素&#34;&gt;访问元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.back()		&lt;span style=&#34;color:#888&#34;&gt;//返回c中尾元素的引用，若c为空，则函数行为未定义。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.front()		&lt;span style=&#34;color:#888&#34;&gt;//范围c中首元素的引用
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c[n]			&lt;span style=&#34;color:#888&#34;&gt;//返回c中下标为n的元素的引用，n是一个无符号整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.at(n)			&lt;span style=&#34;color:#888&#34;&gt;//返回下标为n的元素的引用，若下标越界，则返回out_of_range异常
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;at和下标操作只适用于string、vector、array和deque&lt;/p&gt;
&lt;p&gt;back不适用于forward_list&lt;/p&gt;
&lt;p&gt;以上访问元素的成员函数返回的都是&lt;strong&gt;引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;删除元素&#34;&gt;删除元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.pop_back()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中尾元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.pop_front()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中首元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器p所指元素，返回一个指向被删元素之后元素的迭代器；若p指向尾元素，则返回尾后迭代器；若p是尾后迭代器，则函数行为未定义
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若e本身就是尾后迭代器，则也返回尾后迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.clear()		&lt;span style=&#34;color:#888&#34;&gt;//删除c中所有元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;forward_list有特殊erase，且不支持pop_back.&lt;/p&gt;
&lt;p&gt;vector和string不支持pop_front.&lt;/p&gt;
&lt;p&gt;erase从容器中指定位置删除元素，还可以使用一对迭代器，删除一个范围内的元素。&lt;/p&gt;
&lt;h4 id=&#34;特殊的forward_list操作&#34;&gt;特殊的forward_list操作&lt;/h4&gt;
&lt;p&gt;在链表中添加或删除一个链接，会改变序列中的链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.before_begin()		&lt;span style=&#34;color:#888&#34;&gt;//返回指向链表首元素之前不存在的元素迭代器，该迭代器不能解引用。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,t)	&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的为止插入元素，t是一个对象，n是数量，b和e是一对迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)	&lt;span style=&#34;color:#888&#34;&gt;//il是一个花括号列表
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的位置插入元素，t是一个对象，n是数量，b和e是表示范围的一对迭代器，il是一个花括号列表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;emplace_after(p,args)	&lt;span style=&#34;color:#888&#34;&gt;//使用args在p指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除p指向位置之后的元素，或删除从b之后直到e之间的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(b,e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在forward_list中添加或删除元素时，我们要关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱。&lt;/p&gt;
&lt;h4 id=&#34;改变容器大小&#34;&gt;改变容器大小&lt;/h4&gt;
&lt;p&gt;可以使用resize来增大或缩小容器。&lt;strong&gt;array不支持resize&lt;/strong&gt;。若当前大小大于所要求的大小，则容器后部的元素会被删除；所当前大小小于新大小，则将新元素添加到容器后部。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ilist(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int：每个的值都是43
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;15&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将5个值为0的元素添加到ilist末尾
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;,&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将10个值为1的元素添加到ilist末尾
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;容器操作可能使迭代器失效&#34;&gt;容器操作可能使迭代器失效&lt;/h4&gt;
&lt;p&gt;根据不同容器在内存中存储的方式不同，向容器中添加或删除元素会导致不同类型的迭代器失效。&lt;/p&gt;
&lt;h2 id=&#34;vector对象的增长&#34;&gt;vector对象的增长&lt;/h2&gt;
&lt;p&gt;vector和string的实现通常会分配比新的空间需求&lt;strong&gt;更大的内存空间&lt;/strong&gt;，容器预留这些空间作为&lt;strong&gt;备份&lt;/strong&gt;，可用来保存更多的新元素，这样就不需要每次添加新元素都重新分配容器的内存空间了。&lt;/p&gt;
&lt;p&gt;以下是vector和string提供的一些管理容量的成员函数，允许我们与它的实现中内存分配部分互动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.shrink_to_fit()		&lt;span style=&#34;color:#888&#34;&gt;//将capacity减少为与size()相同大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.capacity()			&lt;span style=&#34;color:#888&#34;&gt;//不重新分配内存空间的话，c可以保存多少元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.reserve(n)			&lt;span style=&#34;color:#888&#34;&gt;//分配至少能容纳n个元素的内存空间
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;reserve不改变容器中元素数量，只影响预先分配内存空间的大小。&lt;/p&gt;
&lt;p&gt;shrink_to_fit只适用于vector、string和deque。&lt;/p&gt;
&lt;p&gt;capacity、reserve只适用于vector、string。&lt;/p&gt;
&lt;h2 id=&#34;额外的string操作&#34;&gt;额外的string操作&lt;/h2&gt;
&lt;p&gt;这些操作大部分是提供&lt;strong&gt;string类和C风格字符数组&lt;/strong&gt;之间的&lt;strong&gt;相互转换&lt;/strong&gt;，或者增加了允许我们用&lt;strong&gt;下标&lt;/strong&gt;代替迭代器。&lt;/p&gt;
&lt;h4 id=&#34;构造string的其他方法&#34;&gt;构造string的其他方法&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string s(cp, n)		//s是cp指向的数组中前n个字符的拷贝。
string s(s2, pos2)	//s是string s2从下标pos2开始的字符的拷贝。
string s(s2, pos2, len2)	//s是string s2从下标pos2开始len2个字符的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些构造函数接受一个string或一个const char*参数，还接受指定拷贝多少个字符的参数。当传递给他一个string时，还可指定一个下标指出从哪里开始拷贝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.substr(pos, n)	&lt;span style=&#34;color:#888&#34;&gt;//返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;改变string的其他方法&#34;&gt;改变string的其他方法&lt;/h4&gt;
&lt;p&gt;定义了额外的insert和erase版本，还定义了两个额外的成员函数append和replace。&lt;/p&gt;
&lt;p&gt;append操作是在string末尾进行插入操作的一种简写。&lt;/p&gt;
&lt;p&gt;replace操作是调用erase和insert的一种简写形式。&lt;/p&gt;
&lt;h4 id=&#34;string搜索&#34;&gt;string搜索&lt;/h4&gt;
&lt;p&gt;string类提供了6个不同的搜索函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.find(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.rfind(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args最后一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_first_of(args)	&lt;span style=&#34;color:#888&#34;&gt;//在s中查找args中任何一个字符第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_last_of(args)
s.find_first_not_of(args)
s.find_last_not_of(args)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;compare函数&#34;&gt;compare函数&lt;/h4&gt;
&lt;p&gt;标准库string还提供了一组compare函数，根据s是等于、大于还是小于参数指定的字符串，&lt;code&gt;s.compare&lt;/code&gt;返回0、整数或负数。&lt;/p&gt;
&lt;p&gt;s.compare有6个版本的参数形式。&lt;/p&gt;
&lt;h4 id=&#34;数值转换&#34;&gt;数值转换&lt;/h4&gt;
&lt;p&gt;string和数值之间的转换&lt;/p&gt;
&lt;h2 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h2&gt;
&lt;p&gt;除顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priority_queue&lt;/p&gt;
&lt;p&gt;一个适配器是一种机制，能使某种事物看起来像另一种事物。&lt;/p&gt;
&lt;p&gt;一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。&lt;/p&gt;
&lt;p&gt;例如，stack适配器接受一个顺序容器，并使其操作起来像一个stack一样。&lt;/p&gt;
&lt;p&gt;所有容器适配器&lt;strong&gt;都支持的操作和类型&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;size_type		&lt;span style=&#34;color:#888&#34;&gt;//一种类型，足够保存当前类型的最大对象的大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;value_type
container_type	&lt;span style=&#34;color:#888&#34;&gt;//实现适配器的底层容器类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A a;			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的空适配器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;a&lt;/span&gt;(c);			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的适配器，带有容器c的一个拷贝
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;关系运算符&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;等等&lt;/span&gt;
a.empty()
a.size()
swap(a,b)		&lt;span style=&#34;color:#888&#34;&gt;//交换a、b的内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;a.swap(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;定义一个适配器&#34;&gt;定义一个适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; stk(deq);	&lt;span style=&#34;color:#888&#34;&gt;//deq是一个deque&amp;lt;int&amp;gt;，从deq拷贝元素到stk
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;栈适配器&#34;&gt;栈适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; intStack;	&lt;span style=&#34;color:#888&#34;&gt;//声明一个空栈
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他一些栈操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.pop()
s.push(item)	&lt;span style=&#34;color:#888&#34;&gt;//创建一个新元素压入栈顶，该元素通过拷贝或移动item实现，或有args构造
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.emplace(args)
s.top()			&lt;span style=&#34;color:#888&#34;&gt;//返回栈顶元素，但不讲栈弹出
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;队列适配器&#34;&gt;队列适配器&lt;/h4&gt;
&lt;p&gt;queue和priority_queue适配器定义在queue头文件。&lt;/p&gt;
&lt;p&gt;标准库queue是一种FIFO的策略。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 1.计算机系统漫游</title>
        <link>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link>
        <pubDate>Fri, 11 Jun 2021 12:18:22 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ -&lt;p&gt;在本书中我们将会学习到一些使用技巧，比如如何避免由于&lt;strong&gt;计算机表示数字的方式&lt;/strong&gt;引起的错误；通过一些技巧&lt;strong&gt;优化C代码&lt;/strong&gt;，以充分利用现代处理器和存储器系统的设计；了解&lt;strong&gt;编译器&lt;/strong&gt;如何实现过程调用，利用这些知识避免&lt;strong&gt;缓冲区溢出&lt;/strong&gt;错误带来的安全漏洞；学习如何识别和避免&lt;strong&gt;链接&lt;/strong&gt;时的错误；如何编写Unix Shell、动态存储分配包、Web服务器；&lt;strong&gt;并发&lt;/strong&gt;带来的希望和陷阱，对于现在的单芯片集成多个处理器核心非常重要。&lt;/p&gt;
&lt;p&gt;我们通过围绕Hello程序执行时的整个生命周期来对系统进行学习：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Hello, world&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;信息就是位上下文&#34;&gt;信息就是位+上下文&lt;/h2&gt;
&lt;p&gt;8位为一个字节。&lt;/p&gt;
&lt;p&gt;现代计算机系统使用ASCII标准来表示文本字符。即用一个&lt;strong&gt;单字节&lt;/strong&gt;大小的整数值表示一个符号。&lt;/p&gt;
&lt;p&gt;数字的机器表示是对真值的有限近似。&lt;/p&gt;
&lt;h2 id=&#34;程序被翻译为不同的格式&#34;&gt;程序被翻译为不同的格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hello.c&lt;/code&gt;中的每条C语句都会转换为一系列低级&lt;strong&gt;机器语言&lt;/strong&gt;指令。这些指令按照&lt;strong&gt;可执行目标程序&lt;/strong&gt;格式打包，以二进制磁盘文件的形式存放。&lt;/p&gt;
&lt;p&gt;编译系统：&lt;/p&gt;
&lt;p&gt;hello.c(源程序，文本) -&amp;gt; &lt;code&gt;预处理器(cpp)&lt;/code&gt; -&amp;gt; hello.i(修改了的源程序，文本) -&amp;gt; &lt;code&gt;编译器(ccl)&lt;/code&gt; -&amp;gt; hello.s(汇编程序，文本) -&amp;gt; &lt;code&gt;汇编器&lt;/code&gt; -&amp;gt; hello.o(可重定位目标程序，二进制) -&amp;gt; &lt;code&gt;链接器&lt;/code&gt; -&amp;gt; hello(可执行目标程序，二进制)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：预处理器(cpp)根据以字符&lt;code&gt;#&lt;/code&gt;开头的命令，修改原始C程序。例如&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;告诉预处理器读取系统头文件的内容，将其插入程序文本中，得到另一个C程序，以&lt;code&gt;.i&lt;/code&gt;为扩展名。&lt;/li&gt;
&lt;li&gt;编译阶段：编译器(ccl将&lt;code&gt;hello.i&lt;/code&gt;翻译为&lt;code&gt;hello.s&lt;/code&gt;，其包含了&lt;strong&gt;汇编语言程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;汇编阶段：汇编器(as)将&lt;code&gt;hello.s&lt;/code&gt;翻译为&lt;strong&gt;机器语言指令&lt;/strong&gt;，将这些指令打包为&lt;strong&gt;可重定位目标程序&lt;/strong&gt;，将结果保存在&lt;code&gt;hello.o&lt;/code&gt;中，该文件为二进制文件。&lt;/li&gt;
&lt;li&gt;链接阶段：hello程序调用了printf函数，它是C编译器提供的标准C库中的一个函数，printf函数存在于一个名为&lt;code&gt;printf.o&lt;/code&gt;的单独预编译好的目标文件中，这个文件要以某种形式合并到我们的&lt;code&gt;hello.o&lt;/code&gt;程序中，链接器(ld)负责这种合并，合并后就得到了&lt;strong&gt;可执行目标文件&lt;/strong&gt;&lt;code&gt;hello&lt;/code&gt;，其可以被加载到内存中，由系统执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器的工作方式&#34;&gt;编译器的工作方式&lt;/h2&gt;
&lt;p&gt;有一些重要原因使得我们必须知道编译器的工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化程序性能。我们需要了解一些机器代码及编译器将不同C语句转化为机器代码的方式，例如一个switch语句是否总比一系列if-else语句高效。&lt;/li&gt;
&lt;li&gt;理解链接时出现的错误。&lt;/li&gt;
&lt;li&gt;避免安全漏洞。缓冲区溢出错误是大多网络和服务器安全漏洞的主要原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;处理器读取并解释储存在内存中的指令&#34;&gt;处理器读取并解释储存在内存中的指令&lt;/h2&gt;
&lt;p&gt;要在Unix系统运行可执行目标文件hello，需要将文件名输入shell应用程序中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./hello
hello,world
linux&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h3&gt;
&lt;h4 id=&#34;总线&#34;&gt;总线&lt;/h4&gt;
&lt;p&gt;贯穿整个系统，负责信息字节在各个部件之间传递。&lt;/p&gt;
&lt;p&gt;通常被设计为传送定长的字节块，即&lt;strong&gt;字&lt;/strong&gt;，字中的字节数（即字长）是基本的系统参数，如今大多数机器中字长为8字节(即64位)，4字节(32位)在逐渐被64位取代。&lt;/p&gt;
&lt;h4 id=&#34;io设备&#34;&gt;I/O设备&lt;/h4&gt;
&lt;p&gt;每个I/O设备通过&lt;strong&gt;控制器或适配器&lt;/strong&gt;与I/O总线相连，控制器为I/O设备本身或系统主板上的芯片组，适配器为插在主板插槽上的卡。&lt;/p&gt;
&lt;h4 id=&#34;主存ram&#34;&gt;主存RAM&lt;/h4&gt;
&lt;p&gt;临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。由一组&lt;strong&gt;动态随机存取存储器(DRAM)&lt;strong&gt;芯片组成。逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的&lt;/strong&gt;地址&lt;/strong&gt;(数组索引)，这些地址从零开始。&lt;/p&gt;
&lt;h4 id=&#34;处理器&#34;&gt;处理器&lt;/h4&gt;
&lt;p&gt;CPU是解释或执行存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备(&lt;strong&gt;寄存器&lt;/strong&gt;)，称为程序计数器(PC)，PC指向主存中的某条机器语言指令（即包含该指令的地址）。&lt;/p&gt;
&lt;p&gt;处理器在一直不停地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个简单的指令执行模型来操作的，这个模型是&lt;strong&gt;指令集架构&lt;/strong&gt;决定的。该模型中指令按照严格的顺序执行。执行一条指令包含一系列步骤，处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，循环操作。&lt;/p&gt;
&lt;p&gt;这样的简单操作并不多，主要围绕**主存、寄存器文件和ALU(算术逻辑单元)**进行。寄存器文件是一个小型存储设备，由一些单个字长的寄存器组成，ALU计算新的数据和地址值。CPU可能进行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载：从主存读取一个字到寄存器&lt;/li&gt;
&lt;li&gt;存储：从寄存器赋值一个字到主存&lt;/li&gt;
&lt;li&gt;操作：将两个寄存器的内容复制到ALU，ALU对两个字进行算术运算，将结果存放到一个寄存器中&lt;/li&gt;
&lt;li&gt;跳转：从指令本身抽取一个字，将这个字复制到PC中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令集架构：每条机器代码指令的效果&lt;/p&gt;
&lt;p&gt;微体系结构：处理器实际上是如何实现的&lt;/p&gt;
&lt;h3 id=&#34;运行hello程序&#34;&gt;运行hello程序&lt;/h3&gt;
&lt;p&gt;在键盘上输入&lt;code&gt;.\hello&lt;/code&gt;后，shell会将这些字符逐一读入寄存器，再将其存放到内存中。按下回车后，shell知道命令输入已经结束，将执行一系列指令加载hello文件，这些指令会将hello目标文件中的代码和数据从磁盘复制到主存，利用DMA(直接存储器存取)技术，可将数据不经过CPU直接从磁盘放入主存。&lt;/p&gt;
&lt;p&gt;目标文件hello被放入主存后，处理器就开始执行机器语言指令。&lt;/p&gt;
&lt;h2 id=&#34;高速缓存&#34;&gt;高速缓存&lt;/h2&gt;
&lt;p&gt;为了减少信息加载的时间，采用更小更快的存储设备作为数据或指令暂时的集结区域。处理器芯片上的L1高速缓存缓存的访问速度集合和访问寄存器文件一样快，容量更大的L2高速缓存通过特殊总线连接到寄处理器。高速缓存采用静态随机访问存储器（SRAM）技术实现。&lt;/p&gt;
&lt;h2 id=&#34;存储器层次&#34;&gt;存储器层次：&lt;/h2&gt;
&lt;p&gt;L0：寄存器&lt;/p&gt;
&lt;p&gt;L1：L1高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L2：L2高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L3：L3高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L4：主存（DRAM）&lt;/p&gt;
&lt;p&gt;L5：本地磁盘&lt;/p&gt;
&lt;p&gt;L6：远程存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%BE%E4%BE%8B.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图为我的电脑的三级缓存示意。&lt;/p&gt;
&lt;h2 id=&#34;操作系统管理硬件&#34;&gt;操作系统管理硬件&lt;/h2&gt;
&lt;p&gt;前面的shell程序和hello程序都依靠&lt;strong&gt;操作系统&lt;/strong&gt;提供的服务访问存储器。操作系统是应用程序和硬件之间的软件。&lt;/p&gt;
&lt;p&gt;操作系统的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;
&lt;li&gt;向应用程序提供简单的机制控制复杂又不同的低级硬件设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统通过几个基本抽象概念：进程、虚拟内存和文件实现这些功能。&lt;/p&gt;
&lt;p&gt;文件是对I/O设备的抽象。&lt;/p&gt;
&lt;p&gt;虚拟内存是对主存和磁盘I/O设备的抽象。&lt;/p&gt;
&lt;p&gt;进程是对处理器、主存和磁盘I/O设备的抽象。&lt;/p&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;p&gt;进程是操作系统对正在运行程序的一种抽象，一个系统可以同时运行多个进行，每个进程好像都在独占使用硬件。并发运行指的是多个不同程序进程指令交错运行。处理器通过在进程间切换来实现多个程序的并发运行，这种机制称为&lt;strong&gt;上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;操作系统保存跟踪进程运行所需要的所有状态信息，这种状态即为上下文。这些信息有很多，比如PC和寄存器文件的当前值。&lt;/p&gt;
&lt;p&gt;任何一个时刻，单处理器只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到新进程时，就会进行上下文切换。&lt;/p&gt;
&lt;p&gt;从一个进程到另一个进程的切换是操作系统内核（kernal）管理的。&lt;strong&gt;内核&lt;/strong&gt;是操作系统代码&lt;strong&gt;常驻主存&lt;/strong&gt;的部分。内核不是一个独立的进程，是系统管理全部进程所用的代码和数据结构的集合。&lt;/p&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;p&gt;一个进程可以有多个成为线程的执行单元组成，每个线程都运行在进程的上下文中，共享同样的代码和全部数据。多线程相比多进程更容易共享数据。&lt;/p&gt;
&lt;h3 id=&#34;虚拟内存&#34;&gt;虚拟内存&lt;/h3&gt;
&lt;p&gt;虚拟内存为每个进程提供一个假象，即每个进程都在&lt;strong&gt;独占地使用主存&lt;/strong&gt;。每个进程看到内存都是一致的，成为虚拟地址空间。&lt;/p&gt;
&lt;p&gt;每个进程看到的虚拟地址由大量准确定义的&lt;strong&gt;区&lt;/strong&gt;构成，每个区都有专门的功能。以下从最低的地址逐步向上介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序代码和数据：所有进程的代码是从同一固定地址开始，紧接着是和C全局变量对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。&lt;/li&gt;
&lt;li&gt;堆：当调用malloc和free这样的函数时，堆可以动态地扩展和收缩。&lt;/li&gt;
&lt;li&gt;共享库：是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。&lt;/li&gt;
&lt;li&gt;栈：编译器用它来实现函数调用，栈在程序执行期间可以动态扩展和收缩。&lt;/li&gt;
&lt;li&gt;内核虚拟内存：地址空间顶部区域是为内核保留的，不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;
&lt;p&gt;文件就是字节序列，系统所有输入输出都是通过使用一小组成为Unix I/O的系统函数调用读写文件实现的。&lt;/p&gt;
&lt;h2 id=&#34;系统之间利用网络通信&#34;&gt;系统之间利用网络通信&lt;/h2&gt;
&lt;p&gt;网络是一个I/O设备，通过网络适配器连接到系统总线。&lt;/p&gt;
&lt;h2 id=&#34;一些重要主题&#34;&gt;一些重要主题&lt;/h2&gt;
&lt;h3 id=&#34;并发和并行&#34;&gt;并发和并行&lt;/h3&gt;
&lt;p&gt;并发：一个同时具有多个活动的系统&lt;/p&gt;
&lt;p&gt;并行：用并发使得一个系统运行得更快&lt;/p&gt;
&lt;p&gt;并行可以在计算机系统的多个抽象层次上运行。&lt;/p&gt;
&lt;h4 id=&#34;线程级并发&#34;&gt;线程级并发&lt;/h4&gt;
&lt;h4 id=&#34;指令级并发&#34;&gt;指令级并发&lt;/h4&gt;
&lt;h4 id=&#34;单指令多数据并行&#34;&gt;单指令、多数据并行&lt;/h4&gt;
&lt;h3 id=&#34;计算机系统中抽象的重要性&#34;&gt;计算机系统中抽象的重要性&lt;/h3&gt;
&lt;p&gt;文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，进程是对正在运行程序的抽象，虚拟机提供对整个计算机的抽象。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>cs231n——1.Nearest Neighbor Classifier</title>
        <link>https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/</link>
        <pubDate>Wed, 09 Jun 2021 17:41:44 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/ -&lt;p&gt;图像分类规范化步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：输入带有不同标签的图像作为训练集&lt;/li&gt;
&lt;li&gt;学习：使用训练集学习每种类别的抽象特征&lt;/li&gt;
&lt;li&gt;评估：通过测试集评估分类器的质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nearest-neighbor-classifier&#34;&gt;Nearest Neighbor Classifier&lt;/h2&gt;
&lt;p&gt;CIFAR-10 dataset:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10 classes (airplane, automobile, bird, etc)&lt;/li&gt;
&lt;li&gt;60,000 tiny images that are 32 pixels high and wide&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k-NN通过将一张测试集图片与所有的训练集图片进行比较，预测结果。&lt;/p&gt;
&lt;h3 id=&#34;l1-distance&#34;&gt;L1 distance:&lt;/h3&gt;
&lt;p&gt;$$
d_{1}\left(I_{1}, I_{2}\right)=\sum_{p}\left|I_{1}^{p}-I_{2}^{p}\right|
$$&lt;/p&gt;
&lt;p&gt;将两张图片分别表示为$I_1, I_2$两个向量，使用L1距离来比较两张图片。&lt;/p&gt;
&lt;p&gt;通常使用准确率来评估分类器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;Xtr, Ytr, Xte, Yte &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; load_CIFAR10(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;data/cifar10/&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#888&#34;&gt;# a magic function we provide&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# flatten out all images to be one-dimensional&lt;/span&gt;
Xtr_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xtr&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;reshape(Xtr&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#888&#34;&gt;# Xtr_rows becomes 50000 x 3072&lt;/span&gt;
Xte_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xte&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;reshape(Xte&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#888&#34;&gt;# Xte_rows becomes 10000 x 3072&lt;/span&gt;

nn &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; NearestNeighbor() &lt;span style=&#34;color:#888&#34;&gt;# create a Nearest Neighbor classifier class&lt;/span&gt;
nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;train(Xtr_rows, Ytr) &lt;span style=&#34;color:#888&#34;&gt;# train the classifier on the training images and labels&lt;/span&gt;
Yte_predict &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;predict(Xte_rows) &lt;span style=&#34;color:#888&#34;&gt;# predict labels on the test images&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# and now print the classification accuracy, which is the average number&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# of examples that are correctly predicted (i.e. label matches)&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;accuracy: &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt; ( np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;mean(Yte_predict &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; Yte) )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here is an implementation of a simple Nearest Neighbor classifier with the L1 distance that satisfies this template:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;NearestNeighbor&lt;/span&gt;(&lt;span style=&#34;color:#007020&#34;&gt;object&lt;/span&gt;):
  &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; __init__(self):
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;pass&lt;/span&gt;

  &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;train&lt;/span&gt;(self, X, y):
    &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;#34;&amp;#34; X is N x D where each row is an example. Y is 1-dimension of size N &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;# the nearest neighbor classifier simply remembers all the training data&lt;/span&gt;
    self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;Xtr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X
    self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;ytr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y

  &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;predict&lt;/span&gt;(self, X):
    &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;#34;&amp;#34; X is N x D where each row is an example we wish to predict label for &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    num_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]	&lt;span style=&#34;color:#888&#34;&gt;#训练样本数量&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;# lets make sure that the output type matches the input type&lt;/span&gt;
    Ypred &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;zeros(num_test, dtype &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;ytr&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype)

    &lt;span style=&#34;color:#888&#34;&gt;# loop over all test rows&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;range&lt;/span&gt;(num_test):
      &lt;span style=&#34;color:#888&#34;&gt;# find the nearest training image to the i&amp;#39;th test image&lt;/span&gt;
      &lt;span style=&#34;color:#888&#34;&gt;# using the L1 distance (sum of absolute value differences)&lt;/span&gt;
      distances &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sum(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;abs(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;Xtr &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; X[i,:]), axis &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)
      min_index &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;argmin(distances) &lt;span style=&#34;color:#888&#34;&gt;# get the index with smallest distance&lt;/span&gt;
      Ypred[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;ytr[min_index] &lt;span style=&#34;color:#888&#34;&gt;# predict the label of the nearest example&lt;/span&gt;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; Ypred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用L1距离测试的准确率只有38.6%.&lt;/p&gt;
&lt;h3 id=&#34;l2-distance&#34;&gt;L2 distance&lt;/h3&gt;
&lt;p&gt;$$
d_{2}\left(I_{1}, I_{2}\right)=\sqrt{\sum_{p}\left(I_{1}^{p}-I_{2}^{p}\right)^{2}}
$$&lt;/p&gt;
&lt;p&gt;only replace a single line of code above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;distances &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sqrt(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sum(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;square(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;Xtr &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; X[i,:]), axis &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;k---nearest-neighbor-classifier&#34;&gt;k - Nearest Neighbor Classifier&lt;/h2&gt;
&lt;p&gt;找到距离最近的k个图片，k个图片中数量最多的一个标签即为测试图片所分的类别。&lt;/p&gt;
&lt;h2 id=&#34;validation-sets-for-hyperparameter-tuning&#34;&gt;Validation sets for Hyperparameter tuning&lt;/h2&gt;
&lt;p&gt;有很多我们可以选择的距离函数，例如L1 norm, L2 norm等，这些选择称为&lt;/p&gt;
&lt;p&gt;Hyperparameter 。通常不能使用test set来调整Hyperparameter。Evaluate on the test set only a single time, at the very end.&lt;/p&gt;
&lt;p&gt;将训练集划分为一个小一些的训练集和一个验证集(validation set)。例如使用CIFAR-10数据集时将训练集分为49,000个训练集和1,000个验证集。&lt;/p&gt;
&lt;p&gt;验证集本质上是一个假的测试集，是用来调整Hyperparameter的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# assume we have Xtr_rows, Ytr, Xte_rows, Yte as before&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# recall Xtr_rows is 50,000 x 3072 matrix&lt;/span&gt;
Xval_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xtr_rows[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;, :] &lt;span style=&#34;color:#888&#34;&gt;# take first 1000 for validation&lt;/span&gt;
Yval &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Ytr[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;]
Xtr_rows &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Xtr_rows[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;:, :] &lt;span style=&#34;color:#888&#34;&gt;# keep last 49,000 for train&lt;/span&gt;
Ytr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Ytr[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1000&lt;/span&gt;:]

&lt;span style=&#34;color:#888&#34;&gt;# find hyperparameters that work best on the validation set&lt;/span&gt;
validation_accuracies &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;]:

  &lt;span style=&#34;color:#888&#34;&gt;# use a particular value of k and evaluation on validation data&lt;/span&gt;
  nn &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; NearestNeighbor()
  nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;train(Xtr_rows, Ytr)
  &lt;span style=&#34;color:#888&#34;&gt;# here we assume a modified NearestNeighbor class that can take a k as input&lt;/span&gt;
  Yval_predict &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;predict(Xval_rows, k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k)
  acc &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;mean(Yval_predict &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; Yval)
  &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;accuracy: &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt; (acc,)

  &lt;span style=&#34;color:#888&#34;&gt;# keep track of what works on the validation set&lt;/span&gt;
  validation_accuracies&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;append((k, acc))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cross-validation&#34;&gt;Cross-validation&lt;/h3&gt;
&lt;p&gt;当训练集数量较少时，使用更为复杂的交叉验证来调整hyperparameter。我们通过迭代不同的验证集并平均计算这些验证集的结果来确定k。例如在5次迭代的交叉验证中，将训练集分为5份，使用4份训练，1份验证，然后改变验证集，迭代5次，最终使用5次的平均结果确定k。&lt;/p&gt;
&lt;h2 id=&#34;nearest-neighbor-classifier的优缺点&#34;&gt;Nearest Neighbor classifier的优缺点&lt;/h2&gt;
&lt;p&gt;验证时的时间成本较高，每个验证样本都要与每一个测试集样本进行比较，效率较低。&lt;/p&gt;
&lt;p&gt;Nearest Neighbor classifier在低维度训练中较为常用，但在图像分类中很少用，因为图像是高维对象，高维对象之间的距离计算式违反直觉的。&lt;/p&gt;
&lt;h2 id=&#34;summery&#34;&gt;Summery&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果数据的维数很高，可以使用降维技术，例如PCA(主成分分析), NCA(邻域成分分析) or Random Projections(随机投影).&lt;/li&gt;
&lt;/ol&gt;
- https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Python基础和numpy</title>
        <link>https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</link>
        <pubDate>Sun, 06 Jun 2021 13:04:49 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/ -&lt;h2 id=&#34;basic-of-python&#34;&gt;Basic of Python&lt;/h2&gt;
&lt;h3 id=&#34;basic-data-types&#34;&gt;Basic data types&lt;/h3&gt;
&lt;h4 id=&#34;numbers&#34;&gt;Numbers&lt;/h4&gt;
&lt;h4 id=&#34;bolleans&#34;&gt;Bolleans&lt;/h4&gt;
&lt;h4 id=&#34;strings&#34;&gt;Strings&lt;/h4&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;h4 id=&#34;lists&#34;&gt;Lists&lt;/h4&gt;
&lt;h4 id=&#34;slicing&#34;&gt;Slicing&lt;/h4&gt;
&lt;h4 id=&#34;loops&#34;&gt;Loops&lt;/h4&gt;
&lt;h4 id=&#34;dictionaries&#34;&gt;Dictionaries&lt;/h4&gt;
&lt;p&gt;key-value&lt;/p&gt;
&lt;h4 id=&#34;sets&#34;&gt;Sets&lt;/h4&gt;
&lt;p&gt;unordered&lt;/p&gt;
&lt;h4 id=&#34;tuples&#34;&gt;Tuples&lt;/h4&gt;
&lt;p&gt;A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot.&lt;/p&gt;
&lt;h3 id=&#34;functions&#34;&gt;Functions&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt; keyword&lt;/p&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Greeter&lt;/span&gt;:

    &lt;span style=&#34;color:#888&#34;&gt;# Constructor&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; __init__(self, name):
        self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;name &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; name  &lt;span style=&#34;color:#888&#34;&gt;# Create an instance variable&lt;/span&gt;

    &lt;span style=&#34;color:#888&#34;&gt;# Instance method&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;greet&lt;/span&gt;(self, loud&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;False&lt;/span&gt;):
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; loud:
          &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;HELLO, &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;format(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;name&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;upper()))
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;:
          &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;!&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;format(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;name))

g &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Greeter(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Fred&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#888&#34;&gt;# Construct an instance of the Greeter class&lt;/span&gt;
g&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;greet()            &lt;span style=&#34;color:#888&#34;&gt;# Call an instance method; prints &amp;#34;Hello, Fred&amp;#34;&lt;/span&gt;
g&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;greet(loud&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;True&lt;/span&gt;)   &lt;span style=&#34;color:#888&#34;&gt;# Call an instance method; prints &amp;#34;HELLO, FRED!&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;numpy&#34;&gt;Numpy&lt;/h2&gt;
&lt;p&gt;Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.&lt;/p&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;p&gt;A numpy array is &lt;strong&gt;a grid of values&lt;/strong&gt;, all of the &lt;strong&gt;same type&lt;/strong&gt;, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.&lt;/p&gt;
&lt;h3 id=&#34;array-indexing&#34;&gt;Array indexing&lt;/h3&gt;
&lt;h4 id=&#34;slicing-1&#34;&gt;Slicing&lt;/h4&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

&lt;span style=&#34;color:#888&#34;&gt;# Create the following rank 2 array with shape (3, 4)&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# [[ 1  2  3  4]&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#  [ 5  6  7  8]&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#  [ 9 10 11 12]]&lt;/span&gt;
a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# Use slicing to pull out the subarray consisting of the first 2 rows&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# and columns 1 and 2; b is the following array of shape (2, 2):&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# [[2 3]&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#  [6 7]]&lt;/span&gt;
b &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;]
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Two ways of accessing the data in the middle row of the array. Mixing integer indexing with slices yields an array of lower rank, while using only slices yields an array of the same rank as the original array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;row_r1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, :]    &lt;span style=&#34;color:#888&#34;&gt;# Rank 1 view of the second row of a  &lt;/span&gt;
row_r2 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, :]  &lt;span style=&#34;color:#888&#34;&gt;# Rank 2 view of the second row of a&lt;/span&gt;
row_r3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; a[[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;], :]  &lt;span style=&#34;color:#888&#34;&gt;# Rank 2 view of the second row of a&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(row_r1, row_r1&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape)
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(row_r2, row_r2&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape)
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(row_r3, row_r3&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;integer-array-indexing&#34;&gt;Integer array indexing&lt;/h4&gt;
&lt;p&gt;Integer array indexing allows you to construct arbitrary arrays using the data from another array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# An example of integer array indexing.&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# The returned array will have shape (3,) and &lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# The above example of integer array indexing is equivalent to this:&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;], a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;result:&lt;/p&gt;
&lt;p&gt;[1 4 5]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# When using integer array indexing, you can reuse the same&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# element from the source array:&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]])

&lt;span style=&#34;color:#888&#34;&gt;# Equivalent to the previous integer array indexing example&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;], a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;One useful trick with integer array indexing is selecting or mutating one element from each row of a matrix:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# Create a new array from which we will select elements&lt;/span&gt;
a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# Create an array of indices&lt;/span&gt;
b &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])

&lt;span style=&#34;color:#888&#34;&gt;# Select one element from each row of a using the indices in b&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;), b])  &lt;span style=&#34;color:#888&#34;&gt;# Prints &amp;#34;[ 1  6  7 11]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[1 6 7 11]&lt;/p&gt;
&lt;h4 id=&#34;boolean-array-indexing&#34;&gt;Boolean array indexing&lt;/h4&gt;
&lt;p&gt;Frequently this type of indexing is used to select the elements of an array that &lt;strong&gt;satisfy some condition&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;]])

bool_idx &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (a &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;)  &lt;span style=&#34;color:#888&#34;&gt;# Find the elements of a that are bigger than 2;&lt;/span&gt;
                    &lt;span style=&#34;color:#888&#34;&gt;# this returns a numpy array of Booleans of the same&lt;/span&gt;
                    &lt;span style=&#34;color:#888&#34;&gt;# shape as a, where each slot of bool_idx tells&lt;/span&gt;
                    &lt;span style=&#34;color:#888&#34;&gt;# whether that element of a is &amp;gt; 2.&lt;/span&gt;

&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(bool_idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[[False False]
[ True  True]
[ True  True]]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# We use boolean array indexing to construct a rank 1 array&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# consisting of the elements of a corresponding to the True values&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# of bool_idx&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[bool_idx])

&lt;span style=&#34;color:#888&#34;&gt;# We can do all of the above in a single concise statement:&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(a[a &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[3 4 5 6]
[3 4 5 6]&lt;/p&gt;
&lt;h3 id=&#34;datatypes&#34;&gt;Datatypes&lt;/h3&gt;
&lt;p&gt;Every numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;])  &lt;span style=&#34;color:#888&#34;&gt;# Let numpy choose the datatype&lt;/span&gt;
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;2.0&lt;/span&gt;])  &lt;span style=&#34;color:#888&#34;&gt;# Let numpy choose the datatype&lt;/span&gt;
z &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], dtype&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;int64)  &lt;span style=&#34;color:#888&#34;&gt;# Force a particular datatype&lt;/span&gt;

&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype, y&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype, z&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dtype)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;array-math&#34;&gt;Array math&lt;/h3&gt;
&lt;p&gt;Note that unlike MATLAB, &lt;code&gt;*&lt;/code&gt; is elementwise multiplication, not matrix multiplication. We instead use the dot function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. dot is available both as a function in the numpy module and as an instance method of array objects:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;]], dtype&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;float64)
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;]], dtype&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;float64)

&lt;span style=&#34;color:#888&#34;&gt;# Elementwise product; both produce the array&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(x &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; y)
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;multiply(x, y))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[[ 5. 12.]
[21. 32.]]
[[ 5. 12.]
[21. 32.]]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;]])
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;],[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;]])

v &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;])
w &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;])

&lt;span style=&#34;color:#888&#34;&gt;# Inner product of vectors; both produce 219&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(v&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dot(w))
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dot(v, w))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;219
219&lt;/p&gt;
&lt;p&gt;You can also use the &lt;code&gt;@&lt;/code&gt; operator which is equivalent to numpy&amp;rsquo;s &lt;code&gt;dot&lt;/code&gt; operator.&lt;/p&gt;
&lt;p&gt;to transpose a matrix, simply use the T attribute of an array object:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;transpose&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;T)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;transpose
[[1 3]
[2 4]]&lt;/p&gt;
&lt;h3 id=&#34;broadcasting&#34;&gt;Broadcasting&lt;/h3&gt;
&lt;p&gt;Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations.&lt;/p&gt;
&lt;p&gt;For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# We will add the vector v to each row of the matrix x,&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# storing the result in the matrix y&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])
v &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;empty_like(x)   &lt;span style=&#34;color:#888&#34;&gt;# Create an empty matrix with the same shape as x&lt;/span&gt;

&lt;span style=&#34;color:#888&#34;&gt;# Add the vector v to each row of the matrix x with an explicit loop&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;range&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;):
    y[i, :] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x[i, :] &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; v

&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[[ 2  2  4]
[ 5  5  7]
[ 8  8 10]
[11 11 13]]&lt;/p&gt;
&lt;p&gt;Numpy broadcasting allows us to perform this computation without actually creating multiple copies of v. Consider this version, using broadcasting:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;

&lt;span style=&#34;color:#888&#34;&gt;# We will add the vector v to each row of the matrix x,&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# storing the result in the matrix y&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;], [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;]])
v &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;array([&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; v  &lt;span style=&#34;color:#888&#34;&gt;# Add v to each row of x using broadcasting&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The line &lt;code&gt;y = x + v&lt;/code&gt; works even though &lt;code&gt;x&lt;/code&gt; has shape &lt;code&gt;(4, 3)&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; has shape &lt;code&gt;(3,)&lt;/code&gt; due to broadcasting; this line works as if v actually had shape &lt;code&gt;(4, 3)&lt;/code&gt;, where each row was a copy of &lt;code&gt;v&lt;/code&gt;, and the sum was performed elementwise.&lt;/p&gt;
&lt;h2 id=&#34;matplotlib&#34;&gt;Matplotlib&lt;/h2&gt;
&lt;p&gt;Matplotlib is a plotting library. In this section give a brief introduction to the &lt;code&gt;matplotlib.pyplot&lt;/code&gt; module, which provides a plotting system similar to that of MATLAB.&lt;/p&gt;
&lt;h3 id=&#34;plotting&#34;&gt;Plotting&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;plt&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt;matplotlib inline
&lt;span style=&#34;color:#888&#34;&gt;# Compute the x and y coordinates for points on a sine curve&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;pi, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0.1&lt;/span&gt;)
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sin(x)

&lt;span style=&#34;color:#888&#34;&gt;# Plot the points using matplotlib&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;plot(x, y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;subplots&#34;&gt;Subplots&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# Compute the x and y coordinates for points on sine and cosine curves&lt;/span&gt;
x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;pi, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0.1&lt;/span&gt;)
y_sin &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sin(x)
y_cos &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;cos(x)

&lt;span style=&#34;color:#888&#34;&gt;# Set up a subplot grid that has height 2 and width 1,&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;# and set the first such subplot as active.&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;subplot(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)

&lt;span style=&#34;color:#888&#34;&gt;# Make the first plot&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;plot(x, y_sin)
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;title(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Sine&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#888&#34;&gt;# Set the second subplot as active, and make the second plot.&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;subplot(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;)
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;plot(x, y_cos)
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;title(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Cosine&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#888&#34;&gt;# Show the figure.&lt;/span&gt;
plt&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>WLAN基本内容和802.11ax</title>
        <link>https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</link>
        <pubDate>Thu, 03 Jun 2021 18:09:38 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/ -&lt;h2 id=&#34;wlan基础内容&#34;&gt;WLAN基础内容&lt;/h2&gt;
&lt;h3 id=&#34;计算机网络概念&#34;&gt;计算机网络概念&lt;/h3&gt;
&lt;p&gt;在学习基本无线网络通信的过程中顺便可以来复习以下计算机网络的相关内容。&lt;/p&gt;
&lt;p&gt;在家庭中我们通常使用路由器联通家中的局域网和外部的广域网，路由器为网络层设备，通过IP和路由表来寻找目的地和转发数据，即为路由功能。&lt;/p&gt;
&lt;p&gt;交换机是数据链路层设备，通过用于在局域网内传输数据，通过MAC地址寻找目的地，数据转发通过硬件来实现，传输速度相较于上一层网络层有很大的性能提升。每个物理设备都具有一个唯一的MAC地址。&lt;/p&gt;
&lt;p&gt;路由器和交换机的不同在于，一个工作在网络层，另一个工作在数据链路层，交换机连接的网络必须使用相同的数据链路层协议，一般即为&lt;strong&gt;802.3(以太网)或802.11(无线局域网)&lt;/strong&gt;。路由器工作在网络层，因此路由器连接的网络必须使用相同的网路层协议，一般为&lt;strong&gt;ip协议&lt;/strong&gt;，但路由器可以连接不同的数据链路层，比如eth2和pppoe，eth2和802.11。&lt;/p&gt;
&lt;p&gt;我们常用的每台终端都有一个MAC地址（即网卡地址），在连接网络后路由器会为其分配一个IP；而一个路由器也拥有一个MAC地址和一个IP。交换机中只有MAC地址表，通过设备的MAC地址来确定数据的目的地。&lt;/p&gt;
&lt;h3 id=&#34;无线局域网&#34;&gt;无线局域网&lt;/h3&gt;
&lt;p&gt;WLAN即为Wireless LAN，无线局域网。无线局域网通用的标准是IEEE定义的802.11系列标准，目前共有六代（2021年），为802.11a/b/g/n/ac/ax，分别从第一代到第六代。&lt;/p&gt;
&lt;p&gt;Wi-Fi称为无线网络，是Wi-Fi联盟的商标，是基于802.11标准实现的无线局域网技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IEEE 802.11标准&lt;/strong&gt;定义了一个媒体访问控制(MAC，即&lt;strong&gt;数据链路层&lt;/strong&gt;协议)和几个&lt;strong&gt;物理层&lt;/strong&gt;规范，为局域内的终端提供无线连接，同时还为监管机构提供了一种标准化方法，对局域网通信的一个或多个&lt;strong&gt;频带&lt;/strong&gt;进行管理。&lt;/p&gt;
&lt;h3 id=&#34;24ghz和5ghz&#34;&gt;2.4GHz和5GHz&lt;/h3&gt;
&lt;p&gt;2.4GHz频道列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频道&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频率 (MHz)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大部分国家&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2412&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2417&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2422&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2427&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2432&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2437&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2442&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2447&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2452&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2457&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2462&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2467&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2472&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;14&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2484&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;5GHz频道列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频道&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;频率 (MHz)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;中国&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40/20 MHz[&lt;a href=&#34;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#cite_note-15&#34;&gt;15]&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40/20 MHz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20 MHz[&lt;a href=&#34;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#cite_note-israel-19&#34;&gt;19]&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;183&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4915&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;184&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4920&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;185&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4925&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;187&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4935&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;188&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4940&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;189&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4945&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;192&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4960&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;196&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4980&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5035&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5040&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5045&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5055&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5060&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5080&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;34&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5170&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5180&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;38&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5190&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5200&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;42&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5210&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;44&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5220&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;46&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5230&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;48&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5240&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;52&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5260&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;56&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5280&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;60&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5300&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5320&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5500&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;104&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5520&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;108&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5540&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;112&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5560&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;116&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5580&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5600&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;124&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5620&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5640&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;132&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5660&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;136&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5680&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;140&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5700&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;149&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5745&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;153&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5765&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;157&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5785&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;161&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5805&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;165&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5825&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;wifi-680211ax&#34;&gt;WiFi 6——802.11ax&lt;/h2&gt;
&lt;p&gt;IEEE 802.11ax为无线局域网标准，Wi-Fi联盟称之为Wi-Fi 6。其支持从1GHz到6GHz的所有ISM频段，包括目前使用的2.4GHz和5GHz频段，向下兼容前代的a/b/g/n/ac。&lt;/p&gt;
&lt;p&gt;主要有以下的先进功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正交频分多址（OFDMA）&lt;/li&gt;
&lt;li&gt;多用户多输入多输出（MU-MIMO）&lt;/li&gt;
&lt;li&gt;160MHz信道（这并不是802.11ax才出现的，在5GHz下即可实现160MHz的带宽）&lt;/li&gt;
&lt;li&gt;1024正交幅度调制（1024-QAM）&lt;/li&gt;
&lt;li&gt;目标唤醒时间（TWT）&lt;/li&gt;
&lt;li&gt;WPA3安全标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面通过整机终端的传输速率来理解这些特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整机速率=空间流数 * (1/Symbol+GI) * 编码方式 * 码率 * 有效子载波数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间流数：AP的天线数&lt;/li&gt;
&lt;li&gt;Symbol与GI：时域上每一帧需要的时间以及空隙&lt;/li&gt;
&lt;li&gt;编码方式：调制技术，即1个Symbol能承载的bit数量。&lt;/li&gt;
&lt;li&gt;码率：排除纠错码后世纪真实传输数据码占理论值的比值&lt;/li&gt;
&lt;li&gt;有效子载波数量：频域上的Symbol，一个子载波承载余个Symbol，例如频宽为HT80时，有效子载波数量为980个；频宽为HT160时，有效子载波数为980*2个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;频分复用技术&#34;&gt;频分复用技术：&lt;/h3&gt;
&lt;p&gt;将子载波分配给不同用户，并在OFDM中添加多址的方法来实现多用户复用信道资源。&lt;/p&gt;
&lt;h3 id=&#34;mu-mimo技术&#34;&gt;MU-MIMO技术：&lt;/h3&gt;
&lt;p&gt;多天线技术，能提高用户容量，每个用户速率更快。&lt;/p&gt;
&lt;h4 id=&#34;dl-mu-mimo&#34;&gt;DL MU-MIMO&lt;/h4&gt;
&lt;p&gt;DL MU-MIMO在802.11ac就已经引入，但只支持DL 4*4 MU-MIMO（下行）。在802.11ax种进一步增加了MU-MIMO数量，支持DL 8x8 MU-MIMO，借助 DL OFDMA技术（下行），可同时进行 MU-MIMO 传输和分配不同 RU 进行多用户多址传输，既增加了系统并发接入量，又均衡了吞吐量。&lt;/p&gt;
&lt;h4 id=&#34;ul-mu-mimo&#34;&gt;UL MU-MIMO&lt;/h4&gt;
&lt;p&gt;UL MU-MIMO（上行）是802.11ax引入的一个重要特性，与下载的SU-MIMO概念类型，都是通过发射机和接收机的多天线技术使用相同信道资源在多个空间流上同时传输数据，唯一的差别点在于 UL MU-MIMO 的多个数据流是来自多个用户。&lt;/p&gt;
&lt;p&gt;802.11ac 及之前的 802.11 标准都是 UL SU-MIMO，即只能接受一个用户发来的数据，多用户并发场景效率较低，802.11ax 支持 UL MU-MIMO 后，借助 UL OFDMA 技术 （上行），可同时进行 MU-MIMO 传输和分配不同 RU 进行多用户多址传输，提升多用户并发场景效率，大大降低了应用时延。&lt;/p&gt;
&lt;h3 id=&#34;更高阶的调制技术1024-qam&#34;&gt;更高阶的调制技术(1024-QAM)：&lt;/h3&gt;
&lt;p&gt;802.11ac 采用的 256-QAM 正交幅度调制，每个符号传输 8bit 数据（2^8=256），802.11ax 将采用 1024-QAM 正交幅度调制，每个符号位传输 10bit 数据（2^10=1024）。&lt;/p&gt;
&lt;p&gt;需要注意的是 802.11ax 中成功使用 1024-QAM 调制取决于信道条件，更密的星座点距离需要更强大的 EVM（误差矢量幅度，用于量化无线电接收器或发射器在调制精度方面的性能）和接受灵敏度功能，并且信道质量要求高于其他调制类型。&lt;/p&gt;
&lt;h3 id=&#34;srbss-coloring&#34;&gt;SR&amp;amp;BSS Coloring&lt;/h3&gt;
&lt;h4 id=&#34;空分复用技术sr&#34;&gt;空分复用技术（SR）&lt;/h4&gt;
&lt;p&gt;Wi-Fi 射频的传输原理是在任何指定时间内，一个信道上只允许一个用户传输数据，如果 Wi-Fi AP 和客户端在同一信道上侦听到有其他 802.11 无线电传输，则会自动进行冲突避免，推迟传输，因此每个用户都必须轮流使用。所以说信道是无线网络中非常宝贵的资源， 特别在高密场景下，信道的合理划分和利用将对整个无线网络的容量和稳定性带来较大的影响。&lt;/p&gt;
&lt;p&gt;802.11ac 及之前的标准，通常采用动态调整 CCA 门限的机制来改善同频信道间的干扰，通过识别同频干扰强度，动态调整 CCA 门限，忽略同频弱干扰信号实现同频并发传输， 提升系统吞吐容量。&lt;/p&gt;
&lt;p&gt;802.11ax 中引入了一种新的同频传输识别机制，叫 BSS Coloring 着色机制，在 PHY 报文头中添加 BSS color 字段对来自不同BSS 的数据进行“染色”，为每个通道分配一种颜色，该颜色标识一组不应干扰的基本服务集（BSS），接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一 BSS 内的干扰信号， 发送将推迟；如果颜色不同，则认为两者之间无干扰，两个 Wi-Fi 设备可同信道同频并行传输。以这种方式设计的网络，那些具有相同颜色的信道彼此相距很远，此时我们再利用动态CCA 机制将这种信号设置为不敏感，事实上它们之间也不太可能会相互干扰。&lt;/p&gt;
&lt;h4 id=&#34;bss-coloring着色机制&#34;&gt;BSS Coloring着色机制&lt;/h4&gt;
&lt;p&gt;802.11ax 中引入了一种新的同频传输识别机制，叫 BSS Coloring 着色机制，在 PHY 报文头中添加 BSS color 字段对来自不同BSS 的数据进行“染色”，为每个通道分配一种颜色，该颜色标识一组不应干扰的基本服务集（BSS），接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一 BSS 内的干扰信号， 发送将推迟；如果颜色不同，则认为两者之间无干扰，两个 Wi-Fi 设备可同信道同频并行传输。以这种方式设计的网络，那些具有相同颜色的信道彼此相距很远，此时我们再利用动态CCA 机制将这种信号设置为不敏感，事实上它们之间也不太可能会相互干扰。&lt;/p&gt;
&lt;h3 id=&#34;扩展覆盖范围er&#34;&gt;扩展覆盖范围（ER）&lt;/h3&gt;
&lt;p&gt;由于 802.11ax 标准采用的是Long OFDM symbol 发送机制，每次数据发送持续时间从原来的 3.2us 提升到 12.8us，更长的发送时间可降低终端丢包率；另外 802.11ax 最小可仅使用 2MHz 频宽进行窄带传输，有效降低频段噪声干扰，提升了终端接受灵敏度，增加了覆盖距离。&lt;/p&gt;
&lt;h3 id=&#34;其他特性&#34;&gt;其他特性&lt;/h3&gt;
&lt;h4 id=&#34;支持24ghz&#34;&gt;支持2.4GHz&lt;/h4&gt;
&lt;p&gt;2.4GHz 频宽窄，且仅有 3 个 20MHz 的互不干扰信道（1,6 和 11），但是有一点不可否认的是 2.4GHz 仍然是一个可用的 Wi-Fi 频段，在很多场景下依然被广泛使用，主要有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;覆盖范围广&lt;/strong&gt;：信号频率越低， 波长越长，绕射能力越强，穿透能力越差，信号损失衰减越小，传输距离越远。虽然 5GHz 频段可带来更高的传播速度，但信号衰减也越大，所以传输距离比 2.4GHz 要短。&lt;/li&gt;
&lt;li&gt;低成本&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;目标唤醒时间&#34;&gt;目标唤醒时间&lt;/h4&gt;
&lt;p&gt;802.11ax AP 可以和 STA 协调目标唤醒时间(TWT)功能的使用，AP 和 STA 会互相交换信息，当中将包含预计的活动持续时间，以定义让 STA 访问介质的特定时间或一组时间， 这样就可以避开多个不同 STA 之间的竞争和重叠情况。另外，支持 802.11ax 标准的 STA 可以使用 TWT 来降低能量损耗，在自身的 TWT 来临之前进入睡眠状态。AP 还可另外设定 TWT编排计划并将 TWT 值提供给 STA，这样双方之间就不需要存在个别的 TWT 协议，此操作称为“广播 TWT 操作”。&lt;/p&gt;
&lt;h2 id=&#34;家庭无线网络配置&#34;&gt;家庭无线网络配置&lt;/h2&gt;
&lt;h3 id=&#34;acap&#34;&gt;AC+AP&lt;/h3&gt;
&lt;h3 id=&#34;mesh组网&#34;&gt;MESH组网&lt;/h3&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://e.huawei.com/cn/material/networking/wlan/b3f46485597c4d72b43a6a27c6480646&#34;&gt;华为Wi-Fi 6(802.11ax)技术白皮书&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/IEEE_802.11ax&#34;&gt;wikipedia IEEE 802.11ax&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8#5_GHz_(802.11a/h/j/n/ac/ax)%5B11%5D&#34;&gt;wikipedia WLAN信道列表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;- https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>字符编码：Unicode, UTF-8</title>
        <link>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/</link>
        <pubDate>Wed, 02 Jun 2021 15:29:29 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/ -&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;p&gt;计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。通俗的说，按照何种规则将字符存储在计算机中，如&amp;rsquo;a&amp;rsquo;用什么表示，称为&amp;quot;&lt;strong&gt;编码&lt;/strong&gt;&amp;quot;；反之，将存储在计算机中的二进制数解析显示出来，称为&amp;quot;&lt;strong&gt;解码&lt;/strong&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符集(charset)&lt;/strong&gt;：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国文字、标点符号、图形符号、数字等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码(character Encoding)&lt;/strong&gt;：即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。&lt;/p&gt;
&lt;h2 id=&#34;ascii字符集和编码&#34;&gt;ASCII字符集和编码&lt;/h2&gt;
&lt;p&gt;ASCII (American Standard Code for Information Interchange)是基于拉丁字母的一套电脑编码系统。主要用于显示现代英语。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASCII字符集&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制字符（回车键、退格、换行键等）；&lt;/li&gt;
&lt;li&gt;可显示字符（英文大小写字符、阿拉伯数字和西文符号）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ASCII编码&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用**8位（bits）**表示一个字符，共256字符。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;ASCII值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;控制字符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;ASCII值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;控制字符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;ASCII值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;控制字符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;ASCII值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;控制字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NUT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(space)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;@&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;96&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;、&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SOH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;33&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;65&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;97&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;STX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;34&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;66&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;98&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ETX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;35&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;#&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;67&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EOT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;68&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ENQ&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;37&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;69&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;E&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;101&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ACK&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;38&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;amp;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;70&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;F&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;102&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BEL&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;39&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;,&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;71&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;G&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;103&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;g&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;72&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;104&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;41&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;73&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;105&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;i&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;42&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;74&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;J&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;106&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;j&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;VT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;43&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;+&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;75&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;K&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;107&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;k&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;44&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;,&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;76&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;L&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;108&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;l&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CR&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;45&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;77&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;109&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;14&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SO&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;46&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;78&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;N&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;110&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SI&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;47&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;/&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;79&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;111&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;o&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DLE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;48&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;80&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;P&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;112&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;17&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DCI&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;49&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;81&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Q&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;113&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;q&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;18&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DC2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;50&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;82&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;R&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;114&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;r&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DC3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;51&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;83&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;115&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DC4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;52&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;84&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;T&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;116&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;21&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NAK&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;53&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;85&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;U&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;117&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;u&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;22&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SYN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;54&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;86&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;V&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;118&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;v&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;55&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;87&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;W&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;119&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;24&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CAN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;56&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;88&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;X&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EM&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;57&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;89&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Y&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;121&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;26&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SUB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;58&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;90&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Z&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;122&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;27&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ESC&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;59&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;91&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;123&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;{&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;28&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;60&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;92&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;/&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;124&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;29&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;61&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;93&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;125&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;62&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;94&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;^&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;126&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;31&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;US&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;63&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;?&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;95&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;_&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;127&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DEL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;0-31和127位控制字符，其余为可显示字符。&lt;/p&gt;
&lt;p&gt;ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语。&lt;/p&gt;
&lt;h2 id=&#34;gbxxxx字符集和编码&#34;&gt;GBXXXX字符集和编码&lt;/h2&gt;
&lt;p&gt;是为了显示中文而设计的额一套编码规则。&lt;/p&gt;
&lt;p&gt;一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。&lt;/p&gt;
&lt;p&gt;在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&amp;quot;&lt;strong&gt;全角&lt;/strong&gt;&amp;ldquo;字符，而原来在127号以下的那些就叫&amp;rdquo;&lt;strong&gt;半角&lt;/strong&gt;&amp;ldquo;字符了。&lt;/p&gt;
&lt;p&gt;上述编码规则就是GB2312。GB2312或GB2312-80是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。&lt;/p&gt;
&lt;p&gt;GBK是对GB2312-80的扩展，也就是CP936字码表 (Code Page 936)的扩展（之前CP936和GB 2312-80一模一样），最早实现于Windows 95简体中文版。&lt;/p&gt;
&lt;h2 id=&#34;unicode字符集和uft编码&#34;&gt;Unicode字符集和UFT编码&lt;/h2&gt;
&lt;p&gt;Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个数字代表唯一的至少在某种语言中使用的符号。（并不是所有的数字都用上了，但是总数已经超过了65535，所以2个字节的数字是不够用的。）&lt;/p&gt;
&lt;p&gt;Unicode是字符集，UTF-32/16/8是三种字符编码方案。&lt;/p&gt;
&lt;h3 id=&#34;utf-32&#34;&gt;UTF-32&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;4字节&lt;/strong&gt;的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。对每个字符都使用4字节。就空间而言，是非常没有效率的。&lt;/p&gt;
&lt;h3 id=&#34;uft-16&#34;&gt;UFT-16&lt;/h3&gt;
&lt;p&gt;实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。&lt;/p&gt;
&lt;p&gt;如果真的需要表达那些很少使用的&amp;quot;星芒层(astral plane)&amp;ldquo;内超过这65535范围的Unicode字符，则需要使用一些诡异的技巧来实现。&lt;/p&gt;
&lt;p&gt;UTF-16编码最明显的优点是它在空间效率上比UTF-32高两倍，因为每个字符只需要&lt;strong&gt;2个字节&lt;/strong&gt;来存储（除去65535范围以外的）。&lt;/p&gt;
&lt;h3 id=&#34;utf-8&#34;&gt;UTF-8&lt;/h3&gt;
&lt;p&gt;UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的&lt;strong&gt;可变长度&lt;/strong&gt;字符编码（定长码），也是一种前缀码。可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍&lt;strong&gt;与ASCII兼容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;UTF-8使用一至四个字节为每个字符编码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。&lt;/li&gt;
&lt;li&gt;带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。&lt;/li&gt;
&lt;li&gt;其他基本多文种平面（BMP）中的字符（这包含了大部分常用中文字）使用三个字节编码。&lt;/li&gt;
&lt;li&gt;其他极少使用的Unicode辅助平面的字符使用四字节编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UTF-8是ASCII的一个超集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。&lt;/p&gt;- https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>机器学习——k近邻(k-NN)算法</title>
        <link>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/</link>
        <pubDate>Wed, 12 May 2021 14:57:17 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/ -&lt;h2 id=&#34;基本概念及原理&#34;&gt;基本概念及原理&lt;/h2&gt;
&lt;p&gt;k近邻(k-nearest neighbors)算法是一种基本分类和回归方法。&lt;/p&gt;
&lt;p&gt;该算法是给定一个&lt;strong&gt;训练数据集&lt;/strong&gt;，对新的&lt;strong&gt;输入测试集&lt;/strong&gt;，在训练集中找到与该测试实例&lt;strong&gt;最邻近&lt;/strong&gt;的k个实例，这k个实例的多数属于某个类，就把该输入实例分类到这个类中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/220px-KnnClassification.svg.png&#34; alt=&#34;220px-KnnClassification.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;有两类不同样本分别用红色三角形和蓝色正方形表示，途中绿色圆形为待分类的数据。这时我们根据k-近邻的思想进行分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当k=3时，判定样本属于红色三角形这一类；&lt;/li&gt;
&lt;li&gt;当k=5时，判定样本属于蓝色正方形这一类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;k的选取及特征归一化&#34;&gt;k的选取及特征归一化&lt;/h2&gt;
&lt;h3 id=&#34;选取k值及其影响&#34;&gt;选取k值及其影响&lt;/h3&gt;
&lt;p&gt;选取较小的k值，整体模型会变得更加复杂，容易发生&lt;strong&gt;过拟合&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;过拟合就是在训练集上准确率非常高，而在测试集上准确率低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;k太小会导致过拟合，容易将一些噪声学习到模型中。&lt;/p&gt;
&lt;p&gt;选取较大的k值，整体模型变得简单，因为当k等于训练样本个数时，无论输入什么测试实例，都将简单地预测它属于&lt;strong&gt;在训练实例中最多的类&lt;/strong&gt;，相当于没有训练模型。&lt;/p&gt;
&lt;p&gt;所以，模型即不能过大也不能过小，一般选取一个较小的数值，通过采取&lt;strong&gt;交叉验证法&lt;/strong&gt;来选取最优的k值，即通过实验调参选取。&lt;/p&gt;
&lt;h3 id=&#34;距离的度量&#34;&gt;距离的度量&lt;/h3&gt;
&lt;p&gt;我们通常使用常见的&lt;strong&gt;欧氏距离&lt;/strong&gt;来衡量高维空间中两个点的距离，即：
$$
L_2(x_i,x_j)=(\sum_{l=1}^{n}| x_i^{(l)}-x_j^{(l)} |)^{\frac{1}{2}}
$$
其中，$x_i=(x_i^{(1)}, x_i^{(2)},&amp;hellip;,x_i^{(n)})$，同理$x_j$。&lt;/p&gt;
&lt;h3 id=&#34;特征归一化的必要性&#34;&gt;特征归一化的必要性&lt;/h3&gt;
&lt;p&gt;如果不进行归一化，让每个特征都同等重要，就会偏向于第一维度的特征，导致多个特征并不是等价重要的，会导致距离计算错误，最终导致预测结果错误。&lt;/p&gt;
&lt;p&gt;进行KNN分类使用的样本特征是${ (x_{i1}, x_{i2},&amp;hellip;,x_{in}) }&lt;em&gt;{i=1}^m$，取每个轴上的最大值减去最小值得：
$$
M_j=\max&lt;/em&gt;{i=1,&amp;hellip;,m}x_{ij}-\min_{i=1,&amp;hellip;,m}x_{ij}
$$
并在计算距离时将每一个坐标轴除以相应的$M_j$进行归一化，即：
$$
d((y_1,&amp;hellip;,y_n),(z_1,&amp;hellip;,z_n))=\sqrt{\sum_{j=1}^{n}(\frac{y_j}{M_j}-\frac{z_j}{M_j})^2}
$$&lt;/p&gt;
&lt;h2 id=&#34;k-nn实现iris鸢尾花数据集聚类&#34;&gt;k-NN实现Iris鸢尾花数据集聚类&lt;/h2&gt;
&lt;h3 id=&#34;k-means聚类算法的实现步骤&#34;&gt;K-Means聚类算法的实现步骤：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为待聚类的点随机寻找几个聚类中心(类别个数)；&lt;/li&gt;
&lt;li&gt;计算每个点到聚类中心的距离，将各个点归类到离该点最近的聚类中去；&lt;/li&gt;
&lt;li&gt;计算每个聚类中所有点的坐标平均值，并将这个平均值作为新的聚类中心，反复执行上一步和该步，直到聚类中心不再进行大范围移动或聚类迭代次数达到要求位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;np&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;pandas&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;pd&lt;/span&gt;

data &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; pd&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;read_csv(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&amp;#39;&lt;/span&gt;, header&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;None&lt;/span&gt;)    &lt;span style=&#34;color:#888&#34;&gt;# 下载iris数据集&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;#data = pd.read_csv(&amp;#39;./data/iris.data.csv&amp;#39;, header=None)&lt;/span&gt;
data&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;columns &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;sepal length&amp;#39;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;sepal width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;petal length&amp;#39;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;petal width&amp;#39;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;species&amp;#39;&lt;/span&gt;]    &lt;span style=&#34;color:#888&#34;&gt;# 特征及类别名称&lt;/span&gt;

X &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; data&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;iloc[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;150&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;]&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;values
y &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; data&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;iloc[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;150&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;]&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;values
y[y &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Iris-setosa&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;                                 &lt;span style=&#34;color:#888&#34;&gt;# Iris-setosa 输出label用0表示&lt;/span&gt;
y[y &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Iris-versicolor&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;                             &lt;span style=&#34;color:#888&#34;&gt;# Iris-versicolor 输出label用1表示&lt;/span&gt;
y[y &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;Iris-virginica&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;                              &lt;span style=&#34;color:#888&#34;&gt;# Iris-virginica 输出label用2表示&lt;/span&gt;
X_setosa, y_setosa &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;], y[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;]                     &lt;span style=&#34;color:#888&#34;&gt;# Iris-setosa 4个特征&lt;/span&gt;
X_versicolor, y_versicolor &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;], y[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;]         &lt;span style=&#34;color:#888&#34;&gt;# Iris-versicolor 4个特征&lt;/span&gt;
X_virginica, y_virginica &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;150&lt;/span&gt;], y[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;150&lt;/span&gt;]         &lt;span style=&#34;color:#888&#34;&gt;# Iris-virginica 4个特征&lt;/span&gt;


&lt;span style=&#34;color:#888&#34;&gt;# training set&lt;/span&gt;
X_setosa_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_setosa[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;, :]
y_setosa_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_setosa[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;]
X_versicolor_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_versicolor[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;, :]
y_versicolor_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_versicolor[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;]
X_virginica_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_virginica[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;, :]
y_virginica_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_virginica[:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;]
X_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;vstack([X_setosa_train, X_versicolor_train, X_virginica_train])
y_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;hstack([y_setosa_train, y_versicolor_train, y_virginica_train])

&lt;span style=&#34;color:#888&#34;&gt;# validation set&lt;/span&gt;
X_setosa_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_setosa[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;, :]
y_setosa_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_setosa[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;]
X_versicolor_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_versicolor[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;, :]
y_versicolor_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_versicolor[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;]
X_virginica_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_virginica[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;, :]
y_virginica_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_virginica[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;30&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;]
X_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;vstack([X_setosa_val, X_versicolor_val, X_virginica_val])
y_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;hstack([y_setosa_val, y_versicolor_val, y_virginica_val])

&lt;span style=&#34;color:#888&#34;&gt;# test set&lt;/span&gt;
X_setosa_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_setosa[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;, :]
y_setosa_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_setosa[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;]
X_versicolor_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_versicolor[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;, :]
y_versicolor_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_versicolor[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;]
X_virginica_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X_virginica[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;, :]
y_virginica_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y_virginica[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;40&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;]
X_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;vstack([X_setosa_test, X_versicolor_test, X_virginica_test])
y_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;hstack([y_setosa_test, y_versicolor_test, y_virginica_test])


&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;KNearestNeighbor&lt;/span&gt;(&lt;span style=&#34;color:#007020&#34;&gt;object&lt;/span&gt;):
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; __init__(self):
       &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;pass&lt;/span&gt;

   &lt;span style=&#34;color:#888&#34;&gt;# 训练函数&lt;/span&gt;
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;train&lt;/span&gt;(self, X, y):
       self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;X_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X
       self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;y_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y

   &lt;span style=&#34;color:#888&#34;&gt;# 预测函数&lt;/span&gt;
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;predict&lt;/span&gt;(self, X, k&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;):
       &lt;span style=&#34;color:#888&#34;&gt;# 计算L2距离&lt;/span&gt;
       num_test &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; X&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]
       num_train &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;X_train&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]
       dists &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;zeros((num_test, num_train))    &lt;span style=&#34;color:#888&#34;&gt;# 初始化距离函数&lt;/span&gt;
       &lt;span style=&#34;color:#888&#34;&gt;# because(X - X_train)*(X - X_train) = -2X*X_train + X*X + X_train*X_train, so&lt;/span&gt;
       d1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;dot(X, self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;X_train&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;T)    &lt;span style=&#34;color:#888&#34;&gt;# shape (num_test, num_train)&lt;/span&gt;
       d2 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sum(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;square(X), axis&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, keepdims&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;True&lt;/span&gt;)    &lt;span style=&#34;color:#888&#34;&gt;# shape (num_test, 1)&lt;/span&gt;
       d3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sum(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;square(self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;X_train), axis&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)    &lt;span style=&#34;color:#888&#34;&gt;# shape (1, num_train)&lt;/span&gt;
       dist &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;sqrt(d1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; d2 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; d3)
       &lt;span style=&#34;color:#888&#34;&gt;# 根据K值，选择最可能属于的类别&lt;/span&gt;
       y_pred &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;zeros(num_test)
       &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;range&lt;/span&gt;(num_test):
           dist_k_min &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;argsort(dist[i])[:k]    &lt;span style=&#34;color:#888&#34;&gt;# 最近邻k个实例位置&lt;/span&gt;
           y_kclose &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;y_train[dist_k_min]     &lt;span style=&#34;color:#888&#34;&gt;# 最近邻k个实例对应的标签&lt;/span&gt;
           y_pred[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;argmax(np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;bincount(y_kclose&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;tolist()))    &lt;span style=&#34;color:#888&#34;&gt;# 找出k个标签中从属类别最多的作为预测类别&lt;/span&gt;

       &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; y_pred

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    KNN &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; KNearestNeighbor()
    KNN&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;train(X_train, y_train)
    y_pred &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; KNN&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;predict(X_test, k&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;)
    accuracy &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;mean(y_pred &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; y_test)
    &lt;span style=&#34;color:#007020&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;测试集预测准确率：&lt;/span&gt;&lt;span style=&#34;background-color:#eee&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt; accuracy)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;测试集预测准确率：1.000000
&lt;/code&gt;&lt;/pre&gt;- https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH08 IO库</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/</link>
        <pubDate>Mon, 10 May 2021 21:04:06 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/ -&lt;h2 id=&#34;io库&#34;&gt;IO库&lt;/h2&gt;
&lt;h3 id=&#34;io类&#34;&gt;IO类&lt;/h3&gt;
&lt;p&gt;为了支持不同类型的IO操作，除了iostream外，标准库还定义了其他一些IO类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件iostream：
&lt;ul&gt;
&lt;li&gt;istream, wistream类型，从流读取数据&lt;/li&gt;
&lt;li&gt;ostream, wostream类型，向流写入数据&lt;/li&gt;
&lt;li&gt;iostream, wiostream类型，读写流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件fstream：
&lt;ul&gt;
&lt;li&gt;ifstream类型，从文件读取数据&lt;/li&gt;
&lt;li&gt;ofstream类型，向文件写入数据&lt;/li&gt;
&lt;li&gt;fstream类型，读写文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件sstream
&lt;ul&gt;
&lt;li&gt;istringstream类型：从string读取数据&lt;/li&gt;
&lt;li&gt;ostringstream类型：向string写入数据&lt;/li&gt;
&lt;li&gt;stringstream类型：读写string&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类型前加一个w的类型是为了支持宽字符，用来操纵wchart_t类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO类型之间的关系&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;类型ifstream和istringstream都继承自istream，我们可以向使用istream对象一样来使用ifstream和istringstream。&lt;/p&gt;
&lt;h4 id=&#34;io对象无拷贝或赋值&#34;&gt;IO对象无拷贝或赋值&lt;/h4&gt;
&lt;p&gt;由于不能拷贝IO对象，因此我们也不能将形参或范围类型设置为流类型，进行IO操作额函数通常以&lt;strong&gt;引用&lt;/strong&gt;的方式传递和范围流。读写一个IO对象会改变其状态，因此传递和范围的引用不能是const的。&lt;/p&gt;
&lt;h4 id=&#34;条件状态&#34;&gt;条件状态&lt;/h4&gt;
&lt;p&gt;IO类定义了一些函数和标志，帮助我们访问和操纵流的条件状态：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//strm为一种IO类型，即上一节给出的各个类型
strm::iostate	//提供了表达条件状态的完整功能
strm::badbit	//用来指出流已崩溃
strm::failbit	//用来指出一个IO操作失败
strm::eofbit	//用来指出流到达了文件结束
strm::goodbit	//用来指出流位处于错误状态。
//其余见书
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;管理输出缓冲&#34;&gt;管理输出缓冲&lt;/h4&gt;
&lt;p&gt;每个输出流都管理一个缓冲区。&lt;/p&gt;
&lt;p&gt;导致缓冲刷新的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束，作为return的一部分操作。&lt;/li&gt;
&lt;li&gt;缓冲区满时，需要刷新。&lt;/li&gt;
&lt;li&gt;使用操纵符如endl显示刷新缓冲区。&lt;/li&gt;
&lt;li&gt;每个输出操作后可以用操纵夫unitbuf设置流的内部状态来清空缓冲区。&lt;/li&gt;
&lt;li&gt;一个输出流可能被关联到另一个输出流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;刷新输出缓冲区：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;	&lt;span style=&#34;color:#888&#34;&gt;//输出hi和一个空格，然后刷新缓冲区
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; flush;	&lt;span style=&#34;color:#888&#34;&gt;//输出hi，然后刷新缓冲区，不附加额外字符
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ends;	&lt;span style=&#34;color:#888&#34;&gt;//输出hi和一个空字符，然后刷新缓冲区
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;文件输入输出&#34;&gt;文件输入输出&lt;/h3&gt;
&lt;p&gt;头文件定义了如上所示的三个类型来住处文件IO。&lt;/p&gt;
&lt;p&gt;除了继承自iostream类型的行为外，fstream中的定义还增加了新的成员来管理与流关联的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;fstream fstrm;	&lt;span style=&#34;color:#888&#34;&gt;//创建一个未绑定的流文件fstrm; fstream是头文件fstream中定义的一个类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;fstream &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;fstrm&lt;/span&gt;(s);	&lt;span style=&#34;color:#888&#34;&gt;//创建一个fstream并打开名为s的文件
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;fstream &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;fstrm&lt;/span&gt;(s,mode);	&lt;span style=&#34;color:#888&#34;&gt;//与上一个相同，但按指定mode打开
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;fstrm.open(s)	&lt;span style=&#34;color:#888&#34;&gt;//打开名为s的文件并将文件与fstrm绑定
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;fstrm.close()	&lt;span style=&#34;color:#888&#34;&gt;//关闭与fstrm绑定的文件，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;fstrm.is_open()	&lt;span style=&#34;color:#888&#34;&gt;//返回一个bool, 指出关联的文件是否成功打开尚未关闭
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;使用文件流对象&#34;&gt;使用文件流对象&lt;/h4&gt;
&lt;h4 id=&#34;文件模式&#34;&gt;文件模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;mode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以读方式打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;out&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以写方式打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;app&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;每次写操作前均定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ate&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打开文件后立即定位到末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;trunc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;截断文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;以out模式打开文件会丢弃已有数据&#34;&gt;以out模式打开文件会丢弃已有数据&lt;/h4&gt;
&lt;h3 id=&#34;string流&#34;&gt;string流&lt;/h3&gt;- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Altium Designer画图流程记录(简略)</title>
        <link>https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</link>
        <pubDate>Fri, 30 Apr 2021 22:47:47 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/ -&lt;p&gt;之前看过博主&lt;a href=&#34;https://space.bilibili.com/384891&#34;&gt;半夜中暑的羊&lt;/a&gt;的原理图以及PCB绘制&lt;a href=&#34;https://www.bilibili.com/video/BV1JE41127Ks&#34;&gt;教程&lt;/a&gt;，收获颇丰，但是视频比较长而且分为多集，每次有些地方忘记时要去找到很不方便，因此趁着这次画一个简单转接版的机会，把视频中的内容整理成文字版，方便之后查找和复习。这里面只涉及基本的两层版的基本绘制。&lt;/p&gt;
&lt;p&gt;共有以下几部分内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原理图库&lt;/li&gt;
&lt;li&gt;核心模块的原理图&lt;/li&gt;
&lt;li&gt;为原理图添加封装&lt;/li&gt;
&lt;li&gt;PCB布局&lt;/li&gt;
&lt;li&gt;PCB布线&lt;/li&gt;
&lt;li&gt;PCB敷铜&lt;/li&gt;
&lt;li&gt;PCB生成BOM及投板&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;pcb各层简介&#34;&gt;PCB各层简介&lt;/h2&gt;
&lt;p&gt;参考自：&lt;a href=&#34;https://blog.csdn.net/qq_29373285/article/details/85339076&#34;&gt;PCB各层介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mechanical-layer机械层&#34;&gt;Mechanical layer(机械层)&lt;/h3&gt;
&lt;p&gt;Altium Designer提供了16个机械层，它一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。这些信息因设计公司或PCB制造厂家的要求而有所不同。另外，机械层可以附加在其它层上一起输出显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/MechanicalLayer.PNG&#34; alt=&#34;MechanicalLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;keep-out-layer禁止布线层&#34;&gt;Keep out layer(禁止布线层)&lt;/h3&gt;
&lt;p&gt;用于定义在电路板上能够有效放置元件和布线的区域。在该层绘制一个封闭区域作为布线有效区，在该区域外是不能自动布局和布线的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/KeepOutLayer.PNG&#34; alt=&#34;KeepOutLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;signal-layer信号层&#34;&gt;Signal layer(信号层)&lt;/h3&gt;
&lt;p&gt;信号层主要用于布置电路板上的导线。Altium Designer提供了32个信号层，包括Top layer(顶层)，Bottom layer(底层)和32个内电层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SignalLayer.PNG&#34; alt=&#34;SignalLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;internal-plane-layer内部电源接地层&#34;&gt;Internal plane layer(内部电源/接地层)&lt;/h3&gt;
&lt;p&gt;Altium Designer提供了32个内部电源层/接地层。该类型的层仅用于多层板，主要用于布置电源层和接地层。我们称双层板，四层板，六层板，一般指信号层和内部电源/接地层的数目。&lt;/p&gt;
&lt;h3 id=&#34;silkscreen-layer丝印层&#34;&gt;Silkscreen layer(丝印层)&lt;/h3&gt;
&lt;p&gt;丝印层主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。Altium Designer提供了Top Overlay（顶层丝印层）和Bottom Overlay（底层丝印层）两个丝印层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SilkscreenLayer.PNG&#34; alt=&#34;SilkscreenLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;solder-mask-layer阻焊层&#34;&gt;Solder mask layer(阻焊层)&lt;/h3&gt;
&lt;p&gt;在焊盘以外的各部位涂覆一层涂料，我们通常用的有绿油、蓝油等，用于阻止这些部位上锡。阻焊层用于在设计过程中&lt;strong&gt;匹配焊盘&lt;/strong&gt;，是&lt;strong&gt;自动产生&lt;/strong&gt;的。阻焊层是负片输出，阻焊层的地方不盖油，其他地方盖油。Altium Designer提供了**Top Solder(顶层)&lt;strong&gt;和&lt;/strong&gt;Bottom Solder(底层)**两个阻焊层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SolderMaskLayer.PNG&#34; alt=&#34;SolderMaskLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;paste-mask-layer助焊层smd贴片层&#34;&gt;Paste mask layer(助焊层，SMD贴片层)&lt;/h3&gt;
&lt;p&gt;它和阻焊层的作用相似，不同的是在机器焊接时对应的表面粘贴式元件的焊盘。Altium Designer提供了Top Paste(顶层助焊层)和Bottom Paste(底层助焊层)两个助焊层。主要针对PCB板上的SMD元件。在将SMD元件贴PCB板上以前，必须在每一个SMD焊盘上先涂上锡膏，在涂锡用的钢网就一定需要这个Paste Mask文件,菲林胶片才可以加工出来。Paste Mask层的Gerber输出最重要的一点要清楚，即这个层主要针对SMD元件，同时将这个层与上面介绍的Solder Mask作一比较，弄清两者的不同作用，因为从菲林胶片图中看这两个胶片图很相似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/PasteMaskLayer.PNG&#34; alt=&#34;PasteMaskLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;multi-layer多层&#34;&gt;Multi layer(多层)&lt;/h3&gt;
&lt;p&gt;电路板上焊盘和穿透式过孔要穿透整个电路板，与不同的导电图形层建立电气连接关系，因此系统专门设置了一个抽象的层—多层。一般，焊盘与过孔都要设置在多层上，如果关闭此层，焊盘与过孔就无法显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/MultiLayer.PNG&#34; alt=&#34;MultiLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;drill-layer钻孔层&#34;&gt;Drill layer(钻孔层)&lt;/h3&gt;
&lt;p&gt;钻孔层提供电路板制造过程中的钻孔信息(如焊盘，过孔就需要钻孔)。Altium Designer提供了Drill gride(钻孔指示)和Drill drawing(钻孔)两个钻孔层。&lt;/p&gt;
&lt;h2 id=&#34;原理图库器件画法&#34;&gt;原理图库器件画法&lt;/h2&gt;
&lt;p&gt;放置矩形&lt;/p&gt;
&lt;p&gt;添加Pin&lt;/p&gt;
&lt;p&gt;设置器件的Designator（例如P?）&lt;/p&gt;
&lt;h2 id=&#34;器件的pcb封装画法&#34;&gt;器件的PCB封装画法&lt;/h2&gt;
&lt;p&gt;确定是过孔还是焊盘，然后根据坐标放置位置，最后画丝印。&lt;/p&gt;
&lt;h2 id=&#34;批量添加封装并给各种原件命名&#34;&gt;批量添加封装并给各种原件命名&lt;/h2&gt;
&lt;h3 id=&#34;添加封装&#34;&gt;添加封装&lt;/h3&gt;
&lt;p&gt;右键-Find Similar Objects选择相同类型的原件-右键-Properties-修改封装&lt;/p&gt;
&lt;h3 id=&#34;批量命名&#34;&gt;批量命名&lt;/h3&gt;
&lt;p&gt;执行&lt;strong&gt;Tools-Annotation-Annotate Schematic&lt;/strong&gt;(或快捷键&lt;strong&gt;T A A&lt;/strong&gt;)命令打开原理图元件命名管理器&lt;/p&gt;
&lt;p&gt;左上角设置命名顺序&lt;/p&gt;
&lt;p&gt;设置命名范围&lt;/p&gt;
&lt;p&gt;然后单击Update&lt;/p&gt;
&lt;p&gt;可以看到新的命名建议，然后执行有效角的接收更改&lt;/p&gt;
&lt;p&gt;依次单击Validate和Execute（保证两排绿√）&lt;/p&gt;
&lt;p&gt;即可完成命名&lt;/p&gt;
&lt;h2 id=&#34;确定pcb范围并布局&#34;&gt;确定PCB范围并布局&lt;/h2&gt;
&lt;p&gt;根据需要的形状和经验粗略地确定版图的位置边界，然后布局元件位置。&lt;/p&gt;
&lt;h2 id=&#34;布线&#34;&gt;布线&lt;/h2&gt;
&lt;p&gt;注意设置焊盘间的距离，jlc为7mil，以及过孔孔径。&lt;/p&gt;
&lt;p&gt;过孔打法：&lt;code&gt;Alt+Shift+鼠标滚轮向上&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;铺铜&#34;&gt;铺铜&lt;/h2&gt;
&lt;p&gt;使用铺铜管理器进行铺铜：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工具→铺铜→铺铜管理器（快捷键:TGM）&lt;/li&gt;
&lt;li&gt;选择来自&amp;hellip;..的新多边形（New Polygon from &amp;hellip;）→板外形（Board Outline）&lt;/li&gt;
&lt;li&gt;设置网络，哪一层？除去死铜&lt;/li&gt;
&lt;li&gt;最后点击应用，确定，这样顶层的铺地铜就铺好了！&lt;/li&gt;
&lt;li&gt;其他层同样按照上面的步骤进行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;设置板子边界&#34;&gt;设置板子边界&lt;/h2&gt;
&lt;p&gt;首先选中Keep-Out-Layer所定义的边界&lt;/p&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;p&gt;【Design】|【Board shape】|【Define from selected objects】&lt;/p&gt;
&lt;p&gt;快捷键为D+S+D+enter&lt;/p&gt;
&lt;h2 id=&#34;其他一些快捷键&#34;&gt;其他：一些快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+D&lt;/code&gt;: View Configuration，用来配置PCB的显示内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+M&lt;/code&gt;：测量长度，使用&lt;code&gt;shift+C&lt;/code&gt;删除测量得到的线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;批量修改元件&#34;&gt;批量修改元件&lt;/h2&gt;
&lt;p&gt;以命名所有电阻为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先使用过滤器选中所有电阻&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行&lt;strong&gt;工具——Annotation——注解&lt;/strong&gt;（英文为&lt;strong&gt;Tools——Annotation——Annotate Schematic&lt;/strong&gt;，或者快捷键&lt;strong&gt;T A A&lt;/strong&gt;）命令打开原理图元件命名管理器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3d渲染图实现&#34;&gt;3D渲染图实现&lt;/h2&gt;
- https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH07 类</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/</link>
        <pubDate>Tue, 27 Apr 2021 10:08:56 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/ -&lt;p&gt;以一个例子来说明类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;strut Sales_data {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#888&#34;&gt;//构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	Sales_data() &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;default&lt;/span&gt;;
	Sales_data(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s) &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; bookNo(s) {}
	Sales_data(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; n, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; p)&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		bookNo(s), units_sold(n), revenue(p&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;n) {}
	Sales_data(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istream &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;);
	&lt;span style=&#34;color:#888&#34;&gt;//成员函数：
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string isbn()	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; {&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; bookNo; }
	Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt; combine(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; avg_price() &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
	std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string bookNo;
	&lt;span style=&#34;color:#888&#34;&gt;//类内初始值(数据成员)
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; units_sold &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; revenue &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0.0&lt;/span&gt;;
};
&lt;span style=&#34;color:#888&#34;&gt;//在类的外部定义成员函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; Sales_data&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;avg_price() &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (units_sold)
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; revenue &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; units_sold;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#888&#34;&gt;//在类的外部定义构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Sales_data&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;Sales_data(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istream &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;is)
{
    read(is, &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//从is中读取一条信息然后存入this对象中
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;成员函数&#34;&gt;成员函数&lt;/h2&gt;
&lt;p&gt;成员函数的&lt;strong&gt;声明&lt;/strong&gt;必须在&lt;strong&gt;类的内部&lt;/strong&gt;，它的&lt;strong&gt;定义&lt;/strong&gt;既可以在类的内部也可以在类的外部。作为接口的非成员函数，它的定义和声明都在类的外部。&lt;/p&gt;
&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;构造函数的任务时初始化类对象的数据成员，无论何时只要类被创建就会执行构造函数。&lt;/p&gt;
&lt;p&gt;构造函数的名字和&lt;strong&gt;类名&lt;/strong&gt;相同，和其他函数不同，构造函数&lt;strong&gt;没有返回类型&lt;/strong&gt;；除此之外的特性类似于其他函数。&lt;/p&gt;
&lt;p&gt;类可以包含多个构造函数，和其他的&lt;strong&gt;重载函数&lt;/strong&gt;差不多，不同构造函数之间必须在参数数量或参数类型上有所区别。&lt;/p&gt;
&lt;p&gt;构造函数不能被声明成&lt;strong&gt;const&lt;/strong&gt;的。当我们创建类的一个const对象，直到构造函数完成初始化的过程，对象才能真正获得其常量属性。&lt;/p&gt;
&lt;p&gt;在类的外部定义构造函数：如上代码所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数初始值列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就对象的数据成员而言，初始化和赋值也有区别。如果没有在构造函数的初始值列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化。&lt;/p&gt;
&lt;p&gt;如果成员是&lt;strong&gt;const&lt;/strong&gt;或&lt;strong&gt;引用&lt;/strong&gt;的话，必须将其初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;ConstRef&lt;/span&gt; {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	ConstRef(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; ii);
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; ci;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;ri;
};
ConstRef&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;ConstRef(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; ii)&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; i(ii), ci(ii), ri(i) {}	&lt;span style=&#34;color:#888&#34;&gt;//显示地初始化引用和const成员
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最好避免使用某些成员初始化其他成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;委托构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个委托构造函数可以使用它属类的其他构造函数执行它自己的初始化过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Sales_data&lt;/span&gt; {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#888&#34;&gt;//非委托构造函数使用对应的实参初始化成员
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	Sales_data(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string s, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; cnt, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; price)&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		bookNo(s), units_sold(cnt), revenue(cnt&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;price);
	&lt;span style=&#34;color:#888&#34;&gt;//其余构造函数委托给另一个构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	Sales_data()&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Sales_data(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {}	&lt;span style=&#34;color:#888&#34;&gt;//默认构造函数，委托给了上面输入3个变量的构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	Sales_data(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string s)&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Sales_data(s, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {}
	Sales_Data(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istrean &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;is)&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Sales_data() {read(is, &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;); }	&lt;span style=&#34;color:#888&#34;&gt;//委托给了默认构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;聚合类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聚合类使得用户可以直接访问其成员并且具有特殊的初始化语法形式。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有成员都是public的。&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数。&lt;/li&gt;
&lt;li&gt;没有类内初始值。&lt;/li&gt;
&lt;li&gt;没有基类，没有virtual函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct Data {
	int ival;
	string s;
};
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;访问控制与封装&#34;&gt;访问控制与封装&lt;/h2&gt;
&lt;p&gt;使用**访问说明符(access specifiers)**加强类的封装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;说明符：定义在其之后的成员在整个程序内可被访问，public成员定义类的接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;说明符：定义在其后的成员可以被类的成员函数访问，但不能被使用该类的代码访问，该种封装隐藏了类的实现细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;struct&lt;/strong&gt;和&lt;strong&gt;class&lt;/strong&gt;关键词的区别：&lt;/p&gt;
&lt;p&gt;我们可以用两个关键词中的任意一个定义类，唯一的区别是两者的&lt;strong&gt;默认访问权限&lt;/strong&gt;不太一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;struct&lt;/code&gt;：定义在第一个访问说明符之前的成员是public的。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;class&lt;/code&gt;：定义在第一个访问说明符之前的成员是private的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;友元&#34;&gt;友元&lt;/h2&gt;
&lt;p&gt;类可以允许其他类或函数访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;，方法是令其他类或函数称为它的友元；如果类想把&lt;strong&gt;一个函数&lt;/strong&gt;作为它的友元，只要增加一条以&lt;code&gt;friend&lt;/code&gt;关键词开头的&lt;strong&gt;函数声明语句&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;友元声明只能出现在&lt;strong&gt;类定义的内部&lt;/strong&gt;，但在类内出现的具体位置不限。&lt;/p&gt;
&lt;p&gt;友元的声明仅仅指定了&lt;strong&gt;访问权限&lt;/strong&gt;，并非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，就必须&lt;strong&gt;在友元声明之外再专门对函数进行一次声明&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;类的作用域&#34;&gt;类的作用域&lt;/h2&gt;
&lt;p&gt;在类的作用域之外，普通的数据和函数成员只能由&lt;strong&gt;对象、引用或指针&lt;/strong&gt;使用**成员访问运算符(&lt;code&gt;. -&amp;gt;&lt;/code&gt;)&lt;strong&gt;来访问；对于类类型成员，则使用&lt;/strong&gt;作用域运算符(&lt;code&gt;::&lt;/code&gt;)**访问。&lt;/p&gt;
&lt;p&gt;一个类就是一个作用域，所以在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; Window_mgr&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;clear(ScreenIndex i)
{
	Screen &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; screens[i];
	s.contents &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; string(s.height &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; s.width, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;类的静态成员&#34;&gt;类的静态成员&lt;/h2&gt;
&lt;p&gt;有时候类需要它的一些成员&lt;strong&gt;与类本身直接相关&lt;/strong&gt;，而不是与类的各个对象保持关联。这是我们可以通过声明静态成员，即在成员的声明前加上关键字&lt;strong&gt;static&lt;/strong&gt;，使得其与类关联在一起。&lt;/p&gt;
&lt;p&gt;静态成员可以是public或private的。&lt;/p&gt;
&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。同样，&lt;strong&gt;类静态成员函数&lt;/strong&gt;也不与任何对象绑定在一起，它们不包含this指针。静态成员函数不能声明成const的，也不能在static函数体内使用this指针。&lt;/p&gt;
&lt;p&gt;使用类的静态成员：&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;作用域运算符&lt;/strong&gt;直接访问静态成员：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; r;
r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Account&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;rate();	&lt;span style=&#34;color:#888&#34;&gt;//Account为类名
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p&gt;
&lt;p&gt;定义静态成员：&lt;/p&gt;
&lt;p&gt;我们既可以在类内部也可以在类外部&lt;strong&gt;定义静态成员函数&lt;/strong&gt;，在类外部定义时不能重复static关键词，该词只出现在类内部的声明中。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 