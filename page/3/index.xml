<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>http://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Mon, 12 Jul 2021 21:26:27 +0800</lastBuildDate>
    
        <atom:link href="http://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>信号与系统学习笔记——Chapter01 信号与系统</title>
        <link>http://eternityqjl.top/posts/signalsystem-ch01/</link>
        <pubDate>Sat, 14 Mar 2020 13:59:44 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/signalsystem-ch01/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/signalsystem-ch01/ -&lt;h2 id=&#34;13-指数信号与正弦信号&#34;&gt;1.3 指数信号与正弦信号&lt;/h2&gt;
&lt;h3 id=&#34;131-连续时间复指数信号与正弦信号&#34;&gt;1.3.1 连续时间复指数信号与正弦信号&lt;/h3&gt;
&lt;p&gt;连续时间复指数信号有如下形式：
$$
x(t)=Ce^{at}
$$&lt;/p&gt;
&lt;h4 id=&#34;实指数信号&#34;&gt;实指数信号&lt;/h4&gt;
&lt;p&gt;上式中的$C$和$a$都为实数的信号。&lt;/p&gt;
&lt;h4 id=&#34;周期复指数信号和正弦信号&#34;&gt;周期复指数信号和正弦信号&lt;/h4&gt;
&lt;p&gt;第二种重要的信号为将上式$a$限制为纯虚数的信号（&lt;strong&gt;复指数信号&lt;/strong&gt;）：
$$
x(t)=e^{jw_0t}
$$
当基波周期$T_0 = \left| \frac {2\pi} {w_0} \right|$时，该信号是周期信号。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;与该信号相关的另一种信号是&lt;strong&gt;正弦信号&lt;/strong&gt;：
$$
x(t)=A\cos(w_0t+\phi)
$$
利用&lt;strong&gt;欧拉公式&lt;/strong&gt;，可以将复指数信号用与其相同几波周期的正弦信号来表示：
$$
e^{jw_0t}=\cos w_0t + j\sin w_0t
$$
$w_0$称为基波频率。&lt;/p&gt;
&lt;p&gt;上述复指数信号和正弦信号都是&lt;strong&gt;具有无限能量&lt;/strong&gt;但&lt;strong&gt;有有限平均功率&lt;/strong&gt;的信号。&lt;/p&gt;
&lt;p&gt;计算证明：
$$
E_{period}=\int_{o}^{T_0} \left| e^{jw_0t} \right|^2 \mathrm{d}t = \int_{o}^{T_0} 1 \cdot \mathrm{d}t = T_0  \&lt;br&gt;
P_{period}= \frac {1}{T_0} E_{period}=1
$$&lt;/p&gt;
&lt;h4 id=&#34;一般复指数信号&#34;&gt;一般复指数信号&lt;/h4&gt;
&lt;p&gt;一复指数信号$Ce^{at}$，将复数$C$和$a$分别用指数式（极坐标）和代数式（笛卡尔坐标）表示：
$$
C = \left| C \right| e^{j \theta} \&lt;br&gt;
a = r + j\omega_0
$$
代入得：
$$
\begin{align}
Ce^{at} 
&amp;amp; = \left| C \right| e^{j\theta} e^{(r+jw_0)t}  \&lt;br&gt;
&amp;amp; = \left| C \right| e^{rt} e^{j(w_0t+\theta)}  \&lt;br&gt;
&amp;amp; = \left| C \right| e^{rt} \cos(w_0t+\theta) + j\left| C \right| e^{rt} \sin(w_0t+\theta)
\end{align}
$$
若$r=0$，则复指数信号的实部和虚部都是&lt;strong&gt;正弦&lt;/strong&gt;；若$r&amp;gt;0$，则实部和虚部是一个&lt;strong&gt;呈指数增长&lt;/strong&gt;的正弦信号；若$r&amp;lt;0$，则二者都是一个&lt;strong&gt;呈指数衰减&lt;/strong&gt;的正弦信号，该信号被称为阻尼正弦震荡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/increasingSineSignal.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;132-离散时间复指数信号与正弦信号&#34;&gt;1.3.2 离散时间复指数信号与正弦信号&lt;/h3&gt;
&lt;p&gt;一种重要的离散时间信号是&lt;strong&gt;复指数信号&lt;/strong&gt;或&lt;strong&gt;序列&lt;/strong&gt;，定义为：
$$
x[n]=C\alpha ^n
$$
其中的$C$和$\alpha$一般为复数，若另$\alpha = e^{\beta}$，则有另外一种表达方式：
$$
x[n]=C e^{\beta n}
$$
从形式上看第二个式子与前面的连续时间复指数信号更相似，但在离散时间的情况下，第一种更为方便使用。&lt;/p&gt;
&lt;h4 id=&#34;实指数信号-1&#34;&gt;实指数信号&lt;/h4&gt;
&lt;p&gt;$C$和$\alpha$都为实数，有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若$\left| \alpha \right| &amp;gt; 1$，信号随n指数增长，若$\left| \alpha \right| &amp;lt; 1$，信号随n指数衰减。&lt;/li&gt;
&lt;li&gt;$\left| \alpha \right|$为正值时，信号的所有值都为整数，$\left| \alpha \right|$为负值时，信号的符号在正负之间交替变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;正弦信号&#34;&gt;正弦信号&lt;/h4&gt;
&lt;h4 id=&#34;一般复指数信号-1&#34;&gt;一般复指数信号&lt;/h4&gt;
&lt;h3 id=&#34;133-离散时间复指数序列的周期性质&#34;&gt;1.3.3 离散时间复指数序列的周期性质&lt;/h3&gt;
&lt;p&gt;这里讨论的关于离散时间复指数序列的性质都是相对于连续时间信号的不同之处。&lt;/p&gt;
&lt;h4 id=&#34;频率性质&#34;&gt;频率性质&lt;/h4&gt;
&lt;p&gt;对于频率为$w_0+2\pi$的离散时间复指数信号：
$$
e^{j(w_0+2\pi)n} = e^{j2\pi n}+e^{jw_0 n} = e^{jw_0 n}
$$
上式表明，频率为$w_0+2\pi$的离散时间复指数信号与频率为$w_0$的信号完全相同。所以离散时间复指数信号的频率只需要在一个$2\pi$间隔内选择，一般在$0\leqslant w_0 \leqslant 2\pi$或$-\pi \leqslant w_0 \leqslant \pi$中选择。&lt;/p&gt;
&lt;p&gt;离散时间复指数信号的低频部分（变化慢的地方）位于$w_0$在0，$2\pi$及其他$\pi$的偶数倍值附近；高频部分位于$w_0$在$\pm \pi$及其他$\pi$的奇数倍附近。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/discreteTimeSignal.JPG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;周期性质&#34;&gt;周期性质&lt;/h4&gt;
&lt;p&gt;为了使得信号$e^{jw_0n}$是周期的，必须有：
$$
e^{jw_0(n+N)} = e^{jw_0n}
$$
这等效于：
$$
e^{jw_0N} = 1 \Leftrightarrow w_0N = 2\pi m \Leftrightarrow \frac{w_0}{2\pi} = \frac{m}{N}
$$
$m$为整数。同时，若$\frac{w_0}{2\pi}$是一个有理数，该信号就是周期的，否则就不是周期的。上式如果$N$和$m$没有公因子，那么$N$九尾基波周期。&lt;/p&gt;
&lt;h4 id=&#34;连续时间和离散时间信号的比较&#34;&gt;连续时间和离散时间信号的比较&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/compare_discrete%26continus.JPG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;14-单位冲激与单位阶跃函数&#34;&gt;1.4 单位冲激与单位阶跃函数&lt;/h2&gt;
&lt;h3 id=&#34;141-离散时间单位脉冲和单位阶跃序列&#34;&gt;1.4.1 离散时间单位脉冲和单位阶跃序列&lt;/h3&gt;
&lt;p&gt;最简单的离散时间信号之一就是&lt;strong&gt;单位脉冲&lt;/strong&gt;（或&lt;strong&gt;单位样本&lt;/strong&gt;），定义为：
$$
\delta[n] = 
\begin{cases}
0, \quad n \ne 0  \&lt;br&gt;
1, \quad n = 0
\end{cases}
$$
另一个基本离散时间信号为&lt;strong&gt;单位阶跃&lt;/strong&gt;，定义为：
$$
u[n] =
\begin{cases}
0, \quad n &amp;lt; 0  \&lt;br&gt;
1, \quad n \geqslant 0
\end{cases}
$$
以上两个离散时间信号存在着密切的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单位脉冲是单位阶跃的&lt;strong&gt;一次差分&lt;/strong&gt;，即$\delta[n] = u[n] - u[n-1]$&lt;/li&gt;
&lt;li&gt;离散时间阶跃是单位样本的&lt;strong&gt;求和函数&lt;/strong&gt;：$u[n] = \sum_{m = - \infty}^{n} \delta[m]$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;142-连续时间单位阶跃和单位冲激函数&#34;&gt;1.4.2 连续时间单位阶跃和单位冲激函数&lt;/h3&gt;
&lt;p&gt;连续时间&lt;strong&gt;单位阶跃函数&lt;/strong&gt;定义为：
$$
u(t)=
\begin{cases}
0, \quad t&amp;lt;0 \&lt;br&gt;
1, \quad t&amp;gt;0
\end{cases}
$$
单位阶跃在$t=0$这一单处不连续。&lt;/p&gt;
&lt;p&gt;连续时间单位阶跃是连续时间单位冲激的&lt;strong&gt;积分函数&lt;/strong&gt;：
$$
u(t) = \int_{-\infty}^{t} \delta(\tau) \mathrm{d}\tau
$$
同时可以看出，连续时间单位冲激可以看成连续时间单位阶跃的**一次微分**：
$$
\delta(t) = \frac{\mathrm{d}u(t)}{\mathrm{d}t}
$$
严格来说$u(t)$是不可微的，可以把上式近似为一个在较短时间$\Delta$内完成&lt;/p&gt;
&lt;h2 id=&#34;15-连续时间和离散时间系统&#34;&gt;1.5 连续时间和离散时间系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;连续时间系统：$x(t) \rightarrow y(t)$&lt;/li&gt;
&lt;li&gt;离散时间系统：$x[n] \rightarrow y[n]$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们的任务是要鉴别一类系统，透彻地了解一类系统的行为，在很多的实践中重要的系统都通过这一类系统来建模。本书重点关注的线性时不变系统这一特殊类别的系统就属于上述分类特性的一类。&lt;/p&gt;
&lt;h3 id=&#34;151-系统的互联&#34;&gt;1.5.1 系统的互联&lt;/h3&gt;
&lt;h4 id=&#34;串联级联&#34;&gt;串联（级联）&lt;/h4&gt;
&lt;p&gt;eg：音频系统：无线电接收机$\rightarrow$唱片播放器$\rightarrow$扬声器&lt;/p&gt;
&lt;h4 id=&#34;并联&#34;&gt;并联&lt;/h4&gt;
&lt;h4 id=&#34;反馈互联&#34;&gt;反馈互联&lt;/h4&gt;
&lt;p&gt;eg：数字控制的一架飞机&lt;/p&gt;
&lt;h3 id=&#34;152-基本系统性质&#34;&gt;1.5.2 基本系统性质&lt;/h3&gt;
&lt;h4 id=&#34;记忆系统和无记忆系统&#34;&gt;记忆系统和无记忆系统&lt;/h4&gt;
&lt;p&gt;如果对自变量的每一个值，一个系统的输出仅仅取决于&lt;strong&gt;该时刻的输入&lt;/strong&gt;，这个系统就称为&lt;strong&gt;无记忆&lt;/strong&gt;系统。例如，如下的表达式：
$$
y[n]=(2x[n]-x^2[n])^2
$$
是一个无记忆系统，任何特定时刻$n_0$的输出$y[n]$只取决于该时刻的输入$x[n]$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;恒等系统&lt;/strong&gt;（即输出等于输入）是一种最简单的无记忆系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散时间记忆系统&lt;/strong&gt;的一个例子就是&lt;strong&gt;累加器&lt;/strong&gt;：
$$
y[n]=\sum_{k=-\infty}^{n} x[k]
$$
第二个离散时间记忆系统的例子是一个**延迟单元**：
$$
y[n] = x[n - 1]
$$
一个**连续时间记忆系统**的例子是**一个电容器**，将电流作为输入，电压作为输出，那么有：
$$
y(t)= \frac{1}{C} \int_{-\infty}^{t} x(\tau) \mathrm{d} \tau
$$
其中的$C$为电容值。&lt;/p&gt;
&lt;p&gt;一个系统中记忆的概念相应于该系统具有&lt;strong&gt;保留或储存不是当前时刻输入信息的功能&lt;/strong&gt;，在许多实际系统中，记忆是直接与能量储存相关联的。&lt;/p&gt;
&lt;h4 id=&#34;可逆性与可逆系统&#34;&gt;可逆性与可逆系统&lt;/h4&gt;
&lt;p&gt;一个系统如果在不同输入下导致不同输出，就称该系统是&lt;strong&gt;可逆的&lt;/strong&gt;。一个系统可逆则一定有一个&lt;strong&gt;逆系统&lt;/strong&gt;存在，逆系统与原系统&lt;strong&gt;级联&lt;/strong&gt;后，会产生一个输出$w[n]$等于一个系统的输入$x[n]$。&lt;/p&gt;
&lt;p&gt;可逆连续时间系统的一个例子：
$$
y(t)=2x(t)
$$
该可逆系统的逆系统为：
$$
w(t)=\frac{1}{2}y(t)
$$
一个&lt;strong&gt;不可逆&lt;/strong&gt;系统的例子如下：
$$
y[n]=0
$$
该系统对任何输入序列产生的都是零输出序列。&lt;/p&gt;
&lt;p&gt;另外一个例子：
$$
y(t)=x^2(t)
$$
这种情况无法根据输出确定输入的正负。&lt;/p&gt;
&lt;h4 id=&#34;因果性&#34;&gt;因果性&lt;/h4&gt;
&lt;p&gt;如果一个系统&lt;strong&gt;在任何时刻的输出&lt;/strong&gt;只取决于&lt;strong&gt;现在的输入以及过去的输入&lt;/strong&gt;，该系统就称为&lt;strong&gt;因果系统&lt;/strong&gt;。这样的系统也被称为&lt;strong&gt;不可预测系统&lt;/strong&gt;，系统的输出值无法预测未来的输入值。&lt;/p&gt;
&lt;p&gt;所有的无记忆系统都是因果的，因为输出仅仅对当前输入值作出响应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;检验系统的因果性时要仔细看系统的输入——输出关系，举两个特殊例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$y[n]=x[-n]$，该系统当输入时间为负值是，输出就与输入的将来值有关，所以该系统不是因果系统。所以检验时要仔细检验在&lt;strong&gt;全部时间&lt;/strong&gt;上的输入——输出关系。&lt;/li&gt;
&lt;li&gt;$y(t)=x(t)\cos(t+1)$，检验因果性时要&lt;strong&gt;把输入信号的影响仔细地与系统定义中的其他函数的影响分开&lt;/strong&gt;，该系统的输出等于同一时刻的输入乘以一个随时间变化的数，所以可以写作$y(t)=x(t)g(t)$，是因果的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;稳定性&#34;&gt;稳定性&lt;/h4&gt;
&lt;p&gt;一个&lt;strong&gt;稳定系统&lt;/strong&gt;在小的输入下的响应不会&lt;strong&gt;发散&lt;/strong&gt;，这是稳定性的最直观理解。&lt;/p&gt;
&lt;h4 id=&#34;时不变性&#34;&gt;时不变性&lt;/h4&gt;
&lt;p&gt;系统的特性和行为不随时间而变，该系统就是时不变的。即如果在一个输入信号上有一个时移，在输出信号中产生同样的时移，那么这个系统就是时不变的。&lt;/p&gt;
&lt;p&gt;具体而言，若$y[n]$是离散时间时不变系统在输入为$x[n]$是的输出，当输入为$x[x-x_0]$时，输出为为$y[x-x_0]$，连续时间情况也是相同的道理。&lt;/p&gt;
&lt;h4 id=&#34;线性&#34;&gt;线性&lt;/h4&gt;
&lt;p&gt;如果某个输入信号是由几个信号的&lt;strong&gt;加权和&lt;/strong&gt;组成，那么输出也就是系统对这组信号中每一个响应的加权和。&lt;/p&gt;
&lt;p&gt;令$y_1(t)$是一个连续时间系统对输入$x_1(t)$的响应，$y_2(t)$是对输入$x_2(t)$的一个输出，那么一个线性系统就应该有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$y_1(t)+y_2(t)$是对$x_1(t)+x_2(t)$的响应&lt;/li&gt;
&lt;li&gt;$ay_1(t)$是对$ax_1(t)$的响应，$a$为任意常数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上两个性质称为&lt;strong&gt;可加性&lt;/strong&gt;和&lt;strong&gt;齐次性&lt;/strong&gt;。&lt;/p&gt;
- http://eternityqjl.top/posts/signalsystem-ch01/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>数字签名和数字证书</title>
        <link>http://eternityqjl.top/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</link>
        <pubDate>Fri, 06 Dec 2019 19:42:38 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/ -&lt;p&gt;理解本文的基础是公钥密码加密，即非对称加密，比如其中一种非对称加密算法RSA。&lt;/p&gt;
&lt;p&gt;非对称加密使用一对密钥，一个为公钥Pub，另一个为私钥Priv&lt;/p&gt;
&lt;p&gt;明文P经过公钥Pub使用RSA加密算法混淆后变成了密文M，密文M无法用公钥Pub解开，只能用私钥Priv解开&lt;/p&gt;
&lt;p&gt;同样的，明文P经过私钥Priv使用RSA加密算法混淆后变成了密文N，密文N只能用公钥Pub解开&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;1信息安全&#34;&gt;1.信息安全&lt;/h2&gt;
&lt;p&gt;在信息安全中共有3个需要解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保密性：保证信息在传输时不被泄露&lt;/li&gt;
&lt;li&gt;完整性：信息在传输时不被篡改&lt;/li&gt;
&lt;li&gt;有效性：信息的使用者是合法的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;公钥密码&lt;/strong&gt;能解决保密性的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字签名&lt;/strong&gt;能解决完整性和有效性的问题&lt;/p&gt;
&lt;h2 id=&#34;2数字签名digital-signature&#34;&gt;2.数字签名(Digital Signature)&lt;/h2&gt;
&lt;p&gt;真实世界中，签名是为了表示某些内容是签名者写的或者他所认可的。计算机中，数字签名也有着相似的含义，数字签名用来证实&lt;strong&gt;消息&lt;/strong&gt;是某个特定的人发送的，即有效性；同时还能证明消息没有被篡改，即完整性。这些是怎么实现的呢？这就是接下来要介绍有关于数字签名的内容。&lt;/p&gt;
&lt;p&gt;数字签名是公钥密码加密的逆向应用：&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;私钥&lt;/strong&gt;加密消息，用&lt;strong&gt;公钥&lt;/strong&gt;解密消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;签名&lt;/strong&gt;：用私钥加密的消息，只有拥有私钥的用户可以生成签名，这也确保了数字签名的发送者是该用户。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证签名&lt;/strong&gt;：即用公钥解密签名，因为公钥是公开的，所以任何人都可以验证签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-生成签名&#34;&gt;2.1 生成签名&lt;/h3&gt;
&lt;p&gt;一般不直接对消息进行签名，而是对消息进行哈希计算后的得到的哈希值进行签名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HASH算法是密码学的基础，其中最重要的两条性质是&lt;strong&gt;不可逆&lt;/strong&gt;和&lt;strong&gt;无冲突&lt;/strong&gt;，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可逆：当你知道x的HASH值时，无法求出x&lt;/li&gt;
&lt;li&gt;无冲突：你知道x，但无法求出一个y使得x与y的HASH值相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个性质&lt;strong&gt;在数学上都是不成立的&lt;/strong&gt;，理论上由无穷多不同的原始值，它们的HASH值都相同。但求逆和求冲突在计算上不可能实现，穷尽人类所有的计算资源都做不到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成签名的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对消息进行哈希计算，得到哈希值&lt;/li&gt;
&lt;li&gt;利用私钥对哈希值进行加密，生成签名&lt;/li&gt;
&lt;li&gt;将签名附在消息后，一起发送&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-验证签名&#34;&gt;2.2 验证签名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;收到签名后，提取消息中的签名&lt;/li&gt;
&lt;li&gt;用公钥对签名进行解密，得到哈希值1&lt;/li&gt;
&lt;li&gt;对消息中的正文进行哈希计算，得到哈希值2&lt;/li&gt;
&lt;li&gt;比较哈希值1和2，如果相同，则验证成功&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：前面提到，哈希值的计算不可逆，因此才能以这种方式验证签名。&lt;/p&gt;
&lt;h2 id=&#34;3数字证书digital-certificate&#34;&gt;3.数字证书(Digital Certificate)&lt;/h2&gt;
&lt;p&gt;数字证书是对&lt;strong&gt;公钥&lt;/strong&gt;进行数字签名，是为了对&lt;strong&gt;公钥的合法性&lt;/strong&gt;提供证明，如果公钥的合法性得不到证明，则就存在中间人攻击的风险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中间人攻击（&lt;strong&gt;M&lt;/strong&gt;an-&lt;strong&gt;i&lt;/strong&gt;n-&lt;strong&gt;t&lt;/strong&gt;he-&lt;strong&gt;m&lt;/strong&gt;iddle-attack）：&lt;/p&gt;
&lt;p&gt;攻击者与通讯的两端分别建立滴露的联系，并交换所受到的数据。即中间人通过截获两端通讯使用的公钥，并将双方的两个公钥都更改为自己的公钥来达到截获消息的目的。&lt;/p&gt;
&lt;p&gt;详情可以参考维基百科：&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&#34;&gt;中间人攻击&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们对于签名的验证需要使用公钥，而公钥的真实合法性就是通过数字证书来的。&lt;strong&gt;证书&lt;/strong&gt;中包含：&lt;strong&gt;公钥、公钥的数字签名、公钥拥有者的信息&lt;/strong&gt;。如果证书验证成功，则代表该公钥是合法的。&lt;/p&gt;
&lt;p&gt;但是，验证证书中的数字签名需要另一个公钥，该公钥的合法性又怎样保证呢？该问题可以无限地循环下去，那岂不是解决不了了？我们相信银行是一个可信的机构，可以放心地把钱存在里面，那么同样存在一个可信机构来颁发证书和提供公钥，我们相信这个机构提供的密钥是合法的。&lt;/p&gt;
&lt;p&gt;这种机构称为&lt;strong&gt;认证机构(Certification Authority, CA)&lt;/strong&gt;，CA认定“公钥确实属于某个私钥的拥有者”，并能生成公钥的数字签名的组织或机构。&lt;/p&gt;
&lt;h3 id=&#34;31-如何生成证书&#34;&gt;3.1 如何生成证书？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;证书即为公钥、公钥的数字签名、一些其他服务器信息的集合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;服务器将&lt;strong&gt;公钥A&lt;/strong&gt;交给CA&lt;/li&gt;
&lt;li&gt;CA通过哈希计算生成公钥A的哈希值，然后用自己的&lt;strong&gt;私钥B&lt;/strong&gt;给&lt;strong&gt;公钥A的哈希值&lt;/strong&gt;加密，生成&lt;strong&gt;数字签名A&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CA把公钥A、数字签名A、一些服务器信息整合，生成证书，发回给服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-如何验证证书&#34;&gt;3.2 如何验证证书？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端得到证书&lt;/li&gt;
&lt;li&gt;客户端通过CA得到证书的&lt;strong&gt;公钥B&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端用&lt;strong&gt;公钥B&lt;/strong&gt;对证书中的&lt;strong&gt;数字签名A&lt;/strong&gt;解密，得到哈希值&lt;/li&gt;
&lt;li&gt;客户端对&lt;strong&gt;公钥A&lt;/strong&gt;进行哈希值计算&lt;/li&gt;
&lt;li&gt;将两个哈希值对比，如果相同，则证书合法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;公钥B和上述私钥B是配对的，分别用于解密和加密证书。&lt;/p&gt;
&lt;h3 id=&#34;33-证书作废&#34;&gt;3.3 证书作废&lt;/h3&gt;
&lt;p&gt;用户的私钥丢失或者被盗时，认证机构需要对证书进行作废，制作一张证书作废清单(Certificate Revocation List, CRL)&lt;/p&gt;
&lt;p&gt;在验证证书是否有效的时候除了看合法的认证机构签名、是否在有效期内，还需要查询认证机构最新的CRL。&lt;/p&gt;
&lt;h2 id=&#34;4应用&#34;&gt;4.应用&lt;/h2&gt;
&lt;p&gt;HTTPS协议，详见之后有关SSL/TLS的博客。&lt;/p&gt;
&lt;h2 id=&#34;5参考&#34;&gt;5.参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/9db57e761255&#34;&gt;什么是数字签名和证书?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20820286&#34;&gt;什么是哈希算法？&lt;/a&gt;&lt;/p&gt;
- http://eternityqjl.top/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>写在2019年的最后一个月的开始</title>
        <link>http://eternityqjl.top/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/</link>
        <pubDate>Sun, 01 Dec 2019 22:06:08 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/ -&lt;p&gt;转眼间2019年就要结束了，依稀记得2019年的刚开始我还在发空间动态说自己又买了一本日历，然而&amp;hellip;明年就不买了吧，我并没有记得经常去看日历，更别说去每天一张一张地撕它。这一年里经历了非常多的事情，从学习、生活、关于未来的各方各面，我都发生了极大的改变，这源于我不断变化的想法，目标总是飘忽不定，我思考过，也经常迷茫，现在也是。&lt;/p&gt;
&lt;p&gt;在写下这些话的时间里，我其实是非常难过和害怕的，这一个周末似乎没干什么事情就又要浑浑噩噩地结束了，直到现在还有一个DDL等着我，明早截止，我还没做完，间歇性拖延症晚期这件事情，一直发生在我身上，毫不夸张地说，我可以不间歇地拖延整整24小时，这过程中总想着做些什么、改变些什么，但除了睡觉，大部分时间眼睛都盯在手机屏幕上，尽管我知道这样做一点儿也不好，但结果还是发生了。我知道学习的重要性，也会去为了一个想要实现的东西不断地思考并找到解决方法，就比如搭建网站这件事情，前前后后花了很多的时间也学习了很多相关知识，基本掌握了中间的原理，结果在我预想的时间之前很久就做出来了，结果还是超乎预期的好。说实话，完成一件能看的到结果的事情能给人的心理带来很大的快感的愉悦，但愉悦过后，又只剩下了迷茫和拖延，并且在为了找到下一个实践目标而苦苦挣扎着。有时候大脑盯着手机屏幕看一些信息的时候，知道这是自己不想接收和浪费时间的，但就是控制不住自己去点开看，这样的人性的弱点也造就了很多的商机，造就了很多企业和公司的成功。&lt;/p&gt;
&lt;p&gt;说点儿别的。在关于情感和人际交往方面，我可能是一个与绝大多数人都不一样的人，在情感上，我很少与他人或者是在公开场合表露（包括我的社交媒体，我发现，自己现在很少在社交媒体上表露自己的情感，更多的是分享一些自己的兴趣爱好，比如我热爱的摄影，因而，我也就把自己的空间对所有人开放了，微信这个东西另当别论，说实话，我挺讨厌这个软件的），但我还是知道自己想要的是什么，纵然我在过去的一年里总是带着一些自卑的情感，很久没有与他人进行深入内心的交谈，KY的与陌生人打电话活动也错过了很多次，每次都是在想和别人深入交流的时候才想起来，结果肯定是已经结束了，今后还是要多多关注，想想能与一同关注KY的人打电话是一件挺幸福的事情，也希望自己能早日找到灵魂伴侣。在人际交往方面，我尝试过学校的很多社团和活动，最终无一例外全都放弃了，我觉得也挺好，这也证明了我确实不喜欢过多的浮于表面和拉帮结派建造复杂人际关系的事情，做好自己就最好了，能认识几个朋友还是随缘了，人也并不需要那么多看上去像是朋友的朋友。&lt;/p&gt;
&lt;p&gt;扯了这么多，还是回到最重要的学习和事业上吧。12月希望自己能好好学习学校的课程知识，好好地应对一下考试。明年下半年就要大三了，这学期结束以后要为成为一个前端工程师立一些目标，毕竟就快要毕业了，还是希望自己能去做自己喜欢的工作，上研究生这件事就暂时不考虑了，我在经历了一些事情以后对于读研这件事一点儿也不感兴趣了，做好自己就好了。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
- http://eternityqjl.top/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络学习日志（一）——应用层</title>
        <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</link>
        <pubDate>Thu, 28 Nov 2019 19:23:38 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/ -&lt;p&gt;应用层是计算机网络从上往下的第一层，这一层的主要内容是网络应用的原理和实现，通过学习几种常见的网络应用程序，并且开发运行在TCP和UTP(运输层)上的网络应用程序，这些应用程序包含Web、电子邮件、DNS、P2P等等。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;应用层协议&#34;&gt;应用层协议&lt;/h2&gt;
&lt;p&gt;开发网络应用程序是要开发运行在不同端系统上并且通过网络(下层协议)彼此通信的程序，这过程中不需要为下层的网络核心设备写程序，因为它们不在应用层上起作用。&lt;/p&gt;
&lt;h3 id=&#34;网络应用程序体系结构&#34;&gt;网络应用程序体系结构&lt;/h3&gt;
&lt;h4 id=&#34;客户服务器体系结构&#34;&gt;客户——服务器体系结构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;客户：发送主机请求&lt;/li&gt;
&lt;li&gt;服务器：总是打开的主机，接收来自客户的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：Web应用程序&lt;/p&gt;
&lt;h4 id=&#34;p2p体系结构&#34;&gt;P2P体系结构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对于数据中心服务器几乎没有依赖。&lt;/li&gt;
&lt;li&gt;应用程序在对等方之间直接通信&lt;/li&gt;
&lt;li&gt;具有自扩展性，报文在主机之间直接发送，服务器用来追踪IP，有安全隐患。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：BitTorrent、Skype&lt;/p&gt;
&lt;h3 id=&#34;进程通信&#34;&gt;进程通信&lt;/h3&gt;
&lt;p&gt;端系统之间的通信实际上是&lt;strong&gt;进程&lt;/strong&gt;，进程通过跨越网络发送&lt;strong&gt;报文&lt;/strong&gt;来进行通信。进程是运行在端系统上的程序，同一个端系统和不同端系统之间的进程都可以进行通信，这里主要讨论不同端系统之间跨越网络的通信。&lt;/p&gt;
&lt;h4 id=&#34;客户与服务器之间的进程&#34;&gt;客户与服务器之间的进程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;客户-服务器体系中，比如Web服务器，一个进程被标识为客户(Client)，另一个进程被标识为服务器(Server)。&lt;/li&gt;
&lt;li&gt;P2P体系中，一个进程既可以是客户又可以是服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程与网络之间的接口套接字&#34;&gt;进程与网络之间的接口——套接字&lt;/h4&gt;
&lt;p&gt;套接字(端口号)是应用程序和运输层之间的接口，也成为应用程序编程接口。&lt;/p&gt;
&lt;h4 id=&#34;进程寻址&#34;&gt;进程寻址&lt;/h4&gt;
&lt;p&gt;为了向特定的目的地发送报文，需要有目的地主机的相关信息，这些信息为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP地址：用来标识目的地主机。&lt;/li&gt;
&lt;li&gt;端口号：用来指定接受进程(即接受套接字)，例如Web服务器用端口号80标识，邮件服务器进程用25标识。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;供应用程序使用的运输服务&#34;&gt;供应用程序使用的运输服务&lt;/h3&gt;
&lt;p&gt;开发应用程序时，需要选择一种适合的运输层协议，运输层协议能够提供的服务主要有以下：&lt;/p&gt;
&lt;h4 id=&#34;可靠数据传输&#34;&gt;可靠数据传输&lt;/h4&gt;
&lt;p&gt;进程与进程之间的可靠数据传输，有不提供可靠数据传输的应用层协议，使用这种应用层协议的应用被称为&lt;strong&gt;容忍丢失的应用&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;吞吐量&#34;&gt;吞吐量&lt;/h4&gt;
&lt;p&gt;发送进程向接收进程交付比特的速率，所以运输层协议可以提供以特定速率确保的可用吞吐量的服务，对此有需求的应用称为&lt;strong&gt;带宽敏感应用&lt;/strong&gt;，如一些多媒体语音和视频应用。&lt;/p&gt;
&lt;h4 id=&#34;定时延迟&#34;&gt;定时（延迟）&lt;/h4&gt;
&lt;p&gt;例子：发送方注入比特至套接字到接收方烧到比特的时间不多于100ms，这对于实时交互应用很重要，例如多方射击游戏。&lt;/p&gt;
&lt;h4 id=&#34;安全性&#34;&gt;安全性&lt;/h4&gt;
&lt;h3 id=&#34;因特网提供和未提供的运输服务&#34;&gt;因特网提供和未提供的运输服务&lt;/h3&gt;
&lt;p&gt;因特网为应用程序提供两个运输层协议，TCP和UDP，开发者必须做出选择。&lt;/p&gt;
&lt;h4 id=&#34;tcp服务&#34;&gt;TCP服务&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;面向连接服务：报文数据流动前，TCP让客户和服务器交换运输层控制信息(即握手)，之后一个&lt;em&gt;TCP连接&lt;/em&gt;就建立了，这条连接是&lt;em&gt;全双工&lt;/em&gt;的，应用程序运行结束后要拆除该连接。&lt;/li&gt;
&lt;li&gt;可靠数据传输服务：无差错、按顺序交付报文。&lt;/li&gt;
&lt;li&gt;拥塞控制机制&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;安全套接字层(Secure Sockets Layer, SSL)，是加强版的TCP协议，提供了进程之间的安全加密服务，这种强化是在应用层上实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;udp服务&#34;&gt;UDP服务&lt;/h4&gt;
&lt;p&gt;是一种轻量运输协议，进程通信时无握手过程，不保证到达，同时无拥塞控制机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注，这里只是简要的内容，更多详细内容将在第三章运输层中提到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&#34;未提供的服务&#34;&gt;未提供的服务&lt;/h4&gt;
&lt;p&gt;以上两个协议提供了可靠数据传输、安全性相关的服务，但并未提供2.3中所述的&lt;em&gt;吞吐量和定时&lt;/em&gt;的服务，所以因特网并不提供这两项服务。虽然未提供具体的服务，但因特网已经运行很多年，对于时间敏感的应用已经被设计得尽可能应对这种保证的缺乏。&lt;/p&gt;
&lt;h3 id=&#34;应用层协议总结&#34;&gt;应用层协议总结&lt;/h3&gt;
&lt;p&gt;应用层协议定义了以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换的报文类型，如请求和响应报文&lt;/li&gt;
&lt;li&gt;报文语法&lt;/li&gt;
&lt;li&gt;字段语义&lt;/li&gt;
&lt;li&gt;确定进程何时发送报文&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web和http&#34;&gt;Web和HTTP&lt;/h2&gt;
&lt;h3 id=&#34;http概况&#34;&gt;HTTP概况&lt;/h3&gt;
&lt;p&gt;**超文本传输协议（HyperText Transfer Protocol，HTTP）**是Web的应用层协议，它由客户程序和服务器程序实现，客户和服务器运行在不同端系统中，通过HTTP报文进行会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web页面&lt;/strong&gt;是由对象组成的，一个对象只是一个文件，如一个HTML文件、一张JEPG图片、一段视频，它们可以由URL寻址(URL地址由两部分组成，主机名和路径)。多数Web页面由&lt;strong&gt;一个HTML基本文件&lt;/strong&gt;和&lt;strong&gt;一些对象&lt;/strong&gt;组成。&lt;/p&gt;
&lt;p&gt;HTTP使用&lt;strong&gt;TCP&lt;/strong&gt;作为支撑运输协议，客户首先发起一个与服务器的TCP连接，建立连接后浏览器和服务器就可以通过套接字进行交互。&lt;/p&gt;
&lt;p&gt;HTTP是一个&lt;strong&gt;无状态协议&lt;/strong&gt;，服务器不会储存客户的状态信息，无论用户进行多少次的重复请求，服务器都会做出反应。&lt;/p&gt;
&lt;h3 id=&#34;非持续性连接和持续性连接&#34;&gt;非持续性连接和持续性连接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;非持续性连接&lt;/em&gt;：客户服务器之间的请求和响应都是经一个单独的TCP连接发送。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;持续性连接&lt;/em&gt;：二者之间的请求和响应经过相同的TCP连接发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;采取非持续性连接的http&#34;&gt;采取非持续性连接的HTTP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;往返时间&lt;/em&gt;（Round-Trip Time，RTT）：该时间指一个短分组从客户到服务器再返回服务器所花的时间。&lt;/li&gt;
&lt;li&gt;必须为每一个请求的对象建立一个&lt;em&gt;全新的TCP连接&lt;/em&gt;，每个连接都需要在客户和服务器中分为TCP缓冲区和保持TCP变量，这会给服务器带来巨大负担；并且每个对象要经历&lt;em&gt;两倍RTT交付时延&lt;/em&gt;，一个RTT用于创建TCP连接，另一个RTT用于请求和接受一个对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;采取持续性连接的http&#34;&gt;采取持续性连接的HTTP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 1.1 连接下，服务器发送响应后保持该TCP连接打开，相同客户和服务器之间，后续的请求和响应报文能够通过相同的连接传送。如果一条连接经过一段时间间隔未使用，则HTTP服务器就会关闭它。&lt;/li&gt;
&lt;li&gt;HTTP/2 允许相同连接中的多个请求和回答相互交错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http报文格式&#34;&gt;HTTP报文格式&lt;/h3&gt;
&lt;h4 id=&#34;请求报文&#34;&gt;请求报文&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;GET&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;/somedir/page.html&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.1&lt;/span&gt;
Host&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; www.someschool.edu	#指明了对象所在主机
Connection&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; close	#让服务器在发送完被请求对象后就关闭这条连接
User-agent&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Mozilla/5.0		#浏览器类型
Accept-language&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; fr		#语言
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一行为&lt;em&gt;请求行&lt;/em&gt;，共有三个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法字段：可取：GET、POST、HEAD、PUT、DELETE，绝大部分请求使用GET。&lt;/li&gt;
&lt;li&gt;URL字段：带有请求对象的标识&lt;/li&gt;
&lt;li&gt;HTTP版本字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一行后的后继行都叫&lt;em&gt;首部行&lt;/em&gt;，具体意义见程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg&#34; alt=&#34;请求报文&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首部行后有一个实体体(entity body)，使用&lt;strong&gt;GET&lt;/strong&gt;请求时实体体为空，而当使用&lt;strong&gt;POST&lt;/strong&gt;方法时才使用该实实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户&lt;strong&gt;提交表单&lt;/strong&gt;时，HTTP客户常常使用POST方法，例如用户向搜索引擎提供搜索关键字时。&lt;/li&gt;
&lt;li&gt;使用POST报文时仍然可以请求Web页面，但Web内容依赖于用户在表单中字段中输入的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;用表单生成的请求报文不是必须使用POST方法，相反也经常使用GET方法，并在所请求的URL中包括输入的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;HEAD方法&lt;/em&gt;类似于GET方法，服务器收到一个HEAD方法的请求时，会用一个HTTP报文进行响应但并不会返回请求的对象，该方法常用在&lt;em&gt;调试跟踪&lt;/em&gt;中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT方法被那些需要向Web服务器上传对象的应用程序使用，DELETE方法允许应用程序删除服务器上的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;响应报文&#34;&gt;响应报文&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#f00;font-weight:bold&#34;&gt;OK&lt;/span&gt;
Connection&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; close	#发送完报文后关闭该TCP连接
Date&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Tue, 18 Aug 2015 15:44:04 GMT		#指示服务器产生并发送该响应报文的日期和时间
Server&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Apache/2.2.3 (CentOS)	#服务器类型及系统，对应于请求报文中的User-agent字段
Last-Modified&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Tue, 18 Aug 2015 15:11:03 GMT	#对象创建或最后修改的日期和时间
Content-Length&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; 6821	#被发送对象的字节数
Content-Type&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; text/html		#对象类型

(data data data ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;一个初始&lt;strong&gt;状态行&lt;/strong&gt;(第一行)：三个字段，协议版本字段、&lt;strong&gt;状态码&lt;/strong&gt;和相应状态信息&lt;/li&gt;
&lt;li&gt;6个&lt;strong&gt;首部行&lt;/strong&gt;(2至7行)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实体体&lt;/strong&gt;：报文的部分，即包含了所请求的对象本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg&#34; alt=&#34;响应报文&#34;&gt;&lt;/p&gt;
&lt;p&gt;状态码和它们对应的短语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK：请求成功&lt;/li&gt;
&lt;li&gt;301 Moved Permanently：请求的对象被永久转移了，新URL定义在响应报文中的&lt;code&gt;Location：&lt;/code&gt;首部行中，客户软件会自动获取新URL&lt;/li&gt;
&lt;li&gt;400 Bad Request：通用差错代码，指请求不能被服务器理解&lt;/li&gt;
&lt;li&gt;404 Not Found：被请求文档不在服务器中&lt;/li&gt;
&lt;li&gt;505 HTTP Version Not Supported：服务器不支持请求报文只用的HTTP协议版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cookie&#34;&gt;cookie&lt;/h3&gt;
&lt;p&gt;HTTP服务器是无状态的，但一个Web站点希望能够识别用户身份，所以HTTP使用cookie允许站点对用户进行追踪。&lt;/p&gt;
&lt;h4 id=&#34;cookie技术组件&#34;&gt;cookie技术组件：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HTTP响应报文中的一个cookie首部行&lt;/li&gt;
&lt;li&gt;HTTP请求报文中的一个cookie首部行&lt;/li&gt;
&lt;li&gt;用户端系统中有一个cookie文件，由用户浏览器进行管理&lt;/li&gt;
&lt;li&gt;位于Web站点的一个后端数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一般工作流程&#34;&gt;一般工作流程：&lt;/h4&gt;
&lt;p&gt;第一次访问某个Web服务器时，服务器会为用户创建一个ID，这个ID会通过响应报文中的一个首部行传给端系统，记录在cookie文件中，同时这个ID被记录在服务器的后端数据库中；当再次访问这个网站时，浏览器会查询cookie文件并抽取对于该网站的识别码，并放到HTTP请求报文的cookie首部中，此时服务器可以跟踪该用户在站点的活动，显示一些内容，比如浏览购物网站会提供上次加入购物车的内容。&lt;/p&gt;
&lt;h3 id=&#34;web缓存代理服务器proxy-server&#34;&gt;Web缓存（代理服务器，proxy server）&lt;/h3&gt;
&lt;p&gt;代理服务器是能代表初始Web服务器来满足HTTP请求的网络实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署Web缓存器的原因&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能大大减少对客户请求的响应时间&lt;/li&gt;
&lt;li&gt;减低因特网上的Web流量，改善应用性能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;条件get方法&#34;&gt;条件GET方法&lt;/h3&gt;
&lt;p&gt;虽然高速缓存能减少响应时间，但也有一个问题，存放在缓存器中的对象副本可能是陈旧的，而HTTP有一种机制，允许缓存器证实它的对象是最新的，及条件GET方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件GET&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求报文使用GET方法&lt;/li&gt;
&lt;li&gt;请求报文中包含一个&lt;code&gt;If-Modified-Since:&lt;/code&gt;首部行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代理服务器代表请求浏览器向Web服务器发送一个请求报文，Web服务器向缓存器发送具有请求对象的响应报文，缓存器将对象转发到浏览器的同时也在本地缓存了该对象，重要的是也同时储存占了最后修改日期；一段时间后，另一个用户通过该缓存器请求同一个对象，该对象可以能已经被修改了，所以缓存器发送一个条件GET执行最新检查，该条件GET包含&lt;code&gt;If-Modified-Since:&lt;/code&gt;首部行，该报文告诉服务器，只有当自指定日期后该对象被修改过，才发送该对象。&lt;/p&gt;
&lt;h2 id=&#34;dns因特网目录服务&#34;&gt;DNS:因特网目录服务&lt;/h2&gt;
&lt;p&gt;主机可以使用主机名(hostname)或是IP地址来进行标识，显然主机名更容易被人们记住，但路由器更喜欢定长的、有层次地IP地址，所以需要一个能进行主机名到IP地址的转换目录服务。这即是&lt;strong&gt;域名系统(Domain Name System, DNS)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;dns提供的服务&#34;&gt;DNS提供的服务&lt;/h3&gt;
&lt;h4 id=&#34;dns组成&#34;&gt;DNS组成&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;由分层的DNS服务器实现的分布式数据库&lt;/li&gt;
&lt;li&gt;使主机能查询分布式数据库的应用层协议，DNS服务器通常是运行BIND软件的UNIX机器&lt;/li&gt;
&lt;li&gt;DNS协议运行在UDP上，使用53号端口&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;请求一个url时具体发生的内容主机名到ip地址的转换&#34;&gt;请求一个URL时具体发生的内容(主机名到IP地址的转换)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同一台主机上运行着DNS应用的客户端&lt;/li&gt;
&lt;li&gt;浏览器从一条URL中抽取出主机名，将主机名传给DNS应用的客户端&lt;/li&gt;
&lt;li&gt;DNS客户端向服务器发出包含主机名的请求&lt;/li&gt;
&lt;li&gt;DNSA客户收到回答报文，其中包含对应主机名的IP&lt;/li&gt;
&lt;li&gt;浏览器收到来自DNS的IP地址，向位于该IP地址80端口的HTTP服务器发起一个TCP连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dns提供的其他服务&#34;&gt;DNS提供的其他服务&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主机别名：主机名可以拥有一个或多个别名，最初的主机名称为&lt;em&gt;规范主机名&lt;/em&gt;，浏览器可以通过调用DNS来获得一个主机别名对应的规范主机名以及主机IP地址&lt;/li&gt;
&lt;li&gt;负载分配：
&lt;ul&gt;
&lt;li&gt;一个繁忙的站点会被冗余在多台服务器上，每台服务器都有着不同的IP地址；所以由于这些冗余服务器的存在，一个IP地址集合于同一个规范主机名相联系&lt;/li&gt;
&lt;li&gt;当用户对映射到某地址集合的主机名发出DNS请求时，该DNS服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址的次序；客户总是向IP地址排在最前面的服务器发送HTTP请求，所有DNS就在松油冗余的Web服务器之间循环分配了负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dns工作机理&#34;&gt;DNS工作机理&lt;/h3&gt;
&lt;p&gt;DNS由分布于全球的大量DNS服务器以及定义了DNS服务器于查询主机之间通信方式的应用层协议组成。集中式DNS设计(全球公用一台DNS服务器)的问题：单点故障、通信容量、远距离延时、维护。&lt;/p&gt;
&lt;h4 id=&#34;分布式层次数据库&#34;&gt;分布式、层次数据库&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg&#34; alt=&#34;DNS服务器&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图，有三个类型的服务器：根DNS服务器、顶级域DNS服务器、权威DNS服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根DNS服务器：由400多个根名字服务器，由不同组织管理，提供顶级域服务器的IP地址。&lt;/li&gt;
&lt;li&gt;顶级域(Top-Level Domain, TLD)DNS服务器：每个顶级域(包括国家顶级域)都有TLD服务器，提供权威DNS服务器的IP地址。&lt;/li&gt;
&lt;li&gt;权威DNS服务器：具有公共可访问主机的组织机构必须提供公共可访问的DNS记录；一个组织机构可通过：
&lt;ul&gt;
&lt;li&gt;构建自己的权威DNS服务器&lt;/li&gt;
&lt;li&gt;租用服务商提供的权威DNS服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一类称为&lt;em&gt;本地DNS服务器&lt;/em&gt;，这类服务器不属于上图所示的层次结构；每个ISP都有一台本地DNS服务器，本地DNS服务器于主机之间距离很近，甚至可能在同一个局域网中，它起代理作用，并将DNS请求转发到DNS服务器层次结构中。&lt;/p&gt;
&lt;h4 id=&#34;dns查询&#34;&gt;DNS查询&lt;/h4&gt;
&lt;p&gt;DNS查询一般分为两类：&lt;em&gt;递归查询&lt;/em&gt;、&lt;em&gt;迭代查询&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;递归查询&lt;/em&gt;：DNS服务器收到客户机请求时，必须使用一个准确的查询结构回复客户机，如果DNS服务器本地没有储存DNS信息，该服务器会&lt;strong&gt;向其他服务器询问&lt;/strong&gt;，并将返回的查询结果提交给客户机。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;迭代查询&lt;/em&gt;：DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址，当客户机发送请求时，DNS服务器&lt;strong&gt;不直接返回结果&lt;/strong&gt;，而是&lt;strong&gt;告诉客户机另一台DNS服务器地址&lt;/strong&gt;，客户机再想这台服务器体提交请求，一次循环到返回查询结果为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E4%BA%92.JPG&#34; alt=&#34;DNS服务器交互&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以图中&lt;em&gt;请求主机和本地DNS服务器&lt;/em&gt;之间为递归查询，&lt;em&gt;本地DNS服务器和其他DNS服务器&lt;/em&gt;之间为迭代查询。&lt;/p&gt;
&lt;h4 id=&#34;dns缓存&#34;&gt;DNS缓存&lt;/h4&gt;
&lt;p&gt;DNS缓存用来改善延时性能并减少在因特网上传输的DNS报文数，例如上图所示，当本地服务器从某个DNS服务器接收到一个回答，他能缓存包含在该回答内的任何信息，当一个主机向本地DNS服务器查询已经缓存的地址时就能够直接将IP地址返回给主机。而主机和主机名于IP地址间的映射不是永久的，DNS服务器一般在一段时间(通常设置为两天)后丢弃缓存信息。&lt;/p&gt;
&lt;h3 id=&#34;dns记录和报文&#34;&gt;DNS记录和报文&lt;/h3&gt;
&lt;p&gt;DNS服务器存储了&lt;em&gt;资源记录(Resource Record, RR)&lt;/em&gt;，RR提供了主机名到IP地址的映射。&lt;/p&gt;
&lt;h4 id=&#34;资源记录元组&#34;&gt;资源记录元组：&lt;/h4&gt;
&lt;p&gt;(Name, Value, Type, TTL)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TTL是该记录的生存时间，决定了资源记录应当从缓存中删除的时间。&lt;/li&gt;
&lt;li&gt;Name和Value的值取决于Type：
&lt;ul&gt;
&lt;li&gt;Type = A，则Name是主机名，Value是主机名对应的IP地址&lt;/li&gt;
&lt;li&gt;Type = NS，则Name是一个域(如foo.com)，而Value知道如何获得该域中主机IP地址的权威DNS服务器的主机名。&lt;/li&gt;
&lt;li&gt;Type = CNAME，则Value是别名为Name的主机对应的规范主机名，如(foo.com, relay1.bar.foo.com, CNAME)。&lt;/li&gt;
&lt;li&gt;Type = MX，则Value是个别名为Name的邮件服务器对应的规范主机名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dns报文&#34;&gt;DNS报文&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/DNS%E6%8A%A5%E6%96%87.JPG&#34; alt=&#34;DNS报文&#34;&gt;&lt;/p&gt;
&lt;p&gt;DNS报文有查询和回答两种，且两种报文的格式相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首部区域：前12字节为首部区域，有6个字段
&lt;ul&gt;
&lt;li&gt;标识符：16比特的数，用于标识该查询。该标识符会被复制到回答报文中，以便匹配。&lt;/li&gt;
&lt;li&gt;标志字段：有若干标志
&lt;ul&gt;
&lt;li&gt;1比特的“查询/回答”标志位&lt;/li&gt;
&lt;li&gt;1比特的“权威的”标志位&lt;/li&gt;
&lt;li&gt;1比特的“希望递归”标志位，用户在该DNS服务器没有某记录时希望它执行递归查询&lt;/li&gt;
&lt;li&gt;1比特的“递归可用”标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4个有关数量的字段，指出了4类数据区域出现的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题区域：包含正在进行的查询信息
&lt;ul&gt;
&lt;li&gt;名字字段：包含正在查询的主机名字&lt;/li&gt;
&lt;li&gt;类型字段：包含Type的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回答区域：来自DNS服务器的回答报文，包含了对最初请求名字的资源记录，即(Name, Value, Type, TTL)；回答区域可以包含多条RR，所以一个主机名能有多个IP地址。&lt;/li&gt;
&lt;li&gt;权威区域：包含了其他权威服务器的记录。&lt;/li&gt;
&lt;li&gt;附加区域：其他有帮助的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DNS脆弱性，一种针对DNS的攻击时分布式拒绝服务（DDos）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;p2p文件分发&#34;&gt;P2P文件分发&lt;/h2&gt;
&lt;p&gt;P2P体系结构对基础设施服务器几乎没有依赖，成对间歇连接的主机(对等放)彼此直接通信。&lt;/p&gt;
&lt;h3 id=&#34;p2p体系结构的扩展性&#34;&gt;P2P体系结构的扩展性&lt;/h3&gt;
&lt;p&gt;客户——服务器体系和P2P体系的比较，结论为在相同的网络速率环境下，随着分发文件数量的增加，P2P的最小分发时间与客户——服务器体系相比差距越来越大，优势越来越明显。&lt;/p&gt;
&lt;h3 id=&#34;bittorrent&#34;&gt;BitTorrent&lt;/h3&gt;
&lt;p&gt;BT是一种用于文件分发的流行P2P协议，参与一个特定分发文件的所有对等方的集合被称为一个&lt;strong&gt;洪流(torrent)&lt;/strong&gt;，一个洪流中的对等方彼此下载等长度的文件&lt;strong&gt;块&lt;/strong&gt;，典型长度为256KB.&lt;/p&gt;
&lt;p&gt;当一个对等方首次加入一个洪流，它没有块，随着时间的流逝，它累计了越来越多的块，同时也为其他对等放上载了多个块；当对等方获得了整个文件，它也许离开洪流，也许留在洪流中并继续向其他对等方上载块。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;追踪器&lt;/strong&gt;：每个洪流都具有一个的基础设施节点；当一个对等方加入洪流时，他向追踪器注册自己，并周期性地通知追踪器它仍在洪流中。一个给定的洪流可能在任何时刻具有数以百计或千计的对等方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何给定时间，每个对等方将具有来自该文件的块的子集，并且不同对等方有不同子集。一个对等方经TCP连接周期性地询问每个邻近对等方它们所具有的块列表，然后对当前没有的块发出请求。&lt;/p&gt;
&lt;p&gt;那么对等方应该向它的邻居请求哪些块呢？应向哪些向它请求的邻居发送块？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最稀缺优先&lt;/strong&gt;技术：针对自己没有的块，在邻居中寻找这些块的副本最少的，并首先请求这些稀缺的块，这也可以同时均衡每个块在洪流中的副本数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对换算法&lt;/strong&gt;：对等方根据当前能够以最高速率向他提供数据的邻居给出优先权；并且确定向流入速率前四的邻居提供数据，且每隔10秒就重新计算速率并重新确定4个对等方，这4个对等方被称为&lt;strong&gt;疏通&lt;/strong&gt;。每过30秒对换方将重新选择一名新的对换伴侣并开始与那位伴侣进行对换，并且如果二者直接都满足对换算法规则，那么互相将对方放入自己的前4人中，这样能使对等方趋于找到彼此的协调速率上载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;视频流和内容分发网&#34;&gt;视频流和内容分发网&lt;/h2&gt;
&lt;h3 id=&#34;http流和dash&#34;&gt;HTTP流和DASH&lt;/h3&gt;
&lt;p&gt;在HTTP流中，视频是指存储在HTTP服务器中的一个文件，每个文件有特定的URL，用户要看视频时，客户与服务器创建一个TCP连接并对URL发送HTTP GET请求，服务器在HTTP响应报文中发送该视频；在客户一侧，视频字节被收集在客户应用缓存中，当缓存中的字节量超过预先设定的门槛，客户应用程序就开始播放视频。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;经HTTP的动态适应性流(Dynamic Adaptive Streaming over HTTP, DASH)&lt;/strong&gt;：DASH中视频被编码为几个不同版本，每个版本有不同的比特率(画质)，当用户的可用带宽较高时，自然选择来自高速率版本的块，同时可用带宽较低时自然选择低速率的块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;告示文件&lt;/strong&gt;：存在于HTTP服务器中，为每个版本提供一个URL及其比特率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内容分发网&#34;&gt;内容分发网&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内容分发网(Content Distribution Network, CDN)&lt;/strong&gt;：是现在主流视频流公司用来向全世界用户分发视频数据的部署在全球多个地理位置的服务器，服务器中存储了视频和其他相关内容的副本。&lt;/p&gt;
&lt;p&gt;CDN服务器安置原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深入&lt;/strong&gt;：靠近端用户，改善时延和吞吐量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邀请做客&lt;/strong&gt;：通过在少量关键位置建造大集群来邀请ISP做客，通常将这些集群放置在因特网交换点(IXP).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDN集群部署就绪后就可以跨集群复制内容，并进行一系列视频管理操作。&lt;/p&gt;
&lt;h4 id=&#34;cdn操作&#34;&gt;CDN操作&lt;/h4&gt;
&lt;p&gt;大多数CDN利用&lt;em&gt;DNS来截获和重定向请求&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户访问位于内容提供商的Web页面&lt;/li&gt;
&lt;li&gt;用户点击视频链接时，用户发哦是那个了一个对于该视频链接的DNS请求&lt;/li&gt;
&lt;li&gt;用户的本地DNS服务器（LDNS）将该请求中继到一台权威DNS服务器上，权威服务器并不返回一个IP地址，而是返回自己租用的内容服务器的主机名&lt;/li&gt;
&lt;li&gt;此时DNS请求进入内容服务器专用DNS基础设施，LDNS发送第二个请求，基础设施DNS服务器最终返回内容服务器的IP地址&lt;/li&gt;
&lt;li&gt;客户收到内容服务器的IP地址后，创建一条TCP连接，并发送HTTP GET 请求，若使用了DASH，服务器将首先向客户发送具有URL列表的告示文件，对应了不同版本视频，客户动态地选择不同版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;集群选择策略&#34;&gt;集群选择策略&lt;/h4&gt;
&lt;p&gt;如上CDN操作所示，CDN得知该用户LDNS服务器的IP地址后，需要基于IP地址选择一个适当的集群，一般采用专用的集群选择策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;地理上最为邻近的集群&lt;/em&gt;：每个LDNS 的IP地址都映射到一个地理位置，CDN选择地理上最为接近的集群。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;当前流量条件&lt;/em&gt;：CDN能对当前集群和客户之间的时延和丢包性能进行周期性实时测量，基于此来选择。&lt;/li&gt;
&lt;/ul&gt;
- http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>关于</title>
        <link>http://eternityqjl.top/about/</link>
        <pubDate>Thu, 28 Nov 2019 18:09:24 +0000</pubDate>
        
        <guid>http://eternityqjl.top/about/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/about/ -&lt;p&gt;四川大学电气工程学院自动化专业在读。励志成为一个软硬兼修的优秀工程师。还在努力中。。。&lt;/p&gt;
&lt;p&gt;喜欢摄影，尤爱拍飞机。&lt;/p&gt;
&lt;p&gt;然后就是旅行过程中的街拍，以及各种奇奇怪怪的照片。&lt;/p&gt;
&lt;p&gt;还偶尔拍一些火车，但现在已经很少拍。&lt;/p&gt;
&lt;p&gt;写文字是我觉得最有趣的事情之一，希望自己能坚持写一些博客。&lt;/p&gt;
&lt;p&gt;我已经初步建好了自己的飞行博物馆的GitBook，以后会逐渐地更新：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://museum.eternityqjl.top&#34;&gt;My Flight Museum&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;网站于2021年7月从Hexo平台迁移至Hugo。&lt;/p&gt;
- http://eternityqjl.top/about/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>GitBook自动发布脚本</title>
        <link>http://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</link>
        <pubDate>Fri, 18 Oct 2019 13:50:49 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/ -&lt;p&gt;GitBook作为一个非常好用的基于Node.js的命令行工具，可以输出HTML、PDF、eBook等多种格式的电子书，这里就不再详细讲述GitBook的构建以及发布到Github托管的过程，网络上有非常多的教程，可以自行Google查看。&lt;/p&gt;
&lt;p&gt;刚开始在每次更新内容的时候都需要一系列的git命令将原始内容仓库和构建的网页仓库同步到Github上，大概需要10条命令，如果你的更新频率很高的话，发布内容将会是有个痛苦的过程，但这里我们可以通过一个shell脚本只使用&lt;code&gt;$ sh deploy.sh&lt;/code&gt;一条命令完成同步内容和构建网页的所有过程。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;首先，在你的GitBook内容根目录下建一个&lt;code&gt;deploy.sh&lt;/code&gt;文件，使用文本编辑器打开，然后输入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#!bin/sh
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;git checkout master
&lt;span style=&#34;color:#888&#34;&gt;# 切换到master分支，及内容所在的仓库&lt;/span&gt;
git add .
git commit -m &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Update&amp;#34;&lt;/span&gt;
git push -u origin master
&lt;span style=&#34;color:#888&#34;&gt;# 添加、提交到Git仓库，然后push到Github上&lt;/span&gt;
gitbook build
&lt;span style=&#34;color:#888&#34;&gt;# 构建Gitbook&lt;/span&gt;

git checkout gh-pages
&lt;span style=&#34;color:#888&#34;&gt;# 切换到gh-pages分支，即生成的HTML网页的仓库&lt;/span&gt;
cp -r _book/* . 
&lt;span style=&#34;color:#888&#34;&gt;# 复制前面构建的内容&lt;/span&gt;
git add .
git commit -m &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Update&amp;#34;&lt;/span&gt;
git push -u origin gh-pages
&lt;span style=&#34;color:#888&#34;&gt;# 添加、提交到Git仓库，然后push到Github上&lt;/span&gt;
git checkout master
&lt;span style=&#34;color:#888&#34;&gt;# 返回master主分支&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后打开命令行，为这个脚本授权：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ chmod +x deploy.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此就完成了，以后在更新的时候只需要输入一条命令&lt;code&gt;$ sh deploy.sh&lt;/code&gt;就可以完成所有操作了。&lt;/p&gt;
- http://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>储存类别、链接和内存管理</title>
        <link>http://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Fri, 18 Oct 2019 10:59:58 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ -&lt;p&gt;一、储存类别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象：具有一定大小空间的一块内存。&lt;/li&gt;
&lt;li&gt;标识符：用来指定特定对象的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;作用域
&lt;ul&gt;
&lt;li&gt;描述了程序中可访问标识符的区域。&lt;/li&gt;
&lt;li&gt;分类：
&lt;ul&gt;
&lt;li&gt;块作用域&lt;/li&gt;
&lt;li&gt;函数作用域&lt;/li&gt;
&lt;li&gt;文件作用域&lt;/li&gt;
&lt;li&gt;函数原型作用域：从形参定义处到原型声明结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全局变量：也称为文件作用域变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接
&lt;ul&gt;
&lt;li&gt;C变量的三种链接属性：
&lt;ul&gt;
&lt;li&gt;外部链接：该类型变量可以在多文件程序中使用&lt;/li&gt;
&lt;li&gt;内部链接：该类型变量只能在一个翻译单元中使用&lt;/li&gt;
&lt;li&gt;无链接：具有块作用域、函数作用域或函数原型作用域的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;储存类别说明符&lt;code&gt;static&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储期：
&lt;ul&gt;
&lt;li&gt;C对象有4种
&lt;ul&gt;
&lt;li&gt;静态存储期：在程序的执行期间一直存在，文件作用域变量都具有静态存储期。&lt;/li&gt;
&lt;li&gt;线性存储期：用于并发程序设计。&lt;/li&gt;
&lt;li&gt;自动存储期：所有局部变量都有该性质，在函数调用时被创建，离开函数时被销毁。&lt;/li&gt;
&lt;li&gt;动态分配存储期：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动变量
&lt;ul&gt;
&lt;li&gt;属于自动存储类别，有自动存储期、块作用域、无链接。&lt;/li&gt;
&lt;li&gt;可显式使用关键词&lt;code&gt;auto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;块作用域和无链接意味着只有在&lt;strong&gt;变量定义的块中&lt;/strong&gt;才能通过变量名访问该变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寄存器变量
&lt;ul&gt;
&lt;li&gt;特殊的自动变量。也是自动存储期、块作用域、无链接。&lt;/li&gt;
&lt;li&gt;可以显式使用关键词&lt;code&gt;register&lt;/code&gt;，是一种请求，编译器可能会拒绝你的请求，此时就变成了普通变量，但仍然无法访问该变量的内存。&lt;/li&gt;
&lt;li&gt;作用是储存在最快的可用内存中，能够以更快的速度访问。&lt;/li&gt;
&lt;li&gt;存储在寄存器中而非内存中，所以无法获取寄存器变量的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;块作用域的静态变量
&lt;ul&gt;
&lt;li&gt;静态指的是在内存中原地不动，但它的值可以改变。&lt;/li&gt;
&lt;li&gt;具有块作用域、无链接、有静态存储期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在块中&lt;/strong&gt;以&lt;code&gt;static&lt;/code&gt;(提供静态存储期)声明这种变量。&lt;/li&gt;
&lt;li&gt;如果未显式地初始化&lt;strong&gt;静态变量&lt;/strong&gt;，它们会被&lt;strong&gt;初始化为0&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部链接的静态变量
&lt;ul&gt;
&lt;li&gt;具有文件作用域、外部链接、静态存储期。&lt;/li&gt;
&lt;li&gt;有时又称为外部存储类型、该类别地变量被称为&lt;strong&gt;外部变量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;创建过程：在&lt;strong&gt;所有函数外&lt;/strong&gt;面(定义性声明)创建这个外部变量。&lt;/li&gt;
&lt;li&gt;函数使用该变量时，为了&lt;strong&gt;指出使用的是外部变量&lt;/strong&gt;，可以用关键字&lt;code&gt;extern&lt;/code&gt;再次声明。&lt;/li&gt;
&lt;li&gt;如果一个源文件使用的外部变量定义在&lt;strong&gt;其他文件&lt;/strong&gt;中，则必须用&lt;code&gt;extern&lt;/code&gt;在该文件中声明该变量。&lt;/li&gt;
&lt;li&gt;定义式声明、引用式声明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部链接的静态变量
&lt;ul&gt;
&lt;li&gt;具有静态存储期、文件作用域、内部链接。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;所有函数外部&lt;/strong&gt;，用存储类别说明符&lt;code&gt;static&lt;/code&gt;定义该类变量。&lt;/li&gt;
&lt;li&gt;该类型变量只能用于&lt;strong&gt;同一个文件中的函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;可以在函数中使用类别说明符&lt;code&gt;extern&lt;/code&gt;重复声明该类型变量，这并不会改变其链接属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多文件(多翻译单元)
&lt;ul&gt;
&lt;li&gt;程序在多个翻译单元中才能体现区别内部和外部变量的重要性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储类别的选择
&lt;ul&gt;
&lt;li&gt;正常情况下多使用自动存储类别，使用外部变量可能在不经意中修改变量的值，count类型变量除外。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、&lt;/p&gt;
- http://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C语言结构</title>
        <link>http://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/</link>
        <pubDate>Tue, 15 Oct 2019 20:03:54 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/ -&lt;p&gt;1.建立结构变量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; book {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; title[MAXTITL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; author[MAXAUTL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;该结构描述了由两个字符数组和一个float类型变量组成的结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.定义结构变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct book library;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把library声明为一个使用book结构类型的结构变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以struct book 相当于过去的int、double等类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; book {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; title[MAXTITL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; author[MAXAUTL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; value;
} library;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该程序为上面声明的完整版。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; { &lt;span style=&#34;color:#888&#34;&gt;//无结构标记
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; title[MAXTITL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; author[MAXAUTL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; value;
} library;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;声明结构和定义结构可以一步完成，如上所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.初始化结构&lt;/p&gt;
&lt;p&gt;4.访问结构成员(点运算符)&lt;/p&gt;
&lt;p&gt;5.结构初始化器&lt;/p&gt;
&lt;p&gt;6.结构数组&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct book library[MAXBKS];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;7.指向结构的指针&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct guy * him;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针可以指向任何现有的guy类型如barney、fellow[0]（一个结构数组的一项即为一个结构变量）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;him = &amp;amp;barney&lt;/code&gt; or &lt;code&gt;him = &amp;amp;fellow[0];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;8.用指针访问成员&lt;/p&gt;
&lt;p&gt;若&lt;code&gt;him == &amp;amp;barney&lt;/code&gt;，那么&lt;code&gt;him-&amp;gt;income&lt;/code&gt;即是&lt;code&gt;barney.income&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;同时，&lt;code&gt;*him&lt;/code&gt;即为指针指向的结构类型。所以，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;barney.income == (*him).income == him-&amp;gt;income&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;9.向函数传递结构的成员、地址、结构本身&lt;/p&gt;
&lt;p&gt;10.其他特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用指针传递信息(作为函数参数)：是使用原始结构进行计算的。&lt;/li&gt;
&lt;li&gt;使用结构作为函数参数：是使用副本进行计算。&lt;/li&gt;
&lt;/ul&gt;
- http://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>字符串输入、输出和字符串函数</title>
        <link>http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</link>
        <pubDate>Sat, 28 Sep 2019 12:15:42 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/ -&lt;h2 id=&#34;字符串输入&#34;&gt;字符串输入&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;gets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用方法：读取整行输入，直到遇到&lt;strong&gt;换行符&lt;/strong&gt;，然后&lt;strong&gt;丢弃换行符&lt;/strong&gt;，储存其余的字符，并在字符末尾添加一个&lt;strong&gt;空字符&lt;/strong&gt;使之成为一个C字符串。&lt;/li&gt;
&lt;li&gt;使用中存在的问题：&lt;code&gt;gets(words)&lt;/code&gt;（char words[STLEN]）的唯一参数为words，该函数无法检查数组是否装得下输入行。数组名会被转化成该数组首元素的地址，该函数只知道数组的开始处，并不知道数组在何处结束。&lt;/li&gt;
&lt;li&gt;如果输入过长，会导致&lt;strong&gt;缓存区溢出&lt;/strong&gt;，详情见书上内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;code&gt;gets()&lt;/code&gt;的替代品：&lt;code&gt;fgets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fgets()&lt;/code&gt;函数通过第二个参数来限制读入的&lt;strong&gt;字符数&lt;/strong&gt;来解决溢出问题。&lt;/li&gt;
&lt;li&gt;相较于&lt;code&gt;gets()&lt;/code&gt;的区别：
&lt;ul&gt;
&lt;li&gt;第二个参数指明了读入字符的最大数量，若该值为n，那么将读入n-1个字符，或遇到第一个&lt;strong&gt;换行符&lt;/strong&gt;为止。&lt;/li&gt;
&lt;li&gt;第三个参数指明了要读入的文件，如果要从键盘输入，则参数设置为stdin标识符。&lt;/li&gt;
&lt;li&gt;如果读到一个换行符，&lt;code&gt;fgets()&lt;/code&gt;会将其&lt;strong&gt;储存在数组中&lt;/strong&gt;，而不是将其丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;gets_s()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;于&lt;code&gt;fgets()&lt;/code&gt;的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数只从标准输入中读取，所以无需第三个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读到&lt;strong&gt;换行符会将其丢弃&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果读到最大字符数都没有读到换行符，会进行以下操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先设置目标数组的首字符为空字符&lt;/p&gt;
&lt;p&gt;读取并丢弃随后的输入直至读到换行符或文件结尾&lt;/p&gt;
&lt;p&gt;返回空指针&lt;/p&gt;
&lt;p&gt;然后调用依赖实现的“处理函数”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.&lt;code&gt;s_gets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取整行输入并&lt;strong&gt;用空字符替代换行符&lt;/strong&gt;，或者(在字符串未结束就遇到了空字符)读取一部分输入，并丢弃其余的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;s_gets&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; st, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ret_val;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;

    ret_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fgets(st, n, stdin);
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret_val)
    {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (st[i] &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; st[i] &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
            i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (st[i] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
            st[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; 
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (getchar() &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
                &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; ret_val;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.&lt;code&gt;scanf()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以第一个非空白字符座位读取的开始，以第一个空白字符(空行、空格、制表符、换行符)座位字符串的结束。&lt;/li&gt;
&lt;li&gt;其他内容略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串输出&#34;&gt;字符串输出&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;puts()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数显示字符串时会在末尾添加一个&lt;strong&gt;换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;该函数的参数为地址，且用双引号括起来的字符串常量作为参数时，参数被视为该字符串的地址。&lt;/li&gt;
&lt;li&gt;当参数为数组中某个项的地址时，如&lt;code&gt;str[5]&lt;/code&gt;,会从这个位置开始依次输出。&lt;/li&gt;
&lt;li&gt;结束条件为&lt;strong&gt;空字符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;code&gt;fputs()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二个参数要指明写入数据的文件，若要打印在显示器上，则用stdout作为参数。&lt;/li&gt;
&lt;li&gt;该函数&lt;strong&gt;不会在字符串末尾添加换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;printf()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串函数&#34;&gt;字符串函数&lt;/h2&gt;
&lt;p&gt;0.这里只写出书上详细介绍的5组字符串函数：&lt;code&gt;strlen()&lt;/code&gt; | &lt;code&gt;strcat()/strncat()&lt;/code&gt; | &lt;code&gt;strcmp()/strncmp()&lt;/code&gt; | &lt;code&gt;strcpy()/strncpy()&lt;/code&gt; | &lt;code&gt;sprintf()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;strlen&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数用于统计字符串的长度，函数返回值为字符串的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;2.&lt;code&gt;strcat()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本定义
&lt;ul&gt;
&lt;li&gt;该函数用于&lt;strong&gt;拼接字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接受两个字符串作为参数&lt;/li&gt;
&lt;li&gt;把第二个字符串的备份附在第一个字符串的末尾，并把拼接后形成的新字符串作为第一个字符串，第二个字符串不变。&lt;/li&gt;
&lt;li&gt;该函数的函数类型是&lt;code&gt;char *&lt;/code&gt;,即指向&lt;code&gt;char&lt;/code&gt;的指针。&lt;/li&gt;
&lt;li&gt;所以该函数返回第一个参数，即拼接第二个字符串后的第一个字符串的&lt;strong&gt;地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存在的问题
&lt;ul&gt;
&lt;li&gt;无法检查第一个数组是否能容纳第二个字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;strncat()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的第三个参数指定了最大添加字符数&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;strncat(bugs, addon, 13)&lt;/code&gt;会把addon字符串的聂荣附加给bugs，加到第13个字符或者遇到空字符的时候停止&lt;/li&gt;
&lt;li&gt;所以，算上空字符(必须要添加空字符，否则就不是字符串了)，bugs数组应该足够大，以容纳原始字符串(不包含空字符)、添加在后面的13个字符、末尾的空字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;4.&lt;code&gt;strcmp()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来把用户的响应于已储存的字符串作比较(比较&lt;strong&gt;两个字符串的内容&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;比较的是字符串的内容而不是字符串的地址，例如
&lt;ul&gt;
&lt;li&gt;定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define ANSWER &amp;quot;Grant&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define SIZE 40&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char try[SIZE]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s_gets(try, SIZE)&lt;/code&gt;\\输入Grant&lt;/li&gt;
&lt;li&gt;如果使用&lt;code&gt;while (try == ANSWER)&lt;/code&gt;,则永远得不到两者相等的结果，因为while比较的是指针，即地址，二者的地址肯定不相同&lt;/li&gt;
&lt;li&gt;但使用&lt;code&gt;strcmp(try, ANSWER)&lt;/code&gt;则能够得到两者内容相等的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：该函数只会比较try中第一个空字符前面的部分，所以该函数可以比较储存在不同大小数组中的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;该函数的返回值：
&lt;ul&gt;
&lt;li&gt;返回实例：
&lt;ul&gt;
&lt;li&gt;比较“A&amp;quot;和本身，返回0&lt;/li&gt;
&lt;li&gt;比较”A&amp;quot;和&amp;quot;B&amp;quot;，返回-1&lt;/li&gt;
&lt;li&gt;比较“B&amp;quot;和”A“，返回1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论：
&lt;ul&gt;
&lt;li&gt;二者相等返回0&lt;/li&gt;
&lt;li&gt;第一个的ASCII码比第二个大就返回负数，比第二个大就返回整数&lt;/li&gt;
&lt;li&gt;返回的整数和负数即为二者的ASCII码之差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;
&lt;li&gt;返回值的具体数值并不重要，重要的是它是0还是非0&lt;/li&gt;
&lt;li&gt;该函数比较的是&lt;strong&gt;字符串而不是字符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限：
&lt;ul&gt;
&lt;li&gt;该函数比较字符串中的字符，直到发现不同的字符为止，这个过程可能会持续到字符串末尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.&lt;code&gt;strncmp()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数可以比较字符不同的地方，也可以只比较第三个参数指定的字符数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如书中的实例：可以限定函数只查找这几个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;6.&lt;code&gt;strcpy()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数是用来拷贝整个字符串的内容，即相当于字符串赋值运算符
&lt;ul&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;str1和str2都是指向字符串的指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str2 = str1;&lt;/code&gt;这个语句拷贝的指针的地址而不是具体内容&lt;/li&gt;
&lt;li&gt;所以要想拷贝整个字符串就要用到该函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;接受两个字符串指针作为参数，可以把第二个指针声明为指针、数组或者字符串常量&lt;/li&gt;
&lt;li&gt;第一个指针应该指向一个数据对象如数组，且该字符串有足够的空间存储源字符串的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他属性：
&lt;ul&gt;
&lt;li&gt;该函数的返回类型是&lt;code&gt;char *&lt;/code&gt;,返回的是第一个参数的值，即一个字符的地址。&lt;/li&gt;
&lt;li&gt;第一个参数不必指向数组的开始，该属性可用于拷贝数组的一部分，详情见书上的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限：
&lt;ul&gt;
&lt;li&gt;与&lt;code&gt;strcat()&lt;/code&gt;一样，不能检查目标空间是否能容纳的下源字符串的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.&lt;code&gt;strncpy()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的第三个参数指明了可拷贝的最大字符数
&lt;ul&gt;
&lt;li&gt;如果要拷贝的字符超过了指定的参数n，当拷贝了n个字符后就会停止，并且也不会在后面添加空字符，容易出现错误，所以要非常注意。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;8.&lt;code&gt;sprintf()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数与&lt;code&gt;printf()&lt;/code&gt;函数类似，但这个是把数据写入字符串，而不是打印在显示器上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该函数的第一个参数是目标字符串的地址，其余的与&lt;code&gt;printf()&lt;/code&gt;类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; first[MAX];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; last[MAX];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; formal[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; MAX &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;];
&lt;span style=&#34;color:#888&#34;&gt;//给以上前面两个数组赋值后就可以进行如下的操作
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;sprintf(formal, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s, %-19s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, last, first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
- http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>抽象数据类型</title>
        <link>http://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
        <pubDate>Tue, 24 Sep 2019 21:33:07 +0000</pubDate>
        
        <guid>http://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
        <description>Jialong&#39;s Blog http://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ -&lt;h2 id=&#34;一抽象数据类型的实现&#34;&gt;一、抽象数据类型的实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//数据类型的实现
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Counter&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;//实例变量
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; String name&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;Counter&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;String id&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; name &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; id&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//实例方法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;++;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;tally&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;toString&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; count &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; name&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;


&lt;span style=&#34;color:#888&#34;&gt;//测试该数据类型的用例
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#333&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;//创建并初始化对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    Counter heads &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Counter&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;heads&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    Counter tails &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Counter&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;tails&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//调用实例方法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;incerment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    tails&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    
    StdOut&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;heads &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; tails&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    StdOut&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;tally&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; tails&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;tally&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例变量：
&lt;ul&gt;
&lt;li&gt;一个实例变量对应了无数的值，因为数据类型的每个实例对象都有有个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造函数：
&lt;ul&gt;
&lt;li&gt;构造函数是用来创建一个对象的表示，即来初始化实例变量。&lt;/li&gt;
&lt;li&gt;它由&lt;strong&gt;可见性修饰符、构造函数名称(即数据类型的名称)、参数变量&lt;/strong&gt;以及初始化实例变量的代码构成。&lt;/li&gt;
&lt;li&gt;上一条加粗的三个组成了签名，例如&lt;code&gt;public Counter (String id) &lt;/code&gt;即为一个签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实例方法：
&lt;ul&gt;
&lt;li&gt;是每个对象的具体行为，即实现数据类型的实例方法。&lt;/li&gt;
&lt;li&gt;与静态方法的唯一区别是它能够访问并操作实力变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域
&lt;ul&gt;
&lt;li&gt;参数变量：作用域为整个方法。&lt;/li&gt;
&lt;li&gt;局部变量：定义后的所有语句(一个花括号内)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例变量&lt;/strong&gt;：整个类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- http://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 