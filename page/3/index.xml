<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sat, 11 Dec 2021 21:38:11 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>计算机网络学习日志（三）——网络层：数据平面</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</link>
        <pubDate>Thu, 05 Aug 2021 22:23:31 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/ -&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;数据平面指的是网络层中&lt;strong&gt;每台路由器&lt;/strong&gt;的功能，该数据平面功能决定了到达路由器输入链路的数据报如何转发到该路由器的输出链路之一。&lt;/p&gt;
&lt;p&gt;而控制平面的功能指的是&lt;strong&gt;网络范围&lt;/strong&gt;的逻辑，控制平面控制数据报沿着从源主机到目的主机的端到端路径中&lt;strong&gt;路由器之间&lt;/strong&gt;的路由方式。其中包括路由选择算法，以及如今广泛应用的诸如OSPF和BGP等路由选择协议。控制平面和数据平面的功能已经被实现为一个整体，位于一台路由器中。&lt;/p&gt;
&lt;p&gt;**软件定义网络（SDN）**通过将这些控制平面的功能作为一种单独的服务，明确分离数据平面和控制平面，控制平面功能通常位于一台远程的控制器中。&lt;/p&gt;
&lt;h2 id=&#34;网络层概述&#34;&gt;网络层概述&lt;/h2&gt;
&lt;h3 id=&#34;转发和路由选择数据平面和控制平面&#34;&gt;转发和路由选择：数据平面和控制平面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;转发：将一个分组从路由器的一条输入链路移动到适当的输出链路&lt;/li&gt;
&lt;li&gt;路由选择：网络层决定分组从发送方到接收方所采用的路由或路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转发（forwarding）是路由器本地动作，路由选择（routing）是网络范围处理过程。&lt;/p&gt;
&lt;p&gt;路由器通过&lt;strong&gt;转发表&lt;/strong&gt;来实现转发功能。&lt;/p&gt;
&lt;h3 id=&#34;网络服务模型&#34;&gt;网络服务模型&lt;/h3&gt;
&lt;p&gt;网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保交付&lt;/li&gt;
&lt;li&gt;具有时延上界的确保交付&lt;/li&gt;
&lt;li&gt;有序分组交付&lt;/li&gt;
&lt;li&gt;确保最小带宽&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因特网的网络层提供了&lt;strong&gt;尽力而为服务&lt;/strong&gt;。并不能对服务做出保证。但尽力而为服务结合适当的玩过带宽已被证明足够好，已被证明能用于大量应用。&lt;/p&gt;
&lt;h2 id=&#34;路由器工作原理&#34;&gt;路由器工作原理&lt;/h2&gt;
&lt;p&gt;以下为一个通用的路由器体系结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入端口：终结输入物理链路的物理层功能；还与位于入链路远端的数据链路层交互来执行数据链路层功能；另外还要执行查找功能，通过查询转发表决定路由器的输出端口&lt;/li&gt;
&lt;li&gt;交换结构：将路由器的输入端口连接到它的输出端口&lt;/li&gt;
&lt;li&gt;输出端口：从交换结构接收分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组&lt;/li&gt;
&lt;li&gt;路由选择处理器：执行控制平面功能。在传统路由器中执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在SDN路由器中，路由选择处理器负责与远程控制器通信，接收其计算的转发表项，并在路由器输入端口安装这些表项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;输入端口处理和基于目的地转发&#34;&gt;输入端口处理和基于目的地转发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86_%E7%BD%91%E7%BB%9C%E5%B1%82.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;交换&#34;&gt;交换&lt;/h3&gt;
&lt;p&gt;交换结构是路由器的核心，通过这种交换结构，分组才能实际地从一个输入端口交换到一个输出端口中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经内存交换&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。分组到达输入端口时被复制到处理器内存中，路由选择处理器从其首部中提取目的地址，在转发表中找打适当输出端口，并将该分组复制到输出端口的缓存中。该种情况下若内存带宽为每秒可以写进内存或从内存中读出最多B个分组，则总的转发吞吐量必然小于B/2。另外这种方式不同同时转发两个分组，即使它们有不同的分组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经总线交换&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。路由器必须跨过单一总线，所以路由器的交换带宽受总线速率的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经互联网络交换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用更加复杂的交换网络来客服单一、共享式总线带宽的限制。&lt;/p&gt;
&lt;p&gt;例如纵横式交换机就是一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直总线与每条水平总线在交叉点交叉，交叉点通过交换结构控制器控制开启和闭合。&lt;/p&gt;
&lt;p&gt;所以纵横式网络能够并行转发多个分组，是非阻塞的。&lt;/p&gt;
&lt;h3 id=&#34;输出端口处理&#34;&gt;输出端口处理&lt;/h3&gt;
&lt;p&gt;选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。&lt;/p&gt;
&lt;h3 id=&#34;排队&#34;&gt;排队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;输入排队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出排队&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;分组调度&#34;&gt;分组调度&lt;/h3&gt;
&lt;p&gt;解决排队的分组如何经输出链路传输的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先进先出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FIFO的链路调度规则，如果分组到达时链路正忙，则需要等待链路中的分组传输完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先权排队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同类型的网络分组有不同的优先权类，每个优先权类通常都有自己的队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环和加权公平排队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;循环排队规则&lt;/strong&gt;中，分组像使用优先权排队那样被分类，但在类之间不存在严格的服务优先权，&lt;strong&gt;循环调度器&lt;/strong&gt;在这些类之间轮流提供服务。一个所谓的&lt;strong&gt;保持工作排队&lt;/strong&gt;规则在有分组排队等待传输时，不允许链路保持空闲。当寻找给定的分组但没有找到时，保持工作的循环规则将立即检查循环序列中的下一个类。&lt;/p&gt;
&lt;p&gt;一种称为&lt;strong&gt;加权平均排队&lt;/strong&gt;（Weighted Fair Queuing, WFQ）规则的通用形式的循环排队已经广泛地实现在路由器中了。WFQ与循环排队的不同在于，每个类在任何时间间隔内可能收到不同数量的服务。每个类i被分配一个权$w_i$，使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接收到的服务部分等于$w_i/(\sum w_j)$，即保证拥有相应权重的带宽。&lt;/p&gt;
&lt;h2 id=&#34;网际协议ip&#34;&gt;网际协议IP&lt;/h2&gt;
&lt;p&gt;因特网网络层的网际协议（IP）。&lt;/p&gt;
&lt;h3 id=&#34;ipv4数据报格式&#34;&gt;IPv4数据报格式&lt;/h3&gt;
&lt;p&gt;网络层分组被称为&lt;strong&gt;数据报&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;：4比特，规定了数据报的IP协议版本。即区分IPv4和IPv6，路由器根据版本号确定如何处理数据报剩余的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首部长度&lt;/strong&gt;：一个IPv4数据报包含一些可变数量的选项，需要用这4比特来确定IP数据报中荷载（被封装的运输层报文）实际开始的地方。大多数数据报不包含选项，所以一般具有20字节的首部长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务类型&lt;/strong&gt;：区别不同类型的数据报（例如一些特别要求低时延、高吞吐量或可靠性的数据报）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据报长度&lt;/strong&gt;：16比特，IP数据报的总长度（包括首部），以字节为单位计；理论最大长度为65535字节。但数据报很少有超过1500字节，因为该长度是以太网帧的最大荷载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识、标志、片偏移&lt;/strong&gt;：这三个字段与IP分片有关。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寿命（Time-to-live, TTL）&lt;/strong&gt;：确保数据报不会永远在网络中循环。每当一台路由器处理数据报时，该字段的值减一，若TTL字段为0则该数据报必须丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上层协议&lt;/strong&gt;：该字段指示了IP数据报的数据部分应该交给哪个特定的运输层协议，只有当IP数据报到达最终目的地时才有用。例如值为6表示要交给TCP，值为17表示要交给UDP。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首部检验和&lt;/strong&gt;：将首部中每2个字节当作一个数，用反码算数对这些数求和。该和用于帮助路由器检测收到的IP数据报中的比特错误。路由器要对每个收到的IP数据报计算其首部检验和，如果数据报中携带的检验和与计算的不一致则检测出这是一个差错，需要将该分组丢弃。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP/IP在运输层与网络层都执行了差错检测，但检测有些区别：IP层只对IP首部计算了检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。另外TCP/UDP与IP不一定都必须属于同一个协议栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源和目的IP地址&lt;/strong&gt;：源生成一个数据报时写入它的IP地址和目的地IP地址，通常目的地址通过DNS查找来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：允许IP首部被扩展。很少使用，在IPv6中已将其去除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据（有效荷载）&lt;/strong&gt;：最重要的字段，交付给目的地运输层的报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipv4数据报分片&#34;&gt;IPv4数据报分片&lt;/h3&gt;
&lt;p&gt;并不是所有链路层协议都能承载相同长度的网络层分组，例如以太网能承载不超过1500字节的数据，而某些广域网帧可承载不超过576字节数据。一个链路层帧能承载的最大数据量叫作&lt;strong&gt;最大传送单元（MTU）&lt;/strong&gt;。链路层协议的MTU严格限制着IP数据报的长度。发送方与目的地路径之间的每段链路可能使用不同的链路层协议，每种协议可能有不同的MTU。&lt;/p&gt;
&lt;p&gt;为了能让过大的IP分组放入链路层帧有效的荷载字段，我们将IP数据报中的数据&lt;strong&gt;分片成&lt;/strong&gt;两个多更多个较小的数据报，用单独的链路层帧封装这些小的数据报，每个较小的数据报都称为&lt;strong&gt;片（fragment）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;片在到达目的地运输层前需要重新组装，TCP与UDP都希望从网路层收到完整的、未分片的报文。为了不影响路由器的性能，IPv4的设计者决定将片的重新组装工作放到&lt;strong&gt;端系统&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;当一台目的地主机从同一源收到一系列数据报时，需要确定这些数据报中的某些是否是一些原来较大的数据报的片；如果是这些片的话，还需要确定何时收到了最后一片，并且如何将这些片拼接起来形成初始的数据报。&lt;/p&gt;
&lt;p&gt;IPv4设计者将&lt;strong&gt;标识、标志和片偏移&lt;/strong&gt;字段放在IP数据报首部中。当生成一个数据报时，发送主机为该数据报贴上&lt;strong&gt;标识号&lt;/strong&gt;；发送主机通常将它发送的每个数据报的标识号加1；当某路由器需要对一个数据报分片时，形成的每个片具有原始数据报的&lt;strong&gt;源地址、目的地址和标识号&lt;/strong&gt;，目的主机能通过标识号确定哪些数据报实际上是同一较大数据报的片。&lt;/p&gt;
&lt;p&gt;IP是一种不可靠服务，有些片可能永远到达不了目的地；为了让目的主机相信它已经收到了初始数据报的最后一个片，最后一个片的&lt;strong&gt;标志比特&lt;/strong&gt;被设置为了0，而其他所有片的标志比特被设置为了1。另外为了让目的主机确认是否丢失了一个片（且能够按照正确顺序组装片），使用&lt;strong&gt;偏移字段&lt;/strong&gt;指定该片应该放在初始数据报的哪个位置。&lt;/p&gt;
&lt;h3 id=&#34;ipv4编址&#34;&gt;IPv4编址&lt;/h3&gt;
&lt;p&gt;一个IP地址与一个接口相关联，接口是主机与物理链路之间的边界。&lt;/p&gt;
&lt;p&gt;每个IP地址的长度为&lt;strong&gt;32比特（4字节）&lt;/strong&gt;，总共有约$2^{32}$，大约40亿个IP地址。这些地址通常按照&lt;strong&gt;点分十进制计法&lt;/strong&gt;书写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因特网的地址分配策略被称为&lt;strong&gt;无类别域间路由选择（Classless Interdomain Routing, CIDR）&lt;/strong&gt;，CIDR将子网寻址的概念一般化了。&lt;/p&gt;
&lt;p&gt;当使用子网寻址时，32比特的IP地址被划为两部分，并且具有点分十进制数形式&lt;code&gt;a.b.c.d/x&lt;/code&gt;，其中x指示了地址的第一部分中的比特数。&lt;/p&gt;
&lt;p&gt;形式为&lt;code&gt;a.b.c.d/x&lt;/code&gt;的地址的x最高比特构成了IP地址的&lt;strong&gt;网络部分&lt;/strong&gt;，经常被称为该地址的&lt;strong&gt;前缀（prefix）&lt;/strong&gt;，一个组成通常被分配一块连续的地址，即具有相同前缀的一段地址。&lt;/p&gt;
&lt;p&gt;使用单个网络前缀通告多个网络的能力称为&lt;strong&gt;地址聚合&lt;/strong&gt;，也成为&lt;strong&gt;路由聚合&lt;/strong&gt;；例如可以用&lt;code&gt;200.23.16.0/20&lt;/code&gt;通告&lt;code&gt;200.23.16.0/23&lt;/code&gt;这个网络。&lt;/p&gt;
&lt;p&gt;当地址不是按照层次的方式分配时，我么使用&lt;strong&gt;最长前缀匹配&lt;/strong&gt;来通告地址块。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;CIDR&lt;/strong&gt;采用前，IP地址的网络部分被限制为长度为8、16或24比特，称为&lt;strong&gt;分类编址&lt;/strong&gt;的编址方案，分别称为A、B、C类网络。但这种分配方案存在一些问题，一个C类子网仅能容纳$2^8-2=254$（其中两个地址预留用于特殊用途）台主机，而一个B类地址可以容纳$2^{16}-2=65534$台主机，对于许多组织来说又太大了。&lt;/p&gt;
&lt;p&gt;接下来介绍一个设备如何从某主机的地址块中分配到一个地址：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取一块地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个组织从ISP获取一个地址块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取主机地址：DHCP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过动态主机配置协议（Dynamic Host Configuration, DHCP）为本组织内的主机和路由器接口配置IP地址。&lt;/p&gt;
&lt;p&gt;DHCP具有即插即用能力，同时避免了网络管理员手动配置网络。&lt;/p&gt;
&lt;p&gt;通过DHCP给新客户分配地址的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DHCP服务器发现：客户使用&lt;strong&gt;DHCP发现报文&lt;/strong&gt;在UDP分组中向端口67发送报文，该报文封装在一个IP数据报中，DHCP客户使用广播目的地址255.255.255.255并且使用本主机源IP地址0.0.0.0。DHCP客户将IP数据报传递给链路层，链路层将该帧广播到所有与该子网连接的节点。&lt;/li&gt;
&lt;li&gt;DHCP服务器提供：DHCP服务器收到发现报文时，用&lt;strong&gt;DHCP提供报文&lt;/strong&gt;向客户作出相应，该报文向子网的所有节点广播，仍使用IP广播地址255.255.255.255。子网中可能存在几个DHCP服务器，客户可以选择位置较为优越的DHCP服务。每台服务器提供的报文包括收到发现报文的事物ID、向客户推荐的IP地址、网络掩码以及&lt;strong&gt;IP地址租用期&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;DHCP请求：新到达的客户从一个或多个DHCP服务器选择一个，并向选中的服务器发送&lt;strong&gt;DHCP请求报文&lt;/strong&gt;进行响应，回显配置参数。&lt;/li&gt;
&lt;li&gt;DHCP ACK：服务器用&lt;strong&gt;DHCP ACK报文&lt;/strong&gt;对DHCP请求报文进行响应，证实所要求的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nat&#34;&gt;NAT&lt;/h3&gt;
&lt;p&gt;网络地址转换使能的路由器对外界就像是一个具有单一IP地址的单一设备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPv4私有IP地址&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;规定区块名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;IP地址区块&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;IP数量&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;分类网络说明&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;子网掩码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;主机端位长&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;24位区块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10.0.0.0 – 10.255.255.255&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16,777,216&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单个A类网络&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10.0.0.0/8 (255.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;24位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20位区块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;172.16.0.0 – 172.31.255.255&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1,048,576&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16个连续B类网络&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;172.16.0.0/12 (255.240.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位区块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;192.168.0.0 – 192.168.255.255&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;65,536&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;256个连续C类网络&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;192.168.0.0/16 (255.255.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些地址只在专用网络中的设备上使用，即这些地址只对该网络中的设备有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络地址转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NAT路由器上有一张&lt;strong&gt;NAT转换表&lt;/strong&gt;，该表项中包含了&lt;strong&gt;端口号及其地址&lt;/strong&gt;，能够把从广域网到达NAT路由器的分组转发给需要到达的内部主机。&lt;/p&gt;
&lt;p&gt;要将专用网中一台设备的请求发送给广域网中的服务器，首先NAT路由器接收到主机发送的数据报，为该数据报生成一个新的源端口，然后将源IP替换为路由器广域网一侧接口的IP，NAT路由器可以选择任意一个当前未在NAT转换表中的源端口号，NAT协议可以支持超过60000个并行连接。&lt;/p&gt;
&lt;h3 id=&#34;ipv6&#34;&gt;IPv6&lt;/h3&gt;
&lt;p&gt;主要为了解决IPv4中32比特的IP地址空间即将用尽，同时改进和强化了IPv4的其他方面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPv6数据报格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/IPv6%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;IPv6引入了以下一些重要的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩大的地址容量&lt;/strong&gt;：IP地址长度从32比特增加到了128比特；IPv6还引入了一种&lt;strong&gt;任播地址&lt;/strong&gt;，这种地址可以使数据报交付给一组主机中的任意一个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化高效的40字节首部&lt;/strong&gt;：一些IPv4字段已经被被舍弃，具体内容如下。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流标签&lt;/strong&gt;：该字段可用于给特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种&lt;strong&gt;非默认服务质量&lt;/strong&gt;或&lt;strong&gt;需要实时服务&lt;/strong&gt;的流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是IPv6定义的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本&lt;/strong&gt;：这4比特用于表示IP版本号，IPv6将该字段设置为6&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量类型&lt;/strong&gt;：这8比特字段与IPv4中的服务类型字段含义相似&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流标签&lt;/strong&gt;：如上面讨论的，该字段用于标识一条数据报的流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有效荷载长度&lt;/strong&gt;：这16比特值作为一个无符号整数，给出了数据的字节数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下一首部&lt;/strong&gt;：标识数据字段交付给哪个协议&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳限制&lt;/strong&gt;：类似于IPv4的TTL，转发数据报的每台路由器对该字段内容减1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源地址和目的地址&lt;/strong&gt;：128比特的IPv6地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;：IPv6数据报的有效荷载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下内容是几个在IPv4数据报中出现但在IPv6数据报中已经不存在的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分片/重新组装&lt;/strong&gt;：IPv6不允许在中间路由器上i进行分片与重新组装，这种操作只能在源与目的地执行。如果路由器收到的IPv6数据报太大而不能转发到输出链路的话，只需丢掉这个数据报。分片与重新组装是一个耗时的操作，将该功能从路由器中删除并放入端系统中，大大加快了网路中的IP转发速率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;首部检验和&lt;/strong&gt;：因为因特网中运输层和数据链路层都进行了检验操作，IP设计者觉得在网路层中具有该项功能较为多余，所以将其去掉。&lt;strong&gt;快速处理IP分组&lt;/strong&gt;才是关注的重点。另外，IPv4首部中包含一个TTL字段，所以在每台路由器上都需要重新计算IPv4首部检验和。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选项&lt;/strong&gt;：使得IP首部字段成为定长的40字节。它没有消失，而可能出现在IPv6首部中由下一个首部指出的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;从IPv4到IPv6的迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过建立隧道在IPv4路由器之间传输IPv6数据报。借助于隧道，在隧道发送端可将整个IPv6数据报放到一个IPv4数据报的数据字段中。&lt;/p&gt;
&lt;h2 id=&#34;通用转发和sdn&#34;&gt;通用转发和SDN&lt;/h2&gt;
&lt;p&gt;软件定义网路：匹配加动作&lt;/p&gt;
&lt;p&gt;分组交换机&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络学习日志（五）——链路层</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
        <pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ -&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;将运行链路层协议的设备称为&lt;strong&gt;节点&lt;/strong&gt;，把沿通信链路连接相邻节点的通信信道称为&lt;strong&gt;链路&lt;/strong&gt;。经过特定链路时，节点将数据包封装在&lt;strong&gt;链路层帧&lt;/strong&gt;中，将该帧传送到链路中。&lt;/p&gt;
&lt;p&gt;链路层提供的服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;成帧&lt;/strong&gt;：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路接入&lt;/strong&gt;：**媒体访问控制协议(MAC)**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠交付&lt;/strong&gt;：链路层通过&lt;em&gt;确认和重传&lt;/em&gt;提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;差错检验和纠正&lt;/strong&gt;：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链路层协议的实现位置：&lt;strong&gt;网络适配器&lt;/strong&gt;（也成为网卡）来实现。&lt;/p&gt;
&lt;h2 id=&#34;差错检测和纠正技术&#34;&gt;差错检测和纠正技术&lt;/h2&gt;
&lt;p&gt;差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。&lt;/p&gt;
&lt;p&gt;这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。&lt;/p&gt;
&lt;h3 id=&#34;奇偶校验&#34;&gt;奇偶校验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;单个奇偶校验位&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/oneByteEvenParity.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为&lt;strong&gt;50%&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二维奇偶校验&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/twoDEvenParity.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;接收方&lt;/strong&gt;检测和纠正差错的能力被称为&lt;strong&gt;前向纠错（Forward Error Correction，FEC）&lt;/strong&gt;。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。&lt;/p&gt;
&lt;h3 id=&#34;检验和&#34;&gt;检验和&lt;/h3&gt;
&lt;p&gt;将d比特数据当作一个k比特的整数序列处理。&lt;strong&gt;因特网检验和&lt;/strong&gt;是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果&lt;em&gt;是否全为1比特&lt;/em&gt;来检验。如果这些比特中存在0比特，则出现差错。&lt;/p&gt;
&lt;p&gt;检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。&lt;/p&gt;
&lt;h3 id=&#34;循环冗余检测crc&#34;&gt;循环冗余检测（CRC）&lt;/h3&gt;
&lt;p&gt;冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。&lt;/p&gt;
&lt;p&gt;考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为&lt;strong&gt;G&lt;/strong&gt;。我们要求G的最高位有效比特为1.&lt;/p&gt;
&lt;p&gt;对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。&lt;/p&gt;
&lt;p&gt;用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。&lt;/p&gt;
&lt;h2 id=&#34;多路访问链路和协议&#34;&gt;多路访问链路和协议&lt;/h2&gt;
&lt;p&gt;网络链路的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。&lt;/li&gt;
&lt;li&gt;广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。&lt;/p&gt;
&lt;p&gt;因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。&lt;/p&gt;
&lt;p&gt;我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。&lt;/p&gt;
&lt;h3 id=&#34;信道划分协议&#34;&gt;信道划分协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;时分多路复用（TDM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设一个支持N个节点的信道传输速率为R bps。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/TDM.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDM将时间划分为&lt;strong&gt;时间帧（Frame）&lt;/strong&gt;，并进一步把每个时间帧划分为N个&lt;strong&gt;时隙（slot）&lt;/strong&gt;，把每个时隙分配给N个节点中的一个。&lt;/li&gt;
&lt;li&gt;无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。&lt;/li&gt;
&lt;li&gt;TDM消除了碰撞且非常公平，但存在以下缺点：
&lt;ul&gt;
&lt;li&gt;节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。&lt;/li&gt;
&lt;li&gt;节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;频分多路复用（FDM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/FDM.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FDM将R bps信道划分为不同频段，每个频段有R/N带宽，并把每个频率分配给N个节点中的一个。&lt;/li&gt;
&lt;li&gt;与TDM有相同的优点和缺点：
&lt;ul&gt;
&lt;li&gt;避免了碰撞，公平划分了带宽，但每个节点只能使用R/N的带宽，即使它是唯一一个有分组发送的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;码分多址（CDMA）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码分多址（Code Division Multiple Access）对每个节点分配一种不同的&lt;strong&gt;编码&lt;/strong&gt;，每个节点用其&lt;strong&gt;唯一的编码&lt;/strong&gt;来对发送的数据进行编码，CMDA有一种特性，即不同的节点能同时传输，并且各自的接收方仍能正确接受发送方编码的数据比特，而不在乎其他节点的干扰传输。&lt;/p&gt;
&lt;h3 id=&#34;随机接入协议&#34;&gt;随机接入协议&lt;/h3&gt;
&lt;p&gt;随机接入协议中，每个传输节点总以&lt;strong&gt;信道的全部速率&lt;/strong&gt;发送，当有碰撞时，涉及碰撞的每个节点重复发送它的帧，直到该帧无碰撞地通过。当一个节点经历一次碰撞时，不必重发该帧，在重发前等待一个&lt;strong&gt;随机时延&lt;/strong&gt;，涉及碰撞的每个节点独立地选择随机时延。&lt;/p&gt;
&lt;p&gt;以下为一些最常用的随机接入协议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时隙ALOHA&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;假设条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有帧由L比特组成。&lt;/li&gt;
&lt;li&gt;时间被划分为L/R秒的时隙。&lt;/li&gt;
&lt;li&gt;节点只在时隙起点开始传输帧。&lt;/li&gt;
&lt;li&gt;节点是同步的，每个节点都知道时隙何时开始。&lt;/li&gt;
&lt;li&gt;如果一个时隙中有两个或多个帧碰撞，则所有节点在该时隙结束前检测到该碰撞事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另p为一个概率，即一个在0和1之间的数，在每个节点中，时隙ALOHA的操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传送它。&lt;/li&gt;
&lt;li&gt;若没有碰撞，则节点成功传送帧，无需重传。&lt;/li&gt;
&lt;li&gt;若有碰撞，则该节点在时隙结束前检测到该碰撞，以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当具有多个活跃节点时，经计算，该协议的&lt;strong&gt;最大效率仅为37%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具有碰撞检测的载波侦听多路访问（CSMA/CD）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;载波侦听：一个节点在传输前先听信道；如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。&lt;/li&gt;
&lt;li&gt;碰撞检测：当一个传输节点传输时一直在侦听此信道，如果它检测到另一个节点正在传输干扰帧，它就停止传输。在重复“侦听-当空闲时传输”循环之前等待一段随机时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;轮流协议&#34;&gt;轮流协议&lt;/h3&gt;
&lt;p&gt;轮流协议能够实现当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轮询协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有节点之一指定为&lt;strong&gt;主节点&lt;/strong&gt;，主节点以循环的方式&lt;strong&gt;轮询&lt;/strong&gt;每个节点。例如，主节点向节点1发送一个报文，告诉它能够传输的帧的最多数量，在节点1传输了一些帧后，主节点告诉节点2它能传输的帧的最多数量。以此循环的方式轮询每个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;令牌传递协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该协议中没有主节点，有一个称为**令牌(token)**的小的特殊帧在节点间以某种固定次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时才持有这个令牌，否则它立即向下一个节点转发该令牌。令牌传递是分散的，有很高的效率。&lt;/p&gt;
&lt;h2 id=&#34;交换局域网&#34;&gt;交换局域网&lt;/h2&gt;
&lt;h3 id=&#34;链路层寻址和地址解析协议arp&#34;&gt;链路层寻址和地址解析协议（ARP）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;链路层地址在主机或路由器的**适配器(网络接口)**中，所以具有多个网络接口的主机和路由器将有与之相关联的多个链路层地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路层交换机&lt;/strong&gt;并不具有与他们的接口相关联的链路层地址，因为链路层交换机的任务是在&lt;strong&gt;主机与路由器之间承载数据报&lt;/strong&gt;，主机或路由器不必将帧寻址到其之间的交换机，交换机透明地执行该项任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的适配器都有不同的MAC地址，这由IEEE来分配管理。&lt;/p&gt;
&lt;p&gt;某适配器要向目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插入帧中，将该帧发送到局域网中；当适配器接收到一个MAC地址时将其与自己的MAC地址进行比较，检查是否匹配，如果匹配则提取出封装的数据包并沿协议栈向上传送，如果不匹配则丢弃该帧。&lt;/p&gt;
&lt;p&gt;有时发送适配器要让局域网中&lt;strong&gt;所有其他适配器&lt;/strong&gt;接受并处理他发送的帧，发送适配器在该帧的目的地址字段插入一个特殊MAC&lt;strong&gt;广播地址&lt;/strong&gt;，对于使用6字节地址的局域网来说，广播地址为48个1组成的字符串，即以16进制表示为&lt;strong&gt;FF-FF-FF-FF-FF-FF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址解析协议（ARP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARP是用来转换网络层&lt;strong&gt;IP地址&lt;/strong&gt;和链路层&lt;strong&gt;MAC地址&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;假设发送主机要向目的主机发送IP数据报，源要向其适配器提供数据报和目的主机的MAC地址，此后源适配器才构造一个包含目的MAC地址的帧发送到局域网中。&lt;/p&gt;
&lt;p&gt;发送主机使用ARP确定目的主机IP地址对应的MAC地址。发送主机向其ARP模块发送目的主机的IP，ARP将IP解析为一个MAC地址。&lt;/p&gt;
&lt;p&gt;每台主机或路由器的内存中有一个&lt;strong&gt;ARP表&lt;/strong&gt;，该表包含了IP地址到MAC地址的映射关系。
&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/ARP%E8%A1%A8.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果发送方ARP表中&lt;strong&gt;没有目的主机的表项&lt;/strong&gt;，则发送方构造一个&lt;strong&gt;ARP分组&lt;/strong&gt;（分组包括发送和接收IP地址以及MAC地址），并指示适配器用&lt;strong&gt;MAC广播地址&lt;/strong&gt;来发送这个分组，适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将帧传送进入子网，包含该ARP查询的帧能够被子网中的&lt;strong&gt;所有其他适配器&lt;/strong&gt;接收到，每个适配器都把该分组向上传递给ARP模块，ARP模块检查其IP地址是否与ARP分组中的目的IP匹配，若匹配则给查询主机发送回一个带有所希望映射的响应ARP分组，然后查询主机更新它的ARP表，然后发送它的IP数据报。&lt;/p&gt;
&lt;p&gt;查询ARP报文是在&lt;strong&gt;广播帧&lt;/strong&gt;中发送的，响应ARP报文是在一个&lt;strong&gt;标准帧&lt;/strong&gt;中发送的。&lt;/p&gt;
&lt;p&gt;最好把ARP看成跨越链路层和网络层边界两边的协议，因为其既包含IP地址又包含MAC地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送数据报到子网以外&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从一个子网将数据包发送到路由器，在从路由器发送到下一个子网的目的适配器，中间需要经过路由器的两个适配器，其中查询MAC地址的过程都是通过ARP来实现的。&lt;/p&gt;
&lt;h3 id=&#34;以太网&#34;&gt;以太网&lt;/h3&gt;
&lt;p&gt;一种广泛部署的有线局域网。&lt;/p&gt;
&lt;p&gt;以太网的安装使用星形拓扑结构，位于中心的是交换机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网帧结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/Ethernet_frame_structure.PNG&#34; alt=&#34;以太网帧结构&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data(数据字段)&lt;/strong&gt;：46-1500字节，这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节，如果IP数据报超过1500字节，主机就要将该数据报分片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dest. address(目的地址)&lt;/strong&gt;：6字节，包含了目的适配器的MAC地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source address(源地址)&lt;/strong&gt;：6字节，包含了传输该帧到局域网上的适配器的MAC地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tyep(类型字段)&lt;/strong&gt;：2字节，类型字段允许以太网复用多种网络协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRC&lt;/strong&gt;：4字节，使接收适配器检测帧中是否引入了差错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Preamble(前同步码)&lt;/strong&gt;：8字节，前7字节的值都是10101010；最后一个字节是10101011。前同步码的前7字节用于唤醒接收适配器，将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特（第一个出现的两个连续的1）警告接收适配器，重要的内容就要来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以太网技术都向网络层提供&lt;strong&gt;无连接&lt;/strong&gt;服务。当适配器A向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并把帧发送到局域网上，没有先与适配器B握手。&lt;/p&gt;
&lt;p&gt;以太网技术都向网络层提供&lt;strong&gt;不可靠&lt;/strong&gt;服务。当适配器B收到来自适配器A的一个帧时，对该帧执行CRC校验，但当该帧通过CRC校验时不发送确认帧，当该帧没有通过CRC校验时也不发送否定确认帧。当某帧没有通过CRC校验时适配器B只是丢弃该帧，A并不知道它传输的帧是否到达B且通过校验，意味着传递到网络层的数据报流有间隙。&lt;/p&gt;
&lt;p&gt;丢弃以太网帧后存在了间隙，主机B上的应用可以通过运输层看到这个间隙。当使用UDP协议时，B中的应用会看到这个间隙；当使用TCP协议时，B中的TCP将不会确认包含在丢弃帧中的数据，从而引起主机A的TCP重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网技术的发展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同速率的以太网：10BASE-T、10BASE-2、100BASE-T、1000BASE-LX和10GBASE-T；第一部分数字代表该标准的速率：10、100、1000、10G；BASE指基带以太网，意味着物理媒体仅承载以太网流量；最后一部分指代物理媒介本身，T指双绞铜线。这些技术指标已经被IEEE 802.3 CSMA/CD标准化。&lt;/p&gt;
&lt;h3 id=&#34;链路层交换机&#34;&gt;链路层交换机&lt;/h3&gt;
&lt;p&gt;交换机的任务是接收入链路层帧并将它们转发到出链路。交换机对子网的主机和路由器是&lt;strong&gt;透明&lt;/strong&gt;的，某主机/路由器向另一个主机/路由器寻址一个帧，顺利地将该帧发送进局域网，并不知道交换机将会接收帧并将它转发到另一个节点。交换机的输出接口设有&lt;strong&gt;缓存&lt;/strong&gt;，防止输入输出链路速率存在差别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换机转发和过滤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤：决定一个帧应该转发到某个接口还是应当将其丢弃。&lt;/li&gt;
&lt;li&gt;转发：决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交换机的过滤和转发借助于&lt;strong&gt;交换机表&lt;/strong&gt;完成。交换机表包含某局域网上某些主机和路由器的表项。&lt;/p&gt;
&lt;p&gt;一个表项包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个MAC地址&lt;/li&gt;
&lt;li&gt;通向该MAC地址的交换机接口&lt;/li&gt;
&lt;li&gt;表项放置在表中的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当交换机的表是完整的时，无需任何广播就向着目的地转发帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交换机的表是自动、动态和自治地建立的，这种能力通过以下方式实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机表初始为空&lt;/li&gt;
&lt;li&gt;对于在接口接收到的每个入帧，该交换机在其表中存储：该帧源地址字段的MAC地址，该帧的到达接口，当前时间。&lt;/li&gt;
&lt;li&gt;如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交换机是&lt;strong&gt;即插即用设备&lt;/strong&gt;，它们不需要网络管理员或用户的干预，也是双工的，可以同时发送和接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路层交换机的性质&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除碰撞：交换机缓存帧并且不会在网段上同时传输多余一个帧。&lt;/li&gt;
&lt;li&gt;异质的链路：交换机将链路彼此隔离，因此局域网中的不同链路能够以不同速率运行并且能够在不同媒体上运行。&lt;/li&gt;
&lt;li&gt;管理：易于进行网络管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟局域网vlan&#34;&gt;虚拟局域网（VLAN）&lt;/h3&gt;
&lt;p&gt;能够限制局域网广播流量；可以将交换机拆分，提高使用效率；能够更加方便地管理用户。&lt;/p&gt;
&lt;p&gt;不同VLAN之间需要通过路由器进行通信，因为VLAN将不同VLAN相互阻隔，一个VLAN中的设备无法直接通过目的MAC地址直接找到目的主机，而是需要通过路由器通过上层的IP进行查找。&lt;/p&gt;
&lt;h2 id=&#34;数据中心网络&#34;&gt;数据中心网络&lt;/h2&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Linux基础知识</title>
        <link>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <pubDate>Thu, 29 Jul 2021 08:44:21 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ -&lt;h2 id=&#34;系统启动过程&#34;&gt;系统启动过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内核的引导：BIOS开机自检，然后读入/boot目录的内核文件&lt;/li&gt;
&lt;li&gt;运行init：init进程是所有进程的起点，运行级别确定&lt;/li&gt;
&lt;li&gt;系统初始化：&lt;code&gt;rc.sysinit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建立终端&lt;/li&gt;
&lt;li&gt;用户登录系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统目录结构&#34;&gt;系统目录结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;：bin是二进制文件的缩写，存放着最常用的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/boot&lt;/code&gt;：存放启动时的核心文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt;：dev是Device的缩写，存放Linux的外部设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt;：Etcetera的缩写，用来存放所有系统管理所需的配置文件和子目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/home&lt;/code&gt;：主目录，Linux中，每个用户都有一个自己的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib&lt;/code&gt;：Library的缩写，存放着系统最基本的动态连接共享库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/media&lt;/code&gt;：自动识别一些设备，将其挂载到这个目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt;：该目录为了让用户临时挂载别的文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/opt&lt;/code&gt;：optional的缩写，给主机额外安装软件所设置的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc&lt;/code&gt;：Processes进程的缩写，是一种虚拟文件系统，存放着当前内核运行状态的一系列特殊文件。该目录不再硬盘上，而是在内存中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/root&lt;/code&gt;：系统管理员主目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt;：temporary的缩写，用来存放临时目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt;：unix shared resources共享资源的缩写，用户的很多应用程序和文件存放于此，类似于windows下的program files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/bin&lt;/code&gt;：系统用户使用的应用程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/src&lt;/code&gt;：内核源代码默认的存放目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var&lt;/code&gt;：variable的缩写，存放着不断扩充着的东西，将经常被修改的目录放在这个目录下，包括各种日志文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件基本属性&#34;&gt;文件基本属性&lt;/h2&gt;
&lt;p&gt;Linux系统是一种多用户系统，不同用户有不同权限。&lt;/p&gt;
&lt;p&gt;通常使用以下命令来修文件和目录的权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chown(change ownerp)：修改所属用户与组&lt;/li&gt;
&lt;li&gt;chmod(change mode)：修改用户的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Linux中使用&lt;code&gt;ll&lt;/code&gt;或&lt;code&gt;ls -l&lt;/code&gt;来显示一个文件的属性以及文件所属的用户和组。&lt;/p&gt;
&lt;p&gt;第一个字符代表这个文件的类型，是目录、文件或连接文件等等：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;d&lt;/code&gt;为目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt;为文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;l&lt;/code&gt;为链接文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;为可存储的接口设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt;为串行端口设备&lt;/p&gt;
&lt;p&gt;接下来的字符以三个为一组，为&lt;code&gt;rwx&lt;/code&gt;三个参数的组合，&lt;code&gt;r&lt;/code&gt;代表可读，&lt;code&gt;w&lt;/code&gt;代表可写，&lt;code&gt;x&lt;/code&gt;代表可执行，从前到后分别代表user、group、everyone的权限，如果没有权限，则用&lt;code&gt;-&lt;/code&gt;表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于root用户，文件权限不起作用。&lt;/p&gt;
&lt;h3 id=&#34;chgrp改变文件属组&#34;&gt;chgrp：改变文件属组&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chgrp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-R&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属组名 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;-R&lt;/code&gt;：recursion，递归，改变目录下所有文件的属性&lt;/p&gt;
&lt;h3 id=&#34;chown更改文件属主也可以同时更改文件属组&#34;&gt;chown：更改文件属主，也可以同时更改文件属组&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chown &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-R&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属主名 文件名
chown &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-r&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属主名:属组名 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;chmod更改文件的9个属性&#34;&gt;chmod：更改文件的9个属性&lt;/h3&gt;
&lt;p&gt;9个权限分别为&lt;strong&gt;owner/group/others(拥有者/组/其他)&lt;/strong&gt; 三种身份各有自己的 &lt;strong&gt;read/write/execute&lt;/strong&gt; 权限。&lt;/p&gt;
&lt;p&gt;第一种方法使用数字来表示，各权限的分数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r：4&lt;/li&gt;
&lt;li&gt;w：2&lt;/li&gt;
&lt;li&gt;x：1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： &lt;strong&gt;-rwxrwx&amp;mdash;&lt;/strong&gt; 分数则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;owner = rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;group = rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;others= &amp;mdash; = 0+0+0 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以等一下我们设定权限的变更时，该文件的权限数字就是 &lt;strong&gt;770&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;第二种方法是使用符号类型改变权限，这里不详细介绍。&lt;/p&gt;
&lt;h2 id=&#34;文件与目录管理&#34;&gt;文件与目录管理&lt;/h2&gt;
&lt;h3 id=&#34;处理目录常用命令&#34;&gt;处理目录常用命令：&lt;/h3&gt;
&lt;p&gt;ls（list files）：列出目录和文件名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a：全部文件，联通隐藏文件&lt;/li&gt;
&lt;li&gt;-d：仅列出目录本身&lt;/li&gt;
&lt;li&gt;-l：长数据串列出，包含文件属性与权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cd（change directory）：切换目录&lt;/p&gt;
&lt;p&gt;pwd（print work directory）：显示当前目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-P：显示出实际的路径，而不是连结（link）路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mkdir（make directory）：创建一个新目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-m：配置文件的权限&lt;/li&gt;
&lt;li&gt;-p：可以递归创建多级目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rmdir（remove directory）：删除一个空目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-p：连同上一级的空目录一起删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cp（copy file）：复制文件或目录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-adfilprsu&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 来源档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; 目标档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;destination&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
cp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; source1 source2 ... directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-a：相当于-pdr&lt;/li&gt;
&lt;li&gt;-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身&lt;/li&gt;
&lt;li&gt;-f：force，若目标文件已存在且无法开启，则移除后再尝试一次&lt;/li&gt;
&lt;li&gt;-i：若目标档已存在时，在覆盖时会先询问&lt;/li&gt;
&lt;li&gt;-p：连同文件属性一起复制过去&lt;/li&gt;
&lt;li&gt;-f：递归持续复制，用于目录的复制&lt;/li&gt;
&lt;li&gt;-s：复制成为符号连结档(symbolic link)&lt;/li&gt;
&lt;li&gt;-u：若destination比source旧才升级destination&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rm（remove）：删除文件或目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-f：force&lt;/li&gt;
&lt;li&gt;-r：递归删除，常用在目录的删除&lt;/li&gt;
&lt;li&gt;-i：互动模式，删除前会询问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mv（move file）：移动文件与目录，或修改文件、目录名称&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mv &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-fiu&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 来源档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; 目标档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;destination&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
mv &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; source1 source2 ... directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-f：force&lt;/li&gt;
&lt;li&gt;-i：若目标文件 (destination) 已经存在时，就会询问是否覆盖&lt;/li&gt;
&lt;li&gt;-u：目标文件已经存在，且 source 比较新，才会升级 (update)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件内容查看&#34;&gt;文件内容查看&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cat：从第一行开始显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tac：从最后一行开始显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nl：显示行号并列出文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;more：一页一页显示和翻动文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空白键 (space)：代表向下翻一页；&lt;/li&gt;
&lt;li&gt;Enter     ：代表向下翻『一行』；&lt;/li&gt;
&lt;li&gt;/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；&lt;/li&gt;
&lt;li&gt;:f      ：立刻显示出档名以及目前显示的行数；&lt;/li&gt;
&lt;li&gt;q       ：代表立刻离开 more ，不再显示该文件内容。&lt;/li&gt;
&lt;li&gt;b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;head：取出文件前面几行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;head &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-n number&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tail：取出文件后面几行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;tail &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-n number&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h2&gt;
&lt;p&gt;常用的三个命令：df、du、fdisk&lt;/p&gt;
&lt;p&gt;df：列出文件系统的整体磁盘使用量&lt;/p&gt;
&lt;p&gt;du：检查磁盘空间使用量&lt;/p&gt;
&lt;p&gt;fdisk：用于磁盘分区&lt;/p&gt;
&lt;h2 id=&#34;配置wsl2开发环境&#34;&gt;配置WSL2开发环境&lt;/h2&gt;
&lt;h3 id=&#34;cc&#34;&gt;C/C++&lt;/h3&gt;
&lt;p&gt;见&lt;a href=&#34;https://code.visualstudio.com/docs/cpp/config-wsl&#34;&gt;Using C++ and WSL in VS Code&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;p&gt;使用脚本安装Anaconda&lt;/p&gt;
- https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络各层级理解</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</link>
        <pubDate>Fri, 23 Jul 2021 12:59:05 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ -&lt;p&gt;一年多前按照层级详细学习了计算机网络的有关内容，包括从应用层、传输层、网络层、数据链路层到物理层的详细信息，并且也学习了一些其他硬件通信协议，比如CAN控制器局域网、SPI等等。在之后的应用和实践中经常对不同层级的网络和网络设备产生疑惑，例如路由器和交换机到底是什么关系？为什么要通过IP地址和MAC地址划分网络层和数据链路层？这里将会详细说明各层网络的具体作用来加深理解和体会。&lt;/p&gt;
&lt;h2 id=&#34;应用层&#34;&gt;应用层&lt;/h2&gt;
&lt;p&gt;应用层是计算机网络体系结构中最高层，意味着这是&lt;strong&gt;和人进行交互&lt;/strong&gt;的层次。&lt;/p&gt;
&lt;p&gt;应用层是计算机网络与用户进行交互的&lt;strong&gt;接口&lt;/strong&gt;或界面，直接向用户提供服务；包括Web、E-mail、DNS、DHCP、FTP等等。&lt;/p&gt;
&lt;p&gt;应用层要解决的主要问题就是如何为用户提供&lt;strong&gt;高效、可靠、满意&lt;/strong&gt;的服务，工程师要根据不同业务场景使用不同技术方法解决这些问题，比如使用多线程、高并发的Web框架，分布式处理等等。&lt;/p&gt;
&lt;h2 id=&#34;传输层&#34;&gt;传输层&lt;/h2&gt;
&lt;p&gt;负责&lt;strong&gt;端到端（进程之间）&lt;strong&gt;的通信。位于两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种&lt;/strong&gt;网络应用进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;端到端的传输分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟传输连接的建立&lt;/li&gt;
&lt;li&gt;源端用户数据沿着传输连接传送到目的端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个数据传输过程中传输层需要完成以下基本功能：传输层寻址、传输连接建立、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和多路分解、崩溃恢复。&lt;/p&gt;
&lt;h2 id=&#34;网络层&#34;&gt;网络层&lt;/h2&gt;
&lt;p&gt;也被称为中转层。他很重要也很复杂，既要解决不同网络的节点通信的路由和协议识别问题，又要通过路由选择策略解决网络拥塞问题。&lt;/p&gt;
&lt;p&gt;网络层主要是为了解决不同网络之间&lt;strong&gt;数据传输和转发&lt;/strong&gt;问题。&lt;/p&gt;
&lt;h2 id=&#34;数据链路层&#34;&gt;数据链路层&lt;/h2&gt;
&lt;p&gt;在原始的、有差错的物理传输线路的基础上，采用差错检测、差错控制和流量控制等方法，将有差错的物理线路改成逻辑上无差错的数据链路，为上一层（网络层）提供高质量服务。&lt;/p&gt;
&lt;p&gt;数据链路层主要是为了&lt;strong&gt;控制数据传输&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;物理层&#34;&gt;物理层&lt;/h2&gt;
&lt;p&gt;位于体系结构最底层，负责在物理介质上位数据链路层提供&lt;strong&gt;原始比特流&lt;/strong&gt;传输的&lt;strong&gt;物理链接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;物理层解决的问题就是&lt;strong&gt;数据传输&lt;/strong&gt;，所有数据到达物理层都会变成二进制的载波信号。&lt;/p&gt;
&lt;h2 id=&#34;交换机和路由器&#34;&gt;交换机和路由器&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&#34;http://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/#wlan%e5%9f%ba%e7%a1%80%e5%86%85%e5%ae%b9&#34;&gt;WLAN基本内容和802.11ax&lt;/a&gt;中的内容。&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>LaTex环境配置和基本功能模块</title>
        <link>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</link>
        <pubDate>Sun, 18 Jul 2021 20:06:26 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ -&lt;h2 id=&#34;环境配置&#34;&gt;环境配置&lt;/h2&gt;
&lt;p&gt;我选择使用VS code + Tex Live作为我的LaTex写作环境，具体配置过程参考自：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/166523064&#34;&gt;Visual Studio Code (vscode)配置LaTeX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是关于使用过程中一些具体模块的讨论：&lt;/p&gt;
&lt;p&gt;部分内容参考自：&lt;a href=&#34;https://liam.page/2014/09/08/latex-introduction/&#34;&gt;一份其实很短的 LaTeX 入门文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里使用&lt;code&gt;xeLatTex&lt;/code&gt;进行编译。&lt;/p&gt;
&lt;h2 id=&#34;基本文档和中英文&#34;&gt;基本文档和中英文&lt;/h2&gt;
&lt;h3 id=&#34;基本文档&#34;&gt;基本文档&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;article&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;% 这里是导言区
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
Hello, world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tex以&lt;code&gt;%&lt;/code&gt;作为注释标记。若要输出百分号&lt;code&gt;%&lt;/code&gt;字符本身，则要在前面加上反斜杠&lt;code&gt;\&lt;/code&gt;进行转义（escape）。&lt;/p&gt;
&lt;h3 id=&#34;中英文混排&#34;&gt;中英文混排&lt;/h3&gt;
&lt;p&gt;目前XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题。至此，我们只需要使用几个简单的宏包，就能完成中文支持了。&lt;/p&gt;
&lt;p&gt;我们使用&lt;code&gt;\usepackage{}&lt;/code&gt;来调用宏包。&lt;/p&gt;
&lt;p&gt;另外，我们使用&lt;code&gt;CTex&lt;/code&gt;宏集来处理中文的版式和标点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
你好，world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与开始相比，文档类别变为&lt;code&gt;ctexart&lt;/code&gt;，并且增加了文档类选项&lt;code&gt;UTF8&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;组织文章基本内容&#34;&gt;组织文章基本内容&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;标题、作者、日期&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\title&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好，world!&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Eternity&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\today&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\maketitle&lt;/span&gt;
你好，world!
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码中的控制序列&lt;code&gt;\maketitle&lt;/code&gt;能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。&lt;/p&gt;
&lt;p&gt;可以通过宏包&lt;code&gt;titling&lt;/code&gt;修改上述默认格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_1.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;章节和段落&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[UTF8]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;ctexart&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\title&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好，world!&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Liam&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\today&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\maketitle&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\section&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;你好中国&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
中国在East Asia.
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello Beijing&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
北京是capital of China.
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsubsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello Dongcheng District&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\paragraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Tian&amp;#39;anmen Square&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
is in the center of Beijing
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subparagraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Chairman Mao&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
is in the center of 天安门广场。
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\subsection&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;Hello 山东&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\paragraph&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;山东大学&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt; is one of the best university in 山东。
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文档类&lt;code&gt;article&lt;/code&gt;/&lt;code&gt;ctexart&lt;/code&gt;中定义了5个控制序列来调整文章组织结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\section{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subsection{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subsubsection{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\paragraph{·}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\subparagraph{·}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_2.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;插入目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在控制序列&lt;code&gt;\maketitle&lt;/code&gt;加入&lt;code&gt;tableofcontents&lt;/code&gt;，编译两次观察效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_3.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;LaTeX 将一个换行当做是一个简单的空格来处理，如果需要换行另起一段，则需要用两个换行（一个空行）来实现。&lt;/p&gt;
&lt;h2 id=&#34;版面设置&#34;&gt;版面设置&lt;/h2&gt;
&lt;h3 id=&#34;页边距&#34;&gt;页边距&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;geometry&lt;/code&gt; 宏包。&lt;a href=&#34;https://texdoc.org/serve/geometry.pdf/0&#34;&gt;geometry文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;geometry&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\geometry&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;papersize=&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;20cm,15cm&lt;span style=&#34;color:#007020&#34;&gt;}}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\geometry&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;left=1cm,right=2cm,top=3cm,bottom=4cm&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;页眉页脚&#34;&gt;页眉页脚&lt;/h3&gt;
&lt;p&gt;设置页眉页脚，推荐使用 &lt;code&gt;fancyhdr&lt;/code&gt; 宏包。&lt;a href=&#34;https://texdoc.org/serve/fancyhdr.pdf/0&#34;&gt;fancyhdr文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;fancyhdr&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\pagestyle&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;fancy&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lhead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\author&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\chead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\date&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\rhead&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;152xxxxxxxx&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\cfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\thepage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\rfoot&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\headrulewidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;0.4pt&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\headwidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\textwidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\renewcommand&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\footrulewidth&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;0pt&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;行间距&#34;&gt;行间距&lt;/h3&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;setspace&lt;/code&gt; 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;setspace&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\onehalfspacing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;段间距&#34;&gt;段间距&lt;/h3&gt;
&lt;p&gt;我们可以通过修改长度 &lt;code&gt;\parskip&lt;/code&gt; 的值来调整段间距。例如在导言区添加以下内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\addtolength&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\parskip&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;.4em&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;希望代码中的特殊字符不被LaTex处理，并且希望有代码高亮。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;listings&lt;/code&gt;宏包来在tex中添加代码段。基本设置参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;listings&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\lstset&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;
language=Matlab,
escapeinside=``, 
numbers=left,
numberstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\tiny&lt;/span&gt;,
breaklines=true, 
backgroundcolor=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;lightgray!40!white&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;,
frame=single,
framerule=0pt,
extendedchars=false, 
keywordstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;blue!70&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\bfseries&lt;/span&gt;, 
basicstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\ttfamily&lt;/span&gt;,
commentstyle=&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\ttfamily\color&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;green!40!black&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;, 
showstringspaces=false&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 &lt;code&gt;graphicx&lt;/code&gt; 宏包提供的 &lt;code&gt;\includegraphics&lt;/code&gt; 命令。比如你在你的 TeX 源文件同目录下，有名为 &lt;code&gt;a.jpg&lt;/code&gt; 的图片，你可以用这样的方式将它插入到输出文档中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\documentclass&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;article&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;graphicx&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\includegraphics&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;a.jpg&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;document&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 &lt;code&gt;\includegraphics&lt;/code&gt; 控制序列的可选参数来控制。比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\includegraphics&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;[width = .8\textwidth]&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;a.jpg&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样图片的宽度会被缩放至&lt;strong&gt;页面宽度的百分之八十&lt;/strong&gt;，图片的总高度会按比例缩放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;\includegraphics&lt;/code&gt;还有很多其他控制序列可以选择使用，可以查看宏包选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tabular&lt;/code&gt; 环境提供了最简单的表格功能。它用 &lt;code&gt;\hline&lt;/code&gt; 命令表示横线，在列格式中用 &lt;code&gt;|&lt;/code&gt; 表示竖线；用 &lt;code&gt;&amp;amp;&lt;/code&gt; 来分列，用 &lt;code&gt;\\&lt;/code&gt; 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 &lt;code&gt;l&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;、&lt;code&gt;r&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;tabular&lt;span style=&#34;color:#007020&#34;&gt;}{&lt;/span&gt;|l|c|r|&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
操作系统&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; 发行版&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; 编辑器&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Windows &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; MikTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TexMakerX &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Unix/Linux &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; teTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; Kile &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
Mac OS &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; MacTeX &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeXShop &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
通用&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeX Live &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt; TeXworks &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
 &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\hline&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;tabular&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h2 id=&#34;数学公式&#34;&gt;数学公式&lt;/h2&gt;
&lt;p&gt;在导言区添加&lt;code&gt;amsmath&lt;/code&gt;宏包来使用数学功能：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\usepackage&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;amsmath&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;数学模式&#34;&gt;数学模式&lt;/h3&gt;
&lt;p&gt;与Markdown中相同，LaTex共有&lt;strong&gt;行内公式&lt;/strong&gt;和&lt;strong&gt;行间公式&lt;/strong&gt;两种模式。&lt;/p&gt;
&lt;p&gt;在行文中，使用 &lt;code&gt;$ ... $&lt;/code&gt; 可以插入行内公式，使用 &lt;code&gt;\[ ... \]&lt;/code&gt; 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 &lt;code&gt;equation&lt;/code&gt; 环境：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;equation&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
...
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;equation&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;无编号的行间公式也可以使用 &lt;code&gt;\begin{displaymath} ... \end{displaymath}&lt;/code&gt; 或者 &lt;code&gt;\begin{equation*} ... \end{equation*}&lt;/code&gt; 来插入，但略显麻烦。（&lt;code&gt;equation*&lt;/code&gt; 中的 &lt;code&gt;*&lt;/code&gt; 表示环境不编号）&lt;/p&gt;
&lt;p&gt;也有 plainTeX 风格的 &lt;code&gt;$$ ... $$&lt;/code&gt; 来插入不编号的行间公式。但是在 LaTeX 中这样做会改变行文的默认行间距，不推荐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标点符号&#34;&gt;标点符号&lt;/h3&gt;
&lt;p&gt;行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。&lt;/p&gt;
&lt;h3 id=&#34;多行公式&#34;&gt;多行公式&lt;/h3&gt;
&lt;p&gt;有的公式特别长，我们需要手动为他们换行；&lt;/p&gt;
&lt;p&gt;有几个公式是一组，我们需要将他们放在一起；&lt;/p&gt;
&lt;p&gt;还有些类似分段函数，我们需要给它加上一个左边的花括号。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;长公式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不对齐：无须对齐的长公式可以使用 &lt;code&gt;multline&lt;/code&gt; 环境。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;multline&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
x = a+b+c+&lt;span style=&#34;color:#007020&#34;&gt;{}&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
d+e+f+g
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;multline&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;如果不需要编号，可以使用 &lt;code&gt;multline*&lt;/code&gt; 环境代替。&lt;/p&gt;
&lt;p&gt;对齐：需要对齐的公式，可以使用 &lt;code&gt;aligned&lt;/code&gt; &lt;em&gt;次环境&lt;/em&gt;来实现，它必须包含在数学环境之内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\[&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{aligned}
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x &lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{}&amp;amp; a&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{} &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;d&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;g
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{aligned}&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公式组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无需对齐的公式组可以使用 &lt;code&gt;gather&lt;/code&gt; 环境，需要对齐的公式组可以使用 &lt;code&gt;align&lt;/code&gt; 环境。他们都带有编号，如果不需要编号可以使用带&lt;code&gt;*&lt;/code&gt;的版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;gather&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
a = b+c+d &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
x = y+z
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;gather&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;align&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
a &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt;= b+c+d &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\\&lt;/span&gt;
x &lt;span style=&#34;color:#007020&#34;&gt;&amp;amp;&lt;/span&gt;= y+z
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{&lt;/span&gt;align&lt;span style=&#34;color:#007020&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;分段函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分段函数可以用&lt;code&gt;cases&lt;/code&gt;次环境来实现，它必须包含在数学环境之内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\[&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; y&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\begin&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{cases}
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x,&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\quad&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; x&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\leq&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;x,&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\quad&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt; x&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#963&#34;&gt;\end&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;{cases} &lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;\]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH10 泛型算法</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</link>
        <pubDate>Sun, 18 Jul 2021 09:16:32 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/ -&lt;p&gt;用来&lt;strong&gt;操纵容器&lt;/strong&gt;。泛型算法独立于任何特定容器，可用于不同类型的容器和不同类型的元素。这些算法是一些&lt;strong&gt;经典算法的公共接口&lt;/strong&gt;，例如排序和搜索。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法定义在&lt;code&gt;algorithm&lt;/code&gt;头文件中，标准库还在&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般这些算法并不直接操作容器，而是遍历由&lt;strong&gt;两个迭代器指定的一个元素范围&lt;/strong&gt;来进行操作。&lt;/p&gt;
&lt;p&gt;算法不依赖于容器，但依赖于元素类型的操作。&lt;/p&gt;
&lt;h2 id=&#34;基本算法&#34;&gt;基本算法&lt;/h2&gt;
&lt;h3 id=&#34;只读算法&#34;&gt;只读算法&lt;/h3&gt;
&lt;p&gt;只读取输入范围的元素，&lt;strong&gt;不改变元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;accumulate&lt;/code&gt;算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其定义在头文件numeric中，接受三个参数，前两个指出了需要求和元素的范围，第三个参数是和的初值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; accumulate(vec.cbegin(), vec.cend(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//对vec中元素求和，和的初值设为0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第三个参数的类型决定了函数中使用哪个&lt;strong&gt;加法运算符&lt;/strong&gt;以及&lt;strong&gt;返回值的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即序列中的元素必须与第三个参数&lt;strong&gt;匹配&lt;/strong&gt;或&lt;strong&gt;能够转换为第三个参数的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;equal&lt;/code&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确定两个序列的值是否保存相同的值，将第一个序列的每个元素与第二个序列的对应元素比较。该算法接受三个迭代器，前两个表示第一个序列的范围，第三个表示第二个序列的首元素。&lt;/p&gt;
&lt;p&gt;equal利用迭代器完成操作，因此我们可以调用equal来比较两个不同类型容器中的元素，并且元素类型也可以不同。&lt;/p&gt;
&lt;h3 id=&#34;写容器元素算法&#34;&gt;写容器元素算法&lt;/h3&gt;
&lt;p&gt;使用这类算法要保证序列原大小&lt;strong&gt;不小于&lt;/strong&gt;算法写入的元素数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fill&lt;/code&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fill接受&lt;strong&gt;一对迭代器&lt;/strong&gt;和&lt;strong&gt;一个值&lt;/strong&gt;，将这个值赋予输入序列中的每个元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;fill(vec.begin(), vec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不能在空容器上调用fill_n.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;back_inserter插入迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接受一个&lt;strong&gt;指向容器的引用&lt;/strong&gt;，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。&lt;/p&gt;
&lt;p&gt;back_inserter是一个定义在头文件iterator中的函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; vec;	&lt;span style=&#34;color:#888&#34;&gt;//空vector
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; back_inserter(vec);	&lt;span style=&#34;color:#888&#34;&gt;//通过其赋值将元素添加到vec中
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;拷贝算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;copy是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。&lt;/p&gt;
&lt;p&gt;该算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。&lt;/p&gt;
&lt;h3 id=&#34;重排容器元素算法&#34;&gt;重排容器元素算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;unique&lt;/code&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;elimDups&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;words)
{
	&lt;span style=&#34;color:#888&#34;&gt;//按字典排序words, 以便查找重复单词
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	sort(words.begin(), words.end());
	&lt;span style=&#34;color:#888&#34;&gt;//unique重排输入范围，使每个单词只出现一次
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; end_unique &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; unique(words.begin(), words.end());
	&lt;span style=&#34;color:#888&#34;&gt;//使用erase操作删除重复单词
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	words.erase(end_unique, words.end());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sort算法接受两个迭代器，表示要排序的元素范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用unique&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unique算法重排输入元素，将相邻的重复项消除，并返回一个指向不重复值范围末尾的迭代器。&lt;/p&gt;
&lt;h2 id=&#34;定制操作&#34;&gt;定制操作&lt;/h2&gt;
&lt;p&gt;很多算法会比较输入序列中的元素。默认情况下，这类算法使用&amp;lt;或==运算符完成比较。标准库还定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。&lt;/p&gt;
&lt;h3 id=&#34;向算法传递函数&#34;&gt;向算法传递函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;谓词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谓词是一个可调用的&lt;strong&gt;表达式&lt;/strong&gt;，其返回结果是一个能&lt;strong&gt;用作条件的值&lt;/strong&gt;。标准库算法使用的谓词分为：一元谓词和二元谓词。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;isShorter&lt;/span&gt;(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s1, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;s2) {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; s1.size() &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; s2.size();
}
sort(words.begin(), words.end(), isShorter);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;stable_sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该排序算法可以保持等长元素间的字典序。&lt;/p&gt;
&lt;h3 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h3&gt;
&lt;h3 id=&#34;lambda捕获和返回&#34;&gt;lambda捕获和返回&lt;/h3&gt;
&lt;h3 id=&#34;参数绑定&#34;&gt;参数绑定&lt;/h3&gt;
&lt;h2 id=&#34;再探迭代器&#34;&gt;再探迭代器&lt;/h2&gt;
&lt;p&gt;除了为每个容器定义的迭代器之外，标准库还在头文件iterator中定义了额外几种迭代器，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。&lt;/li&gt;
&lt;li&gt;流迭代器：这些迭代器被绑定到输入输出流上，可用来遍历所关联的IO流&lt;/li&gt;
&lt;li&gt;反向迭代器：这些迭代器向后移动而不是向前移动&lt;/li&gt;
&lt;li&gt;移动迭代器：（13.6.2节介绍）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入迭代器&#34;&gt;插入迭代器&lt;/h3&gt;
&lt;h3 id=&#34;iostream迭代器&#34;&gt;iostream迭代器&lt;/h3&gt;
&lt;h3 id=&#34;反向迭代器&#34;&gt;反向迭代器&lt;/h3&gt;
&lt;h2 id=&#34;泛型算法结构&#34;&gt;泛型算法结构&lt;/h2&gt;
&lt;p&gt;任何算法最基本的特征是其要求迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别：&lt;/p&gt;
&lt;p&gt;输入、输出、前向、双向、随机访问迭代器&lt;/p&gt;
&lt;h2 id=&#34;特定容器算法&#34;&gt;特定容器算法&lt;/h2&gt;
&lt;p&gt;链表类型list和forward_list定义了几个成员函数形式的算法。他们定义了几个成员函数形式的算法。它们定义了独有的sort、merge、remove、reverse和unique。将以成员函数的形式使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;splice成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表类型还定义了splice算法，该算法是链表数据结构所独有的，因此不需要通用版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.splice(args)
flst.splice_after(args)
(p, lst2)	&lt;span style=&#34;color:#888&#34;&gt;//p是一个指向lst中元素的迭代器或一个指向flst首前位置的迭代器。函数将lst2所有元素移动到lst中p之前的位置或flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或lst相同，且不能是同一个链表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;(p, lst2, p2)
(p, lst2, b, e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;链表特有的操作会改变容器&lt;/strong&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 2.信息的表示和处理（部分完成）</title>
        <link>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
        <pubDate>Mon, 12 Jul 2021 21:26:27 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ -&lt;p&gt;第一部分内容：程序结构和执行&lt;/p&gt;
&lt;p&gt;我们需要用方法表示&lt;strong&gt;基本数据类型&lt;/strong&gt;，然后考虑机器级指令如何操作这样的数据，以及编译器如何将C程序翻译成这样的指令。接下来研究集中处理器的方法，使得我们能够更好地了解硬件资源如何被用来执行指令。&lt;/p&gt;
&lt;h2 id=&#34;信息存储&#34;&gt;信息存储&lt;/h2&gt;
&lt;h3 id=&#34;十六进制表示法及转换&#34;&gt;十六进制表示法及转换&lt;/h3&gt;
&lt;p&gt;二进制和十进制对描述&lt;strong&gt;位模式&lt;/strong&gt;来说都不方便，因此采用16进制数(hex)来表示位模式。&lt;/p&gt;
&lt;p&gt;C语言中16进制数以0X或0x开头，字符‘A’~‘F’既可以是大写也可以是小写。&lt;/p&gt;
&lt;p&gt;二进制和十六进制之间的转换较为简单，不再赘述。&lt;/p&gt;
&lt;p&gt;十进制和十六进制数之间的转换要反复利用乘法和除法进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从十进制到十六进制：反复用16除十进制数&lt;/li&gt;
&lt;li&gt;从十六进制到十进制：用相应的16的幂乘以每个十六进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字数据大小&#34;&gt;字数据大小&lt;/h3&gt;
&lt;p&gt;字长指明指针数据的标称大小。虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是&lt;strong&gt;虚拟地址空间的最大大小&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对一个字长为w的机器而言，虚拟地址的范围是$0$ ~$2^w-1$，程序最多访问$2^w-1$个字节。&lt;/p&gt;
&lt;p&gt;近年，很多机器都从32位字长迁移到了64位字长。大多64位字长机器可以运行32位字长机器编译的程序。32位程序和64位程序的区别在于程序是&lt;strong&gt;如何编译&lt;/strong&gt;成的，而不是运行的机器类型。&lt;/p&gt;
&lt;h3 id=&#34;寻址和字节顺序&#34;&gt;寻址和字节顺序&lt;/h3&gt;
&lt;p&gt;小端法、大端法&lt;/p&gt;
&lt;p&gt;对于跨越多个字节的程序对象，我们必须明确：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个对象的地址是什么&lt;/li&gt;
&lt;li&gt;如何在内存中排列这些字节&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，多字节对象被存储为&lt;strong&gt;连续的字节序列&lt;/strong&gt;，对象的地址为所使用字节中&lt;strong&gt;最小的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小端法：将&lt;strong&gt;最低有效字节&lt;/strong&gt;放在最前面(最小地址)存储。（例如一个二进制数最右边的8位是最低有效字节）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大端法：将&lt;strong&gt;最高有效字节&lt;/strong&gt;放在最前面(最小地址)存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多Intel兼容机使用小端模式。&lt;/p&gt;
&lt;p&gt;以下代码使用强制类型转换来访问和打印不同程序对象的字节表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;byte_pointer;	&lt;span style=&#34;color:#888&#34;&gt;//将byte_pointer定义为一个指向类型为unsigned char对象的指针
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//指针被强制类型转换为unsigned char *, 这告诉编译器程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_bytes&lt;/span&gt;(byte_pointer start, size_t len)
{&lt;span style=&#34;color:#888&#34;&gt;//按顺序显示出指针指向对象的每个字节内容，可以判断出系统使用的小端法还是大端法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	size_t i;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
		printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%.2x&amp;#34;&lt;/span&gt;, start[i]);
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
}

&lt;span style=&#34;color:#888&#34;&gt;//使用sizeof确定对象使用的字节数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_int&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示int对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_float&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示float对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt;));
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;show_pointer&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;x)
{&lt;span style=&#34;color:#888&#34;&gt;//显示void *对象的字节内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	show_bytes((byte_pointer) &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;表示字符串&#34;&gt;表示字符串&lt;/h3&gt;
&lt;p&gt;对文本进行编码。&lt;/p&gt;
&lt;p&gt;ASCII编码、Unicode编码&lt;/p&gt;
&lt;p&gt;之前写过一篇相关博客：&lt;a href=&#34;http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/&#34;&gt;字符编码：Unicode, UTF-8&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;布尔代数&#34;&gt;布尔代数&lt;/h3&gt;
&lt;p&gt;四种布尔运算：&lt;/p&gt;
&lt;p&gt;与、或、非、异或&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异或：当P或Q为真但不同时为真时，异或成立；即当p=1且q=0或p=1且q=1时，p^q=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;位向量的布尔运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按位进行布尔运算。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的位级运算&#34;&gt;C语言中的位级运算&lt;/h3&gt;
&lt;p&gt;按照对应位进行布尔运算。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的逻辑运算&#34;&gt;C语言中的逻辑运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;逻辑运算和位级运算完全不同，逻辑运算认为所有非零的参数都表示TRUE，参数0表示FALSE。以下是一些表达式求值举例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;!0x41&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!0x00&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!!0x41&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;c语言中的移位运算&#34;&gt;C语言中的移位运算&lt;/h3&gt;
&lt;p&gt;左移k位：将操作数向左移动k位，丢弃掉最高的k位并在右端补k个0&lt;/p&gt;
&lt;p&gt;逻辑右移：在左端补k个0&lt;/p&gt;
&lt;p&gt;算数右移：在左端补k个最高有效位的值&lt;/p&gt;
&lt;p&gt;几乎所有编译器都对&lt;strong&gt;有符号数&lt;/strong&gt;使用&lt;strong&gt;算术右移&lt;/strong&gt;，对&lt;strong&gt;无符号数&lt;/strong&gt;使用逻辑右移。&lt;/p&gt;
&lt;h2 id=&#34;整数表示&#34;&gt;整数表示&lt;/h2&gt;
&lt;p&gt;用&lt;strong&gt;位&lt;/strong&gt;来编码整数的两种不同方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种只能表示&lt;strong&gt;非负数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;另一种能表示&lt;strong&gt;负数、零和正数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;整型数据类型&#34;&gt;整型数据类型&lt;/h3&gt;
&lt;p&gt;C语言通过&lt;strong&gt;关键字&lt;/strong&gt;来表示多种整型数据类型，这些关键字包括char、short、long，同时还能指示被表示的数字是非负数（声明为unsigned）。&lt;/p&gt;
&lt;p&gt;为不同大小分配的字节数根据程序编译为32位还是64位有所不同；根据字节分配，不同大小所能表示的值的范围是不同的。&lt;/p&gt;
&lt;p&gt;取值范围是不对称的，负数的范围比正数大1.&lt;/p&gt;
&lt;h3 id=&#34;无符号数的编码&#34;&gt;无符号数的编码&lt;/h3&gt;
&lt;p&gt;直接按照二进制进行编码即可。B2U：将二进制编码映射到一个非负整数&lt;/p&gt;
&lt;p&gt;无符号数的编码具有唯一性&lt;/p&gt;
&lt;h3 id=&#34;补码编码&#34;&gt;补码编码&lt;/h3&gt;
&lt;p&gt;(two&amp;rsquo;s-complement)。用来表示有符号数，将字的最高有效位解释为&lt;strong&gt;负权&lt;/strong&gt;，用$B2T_w$表示：
$$
B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2_i
$$
最高有效位$x_{w-1}$称为符号位，它的权重为$-2^{w-1}$，是无符号表示中权重的负数。&lt;/p&gt;
&lt;p&gt;从维向量到整数映射的举例：
$$
B2T_4([0001])=1 \
B2T_4([0101])=5 \
B2T_4([1011])=5 \
B2T_4([1111])=-1
$$
w位补码所能表示的值的范围是：$[-2^{w-1},2^{w-1}-1]$，例如长度为4的补码可以表示的范围是$[-8,7]$。与无符号数一样，在可表示的取值范围内，每个数字都唯一的w位补码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用补码来编码负数（有符号数）&lt;/strong&gt;。几乎所有现代机器目前都采用补码编码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反码：最高有效位的权是$-(2^{w-1}-1)$，其他和补码一样。&lt;/p&gt;
&lt;p&gt;原码：最高有效位是符号位，用来确定剩下的位应该取负权还是正权。&lt;/p&gt;
&lt;p&gt;这两种表示方式对于数字0都有两种不同的编码方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;有符号数和无符号数之间的转换&#34;&gt;有符号数和无符号数之间的转换&lt;/h3&gt;
&lt;p&gt;对于多数C语言的实现来说，这个问题都是从&lt;strong&gt;位级&lt;/strong&gt;角度来看的，而不是&lt;strong&gt;数&lt;/strong&gt;的角度。&lt;/p&gt;
&lt;p&gt;处理同样字长的有符号和无符号数之间相互转换的规则为：数值可能会改变，但&lt;strong&gt;位模式&lt;/strong&gt;不变。&lt;/p&gt;
&lt;p&gt;补码转换为无符号数$T2U_w(x)$，当x&amp;lt;0时值改变，计算结果为$x+2^w$，当x&amp;gt;0时值不变。&lt;/p&gt;
&lt;h3 id=&#34;c语言中的有符号数和无符号数&#34;&gt;C语言中的有符号数和无符号数&lt;/h3&gt;
&lt;p&gt;C语言支持所有整型数据类型的有符号和无符号计算，几乎所有机器都采用&lt;strong&gt;补码&lt;/strong&gt;表示有符号数。通常大多数数字都默认是有符号的。&lt;/p&gt;
&lt;h3 id=&#34;扩展一个数字的位表示&#34;&gt;扩展一个数字的位表示&lt;/h3&gt;
&lt;p&gt;将无符号数扩展为一个更大的数据类型：只需在表示的开头添加0即可。&lt;/p&gt;
&lt;p&gt;将一个补码扩展为一个更大的数据类型：执行一个&lt;strong&gt;符号扩展&lt;/strong&gt;，即在开头添加最高有效位数字。&lt;/p&gt;
&lt;p&gt;符号扩展不改变补码表示的数字。&lt;/p&gt;
&lt;h3 id=&#34;截断数字&#34;&gt;截断数字&lt;/h3&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;为了避免出现错误或漏洞，我们&lt;strong&gt;绝不使用无符号数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;整数运算&#34;&gt;整数运算&lt;/h2&gt;
&lt;h3 id=&#34;无符号加法&#34;&gt;无符号加法&lt;/h3&gt;
&lt;p&gt;两个无符号数相加，如果完整的整数结果不能放到数据类型的字长限制中去，那么就会发生溢出，当无符号数加法发生溢出时，结果为丢弃溢出的最高位后的结果，即减去$2^w$。&lt;/p&gt;
&lt;h3 id=&#34;补码加法&#34;&gt;补码加法&lt;/h3&gt;
&lt;p&gt;分为正溢出、正常、负溢出三种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正溢出：和减去$2^w$&lt;/li&gt;
&lt;li&gt;负溢出：和加上$2^w$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;补码的非&#34;&gt;补码的非&lt;/h3&gt;
&lt;p&gt;当$x=\text{TMin}_w$时，补码的非的结果为：$\text{TMin}_w$，否则结果为$-x$&lt;/p&gt;
&lt;h3 id=&#34;无符号乘法&#34;&gt;无符号乘法&lt;/h3&gt;
&lt;p&gt;乘积可能需要$2w$位来表示，C语言中无符号被定义为产生w位值，即2w乘积结果的低2w位。将一个无符号数截断为w位等价于计算该值模$2^w$&lt;/p&gt;
&lt;h3 id=&#34;补码乘法&#34;&gt;补码乘法&lt;/h3&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;计算机的整数运算实际上是一种模运算，表示数字时的有限字长限制了可能的值的取值范围，结果运算溢出。&lt;/p&gt;
&lt;p&gt;补码提供了一种既能表示整数也能表示负数的灵活方法，同时使用了与执行无符号算术相同的位级实现。&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;h3 id=&#34;二进制小数&#34;&gt;二进制小数&lt;/h3&gt;
&lt;h3 id=&#34;ieee浮点数表示&#34;&gt;IEEE浮点数表示&lt;/h3&gt;
&lt;h3 id=&#34;舍入&#34;&gt;舍入&lt;/h3&gt;
&lt;h3 id=&#34;浮点运算&#34;&gt;浮点运算&lt;/h3&gt;
- https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>CAN总线</title>
        <link>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</link>
        <pubDate>Mon, 12 Jul 2021 18:16:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/ -&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;
&lt;p&gt;Controller Area Network&lt;/p&gt;
&lt;p&gt;CAN总线由BOSCH公司开发，是一种多主控(Multi-Master)的现场总线系统，CAN网络的消息是广播式的，即同一时刻网络上所有节点侦测的数据是一致的，是一种基于&lt;strong&gt;消息广播&lt;/strong&gt;模式的串行通信总线。&lt;/p&gt;
&lt;p&gt;CAN总线的很多优点，使得它得到了广泛的应用，如传输速度最高到1Mbps, 通信距离最远到10km，无损位仲裁机制，多主结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAN总线标准&lt;/strong&gt;规定了&lt;strong&gt;物理层&lt;/strong&gt;和&lt;strong&gt;数据链路层&lt;/strong&gt;，应用层标准由具体应用决定。&lt;/p&gt;
&lt;h2 id=&#34;can物理层&#34;&gt;CAN物理层&lt;/h2&gt;
&lt;p&gt;连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的&lt;strong&gt;差分电平信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;节点主要包括Host、控制器和收发器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;常集成有CAN控制器，&lt;strong&gt;CAN控制器&lt;/strong&gt;负责处理协议相关功能，以减轻Host的负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAN收发器&lt;/strong&gt;将控制器连接到传输媒介。通常控制器和总线收发器通过光耦或磁耦隔离，这样即使总线上过压损坏收发器，控制器和Host设备也可以得到保护。&lt;/p&gt;
&lt;p&gt;在发送数据时，CAN控制器把要发送的二进制编码通过&lt;strong&gt;CAN_Tx线&lt;/strong&gt;发送到CAN收发器，然后由收发器把这个普通的逻辑电平信号转化成&lt;strong&gt;差分信号&lt;/strong&gt;，通过&lt;strong&gt;差分线CAN_High和CAN_Low&lt;/strong&gt;输出到CAN总线网络。接收数据过程，相反。采用差分信号，可以取得更好的电磁兼容效果。因此，CAN总线物理传输媒介只需要两根线。&lt;/p&gt;
&lt;p&gt;下图为一CAN收发器应用的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_example.PNG&#34; alt=&#34;CAN总线示例&#34;&gt;&lt;/p&gt;
&lt;p&gt;高速CAN总线最高信号传输速率为1Mbps，支持最长距离40m。ISO11898-2要求在高速CAN总线两段安装&lt;strong&gt;端接电阻&lt;/strong&gt;RL（端接电阻一般为120Ω，因为电缆的特性阻抗为120 Ω，为了模拟无限远的传输线。）以消除反射。低速CAN最高速度只有125Kbps，所以ISO11898-3没有端接要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_bus_Res.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;差分信号&#34;&gt;差分信号&lt;/h3&gt;
&lt;p&gt;CAN总线采用差分信号传输，通常情况下只需要两根信号线就可以进行正常的通信。在差分信号中，逻辑0和逻辑1是用两根差分信号线的电压差来表示。&lt;/p&gt;
&lt;p&gt;当处于&lt;strong&gt;逻辑1&lt;/strong&gt;，CAN_High和CAN_Low的电压差小于0.5V时，称为&lt;strong&gt;隐性电平（Recessive）&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;当处于&lt;strong&gt;逻辑0&lt;/strong&gt;，CAN_High和CAN_Low的电压差大于0.9V，称为&lt;strong&gt;显性电平（Dominant）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CAN总线遵从“线与”机制：“显性”位可以覆 盖“隐性”位；只有所有节点都发 送“隐性”位， 总线才处于“隐性” 状态。这种“线与”机制使CAN总线呈现显性优先的特性。&lt;/p&gt;
&lt;h2 id=&#34;can数据链路层&#34;&gt;CAN数据链路层&lt;/h2&gt;
&lt;p&gt;在SPI通信中，片选、时钟信号、数据输入及数据输出这四个信号都有单独的信号线。而CAN使用的是两条差分信号线，&lt;strong&gt;只能表达一个信号&lt;/strong&gt;。简洁的物理层决定了CAN必然要配上一套更为复杂的协议。如何用一个信号通道实现同样甚至更强大的功能，答案就是对数据或操作命令进行打包。&lt;/p&gt;
&lt;h3 id=&#34;通信机制&#34;&gt;通信机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多主机(Multi-Master)&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;安全敏感的应用（如汽车动力）对通信系统的&lt;strong&gt;可靠性&lt;/strong&gt;要求很高。将总线能否正常工作归结到单一节点是非常危险的，比较合理的方案是对总线接入的&lt;strong&gt;去中心化&lt;/strong&gt;，即每个节点都有接入总线的能力。这也是CAN总线采用多主控（Multi-Master）线性拓扑结构的原因。&lt;/p&gt;
&lt;p&gt;在CAN总线上，每个节点都有往总线上发送消息的能力，而消息的发送不必遵从任何预先设定的时序，通信是&lt;strong&gt;事件驱动&lt;/strong&gt;的。只有当有新的信息传递时，CAN总线才处于忙碌的状态，这使得节点接入总线速度非常快。CAN总线理论最高数据传输速率为1Mbps，对于异步事件反应迅速，基本对于ms级别的实时应用没有任何问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻址机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;CAN总线不设定节点的地址，而是通过消息的&lt;strong&gt;标识符（Identifier）&lt;strong&gt;来区别消息。这种机制虽然会增加消息的复杂度（增加标识符），但是节点在此情况下可以无需了解其他节点的状况，而&lt;/strong&gt;相互间独立工作&lt;/strong&gt;。在总线上增加节点时仅需关注消息类型，而非系统上其他节点的状况。这种以消息标识符寻址的方式，让总线上增加节点变得更加灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线访问 CSMA/CD+AMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多路载波侦听+基于消息优先级的冲突检测和非破坏性的仲裁机制（CSMA/CD+AMP）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CSMA（Carrie Sense Multiple Access）指的是所有节点必须都等到总线处于&lt;strong&gt;空闲状态&lt;/strong&gt;时才能往总线上发送消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CD+AMP（Collision Detection + Arbitration on Message Priority）指的是如果多个节点往总线上发送消息时，具备&lt;strong&gt;最高优先级&lt;/strong&gt;的消息获得总线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非破坏性仲裁机制：通过ID仲裁，ID&lt;strong&gt;数值越小&lt;/strong&gt;，报文&lt;strong&gt;优先级越高&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;发送低优先级报文的节点退出仲裁后，在下次总线空闲时自动重发报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;高优先级的报文&lt;strong&gt;不能中断&lt;/strong&gt;低优先级报文的发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报文接受过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAN控制器大多具有根据ID过滤报文的功能，即只接收某些ID的报文。节点对接收到的报文进行过滤：比较消息ID与选择器（Accepter）中和接受过滤相关位是否相同。如果相同，接收；如果不相同，则过滤。&lt;/p&gt;
&lt;h3 id=&#34;报文种类及结构&#34;&gt;报文种类及结构&lt;/h3&gt;
&lt;p&gt;在原始数据段的前面加上&lt;strong&gt;传输起始标签、片选（识别）标签、控制标签&lt;/strong&gt;，在数据的尾段加上&lt;strong&gt;CRC校验标签、应答标签和传输结束标签&lt;/strong&gt;。把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了。&lt;/p&gt;
&lt;p&gt;各种各样的标签，起到了协同传输的作用。当整个数据包被传输到其他设备时，只要这些设备按格式去解读，就能还原出原始数据。类似这样的数据包就被称为CAN的数据帧。&lt;/p&gt;
&lt;p&gt;为了更有效的控制通信，CAN一共规定了5中类型的帧，帧也称为报文。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;帧&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;帧用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于发送单元向接收单元传输数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;远程帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于接收单元向具有相同ID的发送单元请求数据的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;错误帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于当检测出错误时，向其他单元通知错误的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超载帧&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于接收单元通知其尚未做好接受准备的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧间隔&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于将数据帧及遥控帧与前面其他帧分离开的帧&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;数据帧&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_dataFrame.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;共分为7个段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帧起始（SOF）：标识一个数据帧的开始，固定一个显性位。用于同步，总线空闲期间的任何隐性到线性的跳变都将引起节点进行硬同步&lt;/li&gt;
&lt;li&gt;仲裁段：内容为本数据帧的ID信息&lt;/li&gt;
&lt;li&gt;控制段：r1和r0为保留位，默认设置为显性位。DLC（Data Length Code）段用二进制编码表示本报文的数据段包含多少字节，由4位组成，DLC3-DLC0，表示的数字为0-8.&lt;/li&gt;
&lt;li&gt;数据段：数据帧的核心内容，有0-8个字节长度。&lt;/li&gt;
&lt;li&gt;CRC段：报文包含了一段15位的CRC校验码，来检验是否出错。&lt;/li&gt;
&lt;li&gt;ACK段：包含确认位和界定符。在发送节点发送时为隐形位，当接收节点收到正确报文时，将其覆盖为显性。&lt;/li&gt;
&lt;li&gt;帧结束段（EOF）：由发送端发送7个隐形位表示结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步&#34;&gt;同步&lt;/h2&gt;
&lt;p&gt;CAN总线使用&lt;strong&gt;位同步&lt;/strong&gt;的方式来确保通信时序，以及对总线的电平进行正确采样。&lt;/p&gt;
&lt;h3 id=&#34;位时序&#34;&gt;位时序&lt;/h3&gt;
&lt;h3 id=&#34;同步-1&#34;&gt;同步&lt;/h3&gt;
&lt;p&gt;分为硬同步和重新同步。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;部分内容转载自：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32262127&#34;&gt;知乎-Choris-一口气从零读懂CAN总线&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>存储器详解</title>
        <link>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Sun, 04 Jul 2021 16:09:50 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ -&lt;p&gt;计算机存储器只要分为内存和外存。内存是CPU直接寻址的存储空间，访问频率快，而外存访问慢。&lt;/p&gt;
&lt;h2 id=&#34;易失性存储器随机存取存储器ram&#34;&gt;易失性存储器（随机存取存储器，RAM）&lt;/h2&gt;
&lt;p&gt;Random Access Memory，存储在其中的资料会在电力切断后消失，所以属于易失性存储器。&lt;/p&gt;
&lt;h3 id=&#34;动态随机存取存储器dram&#34;&gt;动态随机存取存储器（DRAM）&lt;/h3&gt;
&lt;p&gt;Dynamic Random Access Memory，主要的作用原理是利用电容内&lt;strong&gt;存储电荷的多寡&lt;/strong&gt;来代表一个二进制比特（bit）是1还是0。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别资料，而导致资料毁损。因此对于DRAM来说，周期性地充电是一个不可避免的条件。由于这种需要&lt;strong&gt;定时刷新&lt;/strong&gt;的特性，因此被称为“动态”存储器。&lt;/p&gt;
&lt;h3 id=&#34;静态随机存取存储器sram&#34;&gt;静态随机存取存储器（SRAM）&lt;/h3&gt;
&lt;p&gt;Static Random Access Memory，所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失。&lt;/p&gt;
&lt;p&gt;SRAM由存储矩阵、地址译码器和读/写控制电路组成，容量的扩展有两个方面：位数的扩展用芯片的并联，字数的扩展可用外加译码器控制芯片的片选输入端[2]。SRAM中的每一bit储存在由4个场效应管（M1, M2, M3, M4）构成两个交叉耦合的反相器中。另外两个场效应管（M5, M6）是储存基本单元到用于读写的位线（Bit Line）的控制开关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SRAM_Cell_(6_Transistors).svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;非易失性存储器主要为只读存储器rom&#34;&gt;非易失性存储器（主要为只读存储器，ROM）&lt;/h2&gt;
&lt;p&gt;Read-Only Memory，一旦存储资料就无法再将之改变或删除，且内容不会因为电源关闭而消失。&lt;/p&gt;
&lt;h3 id=&#34;可编程式只读存储器prom&#34;&gt;可编程式只读存储器（PROM）&lt;/h3&gt;
&lt;p&gt;Programmable read-only memory，每个比特都由熔丝或反熔丝的状态决定资料内容。这种存储器用作永久存放程序之用。常用于电子游戏机、电子词典等预存固定资料或程序的各式电子产品之上。PROM与狭义的ROM（Mask ROM）的差别在于前者可在IC制造完成后才依需要写入资料，后者的资料需在制造IC时一并制作在里面。&lt;/p&gt;
&lt;p&gt;一个典型的PROM一开始时每个比特都会是1，编程中如将该比特的熔丝（fuse）烧断则成为0，这一过程是不可逆的（即刻录后不能再改变），断电后也不会消失记忆，所以这种存储器是一种只读存储器。&lt;/p&gt;
&lt;h3 id=&#34;可擦除可编程式只读存储器eprom&#34;&gt;可擦除可编程式只读存储器（EPROM）&lt;/h3&gt;
&lt;p&gt;Erasable Programmable Read Only Memory，它是一组浮栅晶体管，被一个提供比电子电路中常用电压更高电压的电子器件分别编程。一旦编程完成后，EPROM只能用强紫外线照射来擦除。通过封装顶部能看见硅片的透明窗口，很容易识别EPROM，这个窗口同时用来进行紫外线擦除。&lt;/p&gt;
&lt;h3 id=&#34;电子抹除式可复写只读存储器eeprom&#34;&gt;电子抹除式可复写只读存储器（EEPROM）&lt;/h3&gt;
&lt;p&gt;Electrically-Erasable Programmable Read-Only Memory，是一种可以通过电子方式多次复写的半导体存储设备。相比EPROM， EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据， EEPROM 属于SPD（串行存在检测）技术的一种延伸。&lt;/p&gt;
&lt;p&gt;在民用的DDR SDRAM及其主流后续产品中，一般 EEPROM 主要用于保存内存的开发者信息、生产时间、内存信息、通信协议、既定内存频率、供电电压、供电电流、物理信息以及内存XMP等信息，并且电脑会在开机自检（Power-On Self-Test；POST）时会读取这些信息以保持电脑的正常开机。&lt;/p&gt;
&lt;h3 id=&#34;闪存flash-memory&#34;&gt;闪存（Flash Memory）&lt;/h3&gt;
&lt;p&gt;闪存是一种特殊的、以宏块抹写的EEPROM。&lt;/p&gt;
&lt;p&gt;NOR和NAND两种类型&lt;/p&gt;
&lt;h4 id=&#34;nand-flash&#34;&gt;NAND Flash&lt;/h4&gt;
&lt;p&gt;SLC(单阶存储单元)、MLC(多阶存储单元，一般指2)、TLC(三阶存储单元)、QLC&lt;/p&gt;
&lt;p&gt;现在消费级产品都是TLC&lt;/p&gt;
&lt;h4 id=&#34;移动端使用的闪存协议变化&#34;&gt;移动端使用的闪存协议变化&lt;/h4&gt;
&lt;p&gt;eMMC-UFS&lt;/p&gt;- https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH09 顺序容器</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Tue, 15 Jun 2021 15:36:20 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ -&lt;p&gt;顺序容器&lt;/p&gt;
&lt;p&gt;一个容器就是一些特定类型对象的集合。&lt;/p&gt;
&lt;p&gt;顺序容器提供了&lt;strong&gt;控制元素存储&lt;/strong&gt;和&lt;strong&gt;访问顺序&lt;/strong&gt;的能力。这种顺序与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;p&gt;关联容器与顺序容器有着根本不同，关联容器中的元素是按照&lt;strong&gt;关键词&lt;/strong&gt;来保存和访问的，即&lt;strong&gt;Key-Value&lt;/strong&gt;；与之相对的是顺序容器中的元素按照它们在容器中的位置来顺序保存和访问。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;顺序容器都提供了&lt;strong&gt;快速顺序访问元素&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;顺序容器类型(名称)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;性能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vector&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可变大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在尾部之外的位置插入删除元素很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;deque&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双端队列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。在头尾插入删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双向链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持双向顺序访问。在list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forward_list&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单项链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只支持单项顺序访问。在forward_list中任何位置插入删除元素都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;array&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定大小数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持快速随机访问。不能添加删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;与vector相似的容器，专门用于保存字符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随机访问快，在尾部插入删除速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了固定大小的array外，其他容器都提供高效的内存管理。容器保存元素的策略对容器操作的效率有着很大影响。&lt;/p&gt;
&lt;p&gt;string和vector将元素保存在&lt;strong&gt;连续的内存空间&lt;/strong&gt;中，因此由元素的下标来计算其地址非常快速。但在这两种容器的中间位置插入和删除元素的速度非常慢，因为一次插入或删除后，需要移动插入、删除位置后的&lt;strong&gt;所有元素&lt;/strong&gt;以保证存储的连续。&lt;/p&gt;
&lt;p&gt;list和forward_list两个容器能令任何位置的添加和删除操作都很快，但这两种容器&lt;strong&gt;不支持随机访问&lt;/strong&gt;，因为元素保存的内存空间不连续，只能通过遍历整个容器来访问一个元素。与vector和string相比，额外内存开销也很大。&lt;/p&gt;
&lt;p&gt;forward_list与最好的手写单向链表数据结构性能相当，因此没有size操作，因为保存或计算大小会多出额外开销。&lt;/p&gt;
&lt;p&gt;deque支持快读随机访问，在该容器中间位置添加或删除元素速度很慢，但在两端很快。&lt;/p&gt;
&lt;h2 id=&#34;容器库概览&#34;&gt;容器库概览&lt;/h2&gt;
&lt;p&gt;容器类型上的操作分成了层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些操作式所有容器都提供的；&lt;/li&gt;
&lt;li&gt;另外一些操作仅针对顺序容器、关联容器或无序容器；&lt;/li&gt;
&lt;li&gt;还有一些操作只适合一小部分容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器通过&lt;strong&gt;尖括号&lt;/strong&gt;指定类型。&lt;/p&gt;
&lt;h3 id=&#34;容器操作&#34;&gt;容器操作&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;iterator
size_type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*iter	//返回迭代器iter所指元素的引用
iter-&amp;gt;name	//解引用iter并获取该元素的名为mem的成员
++iter	//令iter指示容器中的下一个元素
--iter	//令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个&lt;strong&gt;迭代器范围&lt;/strong&gt;由一对迭代器表示，这两个迭代器被称为begin和end，begin指向容器第一个元素，end指向容器的&lt;strong&gt;尾后元素&lt;/strong&gt;，这种元素范围被称为&lt;strong&gt;左闭合区间&lt;/strong&gt;，即&lt;code&gt;[begin, end)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对构成范围的迭代器的要求：&lt;strong&gt;end不在begin之前&lt;/strong&gt;。可以通过对begin进行若干次递增，使得begin==end。&lt;/p&gt;
&lt;h3 id=&#34;容器类型成员&#34;&gt;容器类型成员&lt;/h3&gt;
&lt;p&gt;每个容器都定义了多个类型。如之前使用过的&lt;code&gt;interator&lt;/code&gt;、&lt;code&gt;size_type&lt;/code&gt;等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;interator
const_iterator
size_type
difference_type
value_type
reference
const_reference
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;iterator iter;
vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;begin和end成员&#34;&gt;begin和end成员&lt;/h3&gt;
&lt;p&gt;begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。还有不同类型的反向迭代器、const迭代器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;list&amp;lt;int&amp;gt; a = {1, 2, 3};
auto it1 = a.begin();	//list&amp;lt;int&amp;gt;::iterator
auto it2 = a.rbegin();	//反向迭代器 list&amp;lt;int&amp;gt;::reverse_iterator
auto it3 = a.cbegin();	//const迭代器 list&amp;lt;int&amp;gt;::const_iterator
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;容器定义和初始化&#34;&gt;容器定义和初始化&lt;/h3&gt;
&lt;p&gt;每个容器类型都定义了一个默认构造函数。除了array外，其他容器的默认构造函数都会创建一个指定类型的空容器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C c;	//默认构造函数
C c1(c2)	//c1初始化为c2的拷贝。两者必须是相同类型的容器
C c{a,b,c...}	//c初始化为初始化列表中元素的拷贝
C c(b,e)	//c初始化为迭代器b和e指定范围中元素的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与顺序容器（除了array）大小相关的一个构造函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ivec(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int元素，每个都初始化为1
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; scev(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个元素，每个都是空string
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标准库array具有固定大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存42个int的数组
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//类型为保存10个string的数组
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用array时必须同时指定&lt;strong&gt;元素类型&lt;/strong&gt;和&lt;strong&gt;大小&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;array&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;::&lt;/span&gt;size_type j;	&lt;span style=&#34;color:#888&#34;&gt;//错误，未指定大小
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个默认构造的array是非空的，它包含了与其大小一样多的元素，这些元素都被默认初始化。&lt;/p&gt;
&lt;h3 id=&#34;赋值和swap&#34;&gt;赋值和swap&lt;/h3&gt;
&lt;p&gt;赋值将左边容器中的所有元素替换为右边容器中元素的拷贝。如果两个容器原来大小不同，赋值运算后两者大小都与右边容器的原大小相等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; c2;	&lt;span style=&#34;color:#888&#34;&gt;//将c1替换为c2中元素的拷贝，拷贝后c1的大小与原c2相同
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {a, b, c}
swap(c1, c2)
c1.swap(c2)	&lt;span style=&#34;color:#888&#34;&gt;//与上一个等价
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//assign操作不适用于关联容器和array
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为迭代器b和e所表示范围的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(il)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为初始化列表il中的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;seq.assign(n,t)	&lt;span style=&#34;color:#888&#34;&gt;//将seq中的元素替换为n个值为t的元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;assign用参数所指定的元素拷贝替换左边容器中所有元素。assign操作不适用于array和关联容器。&lt;/p&gt;
&lt;p&gt;swap只是交换了两个容器内部的&lt;strong&gt;数据结构&lt;/strong&gt;，但例外是swap两个array会真正交换它们的元素。&lt;/p&gt;
&lt;h3 id=&#34;容器大小操作&#34;&gt;容器大小操作&lt;/h3&gt;
&lt;p&gt;成员函数&lt;code&gt;size&lt;/code&gt;返回容器中元素的数目；&lt;code&gt;empty&lt;/code&gt;当size为0时返回布尔值true，否则返回false；&lt;code&gt;max_size&lt;/code&gt;返回一个大于或等于该类型容器所能容纳的最大元素数的值。&lt;/p&gt;
&lt;p&gt;forward_list支持&lt;code&gt;max_size&lt;/code&gt;和&lt;code&gt;empty&lt;/code&gt;但不支持size。&lt;/p&gt;
&lt;h3 id=&#34;关系运算符&#34;&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;每个容器类型都支持相等运算符(即&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;)；除&lt;strong&gt;无序关联容器&lt;/strong&gt;外的所有容器都支持关系运算符(&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=)。&lt;/p&gt;
&lt;p&gt;关系运算符左右两边的运算对象必须是&lt;strong&gt;相同类型的容器&lt;/strong&gt;，且保存&lt;strong&gt;元素的类型也必须相等&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顺序容器操作&#34;&gt;顺序容器操作&lt;/h2&gt;
&lt;p&gt;顺序容器和关联容器的不同在于两者&lt;strong&gt;组织元素的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了上一节介绍的&lt;strong&gt;所有容器都支持的操作外&lt;/strong&gt;，本章剩余部分将介绍顺序容器的所有操作。&lt;/p&gt;
&lt;h4 id=&#34;向顺序容器添加元素&#34;&gt;向顺序容器添加元素&lt;/h4&gt;
&lt;p&gt;向顺序容器中除了array外添加元素的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.push_back(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的尾部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_back(args)
c.push_front(t)			&lt;span style=&#34;color:#888&#34;&gt;//在c的头部创建值为t或由args创建的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.emplace_front(args)
c.insert(p,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前创建一个值为t的元素。返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,n,t)			&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,b,e)			&lt;span style=&#34;color:#888&#34;&gt;//将迭代器b和e指向范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.insert(p,il)			&lt;span style=&#34;color:#888&#34;&gt;//il为一个花括号包围的元素值列表，将这些值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;forword_list&lt;/code&gt;不支持&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;emplace_back&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持&lt;code&gt;push_front&lt;/code&gt;和&lt;code&gt;emplace_front&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;使用这些操作时要注意策略，根据不同容器的&lt;strong&gt;不同数据结构的特性&lt;/strong&gt;来使用。&lt;/p&gt;
&lt;p&gt;emplace操作构造而不是拷贝元素，将参数传递给元素类型的构造函数，直接构造元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_back&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了array和forward_list外，每个顺序容器都支持该操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用push_front&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;list、forward_list和deque容器还支持&lt;code&gt;push_front&lt;/code&gt;，此操作将元素插入容器头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器特定为止添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;insert成员匀速我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。&lt;/p&gt;
&lt;p&gt;每个insert都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。&lt;/p&gt;
&lt;p&gt;insert函数还可以接受更多参数，其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;svec.insert(svec.end(), &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用emplace操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++11引入了三个新成员——emplace_front、emplace和emplace_back，这些操作&lt;strong&gt;构造&lt;/strong&gt;而不是拷贝元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.emplace_back(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;123445&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;15.99&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在c的末位构造一个Sales_data对象。&lt;/p&gt;
&lt;h4 id=&#34;访问元素&#34;&gt;访问元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.back()		&lt;span style=&#34;color:#888&#34;&gt;//返回c中尾元素的引用，若c为空，则函数行为未定义。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.front()		&lt;span style=&#34;color:#888&#34;&gt;//范围c中首元素的引用
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c[n]			&lt;span style=&#34;color:#888&#34;&gt;//返回c中下标为n的元素的引用，n是一个无符号整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.at(n)			&lt;span style=&#34;color:#888&#34;&gt;//返回下标为n的元素的引用，若下标越界，则返回out_of_range异常
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;at和下标操作只适用于string、vector、array和deque&lt;/p&gt;
&lt;p&gt;back不适用于forward_list&lt;/p&gt;
&lt;p&gt;以上访问元素的成员函数返回的都是&lt;strong&gt;引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;删除元素&#34;&gt;删除元素&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.pop_back()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中尾元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.pop_front()	&lt;span style=&#34;color:#888&#34;&gt;//删除c中首元素，若c为空，则函数行为未定义，返回void
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器p所指元素，返回一个指向被删元素之后元素的迭代器；若p指向尾元素，则返回尾后迭代器；若p是尾后迭代器，则函数行为未定义
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.erase(b,e)	&lt;span style=&#34;color:#888&#34;&gt;//删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若e本身就是尾后迭代器，则也返回尾后迭代器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.clear()		&lt;span style=&#34;color:#888&#34;&gt;//删除c中所有元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;forward_list有特殊erase，且不支持pop_back.&lt;/p&gt;
&lt;p&gt;vector和string不支持pop_front.&lt;/p&gt;
&lt;p&gt;erase从容器中指定位置删除元素，还可以使用一对迭代器，删除一个范围内的元素。&lt;/p&gt;
&lt;h4 id=&#34;特殊的forward_list操作&#34;&gt;特殊的forward_list操作&lt;/h4&gt;
&lt;p&gt;在链表中添加或删除一个链接，会改变序列中的链接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;lst.before_begin()		&lt;span style=&#34;color:#888&#34;&gt;//返回指向链表首元素之前不存在的元素迭代器，该迭代器不能解引用。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,t)	&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的为止插入元素，t是一个对象，n是数量，b和e是一对迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)	&lt;span style=&#34;color:#888&#34;&gt;//il是一个花括号列表
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//在迭代器p之后的位置插入元素，t是一个对象，n是数量，b和e是表示范围的一对迭代器，il是一个花括号列表。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;emplace_after(p,args)	&lt;span style=&#34;color:#888&#34;&gt;//使用args在p指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(p)		&lt;span style=&#34;color:#888&#34;&gt;//删除p指向位置之后的元素，或删除从b之后直到e之间的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;lst.erase_after(b,e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在forward_list中添加或删除元素时，我们要关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱。&lt;/p&gt;
&lt;h4 id=&#34;改变容器大小&#34;&gt;改变容器大小&lt;/h4&gt;
&lt;p&gt;可以使用resize来增大或缩小容器。&lt;strong&gt;array不支持resize&lt;/strong&gt;。若当前大小大于所要求的大小，则容器后部的元素会被删除；所当前大小小于新大小，则将新元素添加到容器后部。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; ilist(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//10个int：每个的值都是43
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;15&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将5个值为0的元素添加到ilist末尾
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;ilist.resize(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;25&lt;/span&gt;,&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//将10个值为1的元素添加到ilist末尾
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;容器操作可能使迭代器失效&#34;&gt;容器操作可能使迭代器失效&lt;/h4&gt;
&lt;p&gt;根据不同容器在内存中存储的方式不同，向容器中添加或删除元素会导致不同类型的迭代器失效。&lt;/p&gt;
&lt;h2 id=&#34;vector对象的增长&#34;&gt;vector对象的增长&lt;/h2&gt;
&lt;p&gt;vector和string的实现通常会分配比新的空间需求&lt;strong&gt;更大的内存空间&lt;/strong&gt;，容器预留这些空间作为&lt;strong&gt;备份&lt;/strong&gt;，可用来保存更多的新元素，这样就不需要每次添加新元素都重新分配容器的内存空间了。&lt;/p&gt;
&lt;p&gt;以下是vector和string提供的一些管理容量的成员函数，允许我们与它的实现中内存分配部分互动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c.shrink_to_fit()		&lt;span style=&#34;color:#888&#34;&gt;//将capacity减少为与size()相同大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.capacity()			&lt;span style=&#34;color:#888&#34;&gt;//不重新分配内存空间的话，c可以保存多少元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.reserve(n)			&lt;span style=&#34;color:#888&#34;&gt;//分配至少能容纳n个元素的内存空间
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;reserve不改变容器中元素数量，只影响预先分配内存空间的大小。&lt;/p&gt;
&lt;p&gt;shrink_to_fit只适用于vector、string和deque。&lt;/p&gt;
&lt;p&gt;capacity、reserve只适用于vector、string。&lt;/p&gt;
&lt;h2 id=&#34;额外的string操作&#34;&gt;额外的string操作&lt;/h2&gt;
&lt;p&gt;这些操作大部分是提供&lt;strong&gt;string类和C风格字符数组&lt;/strong&gt;之间的&lt;strong&gt;相互转换&lt;/strong&gt;，或者增加了允许我们用&lt;strong&gt;下标&lt;/strong&gt;代替迭代器。&lt;/p&gt;
&lt;h4 id=&#34;构造string的其他方法&#34;&gt;构造string的其他方法&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string s(cp, n)		//s是cp指向的数组中前n个字符的拷贝。
string s(s2, pos2)	//s是string s2从下标pos2开始的字符的拷贝。
string s(s2, pos2, len2)	//s是string s2从下标pos2开始len2个字符的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些构造函数接受一个string或一个const char*参数，还接受指定拷贝多少个字符的参数。当传递给他一个string时，还可指定一个下标指出从哪里开始拷贝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.substr(pos, n)	&lt;span style=&#34;color:#888&#34;&gt;//返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;改变string的其他方法&#34;&gt;改变string的其他方法&lt;/h4&gt;
&lt;p&gt;定义了额外的insert和erase版本，还定义了两个额外的成员函数append和replace。&lt;/p&gt;
&lt;p&gt;append操作是在string末尾进行插入操作的一种简写。&lt;/p&gt;
&lt;p&gt;replace操作是调用erase和insert的一种简写形式。&lt;/p&gt;
&lt;h4 id=&#34;string搜索&#34;&gt;string搜索&lt;/h4&gt;
&lt;p&gt;string类提供了6个不同的搜索函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.find(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.rfind(args)				&lt;span style=&#34;color:#888&#34;&gt;//查找s中args最后一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_first_of(args)	&lt;span style=&#34;color:#888&#34;&gt;//在s中查找args中任何一个字符第一次出现的位置
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.find_last_of(args)
s.find_first_not_of(args)
s.find_last_not_of(args)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;compare函数&#34;&gt;compare函数&lt;/h4&gt;
&lt;p&gt;标准库string还提供了一组compare函数，根据s是等于、大于还是小于参数指定的字符串，&lt;code&gt;s.compare&lt;/code&gt;返回0、整数或负数。&lt;/p&gt;
&lt;p&gt;s.compare有6个版本的参数形式。&lt;/p&gt;
&lt;h4 id=&#34;数值转换&#34;&gt;数值转换&lt;/h4&gt;
&lt;p&gt;string和数值之间的转换&lt;/p&gt;
&lt;h2 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h2&gt;
&lt;p&gt;除顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priority_queue&lt;/p&gt;
&lt;p&gt;一个适配器是一种机制，能使某种事物看起来像另一种事物。&lt;/p&gt;
&lt;p&gt;一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。&lt;/p&gt;
&lt;p&gt;例如，stack适配器接受一个顺序容器，并使其操作起来像一个stack一样。&lt;/p&gt;
&lt;p&gt;所有容器适配器&lt;strong&gt;都支持的操作和类型&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;size_type		&lt;span style=&#34;color:#888&#34;&gt;//一种类型，足够保存当前类型的最大对象的大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;value_type
container_type	&lt;span style=&#34;color:#888&#34;&gt;//实现适配器的底层容器类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A a;			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的空适配器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;A &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;a&lt;/span&gt;(c);			&lt;span style=&#34;color:#888&#34;&gt;//创建一个名为a的适配器，带有容器c的一个拷贝
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;关系运算符&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;等等&lt;/span&gt;
a.empty()
a.size()
swap(a,b)		&lt;span style=&#34;color:#888&#34;&gt;//交换a、b的内容
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;a.swap(b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;定义一个适配器&#34;&gt;定义一个适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; stk(deq);	&lt;span style=&#34;color:#888&#34;&gt;//deq是一个deque&amp;lt;int&amp;gt;，从deq拷贝元素到stk
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;栈适配器&#34;&gt;栈适配器&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;stack&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; intStack;	&lt;span style=&#34;color:#888&#34;&gt;//声明一个空栈
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他一些栈操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;s.pop()
s.push(item)	&lt;span style=&#34;color:#888&#34;&gt;//创建一个新元素压入栈顶，该元素通过拷贝或移动item实现，或有args构造
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;s.emplace(args)
s.top()			&lt;span style=&#34;color:#888&#34;&gt;//返回栈顶元素，但不讲栈弹出
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;队列适配器&#34;&gt;队列适配器&lt;/h4&gt;
&lt;p&gt;queue和priority_queue适配器定义在queue头文件。&lt;/p&gt;
&lt;p&gt;标准库queue是一种FIFO的策略。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 