<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 28 Dec 2021 21:53:28 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>算法——红黑树</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
        <pubDate>Sat, 27 Nov 2021 21:03:17 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/ -&lt;p&gt;本节是为了介绍一种二分查找树，无论如何构造，它的运行时间都是对数级别的。在一棵含有N个结点的树中，树的高为$\lg N$。&lt;/p&gt;
&lt;h2 id=&#34;2-3查找树&#34;&gt;2-3查找树&lt;/h2&gt;
&lt;p&gt;允许一个结点保存多个键。一颗2-3查找树由2-结点和3-结点组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2-结点：含有一个键（及其对应键值）和两条链接&lt;/li&gt;
&lt;li&gt;3-结点：含有两个键（及其对应键值）和三条链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样地，将指向一颗空树的链接称为空链接。&lt;/p&gt;
&lt;h3 id=&#34;查找&#34;&gt;查找&lt;/h3&gt;
&lt;p&gt;与二叉查找树基本相同，只是可能多了中间结点，从上向下一次递归查找。&lt;/p&gt;
&lt;h3 id=&#34;插入新键&#34;&gt;插入新键&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;向2-结点插入新键&lt;/li&gt;
&lt;li&gt;向一棵只含有3-结点的树中插入新键&lt;/li&gt;
&lt;li&gt;向一个父结点为2-结点的3-结点中插入新键&lt;/li&gt;
&lt;li&gt;向一个父结点为3-结点的3-结点中插入新键&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局性质&#34;&gt;全局性质&lt;/h3&gt;
&lt;p&gt;任意空链接到根结点的路径长度都是相等的。&lt;/p&gt;
&lt;p&gt;一棵含有N个结点的2-3树高度在$\lfloor \log_3N\rfloor$（树中全是3-结点）和$\lfloor \lg N\rfloor$（树中全是2-结点）之间。&lt;/p&gt;
&lt;h2 id=&#34;红黑二叉查找树&#34;&gt;红黑二叉查找树&lt;/h2&gt;
&lt;p&gt;用标准二叉查找树和一些额外的信息来表示2-3树。将树中的链接分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红链接：将两个2-结点连接起来构成一个3-结点&lt;/li&gt;
&lt;li&gt;黑链接：2-3树中的普通链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相当于将3-结点表示为一条左斜的红色链接。这种方法的优点是我们无需修改就可以直接使用标准二叉查找树的&lt;code&gt;get()&lt;/code&gt;方法。对于任意的2-3树，只需对结点进行转换，就可以立即派生出一棵对应的二叉查找树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种等价的定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红链接均为左链接&lt;/li&gt;
&lt;li&gt;没有任何一个结点同时和两条红链接相连&lt;/li&gt;
&lt;li&gt;该树是完美黑色平衡的，即任意空链接到根结点路径上的黑链接数量相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;插入操作的方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;左旋转、右旋转、颜色转换&lt;/p&gt;
&lt;h2 id=&#34;红黑树的实现&#34;&gt;红黑树的实现&lt;/h2&gt;
&lt;p&gt;红黑树的插入算法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; RED &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; BLACK &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Node&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    Key key&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    Value val&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    Node left&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; right&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; color&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    Node&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Key key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Value val&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; color&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; N&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; color&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;isRed&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node x&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

Node &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;rotateLeft&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    Node x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; 1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

Bode &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;rotateRight&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    Node x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; 1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;flipColors&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; BLACK&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; BLACK&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;RedBlackBST&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Key &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;extends&lt;/span&gt; Comparable&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Key&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;,&lt;/span&gt; Value&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; Node root&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Key key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Value val&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
        root &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; put&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;root&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        root&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; BLACK&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; Node &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Key key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Value val&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Node&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; cmp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;compareTo&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;key&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; 		&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;cmp &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; 0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;	h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; put&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;cmp &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; 0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;	h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; put&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;))&lt;/span&gt;		h &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; rotateLeft&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;))&lt;/span&gt;	h &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; rotateRight&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;))&lt;/span&gt;		flipColors&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        
        h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; 1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;   
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一条if语句：将任意含有红色右链接的3-结点（或临时4-结点）向左旋转；&lt;/p&gt;
&lt;p&gt;第二条if语句：将临时的4-结点中两条连续红链接中的上层链接向右旋转；&lt;/p&gt;
&lt;p&gt;第三条if语句：进行颜色转换，并将红链接在树中向上传递。&lt;/p&gt;
&lt;h2 id=&#34;红黑树的删除操作&#34;&gt;红黑树的删除操作&lt;/h2&gt;
&lt;h3 id=&#34;自顶向下的2-3-4树&#34;&gt;自顶向下的2-3-4树&lt;/h3&gt;
&lt;h2 id=&#34;红黑树的性质&#34;&gt;红黑树的性质&lt;/h2&gt;
&lt;p&gt;所有基于红黑树的符号表（键值对）实现都能保证操作的运行时间为&lt;strong&gt;对数级别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一棵大小为N的红黑树的高度不会超过$2\lg N$。&lt;/p&gt;
&lt;p&gt;一颗大小为N的红黑树中，根结点到任意结点的平均路径为$\lg N$。&lt;/p&gt;
&lt;p&gt;红黑树的实现中最复杂的代码仅限于插入和删除方法，其他的二叉查找树中的查找最大最小键不做任何变动即可继续使用。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH12 动态内存</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
        <pubDate>Thu, 18 Nov 2021 09:20:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/ -&lt;p&gt;C++支持动态分配对象，动态分配的对象的生存期与它们在哪里创建无关，只有当显示地被释放时，这些对象才会销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态内存&lt;/strong&gt;用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。&lt;strong&gt;栈内存&lt;/strong&gt;用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。&lt;/p&gt;
&lt;p&gt;除了静态内存和栈内存，每个程序还拥有一个&lt;strong&gt;内存池&lt;/strong&gt;，这部分内存被称为&lt;strong&gt;堆&lt;/strong&gt;，程序用堆来存储&lt;strong&gt;动态分配&lt;/strong&gt;的对象，即那些在程序运行时分配的对象。动态对象的&lt;strong&gt;生存期由程序来控制&lt;/strong&gt;，即动态对象不再使用时，我们的代码必须显示销毁它们。&lt;/p&gt;
&lt;h2 id=&#34;动态内存与智能指针&#34;&gt;动态内存与智能指针&lt;/h2&gt;
&lt;p&gt;动态内存的管理是通过&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;完成的。new为对象分配空间并返回一个指向该对象的指针，delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;p&gt;新的标准库提供了两种&lt;strong&gt;智能指针&lt;/strong&gt;类型来管理动态对象，这两种智能指针的区别在于管理底层指针的方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;允许&lt;strong&gt;多个指针指向同一个对象&lt;/strong&gt;；&lt;code&gt;unique_ptr&lt;/code&gt;独占所指向的对象。标准库还顶一个名为&lt;code&gt;weak_ptr&lt;/code&gt;的伴随类，是一种弱引用，指向&lt;code&gt;shared_ptr&lt;/code&gt;所管理的对象。&lt;/p&gt;
&lt;h3 id=&#34;shared_ptr类&#34;&gt;shared_ptr类&lt;/h3&gt;
&lt;p&gt;类似于vector，&lt;strong&gt;智能指针&lt;/strong&gt;也是模板，当我们创建一个智能指针时，必须提供额外信息——指针&lt;strong&gt;可以指向的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p1;		&lt;span style=&#34;color:#888&#34;&gt;//可以指向string
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; p2;	&lt;span style=&#34;color:#888&#34;&gt;//可以指向int的list
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认初始化的智能指针中保存着一个空指针。使用方法与普通指针类似，解引用一个智能指针返回它指向的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;make_shared函数&lt;/strong&gt;
是最安全的用来分配和使用动态内存的标准库函数。&lt;/p&gt;
&lt;p&gt;此函数在动态内存中分配一个对象并初始化它，返回指向此对象的&lt;code&gt;shared_ptr&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;); &lt;span style=&#34;color:#888&#34;&gt;//指向一个值为42的int的shared_ptr
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用make_shared时要指定创建对象的类型，方法与定义模板类相同，在函数名后跟一个尖括号，在其中给出类型，如上所示。另外，make_shared用其参数来构造给定类型的对象。例如调用&lt;code&gt;make_shared&amp;lt;string&amp;gt;&lt;/code&gt;时传递参数必须与string的某个构造函数匹配。&lt;/p&gt;
&lt;p&gt;一般使用auto来定义一个对象来保存make_shared的结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; p6 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;shared_ptr的拷贝和赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个shared_ptr都会记录&lt;strong&gt;指向相同对象&lt;/strong&gt;的其他shared_ptr的数量。&lt;/p&gt;
&lt;p&gt;每个shared_ptr都有一个关联的计数器，称其为&lt;strong&gt;引用计数&lt;/strong&gt;。无论何时拷贝一个shared_ptr，计数器都会递增。&lt;/p&gt;
&lt;p&gt;当我们给shared_ptr赋予一个新值或shared_ptr被销毁时，计数器就会递减。&lt;/p&gt;
&lt;p&gt;一旦一个shared_ptr的计数器变为0，它就会释放自己所管理的对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);
r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; q;	&lt;span style=&#34;color:#888&#34;&gt;//给r赋值，令它指向另一个地址；递增q指向的对象的引用次数；递减r原来指向对象的引用次数；r原来指向的对象已经没有引用者，会自动释放
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;shared_ptr自动销毁所管理的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。这是通过另一个特殊成员函数——&lt;strong&gt;析构函数&lt;/strong&gt;完成的。析构函数一般用来释放对象多分配的资源。&lt;/p&gt;
&lt;p&gt;shared_ptr的析构函数会&lt;strong&gt;递减&lt;/strong&gt;它所指向对象的引用次数，引用次数变为0后shared_ptr的析构函数就会自动销毁对象并释放内存。&lt;/p&gt;
&lt;p&gt;由于最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重用，否则程序虽然会正常执行，但会浪费内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用动态内存的原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序不知道自己需要使用多少对象（容器类就是出于这种原因从而使用动态内存）&lt;/li&gt;
&lt;li&gt;程序不知道对象的准确类型&lt;/li&gt;
&lt;li&gt;程序需要在多个对象间共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直接管理内存&#34;&gt;直接管理内存&lt;/h3&gt;
&lt;p&gt;使用运算符&lt;code&gt;new&lt;/code&gt;分配内存，&lt;code&gt;delete&lt;/code&gt;释放new分配的内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用new动态分配和初始化对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在自由空间分配的&lt;strong&gt;内存是无名的&lt;/strong&gt;，因此new无法为其分配的对象命名，而是返回一个&lt;strong&gt;指向该对象的指针&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pi &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//pi指向一个动态分配的、未初始化的无名对象
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认情况下动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的。类类型对象将用默认构造函数进行初始化：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;string &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ps &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; string;	&lt;span style=&#34;color:#888&#34;&gt;//初始化为空string
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pi &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//pi指向一个未初始化的int
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; p1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt;(obj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以通过括号包围的初始化器判断我们想到分配的对象类型，然后使用auto。但只有括号内仅有单一初始化器时才能使用auto。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态分配的const对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pci &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1024&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个动态分配的const必须进行初始化，对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，其他类型的对象必须显式初始化。上面new返回的是一个指向const的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存耗尽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序内存耗尽后new表达式就会失败，然后抛出一个类型为&lt;code&gt;std::bad_alloc&lt;/code&gt;的异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;释放动态内存&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; p;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;delete接受一个指针，销毁其指向的对象，释放对应内存。&lt;/p&gt;
&lt;p&gt;向delete传递的指针值必须指向动态分配的内存或是一个空指针。释放一块非new分配的内存，其行为未定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态对象的生存周期直到被释放为止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了额外负担，调用者必须记得释放内存。&lt;/p&gt;
&lt;h3 id=&#34;shared_ptr和new结合使用&#34;&gt;shared_ptr和new结合使用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p2(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;));
shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//错误，必须使用直接初始化
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接受指针参数的智能指针的构造函数时explicit的，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针.&lt;/p&gt;
&lt;p&gt;不要混用内置指针和智能指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他shared_ptr操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;p.reset(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1024&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用reset将一个新的指针赋予一个shared_ptr.上面的例子中p指向了一个新对象。&lt;/p&gt;
&lt;h3 id=&#34;智能指针和异常&#34;&gt;智能指针和异常&lt;/h3&gt;
&lt;p&gt;使用智能指针时，即使程序块过早结束（发生异常），智能指针也能确保在内存不再需要时将其释放。&lt;/p&gt;
&lt;p&gt;与之相对的，当发生异常时，我们直接管理的内存不会自动释放。如果使用内置指针管理内存，且在new之后再对应的delete之前发生异常，内存不会被释放。&lt;/p&gt;
&lt;h3 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h3&gt;
&lt;p&gt;一个unique_ptr&lt;strong&gt;拥有&lt;/strong&gt;它所指向的对象，某个时刻只能有&lt;strong&gt;一个unique_ptr指向一个给定对象&lt;/strong&gt;，因此其&lt;strong&gt;不支持普通的拷贝或赋值&lt;/strong&gt;操作；当unique_ptr被销毁时，它所指向的对象也被销毁。&lt;/p&gt;
&lt;p&gt;unique_ptr没有类似于make_shared的标准库函数返回一个shared_ptr；我们定义一个unique_ptr时，需要将其绑定到一个&lt;strong&gt;new返回的指针&lt;/strong&gt;上；初始化unique_ptr必须采用&lt;strong&gt;直接初始化&lt;/strong&gt;形式，即使用括号直接初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p2(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;));	&lt;span style=&#34;color:#888&#34;&gt;//p2指向一个值为42的int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;unique_ptr的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;T, D&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; u(d)	&lt;span style=&#34;color:#888&#34;&gt;//空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//释放u指向的对象，将u置为空
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u.release()	&lt;span style=&#34;color:#888&#34;&gt;//u放弃对指针的控制权，返回指针，并将u置为空
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u.reset()	&lt;span style=&#34;color:#888&#34;&gt;//释放u指向的对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u.reset(q)	&lt;span style=&#34;color:#888&#34;&gt;//q为内置指针，另u指向这个对象
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然我们不能拷贝或赋值unique_ptr，但可以通过调用&lt;strong&gt;release或reset&lt;/strong&gt;将指针的所有权从一个unique_ptr转移给另一个unique：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p2(p1.release());&lt;span style=&#34;color:#888&#34;&gt;//release将p1置为空
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p3(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; string(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Trex&amp;#34;&lt;/span&gt;));
p2.reset(p3.release());	&lt;span style=&#34;color:#888&#34;&gt;//reset释放了p2原来指向的内存
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;weak_ptr&#34;&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;weak_ptr是一种&lt;strong&gt;不控制所指向对象生存期&lt;/strong&gt;的智能指针，它指向一个&lt;strong&gt;shared_ptr管理的对象&lt;/strong&gt;。将一个weak_ptr绑定到shared_ptr&lt;strong&gt;不会改变对象的引用计数&lt;/strong&gt;。一旦最后一只指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。weak_ptr的名字抓住了这种指针弱共享的特点。&lt;/p&gt;
&lt;h2 id=&#34;动态数组&#34;&gt;动态数组&lt;/h2&gt;
&lt;p&gt;可以一次为很多对象分配动态内存。C++语言和标准库提供了两种一次分配一个对象数组的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用new表达式语法&lt;/li&gt;
&lt;li&gt;标准库中allocator的类，允许我们将分配和初始化分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单，更不容易出现内存管理错误并可能有更好的性能。&lt;/p&gt;
&lt;h3 id=&#34;new和数组&#34;&gt;new和数组&lt;/h3&gt;
&lt;p&gt;为了让new分配一个对象数组，要在类型名之后跟一对&lt;strong&gt;方括号&lt;/strong&gt;，在其中要指明分配对象的数目。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pia &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt;];	&lt;span style=&#34;color:#888&#34;&gt;//pia指向第一个int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的例子中，new分配32个int对象并返回指向第一个int对象的指针。&lt;/p&gt;
&lt;p&gt;也可以用一个表示数组类型的&lt;strong&gt;类型别名&lt;/strong&gt;来分配一个数组，这样new表达式就不需要方括号了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;智能指针和动态数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标准库提供了一个可以管理new分配的数组的unique_ptr版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;[]&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; up(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了用一个unique_ptr管理动态数组，必须在一个动态类型后面跟一对方括号。&lt;/p&gt;
&lt;h3 id=&#34;allocator类&#34;&gt;allocator类&lt;/h3&gt;
&lt;p&gt;标准库allocator类定义在头文件memory中，其帮助我们将内存分配和对象构造分离开来。它提供了一种类型感知的内存分配方法。&lt;/p&gt;
&lt;h2 id=&#34;使用标准库文本查询程序&#34;&gt;使用标准库：文本查询程序&lt;/h2&gt;
&lt;p&gt;这个例子作为标准库相关内容学习的总结。&lt;/p&gt;
&lt;p&gt;现代C++程序应该尽可能使用智能指针。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH11 关联容器</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Mon, 15 Nov 2021 15:32:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/ -&lt;p&gt;键值对。&lt;/p&gt;
&lt;p&gt;set和map&lt;/p&gt;
&lt;h2 id=&#34;使用关联容器&#34;&gt;使用关联容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;map： 关联数组，关键字——值。&lt;/li&gt;
&lt;li&gt;set：关键字的简单集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以进行列表初始化&lt;/p&gt;
&lt;h2 id=&#34;关联容器概述&#34;&gt;关联容器概述&lt;/h2&gt;
&lt;p&gt;关联容器不支持顺序容器的位置相关的操作，例如&lt;code&gt;push_front&lt;/code&gt;，原因是关联容器中的值是按照关键字存储的，这些操作没有意义。&lt;/p&gt;
&lt;p&gt;另外无序容器还提供调整哈希性能的操作。&lt;/p&gt;
&lt;h3 id=&#34;定义关联容器&#34;&gt;定义关联容器&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; word_count;	&lt;span style=&#34;color:#888&#34;&gt;//空容器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;set&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; exclude &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;the&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;but&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;and&amp;#34;&lt;/span&gt;};
map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; authors &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {{&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Joyce&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;James&amp;#34;&lt;/span&gt;},
                               {&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Austen&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Jane&amp;#34;&lt;/span&gt;}};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初始化一个map时必须提供关键字类型和值类型。&lt;/p&gt;
&lt;h3 id=&#34;关键字类型的要求&#34;&gt;关键字类型的要求&lt;/h3&gt;
&lt;p&gt;对于有序容器map、set、multimap、multiset，关键字类型必须定义元素比较的方法。所提供的操作必须在关键字类型上定义一个严格弱序。&lt;/p&gt;
&lt;h3 id=&#34;pair类型&#34;&gt;pair类型&lt;/h3&gt;
&lt;p&gt;定义在头文件utility中。&lt;/p&gt;
&lt;p&gt;pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;pair&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; anon;
pair&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; author{&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;James&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Joyce&amp;#34;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;pair的数据成员是public的，两个成员分别命名为first和second，可以用普通的成员访问符号来访问它们。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; w.first &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; w.second &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;关联容器操作&#34;&gt;关联容器操作&lt;/h2&gt;
&lt;p&gt;除了之前在顺序容器P295页列出的类型，关联容器还定义了以下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key_type&lt;/code&gt;：此容器类型的关键字类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapped_type&lt;/code&gt;：每个关键字关联的类型，只适用于map&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value_type&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;对于set而言，与&lt;code&gt;key_type&lt;/code&gt;相同&lt;/li&gt;
&lt;li&gt;对于map而言，为&lt;code&gt;pair&amp;lt;const key_type, mapped_type&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用作用域运算符来提取一个类型的成员，例如：&lt;code&gt;map&amp;lt;string, int&amp;gt;::key_value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;只有map类型才定义了&lt;code&gt;mapped_type&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;关联容器迭代器&#34;&gt;关联容器迭代器&lt;/h3&gt;
&lt;p&gt;解引用一个关联容器迭代器时，就能得到一个类型为容器的value_type的值的引用。对于&lt;strong&gt;map&lt;/strong&gt;而言，&lt;strong&gt;value_type是一个pair类型&lt;/strong&gt;，其first成员保存&lt;strong&gt;const的关键字&lt;/strong&gt;，second成员保存值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; map_it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; word_count.begin();
&lt;span style=&#34;color:#888&#34;&gt;//*map_it是指向一个pair&amp;lt;const string, size_t&amp;gt;对象的引用
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;first;	&lt;span style=&#34;color:#888&#34;&gt;//打印此元素的关键字
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;first &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;new key&amp;#34;&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//错误，关键字是const的
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切记，一个map的value_type是一个pair，可以改变pair的值但不能改变关键字成员的值。&lt;/p&gt;
&lt;p&gt;我们通常不对关联容器使用泛型算法，&lt;strong&gt;关键字是const&lt;/strong&gt;这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是count的，map中元素是pair，其第一个成员是const的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遍历关联容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;map和set都支持begin和end操作，我们可以用这些函数获取迭代器，然后用迭代器来遍历容器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; map_it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; word_count.cbegin();
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (map_it &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; word_count.cend()) {
    cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;first &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;occurs &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;second &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;times&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;map_it;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外我们通常不对关联容器使用泛型算法，关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法要写入值。&lt;/p&gt;
&lt;h3 id=&#34;添加元素&#34;&gt;添加元素&lt;/h3&gt;
&lt;p&gt;关联容器的&lt;strong&gt;insert成员&lt;/strong&gt;向容器中添加一个元素或一个元素范围，map和set不包含重复关键字，因此插入一个已存在的元素对容器没有任何影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向map添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记住元素类型是pair。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;word_count.insert({word, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;});
word_count.insert(make_pair(word, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;c.emplace(args)&lt;/code&gt;：对于map和set，只有当元素的关键字不在c中时才插入（或构造）元素。&lt;/p&gt;
&lt;p&gt;insert返回的值依赖于容器类型和参数，对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功，pair的first成员是一个&lt;strong&gt;迭代器&lt;/strong&gt;，指向具有给定关键字的元素；second成员是一个&lt;strong&gt;bool值&lt;/strong&gt;，指出元素时插入成功还是已经存在于容器中。&lt;/p&gt;
&lt;h3 id=&#34;删除元素&#34;&gt;删除元素&lt;/h3&gt;
&lt;p&gt;关联容器定义了三个版本的erase，与顺序容器一样，我们可以通过传递给erase一个&lt;strong&gt;迭代器&lt;/strong&gt;或一个&lt;strong&gt;迭代器对&lt;/strong&gt;来删除一个元素或一个元素范围。&lt;/p&gt;
&lt;p&gt;关联容器额外提供一个erase操作，接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量。&lt;/p&gt;
&lt;h3 id=&#34;map的下标操作&#34;&gt;map的下标操作&lt;/h3&gt;
&lt;p&gt;map和unordered_map容器提供了下标运算符和一个对应的at函数，set类型不支持下标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; word_count;
word_count[&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c[k]	&lt;span style=&#34;color:#888&#34;&gt;//返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.at(k)	&lt;span style=&#34;color:#888&#34;&gt;//访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;访问元素&#34;&gt;访问元素&lt;/h3&gt;
&lt;p&gt;对于不允许重复关键字的容器，使用find和count没什么区别，但对于重复关键字的容器，count还会做更多的工作：如果元素在容器中，能够统计有多少个元素有相同的关键字。如果不需要技术，虽好使用find。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;set&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; iset &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;};
iset.find(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//返回一个迭代器，指向key == 1的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;iset.count(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//返回1
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;iset.count(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//返回0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;无序容器&#34;&gt;无序容器&lt;/h2&gt;
&lt;p&gt;C++11 新定义了4个无序关联容器。这些容器不是使用比较运算符来组织元素，而是使用一个&lt;strong&gt;哈希函数&lt;/strong&gt;和关键字类型的**==运算符**。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。&lt;/p&gt;
&lt;p&gt;虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到更好的效果还要进行一些性能测试和调优。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unordered_map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; word_count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;管理桶&#34;&gt;管理桶&lt;/h3&gt;
&lt;p&gt;无序容器在存储上组织为&lt;strong&gt;一组桶&lt;/strong&gt;，每个桶保存&lt;strong&gt;零个或多个元素&lt;/strong&gt;。无序容器使用一个&lt;strong&gt;哈希函数&lt;/strong&gt;将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个&lt;strong&gt;特定哈希值&lt;/strong&gt;的所有元素都保存在相同的桶中（有点像散列表处理冲突时使用的拉链法）。无需容器的性能依赖于哈希函数的质量和桶的数量。&lt;/p&gt;
&lt;h3 id=&#34;无需容器对关键字类型的要求&#34;&gt;无需容器对关键字类型的要求&lt;/h3&gt;
&lt;p&gt;默认情况下，无需容器使用关键字类型的==运算符来比较元素，它们还是用一个&lt;strong&gt;hash&amp;lt;key_type&amp;gt;类型&lt;/strong&gt;的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>现代操作系统学习日志——文件系统</title>
        <link>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Sat, 13 Nov 2021 19:54:09 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ -&lt;p&gt;所有计算机应用程序都需要存储和检索信息。&lt;/p&gt;
&lt;p&gt;进程运行时可以在自己的地址空间中存储一定量的信息，但存储容量易受到虚拟地址空间大小的限制。另外，进程终止时，它保存的信息也随之丢失，但对于很多应用（例如数据库）而言，有关信息必须能够保存&lt;strong&gt;很长时间甚至永久保留&lt;/strong&gt;。第三个问题是经常需要多个进程同时访问同一信息，解决方法是使得&lt;strong&gt;信息本身独立于任何一个进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，长期存储信息有以下基本要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够存储大量信息&lt;/li&gt;
&lt;li&gt;使用信息的进程终止时，信息仍旧存在&lt;/li&gt;
&lt;li&gt;必须能使多个进程并发访问有关信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘能够进行长期存储，我们将其当作一种大小固定的&lt;strong&gt;块&lt;/strong&gt;的线性序列，并且支持读块k和写块k的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件&lt;/strong&gt;是进程创建的&lt;strong&gt;信息逻辑单元&lt;/strong&gt;，一块磁盘中可以有很多文件，每个文件是独立于其他文件的，文件是&lt;strong&gt;对磁盘的建模&lt;/strong&gt;，而不是对RAM的建模。&lt;/p&gt;
&lt;p&gt;进程可以读取已经存在的文件，并在需要时建立新的文件。存储在文件中的信息必须是持久的。&lt;/p&gt;
&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;
&lt;h3 id=&#34;文件命名&#34;&gt;文件命名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;大小写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些区分、有些不区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UNIX中扩展名只是一张约定，操作系统不强迫采用，是用来提醒文件所有者的。&lt;/p&gt;
&lt;p&gt;而对于可以处理多种类型文件的程序，这类约定特别有用。例如C编译器可以编译、链接多种文件，这是扩展名就很必要。&lt;/p&gt;
&lt;p&gt;另外，Windows关注扩展名并且对其赋予了含义，用户或进程可以在操作系统中注册扩展名，并规定哪个程序拥有该扩展名。&lt;/p&gt;
&lt;h3 id=&#34;文件结构&#34;&gt;文件结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无结构的&lt;strong&gt;字节序列&lt;/strong&gt;（Windows和Unix采用这种方法）&lt;/li&gt;
&lt;li&gt;具有&lt;strong&gt;固定长度记录的序列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由一棵树构成的文件结构，每个记录不必具有相同长度，记录的固定位置上有一个键字段（在一些处理商业数据的大型计算机上广泛应用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件类型&#34;&gt;文件类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通文件&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ASCII文件&lt;/strong&gt;。优势是可以显示和打印，可以用任何文本编辑器进行编辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制文件&lt;/strong&gt;。有一定的内部结构，使用该文件的程序才了解这种结构，只有文件格式正确，操作系统才会执行。详细例子见书上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录&lt;/strong&gt;：管理文件系统结构的系统文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，Unix还具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字符特殊文件&lt;/strong&gt;。与&lt;strong&gt;I/O&lt;/strong&gt;有关，用于串行I/O设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块特殊文件&lt;/strong&gt;。用于&lt;strong&gt;磁盘设备&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个普通文件的例子：一个可执行文件、一个存档文件。详情见书上。&lt;/p&gt;
&lt;h3 id=&#34;文件访问&#34;&gt;文件访问&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;顺序访问&lt;/li&gt;
&lt;li&gt;随机访问文件
&lt;ul&gt;
&lt;li&gt;read操作给出开始读文件的位置&lt;/li&gt;
&lt;li&gt;用seek操作设置当前位置（Windows和UNIX使用这种方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件属性&#34;&gt;文件属性&lt;/h3&gt;
&lt;p&gt;除了文件名和数据外的与文件相关的信息，称为文件&lt;strong&gt;属性&lt;/strong&gt;或&lt;strong&gt;元数据&lt;/strong&gt;。这些信息在不同系统中有着很大差异。主要具有以下属性类别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与&lt;strong&gt;文件保护&lt;/strong&gt;相关的属性。创建者、所有者、口令等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标志&lt;/strong&gt;。用于控制或启动某些特殊属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用关键字查找记录的文件&lt;/strong&gt;中的属性：&lt;strong&gt;记录长度、键的位置和长度&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建时间&lt;/strong&gt;相关属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当前大小&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;p&gt;与文件有关的最常用的一些&lt;strong&gt;系统调用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;open&lt;/li&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;write&lt;/li&gt;
&lt;li&gt;append。write的限制格式，只能从文件末尾添加数据。&lt;/li&gt;
&lt;li&gt;seek&lt;/li&gt;
&lt;li&gt;get attributes&lt;/li&gt;
&lt;li&gt;set attributes&lt;/li&gt;
&lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一个文件系统调用实现复制的简单程序&#34;&gt;一个文件系统调用实现复制的简单程序&lt;/h3&gt;
&lt;p&gt;详情见书上。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;文件系统提供&lt;strong&gt;目录或文件夹&lt;/strong&gt;用于记录文件的位置。很多系统中目录本身也是文件。&lt;/p&gt;
&lt;h3 id=&#34;一级目录&#34;&gt;一级目录&lt;/h3&gt;
&lt;p&gt;有时也称为根目录。&lt;strong&gt;只有一个目录&lt;/strong&gt;，部分原因是只有一个用户。这种目录系统常用于嵌入式装置中。&lt;/p&gt;
&lt;h3 id=&#34;层级目录系统&#34;&gt;层级目录系统&lt;/h3&gt;
&lt;p&gt;使用层次结构（即一个目录树）。可以把文件以自然的方式进行分组，每个而用户可以为自己的目录树拥有自己的私人根目录。用户可以创建任意数量的子目录。&lt;/p&gt;
&lt;h3 id=&#34;路径名&#34;&gt;路径名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;绝对路径名&lt;/li&gt;
&lt;li&gt;相对路径名（又称工作目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持层次目录结构的大多数操作系统在每个目录中有两个特殊目录项&lt;code&gt;.&lt;/code&gt;和&lt;code&gt;..&lt;/code&gt;，常常读作dot和dotdot。dot指当前目录，dotdot指的是其父目录。使用一些与目录相关的命令时可以使用这两个目录项。&lt;/p&gt;
&lt;h3 id=&#34;目录操作&#34;&gt;目录操作&lt;/h3&gt;
&lt;p&gt;这里以UNIX为例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create（有时通过mdir完成）&lt;/li&gt;
&lt;li&gt;delete：删除目录，只有空目录可以删除。&lt;/li&gt;
&lt;li&gt;opendir&lt;/li&gt;
&lt;li&gt;closedir&lt;/li&gt;
&lt;li&gt;readdir&lt;/li&gt;
&lt;li&gt;rename&lt;/li&gt;
&lt;li&gt;link。链接技术允许多个目录中出现同一个文件。这种类型的链接增加了文件的&lt;strong&gt;i节点（i-node）计数器的计数&lt;/strong&gt;，有时称为硬链接。&lt;/li&gt;
&lt;li&gt;unlink。删除目录项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件系统的实现&#34;&gt;文件系统的实现&lt;/h2&gt;
&lt;h3 id=&#34;文件系统布局&#34;&gt;文件系统布局&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202112071744109.jpg&#34; alt=&#34;文件系统布局&#34;&gt;&lt;/p&gt;
&lt;p&gt;文件系统存放在&lt;strong&gt;磁盘&lt;/strong&gt;上，多数磁盘划分为&lt;strong&gt;一个或多个分区&lt;/strong&gt;，&lt;strong&gt;每个分区有一个独立的文件系统&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;磁盘的&lt;strong&gt;0号扇区&lt;/strong&gt;称为&lt;strong&gt;主引导记录（Master Boot Record，MBR）&lt;/strong&gt;，用来引导计算机。&lt;/p&gt;
&lt;p&gt;MBR的结尾是&lt;strong&gt;分区表&lt;/strong&gt;，该表给出了每个分区的起始地址和结束地址。&lt;/p&gt;
&lt;p&gt;计算机被引导时，BIOS读入并执行MBR，确定活动分区，读入其第一个块，称为&lt;strong&gt;引导块&lt;/strong&gt;，并执行之。引导块中的程序将装载该分区中的&lt;strong&gt;操作系统&lt;/strong&gt;。为了统一，每个分区都从一个引导块开始。&lt;/p&gt;
&lt;p&gt;除了从引导块开始，磁盘分区的布局随着文件系统的不同而变化。文件系统通常包含：&lt;strong&gt;超级块、空闲空间管理、i节点、根目录、其他文件和目录&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;文件的实现&#34;&gt;文件的实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;连续分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把每个文件作为一连串&lt;strong&gt;连续数据块&lt;/strong&gt;存储在磁盘中。&lt;/p&gt;
&lt;p&gt;优点：记录每个文件的位置较为简单，只要记住&lt;strong&gt;第一块的磁盘地址&lt;/strong&gt;和&lt;strong&gt;文件块数&lt;/strong&gt;；读操作性能好，只需要一次寻找（一个块）。&lt;/p&gt;
&lt;p&gt;缺点：会产生碎片。&lt;/p&gt;
&lt;p&gt;CD-ROM和DVD使用的就是这种方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个文件构造&lt;strong&gt;磁盘块链表&lt;/strong&gt;，即每个块的第一个字作为指向下一块的指针，块的其他部分存储数据。&lt;/p&gt;
&lt;p&gt;这一方法可以中分利用每个磁盘块。&lt;/p&gt;
&lt;p&gt;这种分配方法中，顺序读文件十分方便，但&lt;strong&gt;随机访问相当缓慢&lt;/strong&gt;（例如随机读取一个大文件中的一个具体的块）。另外，指针占去了一些字节，每个磁盘块存储数据的字节数不再是2的整数次幂。这样怪异的大小降低了系统的运行效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采用内存中的表进行链表分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取出&lt;strong&gt;每个磁盘块的指针字&lt;/strong&gt;，把他们放在内存的一个表中，可以解决上述链表的不足。可以从一个块开始，顺着链走到最后，找到一个文件的全部磁盘块。内存中这样的一个表格称为&lt;strong&gt;文件分配表（File Allocation Table，FAT）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法的缺点是要把整个表都存放在内存中，例如对于一个1TB的磁盘和1KB大小的块，这张表需要有10亿项，每项至少3字节，这张表要占用2.4GB内存，显然并不实用。所以FAT方式不能较好地扩展并应用于大型磁盘中，只是在最初的MS-DOS文件系统比较实用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;i节点（索引）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给每个文件赋予一个称为i节点的数据结构，其中列出了&lt;strong&gt;文件属性&lt;/strong&gt;和&lt;strong&gt;文件块的磁盘地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只有在对应&lt;strong&gt;文件打开时&lt;/strong&gt;其i节点才在&lt;strong&gt;内存中&lt;/strong&gt;，如果每个i节点占有n个字节，最多K个文件同时打开，那么为了打开文件而保留i节点的数组所占的全部内存仅仅是kn个字节，只需提前保留这么多空间即可。&lt;/p&gt;
&lt;p&gt;这个数组通常比FAT占据的空间要小。因为保留所有磁盘块的链表的表大小正比于磁盘自身的大小。而i节点在内存中数组的大小正比于要&lt;strong&gt;同时打开文件的数量&lt;/strong&gt;，与磁盘空间无关。&lt;/p&gt;
&lt;p&gt;i节点的一个问题是如果一个文件所含的磁盘块的数目超出i节点所能容纳的数据怎么办。解决方法为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后一个磁盘地址&lt;strong&gt;不指向数据块&lt;/strong&gt;，指向一个包含额外磁盘块地址的块的地址&lt;/li&gt;
&lt;li&gt;可以有两个或更多个包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。NTFS采用了相似的方法。&lt;/li&gt;
&lt;li&gt;链接方案：将多个索引块链接起来&lt;/li&gt;
&lt;li&gt;多层索引：第一层索引块指向第二层的索引块，第二层的索引块再指向文件块。两层索引允许的最大文件为4GB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;混合索引&lt;/strong&gt;：系统既采用直接地址，又采用单级索引或两级索引分配方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;目录的实现&#34;&gt;目录的实现&lt;/h3&gt;
&lt;p&gt;读文件前必须先打开文件。操作系统利用用户给出的&lt;strong&gt;路径名&lt;/strong&gt;找到相应的&lt;strong&gt;目录项&lt;/strong&gt;。目录项中提供了查找文件磁盘块所需的信息，因系统而异，可以是&lt;strong&gt;上一节中介绍的几种方法对应的信息&lt;/strong&gt;，如整个文件的磁盘地址（连续分配）、第一个块的编号（两种链表分配方案）、i节点号。（最新的操作系统使用i节点实现文件，每个目录项只引用i节点的目录）&lt;/p&gt;
&lt;p&gt;目录系统的主要功能就是把&lt;strong&gt;ASCII文件名&lt;/strong&gt;映射成&lt;strong&gt;定位文件数据所需的信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与此相关的问题是在何处&lt;strong&gt;存放文件属性&lt;/strong&gt;，共有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接存放在&lt;strong&gt;目录项&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录中有一个固定大小的&lt;strong&gt;目录项列表&lt;/strong&gt;，每个文件对应一项，其中包含文件名、文件属性的结构体以及说明磁盘块位置的一个或多个磁盘地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存放在&lt;strong&gt;i节点&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用i节点系统采用的方式，不存放在目录项中。这种情形下&lt;strong&gt;目录项&lt;/strong&gt;会更短：只有&lt;strong&gt;文件名和i节点号&lt;/strong&gt;，这种方法更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现可变长的长文件名的方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种方法是放弃所有目录项一样大。每个目录项有一个固定部分，这个固定部分以目录项长度开始，后面是固定格式的数据，包括各种属性，最后才是一个任意长度的实际文件名。为了使每个目录项从字的边界开始，每个文件名被填充成整数个字。这种方法的缺点是一走文件后引入了一个长度可变的空闲，下一个文件不一定适合这个空隙。另外，一个目录项可能分布在多个内存页面，读取文件名时可能发生缺页。&lt;/li&gt;
&lt;li&gt;另一种方法是使目录项有固定长度，&lt;strong&gt;文件名存放在目录后面的堆中&lt;/strong&gt;。优点是移走一个文件的目录项后，另一个文件的目录项可以适合这个空隙。另外要&lt;strong&gt;对堆进行管理&lt;/strong&gt;，处理文件名时还可能出现缺页。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加速查找文件名的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在每个目录中使用散列表进行查找。一般使用拉链法处理散列表的冲突。&lt;/p&gt;
&lt;p&gt;另一种加快大型目录查找速度的方法是将查找结果存入高速缓存。&lt;/p&gt;
&lt;h3 id=&#34;共享文件&#34;&gt;共享文件&lt;/h3&gt;
&lt;p&gt;通过&lt;strong&gt;链接&lt;/strong&gt;来实现不同目录的用户共享同一个而文件，这样，文件系统本身就是一个&lt;strong&gt;有向无环图DAG&lt;/strong&gt;而不是一棵树，这使得文件系统维护变得复杂，但也是必须付出的代价。&lt;/p&gt;
&lt;p&gt;共享也带来一些问题。若目录中包含磁盘地址，当链接文件时，必须把A目录中的地址复制到B目录，如果A或B随后又向目录中添加了内容，则新的数据块将只列入进行添加工作的用户目录中，其他用户对此不知情。解决这个问题的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构，目录指向这个小型数据结构。UNIX中使用的就是&lt;strong&gt;i节点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号链接法&lt;/strong&gt;，又称软链接法。系统建立一个&lt;strong&gt;类型为LINK的新文件&lt;/strong&gt;，将其存放在A的目录下，使得A与B的一个文件存在链接。新文件中只包含了它所链接的文件的&lt;strong&gt;路径名&lt;/strong&gt;。当A读该链接文件时，操作系统看到要读的文件类型为LINK，则找到该文件所链接的文件的名字，去读那个文件。符号链接法的问题是需要额外的开销，必须读取包含路径的文件，然后要一部分一部分地扫描路径，直到找到i节点。这些操作需要很多次额外的磁盘访问，并且每个符号链接都需要额外的i节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;日志结构文件系统&#34;&gt;日志结构文件系统&lt;/h3&gt;
&lt;p&gt;解决磁盘寻道时间没有快速发展但其他部件例如CPU、内存容量快速发展而带来的性能瓶颈。&lt;/p&gt;
&lt;p&gt;Berkeley设计了一种全新的文件系统来缓解这个问题，就是日志文件系统（Log-Structured File System，LFS）。&lt;/p&gt;
&lt;p&gt;促使LFS设计的主要原因是，CPU运行速度越来越快，内存容量变得更大，同时磁盘高速缓存也迅速增加，进而，不需要磁盘访问操作，就有可能满足直接来自文件系统高速缓存的很大一部分读请求。因此，未来多数磁盘访问的是写操作。&lt;/p&gt;
&lt;p&gt;更糟糕的是大多数文件系统中写操作往往都是零碎的，而一个50us的写操作前需要等待10ms的寻道时间和4ms的旋转延迟时间，可见零碎的写操作是没有效率的。根据上面的数据，磁盘的利用率下降到了1%以下。&lt;/p&gt;
&lt;p&gt;在UNIX文件系统上创建一个新的文件时，为了写这个文件，必须写该文件目录的i节点、目录块、文件的i节点以及文件本身。这些写操作都可能被延迟，那么如果在写操作完成前发生司机，就可能在文件系统中造成严重不一致性。因此i节点的写操作一般是立即完成的。&lt;/p&gt;
&lt;p&gt;处于这一原因，LFS的设计者决定重新实现一种文件系统，在面对一个大部分由零碎的随机写操作组成的任务时，同样能充分利用磁盘带宽。思想史将整个磁盘结构化为一个日志，每隔一段时间或由=有特殊要求时，被缓冲在内存中的所有未决的写操作都被放到一个单独的段，作为在日志末尾的一个邻接段写入磁盘，该段包含i节点、目录块、数据块等，每段开始都是段的摘要，说明段中包含的内容。&lt;/p&gt;
&lt;h3 id=&#34;日志文件系统&#34;&gt;日志文件系统&lt;/h3&gt;
&lt;p&gt;借鉴日志结构文件系统的实际应用，基本思想是保存一个用于&lt;strong&gt;记录系统下一步要做什么&lt;/strong&gt;的日志。这样当系统在完成它们即将完成的任务前崩溃时，重新启动后，可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。&lt;/p&gt;
&lt;p&gt;微软的NTFS、Linux ext3等文件系统都支持使用日志。&lt;/p&gt;
&lt;h3 id=&#34;虚拟文件系统&#34;&gt;虚拟文件系统&lt;/h3&gt;
&lt;p&gt;在同一个操作系统下可能使用很多不同的文件系统。Windows有一个主要的NTFS文件系统，但也包含老的FAT-32或FAT-16驱动器或分区，并且不时需要一个CD-ROM或DVD。Windows通过指定&lt;strong&gt;不同盘符&lt;/strong&gt;来处理这些不同的文件系统。当一个进程打开一个文件，盘符是显式或隐式存在的，所以Windows知道向哪个文件系统传递请求，不需要整合不同类型文件系统。&lt;/p&gt;
&lt;p&gt;相比之下，现代UNIX系统&lt;strong&gt;将多种文件系统整合到一个统一的结构中&lt;/strong&gt;。从用户的观点看，只有一个文件系统层级，他们事实上是多种不相容的文件系统，对用户和进程不可见。&lt;/p&gt;
&lt;p&gt;绝大多数UNIX操作系统都使用虚拟文件系统（Virtual File System, VFS）。关键思想就是抽象出所有文件系统共有的部分，并将这部分单独的代码放在单独一层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.jpg&#34; alt=&#34;虚拟文件系统&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件系统管理和优化&#34;&gt;文件系统管理和优化&lt;/h2&gt;
&lt;h3 id=&#34;磁盘空间管理&#34;&gt;磁盘空间管理&lt;/h3&gt;
&lt;p&gt;把文件分割成固定大小的块来存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;块大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据文件的大小来确定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记录空闲文件块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共有两种方法被广泛使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘块链表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链表的每个块中包含尽可能多的空闲磁盘块号。通常情况下，采用空闲块存放空闲表，这样不会影响存储器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;n个块的磁盘需要n位位图。位图中，空闲块用1表示，已分配块用0表示。&lt;/p&gt;
&lt;h3 id=&#34;文件系统备份&#34;&gt;文件系统备份&lt;/h3&gt;
&lt;h3 id=&#34;文件系统的一致性&#34;&gt;文件系统的一致性&lt;/h3&gt;
&lt;h3 id=&#34;文件系统性能&#34;&gt;文件系统性能&lt;/h3&gt;
&lt;p&gt;许多文件系统采用一些措施来改善性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高速缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把一系列的块存放在内存中。确定块是否在内存中的方法是使用&lt;strong&gt;散列表&lt;/strong&gt;，将设备和磁盘地址进行散列操作，然后在散列表中查找。&lt;/p&gt;
&lt;p&gt;高速缓存的调入调出原理与Cache一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;块提前读取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要用到块以前，试图提前将其写入高速缓存，从而提高命中率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少磁盘臂运动&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;磁盘碎片整理&#34;&gt;磁盘碎片整理&lt;/h3&gt;
&lt;p&gt;移动文件使它们相邻，并把所有的空闲空间放在一个或多个大的连续区域内。Windows中的defrag程序就是从事这个工作的。&lt;/p&gt;
&lt;p&gt;固态硬盘不需要这类操作。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法的时间复杂度和空间复杂度</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
        <pubDate>Fri, 13 Aug 2021 16:15:00 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/ -&lt;p&gt;用来衡量不同算法之间的优劣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：执行当前算法所&lt;strong&gt;消耗的时间&lt;/strong&gt;，用时间复杂度来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;空间维度：执行当前算法需要&lt;strong&gt;占用的内存空间&lt;/strong&gt;，我们通常用空间复杂度来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;大O符号表示法&lt;/strong&gt; ，即 T(n) = O(f(n))，这是时间复杂度的公式，f(n)表示&lt;strong&gt;每行代码执行次数之和&lt;/strong&gt;，O表示&lt;strong&gt;正比例关系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们通过以下一个程序举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i)
{
   j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
   j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设每行代码的执行时间都一样，我们用&lt;strong&gt;1颗粒时间&lt;/strong&gt;来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间，那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)&lt;/p&gt;
&lt;p&gt;大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。&lt;/p&gt;
&lt;p&gt;如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度级&#34;&gt;时间复杂度级&lt;/h3&gt;
&lt;p&gt;常见的时间复杂度级有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常数阶O(1)&lt;/li&gt;
&lt;li&gt;对数阶O(logN)&lt;/li&gt;
&lt;li&gt;线性阶O(n)&lt;/li&gt;
&lt;li&gt;线性对数阶O(nlogN)&lt;/li&gt;
&lt;li&gt;平方阶O(n²)&lt;/li&gt;
&lt;li&gt;立方阶O(n³)&lt;/li&gt;
&lt;li&gt;K次方阶O(n^k)&lt;/li&gt;
&lt;li&gt;指数阶(2^n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上向下时间复杂度越来越大，执行效率越来越低。&lt;/p&gt;
&lt;p&gt;下面来选取一些来举例：&lt;/p&gt;
&lt;h3 id=&#34;常数阶o1&#34;&gt;常数阶O(1)&lt;/h3&gt;
&lt;p&gt;无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i;
j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; j;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;线性阶on&#34;&gt;线性阶O(n)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i)
{
   j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
   j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;for循环中的代码会执行n遍。&lt;/p&gt;
&lt;h3 id=&#34;对数阶ologn&#34;&gt;对数阶O(logN)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt;(i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;n)
{
    i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里可以试着求解以下，假设循环x次后，i就大于n，循环就结束了，即$2^x=n$，那么$x=\log_2n$。即当循环$\log_2n$后代码就结束了，因此时间复杂度为O(logN).&lt;/p&gt;
&lt;h3 id=&#34;线性对数阶onlongn&#34;&gt;线性对数阶O(nlongN)&lt;/h3&gt;
&lt;p&gt;将时间复杂度为O(longN)的代码循环n遍就可以得到，将上面的代码稍作修改即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt;(m&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; m&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;n; m&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
{
    i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt;(i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;n)
    {
        i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;平方阶on2&#34;&gt;平方阶O(n^2)&lt;/h3&gt;
&lt;p&gt;很容易理解，将两个n次循环嵌套即可得到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt;(x&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt;n; x&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
{
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt;n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
    {
       j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
       j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;立方阶on3k次方阶onk&#34;&gt;立方阶O(n^3)、k次方阶O(n^k)&lt;/h3&gt;
&lt;p&gt;与平方阶类似，立方阶相当于3层循环。&lt;/p&gt;
&lt;h2 id=&#34;空间复杂度&#34;&gt;空间复杂度&lt;/h2&gt;
&lt;p&gt;空间复杂度与时间复杂度相同，实际上也不是用来计算程序实际占用的空间的。&lt;/p&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。&lt;/p&gt;
&lt;p&gt;空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：&lt;/p&gt;
&lt;h3 id=&#34;空间复杂度o1&#34;&gt;空间复杂度O(1)&lt;/h3&gt;
&lt;p&gt;如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i;
j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; j;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)&lt;/p&gt;
&lt;h3 id=&#34;空间复杂度on&#34;&gt;空间复杂度O(n)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;[]&lt;/span&gt; m &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;n&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;i&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;1&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt;n&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
   j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
   j&lt;span style=&#34;color:#333&#34;&gt;++;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一行new了一个数组，这个数据占用的大小为n，第2-6行虽然有循环，但没有分配新的空间，因此空间复杂度看第一行即可，即S(n)=O(n)。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>csapp: 3.程序的机器级表示</title>
        <link>https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link>
        <pubDate>Mon, 09 Aug 2021 16:08:05 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/ -&lt;h1 id=&#34;第三章-程序的机器级表示&#34;&gt;第三章 程序的机器级表示&lt;/h1&gt;
&lt;h2 id=&#34;历史观点&#34;&gt;历史观点&lt;/h2&gt;
&lt;p&gt;典型的编译器在将C程序结构变换成机器代码时所做的转换。&lt;/p&gt;
&lt;p&gt;英特尔X86-64处理器的发展历史。&lt;/p&gt;
&lt;p&gt;从8086到Core i7&lt;/p&gt;
&lt;h2 id=&#34;程序编码&#34;&gt;程序编码&lt;/h2&gt;
&lt;h3 id=&#34;机器级代码&#34;&gt;机器级代码&lt;/h3&gt;
&lt;p&gt;对于机器级编程来说，两种抽象非常重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由&lt;strong&gt;指令集体系结构&lt;/strong&gt;或**指令集架构(ISA, Instruction Set Architecture)**来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，以及每条指令对状态的影响。&lt;/li&gt;
&lt;li&gt;机器级程序使用的内存地址是&lt;strong&gt;虚拟地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x86-64机器码中，一些通常对C语言隐藏的处理器状态都是可见的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;(PC，在x86-64中用%rip表示)：给出将要执行的下一条指令在内存中的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整数寄存器&lt;/strong&gt;文件：包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址(对应C语言指针)或整数数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件码寄存器&lt;/strong&gt;：保存最近执行的算数或逻辑指令的状态信息，用来实现控制或数据流中的条件变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x86-64的虚拟地址由64位的字表示，但目前这些地址的&lt;strong&gt;高16位&lt;/strong&gt;必须设为零，相当于可以表示$2^{48}$或256TB内存范围内的一个字节。及目前的64位计算机只使用48位来表示地址范围。&lt;/p&gt;
&lt;h3 id=&#34;代码示例&#34;&gt;代码示例&lt;/h3&gt;
&lt;p&gt;机器对产生这些汇编语言指令的源代码几乎一无所知，全都是字节序列。&lt;/p&gt;
&lt;p&gt;生成可执行的代码需要对一组目标代码文件运行链接器，这组目标代码文件中必须含有一个main函数。&lt;/p&gt;
&lt;p&gt;链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。&lt;/p&gt;
&lt;p&gt;反汇编器&lt;/p&gt;
&lt;h3 id=&#34;关于格式的注解&#34;&gt;关于格式的注解&lt;/h3&gt;
&lt;p&gt;ATT与Intel汇编代码格式的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel代码省略了指示大小的后缀。例如看到的指令为push和mov而不是pushq和movq。&lt;/li&gt;
&lt;li&gt;Intel代码胜率了寄存器名字前的%符号。&lt;/li&gt;
&lt;li&gt;Intel代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据格式&#34;&gt;数据格式&lt;/h2&gt;
&lt;p&gt;Intel用&lt;strong&gt;字(word)&lt;strong&gt;表示&lt;/strong&gt;16位&lt;/strong&gt;数据类型，因此称&lt;strong&gt;32位&lt;/strong&gt;数为&lt;strong&gt;双字&lt;/strong&gt;，称&lt;strong&gt;64位&lt;/strong&gt;数位&lt;strong&gt;四字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下表给出了C语言基本数据类型对应的x86-64表示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C声明&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Intel数据类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;汇编代码后缀&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小(字节)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;char&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;short&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双字&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;l&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;四字&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;q&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;char*&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;四字&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;q&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单精度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双精度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;l&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;大多数GCC生成的汇编代码指令都有一个字符的后缀，表明&lt;strong&gt;操作数的大小&lt;/strong&gt;。例如数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)、movq(传送四字)。&lt;/p&gt;
&lt;p&gt;浮点数和整数使用一组完全不同的指令和寄存器。&lt;/p&gt;
&lt;h2 id=&#34;访问信息&#34;&gt;访问信息&lt;/h2&gt;
&lt;p&gt;一个x86-64CPU包含一组&lt;strong&gt;16个&lt;/strong&gt;存储64位值的&lt;strong&gt;通用寄存器&lt;/strong&gt;，用来存储整数数据和指针。最初的8086有8个16位的通用寄存器，发展到现在的x86-64后，原来的8个寄存器扩展为了64位，标号从%rax到%rsp，除此之外还新增了8个寄存器，从%r8到%r15。&lt;/p&gt;
&lt;p&gt;在常见程序中不同寄存器扮演不同的角色，最特别的是栈指针%rsp，用来指明运行时栈的结束位置。&lt;/p&gt;
&lt;p&gt;另外15个寄存器的用法更加灵活，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值、以及存储局部和临时数据。&lt;/p&gt;
&lt;h3 id=&#34;操作数指示符&#34;&gt;操作数指示符&lt;/h3&gt;
&lt;p&gt;大多数指令具有一个或多个&lt;strong&gt;操作数&lt;/strong&gt;，指示出一个操作中要使用的源数据值以及放置结果的目的位置。源数据值可以以常数的形式给出，或从寄存器或内存中读出。结果可以存放在寄存器或内存中。操作数可以分为三类，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;立即数&lt;/strong&gt;：用来表示常数值，在ATT编码格式中，立即数是&lt;code&gt;$&lt;/code&gt;后跟一个用标准C表示法表示的整数，例如&lt;code&gt;$0x1F&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄存器&lt;/strong&gt;：表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应8位、16位、32位或64位。用符号$r_a$来表示任意寄存器$a$，用引用$R[r_a]$表示它的值。即将寄存器集合看作一个数组R，用寄存器标识符作为引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存引用&lt;/strong&gt;：根据计算出的地址访问某个内存位置。用符号$M_b[\text{Addr}]$表示对存储在内存中从Addr地址开始的b个字节值的引用，实际中一般省去下表b。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有多种不同的&lt;strong&gt;寻址模式&lt;/strong&gt;，最通用的形式为：$Imm(r_b,r_i,s)$，Imm表示一个立即数偏移，$r_b$表示一个基址寄存器，$r_i$表示一个变址寄存器，s表示一个比例因子，操作数值即有效地址为$M[Imm+R[r_b]+R[r_i]\cdot s]$。其他形式都是这种通用形式的特殊情况。&lt;/p&gt;
&lt;h3 id=&#34;数据传送指令&#34;&gt;数据传送指令&lt;/h3&gt;
&lt;p&gt;最频繁使用的指令是将数据从一个位置复制到另一个位置。这里会介绍很多种数据传送指令，他们或者源和目的类型不同，或者执行的转换不同，或者具有一些副作用。把许多不同指令划分为&lt;strong&gt;指令类&lt;/strong&gt;，每类中的指令执行相同操作，只不过操作数大小不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MOV类指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MOV类由四条指令组成，movb(字节), movw(字), movl(双字), movq(四字)。主要区别为他们操作的数据大小不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MOV S, D&lt;/code&gt;：将S(source)传送到D(destination)&lt;/p&gt;
&lt;p&gt;源操作数指定的值是一个&lt;strong&gt;立即数&lt;/strong&gt;，存储在寄存器或内存中；目的操作数指定一个&lt;strong&gt;位置&lt;/strong&gt;，要么是一个寄存器，要么是一个内存地址。&lt;/p&gt;
&lt;p&gt;x86-64的两个操作数&lt;strong&gt;不能都指向内存位置&lt;/strong&gt;，如果要将一个值从内存的一个位置复制到另一个位置，要先将该值读入寄存器，再将寄存器的值写入目标内存。&lt;/p&gt;
&lt;p&gt;movabsq指令能以任意64位立即数值作为源操作数，并且只能以寄存器为目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将较小源值复制到较大目的：使用MOVZ和MOVS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MOVZ：把目的中剩余的字节填充为0&lt;/p&gt;
&lt;p&gt;MOVS：通过符号扩展来填充，把源操作的最高位进行复制&lt;/p&gt;
&lt;h3 id=&#34;数据传送示例代码&#34;&gt;数据传送示例代码&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;exchange&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;xp, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; y)
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;xp;	&lt;span style=&#34;color:#888&#34;&gt;//解引用操作符，把指针xp指向地址的数值放入寄存器x
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y;	&lt;span style=&#34;color:#888&#34;&gt;//指针符号，把数y放入指针xp指向的地址
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;;xp in %rdi, y in %rsi
exchange:
	movq (%rdi), %rax
	movq %rsi, (%rdi)
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该例子说明了利用MOV指令从内存中读值到寄存器以及从寄存器写入内存。&lt;/p&gt;
&lt;p&gt;局部变量x通常保存在寄存器中，速度较快。&lt;/p&gt;
&lt;h3 id=&#34;压入和弹出栈数据&#34;&gt;压入和弹出栈数据&lt;/h3&gt;
&lt;p&gt;将数据压入程序栈中以及从程序栈中弹出数据。栈是一种数据结构，遵循&lt;strong&gt;后进先出&lt;/strong&gt;。弹出的值是最近被压入且仍在栈中的值。&lt;/p&gt;
&lt;p&gt;栈可以实现为一个数组，总是从数组的一端插入和删除值，这一端被称为&lt;strong&gt;栈顶&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;程序栈存放于内存的一个区域，栈向下增长，即栈顶元素的地址是&lt;strong&gt;最低&lt;/strong&gt;的，根据惯例倒过来画栈，即栈顶在图的底部。栈指针%rsp保存着栈顶元素的地址。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pushq S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;R[%rsp]$\leftarrow$R[%rsp]-8; M[R[%rsp]]$\leftarrow$S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将四字压入栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;popq D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$M[R[%rsp]]; R[%rsp]$\leftarrow$R[%rsp]+8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将四字弹出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;算数和逻辑操作&#34;&gt;算数和逻辑操作&lt;/h2&gt;
&lt;h3 id=&#34;加载有效地址leaq&#34;&gt;加载有效地址leaq&lt;/h3&gt;
&lt;p&gt;leaq指令能执行加法和有限形式的乘法，实际上是movq指令的变形。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;leaq S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D $\leftarrow$&amp;amp;S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加载有效地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;该指令实际并未引用内存，而是将有效地址写入到目的操作数。&amp;amp;为取地址符，即产生一个指针。&lt;/p&gt;
&lt;p&gt;例如如果寄存器%rdx的值为x，指令&lt;code&gt;leaq 7(%rdx,%rdx,4),%rax&lt;/code&gt;将寄存器%rax的值设置为5x+7。这种用法与有效地址的计算无关。&lt;/p&gt;
&lt;p&gt;目的操作数必须是一个寄存器。&lt;/p&gt;
&lt;h3 id=&#34;一元和二元操作&#34;&gt;一元和二元操作&lt;/h3&gt;
&lt;p&gt;一元操作指令和效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;INC D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D+1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DEC D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D-1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;减1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NEG D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$-D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;取负&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NOT D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$~D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;取补&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;只有一个操作数，这个操作数可以是一个寄存器或内存位置。&lt;/p&gt;
&lt;p&gt;二元操作指令和效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ADD S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D+S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SUB S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D-S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IMUL S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D*S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;乘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;XOR S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D^S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;异或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;OR S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D|S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AND S,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D&amp;amp;S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;与&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。&lt;/p&gt;
&lt;p&gt;当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写入内存。&lt;/p&gt;
&lt;h3 id=&#34;移位操作&#34;&gt;移位操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SAL k,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D&amp;laquo;k&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;左移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SHL k,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D&amp;laquo;k&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;左移(等同于SAL)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SAR k,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D$&amp;raquo;_A$k&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;算数右移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SHR k,D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$D$&amp;raquo;_L$k&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑右移&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;先给出移位量k，第二项给出的是要移位的数。&lt;/p&gt;
&lt;p&gt;移位量可以是&lt;strong&gt;立即数&lt;/strong&gt;，或放在&lt;strong&gt;单字节寄存器%cl&lt;/strong&gt;中。目标操作数可以是一个寄存器或一个内存位置。&lt;/p&gt;
&lt;h3 id=&#34;乘法和除法&#34;&gt;乘法和除法&lt;/h3&gt;
&lt;p&gt;INTEL把16字节的数称为8字。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;imulq S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R[%\text{rdx}]: R[%\text{rax}]\leftarrow S\times R[%\text{rax}]$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有符号全乘法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mulq S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R[%\text{rdx}]: R[%\text{rax}]\leftarrow S\times R[%\text{rax}]$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无符号全乘法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cqto&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;转换为八字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;idivq S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R[%\text{rdx}]\leftarrow R[%\text{rdx}] : R[%\text{rax}] \ \text{mod} \ S$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有符号除法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;divq S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R[%\text{rdx}]\leftarrow R[%\text{rdx}] : R[%\text{rax}] \ \text{mod} \ S$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无符号除法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;imulq指令有两种不同形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;双操作数&lt;/strong&gt;乘法指令：是IMUL的一种形式，从两个64位操作数产生一个64位乘积&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单操作数&lt;/strong&gt;乘法指令：计算两个64位值的全128位乘积，一个是无符号数乘法(mulq)，另一个是补码乘法(imulq)，这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数即如上所示的S给出。乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cqto指令：隐含读出%rax的符号位，并将其复制到%rdx的所有位。&lt;/p&gt;
&lt;p&gt;汇编器能通过计算操作数数目，分辨想用哪条指令。&lt;/p&gt;
&lt;p&gt;乘法代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; __int128 uint128_t;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;store_uprod&lt;/span&gt;(uint128_t &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;dest, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;uint64_t&lt;/span&gt; x, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;uint64_t&lt;/span&gt; y) {
    &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; (uint128_t) y;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将x和y显式地声明为64位数字。使用GCC提供的128位整数支持。这段代码指明得到的乘积应该存放在指针dest指向的16字节处。&lt;/p&gt;
&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;;dest in %rdi, x in %rsi, y in %rdx
store_uprod:
	movq %rsi, %rax
	mulq %rdx
	movq %rax, (%rdi)
	movq %rdx, 8(%rdi)
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存储乘积需要两个movq，一个存储低8个字节，另一个存储高8个字节；由于该机器是小端法及其，所以高位字节存储在大地址。&lt;/p&gt;
&lt;p&gt;除法操作由&lt;strong&gt;单操作数除法指令&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax，将余数存储在寄存器%rdx。&lt;/p&gt;
&lt;p&gt;除法代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;remdiv&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; x, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; y, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;qp, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;rp) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; q &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;y;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;%&lt;/span&gt;y;
	&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;qp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; q;
	&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;rp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;;x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
	movq %rdx, %r8
	movq %rdx, %rax
	cqto
	idivq %rsi
	movq %rax, (%r8)
	movq %rdx, (%rcx)
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;控制&#34;&gt;控制&lt;/h2&gt;
&lt;p&gt;条件和跳转。&lt;/p&gt;
&lt;p&gt;C语言中某些结构例如条件语句、循环语句和分支语句，要求有条件地执行，根据数据测试结果来改变控制流或数据流。&lt;/p&gt;
&lt;h3 id=&#34;条件码&#34;&gt;条件码&lt;/h3&gt;
&lt;p&gt;CPU除了整数寄存器还维护着一组单个位的&lt;strong&gt;条件码寄存器&lt;/strong&gt;，描述了最近的算术和逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CF：进位标志。最近的操作使&lt;strong&gt;最高位产生了进位&lt;/strong&gt;则&lt;strong&gt;置为1&lt;/strong&gt;。可用来检测无符号操作的溢出。(carry)&lt;/li&gt;
&lt;li&gt;ZF：零标志。最近的操作得出的&lt;strong&gt;结果为0&lt;/strong&gt;则置为1。(zero)&lt;/li&gt;
&lt;li&gt;SF：符号标志。最近的操作得到的&lt;strong&gt;结果为负数&lt;/strong&gt;则置为1。(symbol)&lt;/li&gt;
&lt;li&gt;OF：溢出标志。最近的操作导致一个&lt;strong&gt;补码溢出&lt;/strong&gt;则置为1。(overflow)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(F代指Flag)&lt;/p&gt;
&lt;h3 id=&#34;访问条件码&#34;&gt;访问条件码&lt;/h3&gt;
&lt;p&gt;条件码通常不会直接读取，常用方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据条件码的某种组合，将一个字节设置为0或1&lt;/li&gt;
&lt;li&gt;可以条件跳转到程序的某个其他部分&lt;/li&gt;
&lt;li&gt;可以有条件地传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SET指令：第一种情况，根据条件码的某种组合，将一个字节设置为0或1。不同后缀的set指令指明了其所考虑的&lt;strong&gt;条件码组合&lt;/strong&gt;，不是指操作数的大小。&lt;/p&gt;
&lt;p&gt;一条SET指令的&lt;strong&gt;目的操作数&lt;/strong&gt;是&lt;strong&gt;低位单字节寄存器&lt;/strong&gt;元素之一，或&lt;strong&gt;一个字节的内存位置&lt;/strong&gt;，指令会将这个字节设置为0或1.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;同义名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;效果&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;设置条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sete D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$ZF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相等（差为0）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setne D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$~ZF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不相等（差不为0）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sets D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$SF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setns D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$~SF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非负数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setg D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$~(SF^OF)&amp;amp;~ZF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;大于（有符号&amp;gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setge D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D$\leftarrow$~(SF^OF)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;大于等于（有符号&amp;gt;=）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setl D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;小于（有符号&amp;lt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setle D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;小于等于（有符号&amp;lt;=）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;seta D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超过（无符号&amp;gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setae D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超过或相等（无符号&amp;gt;=）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setb D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低于（无符号&amp;lt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;setbe D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低于或相等（无符号&amp;lt;=）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：^代指异或运算。&lt;/p&gt;
&lt;p&gt;各个SET命令的描述都是用的情况是：执行比较指令，根据t=a-b设置条件码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于有符号比较的测试来说，假设a、b、t分别是变量a、b和t的补码形式表示的整数，因此t
&lt;ul&gt;
&lt;li&gt;溢出位OF和符号位SF的EXCLUSIVE-OR提供了a&amp;lt;b是否为真的测试，其他有符号比较测试基于SF异或OF和ZF的其他组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于无符号比较的测试来说，使用的是进位标志CF和零标志ZF的组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;跳转指令&#34;&gt;跳转指令&lt;/h3&gt;
&lt;p&gt;跳转(jump)指令会导致执行&lt;strong&gt;切换到程序中一个全新的位置&lt;/strong&gt;，汇编代码中这些跳转目的地通常用一个**标号(label)**指明。&lt;/p&gt;
&lt;p&gt;汇编器会确定所有带标号指令的地址，并将&lt;strong&gt;跳转目标&lt;/strong&gt;编码为跳转指令的一部分。&lt;/p&gt;
&lt;p&gt;跳转指令分为有条件条状和无条件跳转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无条件跳转&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;jmp指令可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接跳转：跳转目标作为指令的一部分编码，即直接给出一个标号作为跳转目标&lt;/li&gt;
&lt;li&gt;间接跳转：跳转目标是从寄存器或内存位置中读出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;间接跳转的写法是&lt;code&gt;*&lt;/code&gt;后面跟一个操作数指示符，例如：&lt;code&gt;jmp *%rax&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;跳转条件&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jmp Label&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;直接跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jmp *Operand&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;间接跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;有条件跳转&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;根据&lt;strong&gt;条件码的某种组合&lt;/strong&gt;，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字后缀与SET指令相匹配。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;同义名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;跳转条件&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;je Label&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ZF==1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相等（零）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jne Label&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jnz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;~ZF==1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不相等（非零）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;js&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jns&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非负数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jg&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;大于（有符号&amp;gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jge&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jnl&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;大于或等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jl&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;小于（有符号&amp;lt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;小于或等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ja&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超过（无符号&amp;gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jae&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超过或相等（无符号&amp;gt;=）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jb&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低于（无符号&amp;lt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jbe&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低于或相等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;跳转指令的编码&#34;&gt;跳转指令的编码&lt;/h3&gt;
&lt;p&gt;对于链接的理解非常重要，同时也能帮助理解反汇编器的输出。&lt;/p&gt;
&lt;p&gt;跳转指令最常用的是&lt;strong&gt;PC相对编码&lt;/strong&gt;。即将目标指令的地址与紧跟在跳转指令后的那条指令的地址之差作为编码，这些地址偏移量可以编码为1、2或4字节。&lt;/p&gt;
&lt;p&gt;rep指令用来实现重复的字符串操作，可以忽略。&lt;/p&gt;
&lt;h3 id=&#34;用条件控制来实现条件分支&#34;&gt;用条件控制来实现条件分支&lt;/h3&gt;
&lt;p&gt;将条件表达式从C语言翻译为机器码，最常用的方式是结合&lt;strong&gt;有条件和无条件跳转&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;C语言的if-else语句通用模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr)
	then&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;汇编使用以下形式实现，这里用C语法来描述控制流：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;t &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;t)
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt;;
then&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; done;
&lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;done&lt;/span&gt;:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;汇编器位then-statement和else-statement产生了各自的代码块，它会插入条件和无条件分支，保证能执行正确代码块。&lt;/p&gt;
&lt;h3 id=&#34;用条件传送实现条件分支&#34;&gt;用条件传送实现条件分支&lt;/h3&gt;
&lt;p&gt;实现条件操作的传统方法是使用&lt;strong&gt;控制&lt;/strong&gt;的条件转移，当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单，但在现代处理器中非常低效。&lt;/p&gt;
&lt;p&gt;替代策略是使用&lt;strong&gt;数据&lt;/strong&gt;的条件转移。这种方法计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;absdiff&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; x, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; y)
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; result;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; y)
		result &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; y &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; x;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
		result &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; y;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;产生的汇编代码为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;;x in %rdi, y in &amp;amp;rsi
absdiff:
	movq %rsi, %rax
	subq %rdi, %rax		;rval = y - x
	movq %rdi, %rdx
	subq %rsi, %rdx		;eval = x - y
	cmpq %rsi, %rdi		;Compare x:y
	cmovge %rdx, %rax	;If &amp;gt;=, rval = eval
	ret					;Return rval
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;条件传送指令：指令的结果取决于条件码的值，&lt;strong&gt;当传送条件满足时，指令把源值S复制到目的R&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每条指令都有两个操作数：源寄存器或内存地址S，和目的寄存器D&lt;/p&gt;
&lt;p&gt;源和目的的值可以为16、32或64位，不支持单字传送。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;comove S,R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovne S,R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovs S,R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovns S,R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovg S,R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovge S,R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovle&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmova&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovae&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmovb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读取源值，检查条件码，然后要么更新目的寄存器，要么保持不变。&lt;/p&gt;
&lt;h3 id=&#34;循环&#34;&gt;循环&lt;/h3&gt;
&lt;p&gt;汇编中没有相应的循环指令，可以使用条件测试和跳转组合起来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;do-while&lt;/strong&gt;循环&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;loop&lt;/span&gt;:
	body&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
	t &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (t)
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; loop;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;while&lt;/strong&gt;循环&lt;/p&gt;
&lt;p&gt;两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跳转到中间&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; test;
&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;loop&lt;/span&gt;:
	body&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;test&lt;/span&gt;:
	t &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (t)
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; loop;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;guarded-do&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;t &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;t)
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; done;
&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;loop&lt;/span&gt;:
	body&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
	t &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (t)
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;goto&lt;/span&gt; loop;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;循环&lt;/p&gt;
&lt;p&gt;for循环的通用形式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (init&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr; test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr; update&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr)	body&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将其改写为使用while循环的形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;init&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (test&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr) {	body&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;statement	update&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;expr;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;switch语句&#34;&gt;switch语句&lt;/h3&gt;
&lt;p&gt;switch语句可以根据一个&lt;strong&gt;整数索引值&lt;/strong&gt;进行多重分支。而且可以通过使用&lt;strong&gt;跳转表&lt;/strong&gt;这种数据结构使得实现更加高效。&lt;/p&gt;
&lt;p&gt;跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。&lt;/p&gt;
&lt;p&gt;使用跳转表的优点是执行开关语句的时间&lt;strong&gt;与开关情况的数量无关&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;过程&#34;&gt;过程&lt;/h2&gt;
&lt;p&gt;提供了一种封装代码的方式，相当于&lt;strong&gt;函数接口&lt;/strong&gt;。用一组指定的参数和一个可选的返回值实现了某种功能。&lt;/p&gt;
&lt;p&gt;要提供对过程的机器级支持，必须要处理许多不同属性。假设过程P调用过程Q，Q执行后返回到P。这些动作包含以下一个或多个机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传递控制&lt;/strong&gt;：进入过程Q时，&lt;strong&gt;程序计数器&lt;/strong&gt;必须被设置为Q的代码的起始位置，然后在返回时，把程序计数器设置为P中调用Q后面那条指令的地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递数据&lt;/strong&gt;：P必须能够向Q提供一个或多个参数，Q必须向P返回一个值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配和释放内存&lt;/strong&gt;：开始时Q可能要为&lt;strong&gt;局部变量&lt;/strong&gt;分配空间，在返回前又必须释放这些空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;运行时栈&#34;&gt;运行时栈&lt;/h3&gt;
&lt;p&gt;C语言过程调用机制使用了栈数据结构提供后进先出的内存管理原则。&lt;/p&gt;
&lt;p&gt;当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。&lt;/p&gt;
&lt;h3 id=&#34;转移控制&#34;&gt;转移控制&lt;/h3&gt;
&lt;p&gt;当控制从函数P转移到函数Q时，只需要简单地把程序计数器(PC)设置为Q的代码的起始位值，稍后从Q返回时，处理器必须记录好他需要继续P的执行的代码位置。在x86-64中，这个信息用指令&lt;code&gt;call Q&lt;/code&gt;调用过程Q来记录。&lt;/p&gt;
&lt;h2 id=&#34;数组分配和访问&#34;&gt;数组分配和访问&lt;/h2&gt;
&lt;p&gt;C语言可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译为地址计算。&lt;/p&gt;
&lt;h3 id=&#34;基本原则&#34;&gt;基本原则&lt;/h3&gt;
&lt;p&gt;对于数据类型T和整型常数N，数组声明如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;T A[N];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;起始位置为$x_A$，在内存中分配一个$L \cdot N$字节的连续区域，L为数据类型T的大小，其次，引入标识符A，可以用A作为指向数组开头的指针，该指针的值为$x_A$。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;char A[12];&lt;/code&gt;，数组A由12个单字节(char)元素组成。&lt;/p&gt;
&lt;h3 id=&#34;指针运算&#34;&gt;指针运算&lt;/h3&gt;
&lt;h3 id=&#34;嵌套的数组&#34;&gt;嵌套的数组&lt;/h3&gt;
&lt;p&gt;二维数组可以以嵌套声明，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; A[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;][&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等价于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; row3_t[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;];
row3_t A[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二维数组一般按照行优先顺序进行排列。&lt;/p&gt;
&lt;h3 id=&#34;定长数组&#34;&gt;定长数组&lt;/h3&gt;
&lt;p&gt;一般使用&lt;code&gt;#define&lt;/code&gt;声明将常数与一个名字联系起来，然后一直使用这个名字代替常数的数值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define N 16
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; fix_matrix[N][N];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;变长数组&#34;&gt;变长数组&lt;/h3&gt;
&lt;p&gt;ISO C99引入一种功能，允许数组的维度是表达式，在数组被分配时才计算出来。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;var_ele&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; n, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; A[n][n], &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; i, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; j){
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; A[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数&lt;code&gt;n&lt;/code&gt;必须在参数&lt;code&gt;A[n][n]&lt;/code&gt;之前.&lt;/p&gt;
&lt;h2 id=&#34;数据结构struct和union&#34;&gt;数据结构struct和union&lt;/h2&gt;
&lt;p&gt;结构用struct来声明，将多个对象集合到一个单位中。&lt;/p&gt;
&lt;p&gt;联合用union来声明，允许用几种不同类型来引用一个对象。&lt;/p&gt;
&lt;h3 id=&#34;结构&#34;&gt;结构&lt;/h3&gt;
&lt;p&gt;C语言的struct声明创建一个将不同类型的对象集合到一个对象中的数据类型。&lt;strong&gt;用名字来引用&lt;/strong&gt;结构的各个组成部分，类似于数组的实现。&lt;/p&gt;
&lt;p&gt;结构的所有组成部分都放在内存中的一段&lt;strong&gt;连续区域&lt;/strong&gt;，指向结构的指针就是结构&lt;strong&gt;第一个字节的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向对象的C++和Java的对象要比C语言中的结构要复杂精细得多，因为他们将一组方法与一个对象联系起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。&lt;/p&gt;
&lt;p&gt;要产生一个指向结构内部对象的指针，只需将结构的地址加上该字段的偏移量。&lt;/p&gt;
&lt;h3 id=&#34;联合&#34;&gt;联合&lt;/h3&gt;
&lt;p&gt;结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），union占用的内存等于最长的成员占用的内存。union使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。&lt;/p&gt;
&lt;h3 id=&#34;数据对齐&#34;&gt;数据对齐&lt;/h3&gt;
&lt;p&gt;一些计算机对&lt;strong&gt;基本数据类型的合法地址&lt;/strong&gt;作出了限制，要求某种类型对象的地址必须是某个值K(通常是2、4、8)的倍数。这种内存对齐限制简化了处理器和内存之间接口的硬件设计。例如，一个处理器每次总是从内存中读取8个字节，则地址必须为8的倍数；如果我们保证double类型数据的地址对其成8的倍数，那么就可以用一次内存操作来读或写值，否则可能执行两次内存访问，因为对象可能被放在两个8字节内存块中。&lt;/p&gt;
&lt;p&gt;内存地址对其是通过编译器来控制的。对于大多数x86-64指令来说，保持数据对其能提高效率，不会影响程序行为。&lt;/p&gt;
&lt;h2 id=&#34;数据和控制的交互&#34;&gt;数据和控制的交互&lt;/h2&gt;
&lt;h3 id=&#34;指针&#34;&gt;指针&lt;/h3&gt;
&lt;p&gt;下面是一些指针和它们映射到机器代码的关键原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个指针都&lt;strong&gt;对应一个类型&lt;/strong&gt;。类型表明指针指向对象的类型。指针类型不是机器代码的一部分，是C语言提供的一种抽象，帮助我们避免寻址错误。&lt;/li&gt;
&lt;li&gt;每个指针都有一个值。这个值是某个指定类型对象的地址。&lt;/li&gt;
&lt;li&gt;指针用取地址符&lt;code&gt;&amp;amp;&lt;/code&gt;创建。leaq指令用来计算内存引用的地址，&amp;amp;运算符的机器代码实现常用leaq指令来计算表达式的值。&lt;/li&gt;
&lt;li&gt;*解引用符号用于间接引用指针，结果为一个值。&lt;/li&gt;
&lt;li&gt;数组与指针联系紧密。一个数组名可以像一个指针变量一样引用。&lt;/li&gt;
&lt;li&gt;将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值。&lt;/li&gt;
&lt;li&gt;指针也可以指向函数。函数指针的值是该函数机器代码表示中第一条指令的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gdb调试器&#34;&gt;GDB调试器&lt;/h3&gt;
&lt;h3 id=&#34;缓冲区溢出&#34;&gt;缓冲区溢出&lt;/h3&gt;
&lt;p&gt;C对数组引用不进行任何边界检查，局部变量和状态信息都存放在栈中，这就可能导致严重错误。对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，制图重新加载寄存器或执行ret执行时就会发生严重错误。&lt;/p&gt;
&lt;p&gt;常见的状态破坏成为缓冲区溢出。例如，在栈中分配一个字符数组保存一个字符串，但字符串的长度超出了为数组分配的空间。&lt;/p&gt;
&lt;p&gt;缓冲区溢出让程序执行它本来不愿意执行的函数。例如，输入一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码&lt;/p&gt;
&lt;h3 id=&#34;支持变长栈帧&#34;&gt;支持变长栈帧&lt;/h3&gt;
&lt;h2 id=&#34;浮点代码&#34;&gt;浮点代码&lt;/h2&gt;
- https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络学习日志（三）——网络层：数据平面</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</link>
        <pubDate>Thu, 05 Aug 2021 22:23:31 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/ -&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;数据平面指的是网络层中&lt;strong&gt;每台路由器&lt;/strong&gt;的功能，该数据平面功能决定了到达路由器输入链路的数据报如何转发到该路由器的输出链路之一。&lt;/p&gt;
&lt;p&gt;而控制平面的功能指的是&lt;strong&gt;网络范围&lt;/strong&gt;的逻辑，控制平面控制数据报沿着从源主机到目的主机的端到端路径中&lt;strong&gt;路由器之间&lt;/strong&gt;的路由方式。其中包括路由选择算法，以及如今广泛应用的诸如OSPF和BGP等路由选择协议。控制平面和数据平面的功能已经被实现为一个整体，位于一台路由器中。&lt;/p&gt;
&lt;p&gt;**软件定义网络（SDN）**通过将这些控制平面的功能作为一种单独的服务，明确分离数据平面和控制平面，控制平面功能通常位于一台远程的控制器中。&lt;/p&gt;
&lt;h2 id=&#34;网络层概述&#34;&gt;网络层概述&lt;/h2&gt;
&lt;h3 id=&#34;转发和路由选择数据平面和控制平面&#34;&gt;转发和路由选择：数据平面和控制平面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;转发：将一个分组从路由器的一条输入链路移动到适当的输出链路&lt;/li&gt;
&lt;li&gt;路由选择：网络层决定分组从发送方到接收方所采用的路由或路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转发（forwarding）是路由器本地动作，路由选择（routing）是网络范围处理过程。&lt;/p&gt;
&lt;p&gt;路由器通过&lt;strong&gt;转发表&lt;/strong&gt;来实现转发功能。&lt;/p&gt;
&lt;h3 id=&#34;网络服务模型&#34;&gt;网络服务模型&lt;/h3&gt;
&lt;p&gt;网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保交付&lt;/li&gt;
&lt;li&gt;具有时延上界的确保交付&lt;/li&gt;
&lt;li&gt;有序分组交付&lt;/li&gt;
&lt;li&gt;确保最小带宽&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因特网的网络层提供了&lt;strong&gt;尽力而为服务&lt;/strong&gt;。并不能对服务做出保证。但尽力而为服务结合适当的玩过带宽已被证明足够好，已被证明能用于大量应用。&lt;/p&gt;
&lt;h2 id=&#34;路由器工作原理&#34;&gt;路由器工作原理&lt;/h2&gt;
&lt;p&gt;以下为一个通用的路由器体系结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入端口：终结输入物理链路的物理层功能；还与位于入链路远端的数据链路层交互来执行数据链路层功能；另外还要执行查找功能，通过查询转发表决定路由器的输出端口&lt;/li&gt;
&lt;li&gt;交换结构：将路由器的输入端口连接到它的输出端口&lt;/li&gt;
&lt;li&gt;输出端口：从交换结构接收分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组&lt;/li&gt;
&lt;li&gt;路由选择处理器：执行控制平面功能。在传统路由器中执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在SDN路由器中，路由选择处理器负责与远程控制器通信，接收其计算的转发表项，并在路由器输入端口安装这些表项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;输入端口处理和基于目的地转发&#34;&gt;输入端口处理和基于目的地转发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86_%E7%BD%91%E7%BB%9C%E5%B1%82.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;交换&#34;&gt;交换&lt;/h3&gt;
&lt;p&gt;交换结构是路由器的核心，通过这种交换结构，分组才能实际地从一个输入端口交换到一个输出端口中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经内存交换&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。分组到达输入端口时被复制到处理器内存中，路由选择处理器从其首部中提取目的地址，在转发表中找打适当输出端口，并将该分组复制到输出端口的缓存中。该种情况下若内存带宽为每秒可以写进内存或从内存中读出最多B个分组，则总的转发吞吐量必然小于B/2。另外这种方式不同同时转发两个分组，即使它们有不同的分组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经总线交换&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。路由器必须跨过单一总线，所以路由器的交换带宽受总线速率的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经互联网络交换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用更加复杂的交换网络来客服单一、共享式总线带宽的限制。&lt;/p&gt;
&lt;p&gt;例如纵横式交换机就是一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直总线与每条水平总线在交叉点交叉，交叉点通过交换结构控制器控制开启和闭合。&lt;/p&gt;
&lt;p&gt;所以纵横式网络能够并行转发多个分组，是非阻塞的。&lt;/p&gt;
&lt;h3 id=&#34;输出端口处理&#34;&gt;输出端口处理&lt;/h3&gt;
&lt;p&gt;选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。&lt;/p&gt;
&lt;h3 id=&#34;排队&#34;&gt;排队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;输入排队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出排队&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;分组调度&#34;&gt;分组调度&lt;/h3&gt;
&lt;p&gt;解决排队的分组如何经输出链路传输的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先进先出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FIFO的链路调度规则，如果分组到达时链路正忙，则需要等待链路中的分组传输完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先权排队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同类型的网络分组有不同的优先权类，每个优先权类通常都有自己的队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环和加权公平排队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;循环排队规则&lt;/strong&gt;中，分组像使用优先权排队那样被分类，但在类之间不存在严格的服务优先权，&lt;strong&gt;循环调度器&lt;/strong&gt;在这些类之间轮流提供服务。一个所谓的&lt;strong&gt;保持工作排队&lt;/strong&gt;规则在有分组排队等待传输时，不允许链路保持空闲。当寻找给定的分组但没有找到时，保持工作的循环规则将立即检查循环序列中的下一个类。&lt;/p&gt;
&lt;p&gt;一种称为&lt;strong&gt;加权平均排队&lt;/strong&gt;（Weighted Fair Queuing, WFQ）规则的通用形式的循环排队已经广泛地实现在路由器中了。WFQ与循环排队的不同在于，每个类在任何时间间隔内可能收到不同数量的服务。每个类i被分配一个权$w_i$，使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接收到的服务部分等于$w_i/(\sum w_j)$，即保证拥有相应权重的带宽。&lt;/p&gt;
&lt;h2 id=&#34;网际协议ip&#34;&gt;网际协议IP&lt;/h2&gt;
&lt;p&gt;因特网网络层的网际协议（IP）。&lt;/p&gt;
&lt;h3 id=&#34;ipv4数据报格式&#34;&gt;IPv4数据报格式&lt;/h3&gt;
&lt;p&gt;网络层分组被称为&lt;strong&gt;数据报&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;：4比特，规定了数据报的IP协议版本。即区分IPv4和IPv6，路由器根据版本号确定如何处理数据报剩余的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首部长度&lt;/strong&gt;：一个IPv4数据报包含一些可变数量的选项，需要用这4比特来确定IP数据报中荷载（被封装的运输层报文）实际开始的地方。大多数数据报不包含选项，所以一般具有20字节的首部长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务类型&lt;/strong&gt;：区别不同类型的数据报（例如一些特别要求低时延、高吞吐量或可靠性的数据报）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据报长度&lt;/strong&gt;：16比特，IP数据报的总长度（包括首部），以字节为单位计；理论最大长度为65535字节。但数据报很少有超过1500字节，因为该长度是以太网帧的最大荷载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识、标志、片偏移&lt;/strong&gt;：这三个字段与IP分片有关。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寿命（Time-to-live, TTL）&lt;/strong&gt;：确保数据报不会永远在网络中循环。每当一台路由器处理数据报时，该字段的值减一，若TTL字段为0则该数据报必须丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上层协议&lt;/strong&gt;：该字段指示了IP数据报的数据部分应该交给哪个特定的运输层协议，只有当IP数据报到达最终目的地时才有用。例如值为6表示要交给TCP，值为17表示要交给UDP。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首部检验和&lt;/strong&gt;：将首部中每2个字节当作一个数，用反码算数对这些数求和。该和用于帮助路由器检测收到的IP数据报中的比特错误。路由器要对每个收到的IP数据报计算其首部检验和，如果数据报中携带的检验和与计算的不一致则检测出这是一个差错，需要将该分组丢弃。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP/IP在运输层与网络层都执行了差错检测，但检测有些区别：IP层只对IP首部计算了检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。另外TCP/UDP与IP不一定都必须属于同一个协议栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源和目的IP地址&lt;/strong&gt;：源生成一个数据报时写入它的IP地址和目的地IP地址，通常目的地址通过DNS查找来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：允许IP首部被扩展。很少使用，在IPv6中已将其去除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据（有效荷载）&lt;/strong&gt;：最重要的字段，交付给目的地运输层的报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipv4数据报分片&#34;&gt;IPv4数据报分片&lt;/h3&gt;
&lt;p&gt;并不是所有链路层协议都能承载相同长度的网络层分组，例如以太网能承载不超过1500字节的数据，而某些广域网帧可承载不超过576字节数据。一个链路层帧能承载的最大数据量叫作&lt;strong&gt;最大传送单元（MTU）&lt;/strong&gt;。链路层协议的MTU严格限制着IP数据报的长度。发送方与目的地路径之间的每段链路可能使用不同的链路层协议，每种协议可能有不同的MTU。&lt;/p&gt;
&lt;p&gt;为了能让过大的IP分组放入链路层帧有效的荷载字段，我们将IP数据报中的数据&lt;strong&gt;分片成&lt;/strong&gt;两个多更多个较小的数据报，用单独的链路层帧封装这些小的数据报，每个较小的数据报都称为&lt;strong&gt;片（fragment）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;片在到达目的地运输层前需要重新组装，TCP与UDP都希望从网路层收到完整的、未分片的报文。为了不影响路由器的性能，IPv4的设计者决定将片的重新组装工作放到&lt;strong&gt;端系统&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;当一台目的地主机从同一源收到一系列数据报时，需要确定这些数据报中的某些是否是一些原来较大的数据报的片；如果是这些片的话，还需要确定何时收到了最后一片，并且如何将这些片拼接起来形成初始的数据报。&lt;/p&gt;
&lt;p&gt;IPv4设计者将&lt;strong&gt;标识、标志和片偏移&lt;/strong&gt;字段放在IP数据报首部中。当生成一个数据报时，发送主机为该数据报贴上&lt;strong&gt;标识号&lt;/strong&gt;；发送主机通常将它发送的每个数据报的标识号加1；当某路由器需要对一个数据报分片时，形成的每个片具有原始数据报的&lt;strong&gt;源地址、目的地址和标识号&lt;/strong&gt;，目的主机能通过标识号确定哪些数据报实际上是同一较大数据报的片。&lt;/p&gt;
&lt;p&gt;IP是一种不可靠服务，有些片可能永远到达不了目的地；为了让目的主机相信它已经收到了初始数据报的最后一个片，最后一个片的&lt;strong&gt;标志比特&lt;/strong&gt;被设置为了0，而其他所有片的标志比特被设置为了1。另外为了让目的主机确认是否丢失了一个片（且能够按照正确顺序组装片），使用&lt;strong&gt;偏移字段&lt;/strong&gt;指定该片应该放在初始数据报的哪个位置。&lt;/p&gt;
&lt;h3 id=&#34;ipv4编址&#34;&gt;IPv4编址&lt;/h3&gt;
&lt;p&gt;一个IP地址与一个接口相关联，接口是主机与物理链路之间的边界。&lt;/p&gt;
&lt;p&gt;每个IP地址的长度为&lt;strong&gt;32比特（4字节）&lt;/strong&gt;，总共有约$2^{32}$，大约40亿个IP地址。这些地址通常按照&lt;strong&gt;点分十进制计法&lt;/strong&gt;书写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因特网的地址分配策略被称为&lt;strong&gt;无类别域间路由选择（Classless Interdomain Routing, CIDR）&lt;/strong&gt;，CIDR将子网寻址的概念一般化了。&lt;/p&gt;
&lt;p&gt;当使用子网寻址时，32比特的IP地址被划为两部分，并且具有点分十进制数形式&lt;code&gt;a.b.c.d/x&lt;/code&gt;，其中x指示了地址的第一部分中的比特数。&lt;/p&gt;
&lt;p&gt;形式为&lt;code&gt;a.b.c.d/x&lt;/code&gt;的地址的x最高比特构成了IP地址的&lt;strong&gt;网络部分&lt;/strong&gt;，经常被称为该地址的&lt;strong&gt;前缀（prefix）&lt;/strong&gt;，一个组成通常被分配一块连续的地址，即具有相同前缀的一段地址。&lt;/p&gt;
&lt;p&gt;使用单个网络前缀通告多个网络的能力称为&lt;strong&gt;地址聚合&lt;/strong&gt;，也成为&lt;strong&gt;路由聚合&lt;/strong&gt;；例如可以用&lt;code&gt;200.23.16.0/20&lt;/code&gt;通告&lt;code&gt;200.23.16.0/23&lt;/code&gt;这个网络。&lt;/p&gt;
&lt;p&gt;当地址不是按照层次的方式分配时，我么使用&lt;strong&gt;最长前缀匹配&lt;/strong&gt;来通告地址块。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;CIDR&lt;/strong&gt;采用前，IP地址的网络部分被限制为长度为8、16或24比特，称为&lt;strong&gt;分类编址&lt;/strong&gt;的编址方案，分别称为A、B、C类网络。但这种分配方案存在一些问题，一个C类子网仅能容纳$2^8-2=254$（其中两个地址预留用于特殊用途）台主机，而一个B类地址可以容纳$2^{16}-2=65534$台主机，对于许多组织来说又太大了。&lt;/p&gt;
&lt;p&gt;接下来介绍一个设备如何从某主机的地址块中分配到一个地址：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取一块地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个组织从ISP获取一个地址块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取主机地址：DHCP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过动态主机配置协议（Dynamic Host Configuration, DHCP）为本组织内的主机和路由器接口配置IP地址。&lt;/p&gt;
&lt;p&gt;DHCP具有即插即用能力，同时避免了网络管理员手动配置网络。&lt;/p&gt;
&lt;p&gt;通过DHCP给新客户分配地址的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DHCP服务器发现：客户使用&lt;strong&gt;DHCP发现报文&lt;/strong&gt;在UDP分组中向端口67发送报文，该报文封装在一个IP数据报中，DHCP客户使用广播目的地址255.255.255.255并且使用本主机源IP地址0.0.0.0。DHCP客户将IP数据报传递给链路层，链路层将该帧广播到所有与该子网连接的节点。&lt;/li&gt;
&lt;li&gt;DHCP服务器提供：DHCP服务器收到发现报文时，用&lt;strong&gt;DHCP提供报文&lt;/strong&gt;向客户作出相应，该报文向子网的所有节点广播，仍使用IP广播地址255.255.255.255。子网中可能存在几个DHCP服务器，客户可以选择位置较为优越的DHCP服务。每台服务器提供的报文包括收到发现报文的事物ID、向客户推荐的IP地址、网络掩码以及&lt;strong&gt;IP地址租用期&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;DHCP请求：新到达的客户从一个或多个DHCP服务器选择一个，并向选中的服务器发送&lt;strong&gt;DHCP请求报文&lt;/strong&gt;进行响应，回显配置参数。&lt;/li&gt;
&lt;li&gt;DHCP ACK：服务器用&lt;strong&gt;DHCP ACK报文&lt;/strong&gt;对DHCP请求报文进行响应，证实所要求的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nat&#34;&gt;NAT&lt;/h3&gt;
&lt;p&gt;网络地址转换使能的路由器对外界就像是一个具有单一IP地址的单一设备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPv4私有IP地址&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;规定区块名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;IP地址区块&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;IP数量&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;分类网络说明&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;子网掩码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;主机端位长&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;24位区块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10.0.0.0 – 10.255.255.255&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16,777,216&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单个A类网络&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10.0.0.0/8 (255.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;24位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20位区块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;172.16.0.0 – 172.31.255.255&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1,048,576&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16个连续B类网络&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;172.16.0.0/12 (255.240.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位区块&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;192.168.0.0 – 192.168.255.255&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;65,536&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;256个连续C类网络&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;192.168.0.0/16 (255.255.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些地址只在专用网络中的设备上使用，即这些地址只对该网络中的设备有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络地址转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NAT路由器上有一张&lt;strong&gt;NAT转换表&lt;/strong&gt;，该表项中包含了&lt;strong&gt;端口号及其地址&lt;/strong&gt;，能够把从广域网到达NAT路由器的分组转发给需要到达的内部主机。&lt;/p&gt;
&lt;p&gt;要将专用网中一台设备的请求发送给广域网中的服务器，首先NAT路由器接收到主机发送的数据报，为该数据报生成一个新的源端口，然后将源IP替换为路由器广域网一侧接口的IP，NAT路由器可以选择任意一个当前未在NAT转换表中的源端口号，NAT协议可以支持超过60000个并行连接。&lt;/p&gt;
&lt;h3 id=&#34;ipv6&#34;&gt;IPv6&lt;/h3&gt;
&lt;p&gt;主要为了解决IPv4中32比特的IP地址空间即将用尽，同时改进和强化了IPv4的其他方面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPv6数据报格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/IPv6%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;IPv6引入了以下一些重要的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩大的地址容量&lt;/strong&gt;：IP地址长度从32比特增加到了128比特；IPv6还引入了一种&lt;strong&gt;任播地址&lt;/strong&gt;，这种地址可以使数据报交付给一组主机中的任意一个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化高效的40字节首部&lt;/strong&gt;：一些IPv4字段已经被被舍弃，具体内容如下。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流标签&lt;/strong&gt;：该字段可用于给特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种&lt;strong&gt;非默认服务质量&lt;/strong&gt;或&lt;strong&gt;需要实时服务&lt;/strong&gt;的流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是IPv6定义的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本&lt;/strong&gt;：这4比特用于表示IP版本号，IPv6将该字段设置为6&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量类型&lt;/strong&gt;：这8比特字段与IPv4中的服务类型字段含义相似&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流标签&lt;/strong&gt;：如上面讨论的，该字段用于标识一条数据报的流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有效荷载长度&lt;/strong&gt;：这16比特值作为一个无符号整数，给出了数据的字节数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下一首部&lt;/strong&gt;：标识数据字段交付给哪个协议&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳限制&lt;/strong&gt;：类似于IPv4的TTL，转发数据报的每台路由器对该字段内容减1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源地址和目的地址&lt;/strong&gt;：128比特的IPv6地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;：IPv6数据报的有效荷载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下内容是几个在IPv4数据报中出现但在IPv6数据报中已经不存在的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分片/重新组装&lt;/strong&gt;：IPv6不允许在中间路由器上i进行分片与重新组装，这种操作只能在源与目的地执行。如果路由器收到的IPv6数据报太大而不能转发到输出链路的话，只需丢掉这个数据报。分片与重新组装是一个耗时的操作，将该功能从路由器中删除并放入端系统中，大大加快了网路中的IP转发速率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;首部检验和&lt;/strong&gt;：因为因特网中运输层和数据链路层都进行了检验操作，IP设计者觉得在网路层中具有该项功能较为多余，所以将其去掉。&lt;strong&gt;快速处理IP分组&lt;/strong&gt;才是关注的重点。另外，IPv4首部中包含一个TTL字段，所以在每台路由器上都需要重新计算IPv4首部检验和。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选项&lt;/strong&gt;：使得IP首部字段成为定长的40字节。它没有消失，而可能出现在IPv6首部中由下一个首部指出的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;从IPv4到IPv6的迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过建立隧道在IPv4路由器之间传输IPv6数据报。借助于隧道，在隧道发送端可将整个IPv6数据报放到一个IPv4数据报的数据字段中。&lt;/p&gt;
&lt;h2 id=&#34;通用转发和sdn&#34;&gt;通用转发和SDN&lt;/h2&gt;
&lt;p&gt;软件定义网路：匹配加动作&lt;/p&gt;
&lt;p&gt;分组交换机&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络学习日志（五）——链路层</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
        <pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ -&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;将运行链路层协议的设备称为&lt;strong&gt;节点&lt;/strong&gt;，把沿通信链路连接相邻节点的通信信道称为&lt;strong&gt;链路&lt;/strong&gt;。经过特定链路时，节点将数据包封装在&lt;strong&gt;链路层帧&lt;/strong&gt;中，将该帧传送到链路中。&lt;/p&gt;
&lt;p&gt;链路层提供的服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;成帧&lt;/strong&gt;：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路接入&lt;/strong&gt;：**媒体访问控制协议(MAC)**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠交付&lt;/strong&gt;：链路层通过&lt;em&gt;确认和重传&lt;/em&gt;提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;差错检验和纠正&lt;/strong&gt;：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链路层协议的实现位置：&lt;strong&gt;网络适配器&lt;/strong&gt;（也成为网卡）来实现。&lt;/p&gt;
&lt;h2 id=&#34;差错检测和纠正技术&#34;&gt;差错检测和纠正技术&lt;/h2&gt;
&lt;p&gt;差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。&lt;/p&gt;
&lt;p&gt;这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。&lt;/p&gt;
&lt;h3 id=&#34;奇偶校验&#34;&gt;奇偶校验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;单个奇偶校验位&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/oneByteEvenParity.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为&lt;strong&gt;50%&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二维奇偶校验&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/twoDEvenParity.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;接收方&lt;/strong&gt;检测和纠正差错的能力被称为&lt;strong&gt;前向纠错（Forward Error Correction，FEC）&lt;/strong&gt;。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。&lt;/p&gt;
&lt;h3 id=&#34;检验和&#34;&gt;检验和&lt;/h3&gt;
&lt;p&gt;将d比特数据当作一个k比特的整数序列处理。&lt;strong&gt;因特网检验和&lt;/strong&gt;是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果&lt;em&gt;是否全为1比特&lt;/em&gt;来检验。如果这些比特中存在0比特，则出现差错。&lt;/p&gt;
&lt;p&gt;检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。&lt;/p&gt;
&lt;h3 id=&#34;循环冗余检测crc&#34;&gt;循环冗余检测（CRC）&lt;/h3&gt;
&lt;p&gt;冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。&lt;/p&gt;
&lt;p&gt;考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为&lt;strong&gt;G&lt;/strong&gt;。我们要求G的最高位有效比特为1.&lt;/p&gt;
&lt;p&gt;对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。&lt;/p&gt;
&lt;p&gt;用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。&lt;/p&gt;
&lt;h2 id=&#34;多路访问链路和协议&#34;&gt;多路访问链路和协议&lt;/h2&gt;
&lt;p&gt;网络链路的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。&lt;/li&gt;
&lt;li&gt;广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。&lt;/p&gt;
&lt;p&gt;因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。&lt;/p&gt;
&lt;p&gt;我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。&lt;/p&gt;
&lt;h3 id=&#34;信道划分协议&#34;&gt;信道划分协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;时分多路复用（TDM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设一个支持N个节点的信道传输速率为R bps。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/TDM.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDM将时间划分为&lt;strong&gt;时间帧（Frame）&lt;/strong&gt;，并进一步把每个时间帧划分为N个&lt;strong&gt;时隙（slot）&lt;/strong&gt;，把每个时隙分配给N个节点中的一个。&lt;/li&gt;
&lt;li&gt;无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。&lt;/li&gt;
&lt;li&gt;TDM消除了碰撞且非常公平，但存在以下缺点：
&lt;ul&gt;
&lt;li&gt;节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。&lt;/li&gt;
&lt;li&gt;节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;频分多路复用（FDM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/FDM.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FDM将R bps信道划分为不同频段，每个频段有R/N带宽，并把每个频率分配给N个节点中的一个。&lt;/li&gt;
&lt;li&gt;与TDM有相同的优点和缺点：
&lt;ul&gt;
&lt;li&gt;避免了碰撞，公平划分了带宽，但每个节点只能使用R/N的带宽，即使它是唯一一个有分组发送的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;码分多址（CDMA）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码分多址（Code Division Multiple Access）对每个节点分配一种不同的&lt;strong&gt;编码&lt;/strong&gt;，每个节点用其&lt;strong&gt;唯一的编码&lt;/strong&gt;来对发送的数据进行编码，CMDA有一种特性，即不同的节点能同时传输，并且各自的接收方仍能正确接受发送方编码的数据比特，而不在乎其他节点的干扰传输。&lt;/p&gt;
&lt;h3 id=&#34;随机接入协议&#34;&gt;随机接入协议&lt;/h3&gt;
&lt;p&gt;随机接入协议中，每个传输节点总以&lt;strong&gt;信道的全部速率&lt;/strong&gt;发送，当有碰撞时，涉及碰撞的每个节点重复发送它的帧，直到该帧无碰撞地通过。当一个节点经历一次碰撞时，不必重发该帧，在重发前等待一个&lt;strong&gt;随机时延&lt;/strong&gt;，涉及碰撞的每个节点独立地选择随机时延。&lt;/p&gt;
&lt;p&gt;以下为一些最常用的随机接入协议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时隙ALOHA&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;假设条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有帧由L比特组成。&lt;/li&gt;
&lt;li&gt;时间被划分为L/R秒的时隙。&lt;/li&gt;
&lt;li&gt;节点只在时隙起点开始传输帧。&lt;/li&gt;
&lt;li&gt;节点是同步的，每个节点都知道时隙何时开始。&lt;/li&gt;
&lt;li&gt;如果一个时隙中有两个或多个帧碰撞，则所有节点在该时隙结束前检测到该碰撞事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另p为一个概率，即一个在0和1之间的数，在每个节点中，时隙ALOHA的操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传送它。&lt;/li&gt;
&lt;li&gt;若没有碰撞，则节点成功传送帧，无需重传。&lt;/li&gt;
&lt;li&gt;若有碰撞，则该节点在时隙结束前检测到该碰撞，以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当具有多个活跃节点时，经计算，该协议的&lt;strong&gt;最大效率仅为37%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具有碰撞检测的载波侦听多路访问（CSMA/CD）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;载波侦听：一个节点在传输前先听信道；如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。&lt;/li&gt;
&lt;li&gt;碰撞检测：当一个传输节点传输时一直在侦听此信道，如果它检测到另一个节点正在传输干扰帧，它就停止传输。在重复“侦听-当空闲时传输”循环之前等待一段随机时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;轮流协议&#34;&gt;轮流协议&lt;/h3&gt;
&lt;p&gt;轮流协议能够实现当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轮询协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有节点之一指定为&lt;strong&gt;主节点&lt;/strong&gt;，主节点以循环的方式&lt;strong&gt;轮询&lt;/strong&gt;每个节点。例如，主节点向节点1发送一个报文，告诉它能够传输的帧的最多数量，在节点1传输了一些帧后，主节点告诉节点2它能传输的帧的最多数量。以此循环的方式轮询每个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;令牌传递协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该协议中没有主节点，有一个称为**令牌(token)**的小的特殊帧在节点间以某种固定次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时才持有这个令牌，否则它立即向下一个节点转发该令牌。令牌传递是分散的，有很高的效率。&lt;/p&gt;
&lt;h2 id=&#34;交换局域网&#34;&gt;交换局域网&lt;/h2&gt;
&lt;h3 id=&#34;链路层寻址和地址解析协议arp&#34;&gt;链路层寻址和地址解析协议（ARP）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;链路层地址在主机或路由器的**适配器(网络接口)**中，所以具有多个网络接口的主机和路由器将有与之相关联的多个链路层地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路层交换机&lt;/strong&gt;并不具有与他们的接口相关联的链路层地址，因为链路层交换机的任务是在&lt;strong&gt;主机与路由器之间承载数据报&lt;/strong&gt;，主机或路由器不必将帧寻址到其之间的交换机，交换机透明地执行该项任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的适配器都有不同的MAC地址，这由IEEE来分配管理。&lt;/p&gt;
&lt;p&gt;某适配器要向目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插入帧中，将该帧发送到局域网中；当适配器接收到一个MAC地址时将其与自己的MAC地址进行比较，检查是否匹配，如果匹配则提取出封装的数据包并沿协议栈向上传送，如果不匹配则丢弃该帧。&lt;/p&gt;
&lt;p&gt;有时发送适配器要让局域网中&lt;strong&gt;所有其他适配器&lt;/strong&gt;接受并处理他发送的帧，发送适配器在该帧的目的地址字段插入一个特殊MAC&lt;strong&gt;广播地址&lt;/strong&gt;，对于使用6字节地址的局域网来说，广播地址为48个1组成的字符串，即以16进制表示为&lt;strong&gt;FF-FF-FF-FF-FF-FF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址解析协议（ARP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARP是用来转换网络层&lt;strong&gt;IP地址&lt;/strong&gt;和链路层&lt;strong&gt;MAC地址&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;假设发送主机要向目的主机发送IP数据报，源要向其适配器提供数据报和目的主机的MAC地址，此后源适配器才构造一个包含目的MAC地址的帧发送到局域网中。&lt;/p&gt;
&lt;p&gt;发送主机使用ARP确定目的主机IP地址对应的MAC地址。发送主机向其ARP模块发送目的主机的IP，ARP将IP解析为一个MAC地址。&lt;/p&gt;
&lt;p&gt;每台主机或路由器的内存中有一个&lt;strong&gt;ARP表&lt;/strong&gt;，该表包含了IP地址到MAC地址的映射关系。
&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/ARP%E8%A1%A8.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果发送方ARP表中&lt;strong&gt;没有目的主机的表项&lt;/strong&gt;，则发送方构造一个&lt;strong&gt;ARP分组&lt;/strong&gt;（分组包括发送和接收IP地址以及MAC地址），并指示适配器用&lt;strong&gt;MAC广播地址&lt;/strong&gt;来发送这个分组，适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将帧传送进入子网，包含该ARP查询的帧能够被子网中的&lt;strong&gt;所有其他适配器&lt;/strong&gt;接收到，每个适配器都把该分组向上传递给ARP模块，ARP模块检查其IP地址是否与ARP分组中的目的IP匹配，若匹配则给查询主机发送回一个带有所希望映射的响应ARP分组，然后查询主机更新它的ARP表，然后发送它的IP数据报。&lt;/p&gt;
&lt;p&gt;查询ARP报文是在&lt;strong&gt;广播帧&lt;/strong&gt;中发送的，响应ARP报文是在一个&lt;strong&gt;标准帧&lt;/strong&gt;中发送的。&lt;/p&gt;
&lt;p&gt;最好把ARP看成跨越链路层和网络层边界两边的协议，因为其既包含IP地址又包含MAC地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送数据报到子网以外&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从一个子网将数据包发送到路由器，在从路由器发送到下一个子网的目的适配器，中间需要经过路由器的两个适配器，其中查询MAC地址的过程都是通过ARP来实现的。&lt;/p&gt;
&lt;h3 id=&#34;以太网&#34;&gt;以太网&lt;/h3&gt;
&lt;p&gt;一种广泛部署的有线局域网。&lt;/p&gt;
&lt;p&gt;以太网的安装使用星形拓扑结构，位于中心的是交换机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网帧结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/Ethernet_frame_structure.PNG&#34; alt=&#34;以太网帧结构&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data(数据字段)&lt;/strong&gt;：46-1500字节，这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节，如果IP数据报超过1500字节，主机就要将该数据报分片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dest. address(目的地址)&lt;/strong&gt;：6字节，包含了目的适配器的MAC地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source address(源地址)&lt;/strong&gt;：6字节，包含了传输该帧到局域网上的适配器的MAC地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tyep(类型字段)&lt;/strong&gt;：2字节，类型字段允许以太网复用多种网络协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRC&lt;/strong&gt;：4字节，使接收适配器检测帧中是否引入了差错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Preamble(前同步码)&lt;/strong&gt;：8字节，前7字节的值都是10101010；最后一个字节是10101011。前同步码的前7字节用于唤醒接收适配器，将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特（第一个出现的两个连续的1）警告接收适配器，重要的内容就要来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以太网技术都向网络层提供&lt;strong&gt;无连接&lt;/strong&gt;服务。当适配器A向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并把帧发送到局域网上，没有先与适配器B握手。&lt;/p&gt;
&lt;p&gt;以太网技术都向网络层提供&lt;strong&gt;不可靠&lt;/strong&gt;服务。当适配器B收到来自适配器A的一个帧时，对该帧执行CRC校验，但当该帧通过CRC校验时不发送确认帧，当该帧没有通过CRC校验时也不发送否定确认帧。当某帧没有通过CRC校验时适配器B只是丢弃该帧，A并不知道它传输的帧是否到达B且通过校验，意味着传递到网络层的数据报流有间隙。&lt;/p&gt;
&lt;p&gt;丢弃以太网帧后存在了间隙，主机B上的应用可以通过运输层看到这个间隙。当使用UDP协议时，B中的应用会看到这个间隙；当使用TCP协议时，B中的TCP将不会确认包含在丢弃帧中的数据，从而引起主机A的TCP重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网技术的发展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同速率的以太网：10BASE-T、10BASE-2、100BASE-T、1000BASE-LX和10GBASE-T；第一部分数字代表该标准的速率：10、100、1000、10G；BASE指基带以太网，意味着物理媒体仅承载以太网流量；最后一部分指代物理媒介本身，T指双绞铜线。这些技术指标已经被IEEE 802.3 CSMA/CD标准化。&lt;/p&gt;
&lt;h3 id=&#34;链路层交换机&#34;&gt;链路层交换机&lt;/h3&gt;
&lt;p&gt;交换机的任务是接收入链路层帧并将它们转发到出链路。交换机对子网的主机和路由器是&lt;strong&gt;透明&lt;/strong&gt;的，某主机/路由器向另一个主机/路由器寻址一个帧，顺利地将该帧发送进局域网，并不知道交换机将会接收帧并将它转发到另一个节点。交换机的输出接口设有&lt;strong&gt;缓存&lt;/strong&gt;，防止输入输出链路速率存在差别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换机转发和过滤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤：决定一个帧应该转发到某个接口还是应当将其丢弃。&lt;/li&gt;
&lt;li&gt;转发：决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交换机的过滤和转发借助于&lt;strong&gt;交换机表&lt;/strong&gt;完成。交换机表包含某局域网上某些主机和路由器的表项。&lt;/p&gt;
&lt;p&gt;一个表项包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个MAC地址&lt;/li&gt;
&lt;li&gt;通向该MAC地址的交换机接口&lt;/li&gt;
&lt;li&gt;表项放置在表中的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当交换机的表是完整的时，无需任何广播就向着目的地转发帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交换机的表是自动、动态和自治地建立的，这种能力通过以下方式实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机表初始为空&lt;/li&gt;
&lt;li&gt;对于在接口接收到的每个入帧，该交换机在其表中存储：该帧源地址字段的MAC地址，该帧的到达接口，当前时间。&lt;/li&gt;
&lt;li&gt;如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交换机是&lt;strong&gt;即插即用设备&lt;/strong&gt;，它们不需要网络管理员或用户的干预，也是双工的，可以同时发送和接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路层交换机的性质&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除碰撞：交换机缓存帧并且不会在网段上同时传输多余一个帧。&lt;/li&gt;
&lt;li&gt;异质的链路：交换机将链路彼此隔离，因此局域网中的不同链路能够以不同速率运行并且能够在不同媒体上运行。&lt;/li&gt;
&lt;li&gt;管理：易于进行网络管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟局域网vlan&#34;&gt;虚拟局域网（VLAN）&lt;/h3&gt;
&lt;p&gt;能够限制局域网广播流量；可以将交换机拆分，提高使用效率；能够更加方便地管理用户。&lt;/p&gt;
&lt;p&gt;不同VLAN之间需要通过路由器进行通信，因为VLAN将不同VLAN相互阻隔，一个VLAN中的设备无法直接通过目的MAC地址直接找到目的主机，而是需要通过路由器通过上层的IP进行查找。&lt;/p&gt;
&lt;h2 id=&#34;数据中心网络&#34;&gt;数据中心网络&lt;/h2&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Linux基础知识</title>
        <link>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <pubDate>Thu, 29 Jul 2021 08:44:21 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ -&lt;h2 id=&#34;系统启动过程&#34;&gt;系统启动过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内核的引导：BIOS开机自检，然后读入/boot目录的内核文件&lt;/li&gt;
&lt;li&gt;运行init：init进程是所有进程的起点，运行级别确定&lt;/li&gt;
&lt;li&gt;系统初始化：&lt;code&gt;rc.sysinit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建立终端&lt;/li&gt;
&lt;li&gt;用户登录系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统目录结构&#34;&gt;系统目录结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;：bin是二进制文件的缩写，存放着最常用的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/boot&lt;/code&gt;：存放启动时的核心文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt;：dev是Device的缩写，存放Linux的外部设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt;：Etcetera的缩写，用来存放所有系统管理所需的配置文件和子目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/home&lt;/code&gt;：主目录，Linux中，每个用户都有一个自己的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib&lt;/code&gt;：Library的缩写，存放着系统最基本的动态连接共享库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/media&lt;/code&gt;：自动识别一些设备，将其挂载到这个目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt;：该目录为了让用户临时挂载别的文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/opt&lt;/code&gt;：optional的缩写，给主机额外安装软件所设置的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc&lt;/code&gt;：Processes进程的缩写，是一种虚拟文件系统，存放着当前内核运行状态的一系列特殊文件。该目录不再硬盘上，而是在内存中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/root&lt;/code&gt;：系统管理员主目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt;：temporary的缩写，用来存放临时目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt;：unix shared resources共享资源的缩写，用户的很多应用程序和文件存放于此，类似于windows下的program files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/bin&lt;/code&gt;：系统用户使用的应用程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/src&lt;/code&gt;：内核源代码默认的存放目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var&lt;/code&gt;：variable的缩写，存放着不断扩充着的东西，将经常被修改的目录放在这个目录下，包括各种日志文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件基本属性&#34;&gt;文件基本属性&lt;/h2&gt;
&lt;p&gt;Linux系统是一种多用户系统，不同用户有不同权限。&lt;/p&gt;
&lt;p&gt;通常使用以下命令来修文件和目录的权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chown(change ownerp)：修改所属用户与组&lt;/li&gt;
&lt;li&gt;chmod(change mode)：修改用户的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Linux中使用&lt;code&gt;ll&lt;/code&gt;或&lt;code&gt;ls -l&lt;/code&gt;来显示一个文件的属性以及文件所属的用户和组。&lt;/p&gt;
&lt;p&gt;第一个字符代表这个文件的类型，是目录、文件或连接文件等等：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;d&lt;/code&gt;为目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt;为文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;l&lt;/code&gt;为链接文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;为可存储的接口设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt;为串行端口设备&lt;/p&gt;
&lt;p&gt;接下来的字符以三个为一组，为&lt;code&gt;rwx&lt;/code&gt;三个参数的组合，&lt;code&gt;r&lt;/code&gt;代表可读，&lt;code&gt;w&lt;/code&gt;代表可写，&lt;code&gt;x&lt;/code&gt;代表可执行，从前到后分别代表user、group、everyone的权限，如果没有权限，则用&lt;code&gt;-&lt;/code&gt;表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于root用户，文件权限不起作用。&lt;/p&gt;
&lt;h3 id=&#34;chgrp改变文件属组&#34;&gt;chgrp：改变文件属组&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chgrp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-R&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属组名 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;-R&lt;/code&gt;：recursion，递归，改变目录下所有文件的属性&lt;/p&gt;
&lt;h3 id=&#34;chown更改文件属主也可以同时更改文件属组&#34;&gt;chown：更改文件属主，也可以同时更改文件属组&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chown &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-R&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属主名 文件名
chown &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-r&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 属主名:属组名 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;chmod更改文件的9个属性&#34;&gt;chmod：更改文件的9个属性&lt;/h3&gt;
&lt;p&gt;9个权限分别为&lt;strong&gt;owner/group/others(拥有者/组/其他)&lt;/strong&gt; 三种身份各有自己的 &lt;strong&gt;read/write/execute&lt;/strong&gt; 权限。&lt;/p&gt;
&lt;p&gt;第一种方法使用数字来表示，各权限的分数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r：4&lt;/li&gt;
&lt;li&gt;w：2&lt;/li&gt;
&lt;li&gt;x：1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： &lt;strong&gt;-rwxrwx&amp;mdash;&lt;/strong&gt; 分数则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;owner = rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;group = rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;others= &amp;mdash; = 0+0+0 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以等一下我们设定权限的变更时，该文件的权限数字就是 &lt;strong&gt;770&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;第二种方法是使用符号类型改变权限，这里不详细介绍。&lt;/p&gt;
&lt;h2 id=&#34;文件与目录管理&#34;&gt;文件与目录管理&lt;/h2&gt;
&lt;h3 id=&#34;处理目录常用命令&#34;&gt;处理目录常用命令：&lt;/h3&gt;
&lt;p&gt;ls（list files）：列出目录和文件名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a：全部文件，联通隐藏文件&lt;/li&gt;
&lt;li&gt;-d：仅列出目录本身&lt;/li&gt;
&lt;li&gt;-l：长数据串列出，包含文件属性与权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cd（change directory）：切换目录&lt;/p&gt;
&lt;p&gt;pwd（print work directory）：显示当前目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-P：显示出实际的路径，而不是连结（link）路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mkdir（make directory）：创建一个新目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-m：配置文件的权限&lt;/li&gt;
&lt;li&gt;-p：可以递归创建多级目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rmdir（remove directory）：删除一个空目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-p：连同上一级的空目录一起删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cp（copy file）：复制文件或目录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-adfilprsu&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 来源档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; 目标档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;destination&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
cp &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; source1 source2 ... directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-a：相当于-pdr&lt;/li&gt;
&lt;li&gt;-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身&lt;/li&gt;
&lt;li&gt;-f：force，若目标文件已存在且无法开启，则移除后再尝试一次&lt;/li&gt;
&lt;li&gt;-i：若目标档已存在时，在覆盖时会先询问&lt;/li&gt;
&lt;li&gt;-p：连同文件属性一起复制过去&lt;/li&gt;
&lt;li&gt;-f：递归持续复制，用于目录的复制&lt;/li&gt;
&lt;li&gt;-s：复制成为符号连结档(symbolic link)&lt;/li&gt;
&lt;li&gt;-u：若destination比source旧才升级destination&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rm（remove）：删除文件或目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-f：force&lt;/li&gt;
&lt;li&gt;-r：递归删除，常用在目录的删除&lt;/li&gt;
&lt;li&gt;-i：互动模式，删除前会询问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mv（move file）：移动文件与目录，或修改文件、目录名称&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mv &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-fiu&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 来源档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; 目标档&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;destination&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
mv &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; source1 source2 ... directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-f：force&lt;/li&gt;
&lt;li&gt;-i：若目标文件 (destination) 已经存在时，就会询问是否覆盖&lt;/li&gt;
&lt;li&gt;-u：目标文件已经存在，且 source 比较新，才会升级 (update)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件内容查看&#34;&gt;文件内容查看&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cat：从第一行开始显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tac：从最后一行开始显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nl：显示行号并列出文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;more：一页一页显示和翻动文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空白键 (space)：代表向下翻一页；&lt;/li&gt;
&lt;li&gt;Enter     ：代表向下翻『一行』；&lt;/li&gt;
&lt;li&gt;/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；&lt;/li&gt;
&lt;li&gt;:f      ：立刻显示出档名以及目前显示的行数；&lt;/li&gt;
&lt;li&gt;q       ：代表立刻离开 more ，不再显示该文件内容。&lt;/li&gt;
&lt;li&gt;b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;head：取出文件前面几行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;head &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-n number&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tail：取出文件后面几行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;tail &lt;span style=&#34;color:#333&#34;&gt;[&lt;/span&gt;-n number&lt;span style=&#34;color:#333&#34;&gt;]&lt;/span&gt; 文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h2&gt;
&lt;p&gt;常用的三个命令：df、du、fdisk&lt;/p&gt;
&lt;p&gt;df：列出文件系统的整体磁盘使用量&lt;/p&gt;
&lt;p&gt;du：检查磁盘空间使用量&lt;/p&gt;
&lt;p&gt;fdisk：用于磁盘分区&lt;/p&gt;
&lt;h2 id=&#34;配置wsl2开发环境&#34;&gt;配置WSL2开发环境&lt;/h2&gt;
&lt;h3 id=&#34;cc&#34;&gt;C/C++&lt;/h3&gt;
&lt;p&gt;见&lt;a href=&#34;https://code.visualstudio.com/docs/cpp/config-wsl&#34;&gt;Using C++ and WSL in VS Code&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;p&gt;使用脚本安装Anaconda&lt;/p&gt;
- https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络各层级理解</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</link>
        <pubDate>Fri, 23 Jul 2021 12:59:05 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ -&lt;p&gt;一年多前按照层级详细学习了计算机网络的有关内容，包括从应用层、传输层、网络层、数据链路层到物理层的详细信息，并且也学习了一些其他硬件通信协议，比如CAN控制器局域网、SPI等等。在之后的应用和实践中经常对不同层级的网络和网络设备产生疑惑，例如路由器和交换机到底是什么关系？为什么要通过IP地址和MAC地址划分网络层和数据链路层？这里将会详细说明各层网络的具体作用来加深理解和体会。&lt;/p&gt;
&lt;h2 id=&#34;应用层&#34;&gt;应用层&lt;/h2&gt;
&lt;p&gt;应用层是计算机网络体系结构中最高层，意味着这是&lt;strong&gt;和人进行交互&lt;/strong&gt;的层次。&lt;/p&gt;
&lt;p&gt;应用层是计算机网络与用户进行交互的&lt;strong&gt;接口&lt;/strong&gt;或界面，直接向用户提供服务；包括Web、E-mail、DNS、DHCP、FTP等等。&lt;/p&gt;
&lt;p&gt;应用层要解决的主要问题就是如何为用户提供&lt;strong&gt;高效、可靠、满意&lt;/strong&gt;的服务，工程师要根据不同业务场景使用不同技术方法解决这些问题，比如使用多线程、高并发的Web框架，分布式处理等等。&lt;/p&gt;
&lt;h2 id=&#34;传输层&#34;&gt;传输层&lt;/h2&gt;
&lt;p&gt;负责&lt;strong&gt;端到端（进程之间）&lt;strong&gt;的通信。位于两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种&lt;/strong&gt;网络应用进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;端到端的传输分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟传输连接的建立&lt;/li&gt;
&lt;li&gt;源端用户数据沿着传输连接传送到目的端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个数据传输过程中传输层需要完成以下基本功能：传输层寻址、传输连接建立、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和多路分解、崩溃恢复。&lt;/p&gt;
&lt;h2 id=&#34;网络层&#34;&gt;网络层&lt;/h2&gt;
&lt;p&gt;也被称为中转层。他很重要也很复杂，既要解决不同网络的节点通信的路由和协议识别问题，又要通过路由选择策略解决网络拥塞问题。&lt;/p&gt;
&lt;p&gt;网络层主要是为了解决不同网络之间&lt;strong&gt;数据传输和转发&lt;/strong&gt;问题。&lt;/p&gt;
&lt;h2 id=&#34;数据链路层&#34;&gt;数据链路层&lt;/h2&gt;
&lt;p&gt;在原始的、有差错的物理传输线路的基础上，采用差错检测、差错控制和流量控制等方法，将有差错的物理线路改成逻辑上无差错的数据链路，为上一层（网络层）提供高质量服务。&lt;/p&gt;
&lt;p&gt;数据链路层主要是为了&lt;strong&gt;控制数据传输&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;物理层&#34;&gt;物理层&lt;/h2&gt;
&lt;p&gt;位于体系结构最底层，负责在物理介质上位数据链路层提供&lt;strong&gt;原始比特流&lt;/strong&gt;传输的&lt;strong&gt;物理链接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;物理层解决的问题就是&lt;strong&gt;数据传输&lt;/strong&gt;，所有数据到达物理层都会变成二进制的载波信号。&lt;/p&gt;
&lt;h2 id=&#34;交换机和路由器&#34;&gt;交换机和路由器&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&#34;http://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/#wlan%e5%9f%ba%e7%a1%80%e5%86%85%e5%ae%b9&#34;&gt;WLAN基本内容和802.11ax&lt;/a&gt;中的内容。&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 