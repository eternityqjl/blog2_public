<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 07 Dec 2021 17:14:52 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>字符串输入、输出和字符串函数</title>
        <link>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</link>
        <pubDate>Sat, 28 Sep 2019 12:15:42 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/ -&lt;h2 id=&#34;字符串输入&#34;&gt;字符串输入&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;gets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用方法：读取整行输入，直到遇到&lt;strong&gt;换行符&lt;/strong&gt;，然后&lt;strong&gt;丢弃换行符&lt;/strong&gt;，储存其余的字符，并在字符末尾添加一个&lt;strong&gt;空字符&lt;/strong&gt;使之成为一个C字符串。&lt;/li&gt;
&lt;li&gt;使用中存在的问题：&lt;code&gt;gets(words)&lt;/code&gt;（char words[STLEN]）的唯一参数为words，该函数无法检查数组是否装得下输入行。数组名会被转化成该数组首元素的地址，该函数只知道数组的开始处，并不知道数组在何处结束。&lt;/li&gt;
&lt;li&gt;如果输入过长，会导致&lt;strong&gt;缓存区溢出&lt;/strong&gt;，详情见书上内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;code&gt;gets()&lt;/code&gt;的替代品：&lt;code&gt;fgets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fgets()&lt;/code&gt;函数通过第二个参数来限制读入的&lt;strong&gt;字符数&lt;/strong&gt;来解决溢出问题。&lt;/li&gt;
&lt;li&gt;相较于&lt;code&gt;gets()&lt;/code&gt;的区别：
&lt;ul&gt;
&lt;li&gt;第二个参数指明了读入字符的最大数量，若该值为n，那么将读入n-1个字符，或遇到第一个&lt;strong&gt;换行符&lt;/strong&gt;为止。&lt;/li&gt;
&lt;li&gt;第三个参数指明了要读入的文件，如果要从键盘输入，则参数设置为stdin标识符。&lt;/li&gt;
&lt;li&gt;如果读到一个换行符，&lt;code&gt;fgets()&lt;/code&gt;会将其&lt;strong&gt;储存在数组中&lt;/strong&gt;，而不是将其丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;gets_s()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;于&lt;code&gt;fgets()&lt;/code&gt;的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数只从标准输入中读取，所以无需第三个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读到&lt;strong&gt;换行符会将其丢弃&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果读到最大字符数都没有读到换行符，会进行以下操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先设置目标数组的首字符为空字符&lt;/p&gt;
&lt;p&gt;读取并丢弃随后的输入直至读到换行符或文件结尾&lt;/p&gt;
&lt;p&gt;返回空指针&lt;/p&gt;
&lt;p&gt;然后调用依赖实现的“处理函数”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.&lt;code&gt;s_gets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取整行输入并&lt;strong&gt;用空字符替代换行符&lt;/strong&gt;，或者(在字符串未结束就遇到了空字符)读取一部分输入，并丢弃其余的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;s_gets&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; st, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ret_val;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;

    ret_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fgets(st, n, stdin);
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret_val)
    {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (st[i] &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; st[i] &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
            i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (st[i] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
            st[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; 
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (getchar() &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
                &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; ret_val;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.&lt;code&gt;scanf()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以第一个非空白字符座位读取的开始，以第一个空白字符(空行、空格、制表符、换行符)座位字符串的结束。&lt;/li&gt;
&lt;li&gt;其他内容略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串输出&#34;&gt;字符串输出&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;puts()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数显示字符串时会在末尾添加一个&lt;strong&gt;换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;该函数的参数为地址，且用双引号括起来的字符串常量作为参数时，参数被视为该字符串的地址。&lt;/li&gt;
&lt;li&gt;当参数为数组中某个项的地址时，如&lt;code&gt;str[5]&lt;/code&gt;,会从这个位置开始依次输出。&lt;/li&gt;
&lt;li&gt;结束条件为&lt;strong&gt;空字符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;code&gt;fputs()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二个参数要指明写入数据的文件，若要打印在显示器上，则用stdout作为参数。&lt;/li&gt;
&lt;li&gt;该函数&lt;strong&gt;不会在字符串末尾添加换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;printf()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串函数&#34;&gt;字符串函数&lt;/h2&gt;
&lt;p&gt;0.这里只写出书上详细介绍的5组字符串函数：&lt;code&gt;strlen()&lt;/code&gt; | &lt;code&gt;strcat()/strncat()&lt;/code&gt; | &lt;code&gt;strcmp()/strncmp()&lt;/code&gt; | &lt;code&gt;strcpy()/strncpy()&lt;/code&gt; | &lt;code&gt;sprintf()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;strlen&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数用于统计字符串的长度，函数返回值为字符串的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;2.&lt;code&gt;strcat()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本定义
&lt;ul&gt;
&lt;li&gt;该函数用于&lt;strong&gt;拼接字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接受两个字符串作为参数&lt;/li&gt;
&lt;li&gt;把第二个字符串的备份附在第一个字符串的末尾，并把拼接后形成的新字符串作为第一个字符串，第二个字符串不变。&lt;/li&gt;
&lt;li&gt;该函数的函数类型是&lt;code&gt;char *&lt;/code&gt;,即指向&lt;code&gt;char&lt;/code&gt;的指针。&lt;/li&gt;
&lt;li&gt;所以该函数返回第一个参数，即拼接第二个字符串后的第一个字符串的&lt;strong&gt;地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存在的问题
&lt;ul&gt;
&lt;li&gt;无法检查第一个数组是否能容纳第二个字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;strncat()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的第三个参数指定了最大添加字符数&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;strncat(bugs, addon, 13)&lt;/code&gt;会把addon字符串的聂荣附加给bugs，加到第13个字符或者遇到空字符的时候停止&lt;/li&gt;
&lt;li&gt;所以，算上空字符(必须要添加空字符，否则就不是字符串了)，bugs数组应该足够大，以容纳原始字符串(不包含空字符)、添加在后面的13个字符、末尾的空字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;4.&lt;code&gt;strcmp()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来把用户的响应于已储存的字符串作比较(比较&lt;strong&gt;两个字符串的内容&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;比较的是字符串的内容而不是字符串的地址，例如
&lt;ul&gt;
&lt;li&gt;定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define ANSWER &amp;quot;Grant&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define SIZE 40&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char try[SIZE]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s_gets(try, SIZE)&lt;/code&gt;\\输入Grant&lt;/li&gt;
&lt;li&gt;如果使用&lt;code&gt;while (try == ANSWER)&lt;/code&gt;,则永远得不到两者相等的结果，因为while比较的是指针，即地址，二者的地址肯定不相同&lt;/li&gt;
&lt;li&gt;但使用&lt;code&gt;strcmp(try, ANSWER)&lt;/code&gt;则能够得到两者内容相等的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：该函数只会比较try中第一个空字符前面的部分，所以该函数可以比较储存在不同大小数组中的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;该函数的返回值：
&lt;ul&gt;
&lt;li&gt;返回实例：
&lt;ul&gt;
&lt;li&gt;比较“A&amp;quot;和本身，返回0&lt;/li&gt;
&lt;li&gt;比较”A&amp;quot;和&amp;quot;B&amp;quot;，返回-1&lt;/li&gt;
&lt;li&gt;比较“B&amp;quot;和”A“，返回1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论：
&lt;ul&gt;
&lt;li&gt;二者相等返回0&lt;/li&gt;
&lt;li&gt;第一个的ASCII码比第二个大就返回负数，比第二个大就返回整数&lt;/li&gt;
&lt;li&gt;返回的整数和负数即为二者的ASCII码之差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;
&lt;li&gt;返回值的具体数值并不重要，重要的是它是0还是非0&lt;/li&gt;
&lt;li&gt;该函数比较的是&lt;strong&gt;字符串而不是字符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限：
&lt;ul&gt;
&lt;li&gt;该函数比较字符串中的字符，直到发现不同的字符为止，这个过程可能会持续到字符串末尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.&lt;code&gt;strncmp()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数可以比较字符不同的地方，也可以只比较第三个参数指定的字符数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如书中的实例：可以限定函数只查找这几个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;6.&lt;code&gt;strcpy()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数是用来拷贝整个字符串的内容，即相当于字符串赋值运算符
&lt;ul&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;str1和str2都是指向字符串的指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str2 = str1;&lt;/code&gt;这个语句拷贝的指针的地址而不是具体内容&lt;/li&gt;
&lt;li&gt;所以要想拷贝整个字符串就要用到该函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;接受两个字符串指针作为参数，可以把第二个指针声明为指针、数组或者字符串常量&lt;/li&gt;
&lt;li&gt;第一个指针应该指向一个数据对象如数组，且该字符串有足够的空间存储源字符串的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他属性：
&lt;ul&gt;
&lt;li&gt;该函数的返回类型是&lt;code&gt;char *&lt;/code&gt;,返回的是第一个参数的值，即一个字符的地址。&lt;/li&gt;
&lt;li&gt;第一个参数不必指向数组的开始，该属性可用于拷贝数组的一部分，详情见书上的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限：
&lt;ul&gt;
&lt;li&gt;与&lt;code&gt;strcat()&lt;/code&gt;一样，不能检查目标空间是否能容纳的下源字符串的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.&lt;code&gt;strncpy()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的第三个参数指明了可拷贝的最大字符数
&lt;ul&gt;
&lt;li&gt;如果要拷贝的字符超过了指定的参数n，当拷贝了n个字符后就会停止，并且也不会在后面添加空字符，容易出现错误，所以要非常注意。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;8.&lt;code&gt;sprintf()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数与&lt;code&gt;printf()&lt;/code&gt;函数类似，但这个是把数据写入字符串，而不是打印在显示器上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该函数的第一个参数是目标字符串的地址，其余的与&lt;code&gt;printf()&lt;/code&gt;类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; first[MAX];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; last[MAX];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; formal[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; MAX &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;];
&lt;span style=&#34;color:#888&#34;&gt;//给以上前面两个数组赋值后就可以进行如下的操作
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;sprintf(formal, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s, %-19s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, last, first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>抽象数据类型</title>
        <link>https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
        <pubDate>Tue, 24 Sep 2019 21:33:07 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ -&lt;h2 id=&#34;一抽象数据类型的实现&#34;&gt;一、抽象数据类型的实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//数据类型的实现
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Counter&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;//实例变量
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; String name&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;Counter&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;String id&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; name &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; id&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//实例方法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;++;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;tally&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;toString&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; count &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; name&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;


&lt;span style=&#34;color:#888&#34;&gt;//测试该数据类型的用例
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#333&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;//创建并初始化对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    Counter heads &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Counter&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;heads&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    Counter tails &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Counter&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;tails&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//调用实例方法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;incerment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    tails&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    
    StdOut&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;heads &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; tails&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    StdOut&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;tally&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; tails&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;tally&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例变量：
&lt;ul&gt;
&lt;li&gt;一个实例变量对应了无数的值，因为数据类型的每个实例对象都有有个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造函数：
&lt;ul&gt;
&lt;li&gt;构造函数是用来创建一个对象的表示，即来初始化实例变量。&lt;/li&gt;
&lt;li&gt;它由&lt;strong&gt;可见性修饰符、构造函数名称(即数据类型的名称)、参数变量&lt;/strong&gt;以及初始化实例变量的代码构成。&lt;/li&gt;
&lt;li&gt;上一条加粗的三个组成了签名，例如&lt;code&gt;public Counter (String id) &lt;/code&gt;即为一个签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实例方法：
&lt;ul&gt;
&lt;li&gt;是每个对象的具体行为，即实现数据类型的实例方法。&lt;/li&gt;
&lt;li&gt;与静态方法的唯一区别是它能够访问并操作实力变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域
&lt;ul&gt;
&lt;li&gt;参数变量：作用域为整个方法。&lt;/li&gt;
&lt;li&gt;局部变量：定义后的所有语句(一个花括号内)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例变量&lt;/strong&gt;：整个类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>测试GitBook格式</title>
        <link>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/</link>
        <pubDate>Fri, 20 Sep 2019 21:43:41 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/ -&lt;h1 id=&#34;flightmuseum-gitbook&#34;&gt;FlightMuseum-GitBook&lt;/h1&gt;
&lt;h2 id=&#34;目录层级&#34;&gt;目录层级&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preface&lt;/li&gt;
&lt;li&gt;Airbus
&lt;ul&gt;
&lt;li&gt;A320
&lt;ul&gt;
&lt;li&gt;A319&lt;/li&gt;
&lt;li&gt;A320-200&lt;/li&gt;
&lt;li&gt;A320-200neo&lt;/li&gt;
&lt;li&gt;A321&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A330
&lt;ul&gt;
&lt;li&gt;A330-200&lt;/li&gt;
&lt;li&gt;A330-300&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A350
&lt;ul&gt;
&lt;li&gt;A350-900&lt;/li&gt;
&lt;li&gt;A350-1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boeing
&lt;ul&gt;
&lt;li&gt;B737&lt;/li&gt;
&lt;li&gt;B747&lt;/li&gt;
&lt;li&gt;B767&lt;/li&gt;
&lt;li&gt;B777&lt;/li&gt;
&lt;li&gt;B787
&lt;ul&gt;
&lt;li&gt;B787-8 Dreamliner&lt;/li&gt;
&lt;li&gt;B787-9 Dreamliner&lt;/li&gt;
&lt;li&gt;B787-10 Dreamliner&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;.&lt;/li&gt;
&lt;li&gt;Trains
&lt;ul&gt;
&lt;li&gt;CR&lt;/li&gt;
&lt;li&gt;TRA&lt;/li&gt;
&lt;li&gt;JR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一个具体层级的markdown编辑形式&#34;&gt;一个具体层级的Markdown编辑形式&lt;/h2&gt;
&lt;h3 id=&#34;1cathay-pacific--国泰航空----b-lra&#34;&gt;1.Cathay Pacific | 国泰航空    B-LRA&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/DSCF0361.jpg&#34; alt=&#34;国泰航空A350-900&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Serial Number / 生产序列号&lt;/strong&gt;：29&lt;/li&gt;
&lt;li&gt;**First Flight Date / 首飞日期：**24th. Mar 2016  &lt;strong&gt;/&lt;/strong&gt;  2016年3月24日&lt;/li&gt;
&lt;li&gt;**Age (Shotted Date) / 机龄(拍摄日期)：**3.3 years as of 27th. Jul 2019  &lt;strong&gt;/&lt;/strong&gt;  3.3年  摄于2019年7月27日&lt;/li&gt;
&lt;li&gt;**Shotted Place / 拍摄地：**Hong Kong  &lt;strong&gt;/&lt;/strong&gt;  香港&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cathaypacific.com/cx/sc_CN/travel-information/flying-with-us/aircraft-and-fleet/airbus-a350/900.html&#34;&gt;&lt;strong&gt;Seat Configuration / 座位布局：&lt;/strong&gt;&lt;/a&gt;C38 W28 Y214&lt;/li&gt;
&lt;li&gt;**Engines / 引擎：**2 x RR Trent XWB&lt;/li&gt;
&lt;li&gt;Others：-&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2philippines-airlines--菲律宾航空----rp-c3506&#34;&gt;2.Philippines Airlines | 菲律宾航空    RP-C3506&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/DSCF4874.jpg&#34; alt=&#34;菲律宾航空A350-900&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Serial Number / 生产序列号&lt;/strong&gt;：243&lt;/li&gt;
&lt;li&gt;**First Flight Date / 首飞日期：**11st. Sep 2018  &lt;strong&gt;/&lt;/strong&gt;  2018年9月11日&lt;/li&gt;
&lt;li&gt;**Age (Shotted Date) / 机龄(拍摄日期)：**0.8 years as of 9th. Aug 2019  &lt;strong&gt;/&lt;/strong&gt;  0.8年  摄于2019年8月9日&lt;/li&gt;
&lt;li&gt;**Shotted Place / 拍摄地：**Hong Kong  &lt;strong&gt;/&lt;/strong&gt;  香港&lt;/li&gt;
&lt;li&gt;**Seat Configuration / 座位布局：**C30 W24 Y241&lt;/li&gt;
&lt;li&gt;**Engines / 引擎：**2 x RR Trent XWB&lt;/li&gt;
&lt;li&gt;Others：-&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>什么是数据结构？什么又是算法？</title>
        <link>https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</link>
        <pubDate>Thu, 19 Sep 2019 13:55:19 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/ -&lt;h2 id=&#34;数据结构及相关概念&#34;&gt;数据结构及相关概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0. 要想知道什么是数据结构，首先要了解与“数据”相关的概念，这样才能一步步理解什么是数据结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先用放书这件事情来举例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果正常情况下只有你自己一个人的书，那么你把他们一本一本立起来放在书架上就可以了。&lt;/li&gt;
&lt;li&gt;那么如果有一个图书馆那么多的书应该怎样办么？总不能把他们乱起八糟的立起来放吧？那么是不是应该先按照社会科学、理科类、工科类、外语类等等的分类方式先分类，然后按照具体所属的类别把他们一个个放进去？其实数据结构的相关的概念就是一个这样简单的道理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来进行具体的描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是对客观事物的&lt;strong&gt;符号&lt;/strong&gt;表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。&lt;/li&gt;
&lt;li&gt;其实就对应了&lt;strong&gt;图书馆中的所有书&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 数据元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是&lt;strong&gt;数据的基本单位&lt;/strong&gt;，在计算机程序中通常作为一个整体进行考虑号处理。&lt;/li&gt;
&lt;li&gt;对应的就是&lt;strong&gt;某一本具体的书&lt;/strong&gt;，比如”数据结构与算法“这本书。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 数据项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个数据元素&lt;/strong&gt;可由&lt;strong&gt;若干个数据项&lt;/strong&gt;组成，数据项是数据的不可分割的最小单位。&lt;/li&gt;
&lt;li&gt;数据项不就是对应了&lt;strong&gt;书中的具体信息&lt;/strong&gt;，比如书的作者、章节内容、ISBN编号等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 数据对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是&lt;strong&gt;性质相同的数据元素&lt;/strong&gt;的集合，是数据的子集。&lt;/li&gt;
&lt;li&gt;数据元素是一本具体的书，那么性质相同数据元素的集合不就代表了&lt;strong&gt;一类具体的书籍&lt;/strong&gt;吗，就比如计算机类的书籍，其中包含了”数据机构与算法这本书“。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;看到这儿是不是对这几者的关系还有点儿晕？没关系，我们用思维导图来再次说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/%E6%95%B0%E6%8D%AE.png&#34; alt=&#34;数据.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是由每一个具体的&lt;strong&gt;数据元素&lt;/strong&gt;组成的，相同的数据元素同属于一个&lt;strong&gt;数据对象&lt;/strong&gt;，每个数据元素中又有具体的信息——&lt;strong&gt;数据项&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来让我们再次把这些概念对应到具体的例子”书”中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/%E4%B8%BE%E4%BE%8B_%E4%B8%96%E7%95%8C%E4%B8%8A%E6%89%80%E6%9C%89%E4%B9%A6.png&#34; alt=&#34;举例_世界上所有书.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;世界上所有书就是一个&lt;strong&gt;数据&lt;/strong&gt;，每一本具体的书例如“数据结构与算法”就是一个&lt;strong&gt;数据元素&lt;/strong&gt;，每本书中的具体信息例如“书名、作者、ISBN码&amp;hellip;”就是多个&lt;strong&gt;数据项&lt;/strong&gt;，一些相同类型的书的类型例如“计算机类书籍”就是一个&lt;strong&gt;数据对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在你应该清楚以上4个概念了吧？&lt;/p&gt;
&lt;p&gt;那我们回到最初的问题，什么是&lt;strong&gt;数据结构&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;这里我们同样举例子来说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A11%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B9%A6%E7%B1%8D.png&#34; alt=&#34;数据对象1：计算机类书籍.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先，一个类别的书籍中有许多具体的书，如&amp;quot;C语言&amp;quot;、&amp;ldquo;数据结构与算法&amp;rdquo;、&amp;ldquo;编译原理&amp;rdquo;，而这些书之间又有一些&lt;strong&gt;关联&lt;/strong&gt;，比如*&lt;em&gt;某个算法可以用C语言来实现*，&lt;em&gt;&lt;strong&gt;&lt;strong&gt;编译过程中需要用到特定的算法&lt;/strong&gt;等等，这些存在关联的书即&amp;quot;数据元素&amp;quot;的集合就叫做&lt;/strong&gt;数据结构&lt;/em&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相互之间存在一种或多种特定关系的数据元素的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数算法都需要我们适当地组织数据，而为了组织数据就产生了数据结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集合&lt;/p&gt;
&lt;p&gt;线性结构&lt;/p&gt;
&lt;p&gt;树形结构&lt;/p&gt;
&lt;p&gt;网状结构或图状结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;物理结构(储存结构)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序储存结构&lt;/p&gt;
&lt;p&gt;链式储存结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(注：这里不具体展开介绍各个数据结构，在后面的附录里进行介绍)&lt;/p&gt;
&lt;h2 id=&#34;抽象数据类型&#34;&gt;抽象数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指一个数学模型以及定义在该数据模型上的一组操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编写一段计算机程序一般都是实现一种 已有的方法来解决某个问题。这种方法大多 和使用的编程语言无关——它适用于各种计 算机以及编程语言。&lt;/li&gt;
&lt;li&gt;你要在图书馆中找到一本书，需要通过索引查找来确定这本书的位置，这个找书的过程就是一个算法。&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C语言指针</title>
        <link>https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</link>
        <pubDate>Thu, 19 Sep 2019 13:10:25 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/ -&lt;h2 id=&#34;一指针的一些概念&#34;&gt;一、指针的一些概念&lt;/h2&gt;
&lt;h3 id=&#34;1-指针的类型&#34;&gt;1. 指针的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把指针声明语句中的指针名字去掉，剩下的就是&lt;strong&gt;指针本身&lt;/strong&gt;的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-指针所指向的类型&#34;&gt;2. 指针所指向的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把指针声明语句中的指针名字和名字前的指针声明符号*去掉，剩下的就是&lt;strong&gt;指针指向的类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-指针的值指针所指向的内存区或地址&#34;&gt;3. 指针的值——指针所指向的内存区或地址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指针的值是指针本身&lt;strong&gt;存储的数值&lt;/strong&gt;，该值被编译器当作一个地址（在32位程序中，所有类型的指针的值都是一个32位的整数，因为32位程序的内存地址都是32位长。）&lt;/li&gt;
&lt;li&gt;指针所指的&lt;strong&gt;内存区&lt;/strong&gt;就是从指针的值所代表的内存地址开始，长度为&lt;code&gt;sizeof(指针指向的类型)&lt;/code&gt;的一篇内存区。&lt;/li&gt;
&lt;li&gt;我们说&lt;strong&gt;一个指针的值是XX&lt;/strong&gt;，就相当于说&lt;strong&gt;该指针指向了以XX为首地址的一片内存区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;同理，我们说&lt;strong&gt;一个指针指向了某个内存区&lt;/strong&gt;，相当于说&lt;strong&gt;该指针的值是该内存区域的首地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-指针本身所占据的内存区&#34;&gt;4. 指针本身所占据的内存区&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;sizeof(指针的类型)&lt;/code&gt;测试一下就知道了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二指针的算术运算&#34;&gt;二、指针的算术运算&lt;/h2&gt;
&lt;p&gt;**0.**指针可以加上或者减去一个整数，这种运算的意义并不是平常的数值的加减。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example 1&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)a;
ptr&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指针ptr的类型为int*，它指向的类型为int，被初始化为指向整型变量a。&lt;/p&gt;
&lt;p&gt;在第三句中，指针ptr被加上了1，编译器是这样进行处理的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把指针ptr的值加上&lt;code&gt;sizeof(int)&lt;/code&gt;，在32位程序中是被加上了4，因为32位程序中&lt;code&gt;int&lt;/code&gt;占4字节。&lt;/p&gt;
&lt;p&gt;由于地址是用字节作为单位，所以ptr指向的地址由原来的a的地址向高的地方增加了4个地址。&lt;/p&gt;
&lt;p&gt;char类型的长度是一个字节，所以原来的ptr是指向数组a从第0个单元开始的4个字节，现在指向了从第4个单元开始的4个字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;example 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;strong&gt;可以使用&lt;/strong&gt;一个循环&lt;/strong&gt;和&lt;strong&gt;一个指针&lt;/strong&gt;遍历一个数组。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
{
    (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr)&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
    ptr&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该例子中将整形数组中各个单元的值都加1。同时每次循环都将指针加1个单元，所以每次循环都能访问数组的下一个单元。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example 4&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;You_are_a_girl&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;) a;
ptr &lt;span style=&#34;color:#333&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该例子中，指针ptr被加上了5个单元，编译器这样处理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将char的值加上&lt;code&gt;sizeof(int) * 5&lt;/code&gt;,在32位程序中即乘了4*5=20。&lt;/p&gt;
&lt;p&gt;指针的值代表了该指针以这个值为地址指向了某个内存区，所以指针ptr所指向的地址向高地址的方向移动了20个字节&lt;/p&gt;
&lt;p&gt;然而ptr加上5(即地址增加20个字节后)已经指向了数组a的合法范围之外，虽然应用时会出现问题，但在语法上没有问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;**2.**总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个指针ptrold加或减一个整数n后，结果是一个新的指针ptrnew，两个指针的类型相同，指向的类型也相同。&lt;/p&gt;
&lt;p&gt;ptrnew的值比ptrold的值增加或者减少了&lt;code&gt;n * sizeof(int)&lt;/code&gt;个字节，即ptrnew指向的内存区比ptrold指向的内存区向高或低地址的方向移动了&lt;code&gt;n * sizeof(int)&lt;/code&gt;个字节。&lt;/p&gt;
&lt;p&gt;指针进行加减：两个指针不能进行加法操作，这是非法操作，结果毫无意义。两个类型相同的指针可以进行减法运算，一般在数组上应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三运算符和&#34;&gt;三、运算符&amp;amp;和*&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; &amp;amp;是取地址运算符，*是间接运算符。&lt;/p&gt;
&lt;p&gt;&amp;amp;a 运算的结果是一个指针，指针的类型是 *a，指针指向的类型是a的类型，指针指向的地址是a的地址。&lt;/p&gt;
&lt;p&gt;*p的类型是p指向的类型，所占用的地址是p指向的地址。&lt;/p&gt;
&lt;h2 id=&#34;四指针表达式&#34;&gt;四、指针表达式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; 一个表达式的结果如果叫指针，那么这个表达式就叫指针表达式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pa;
pa &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;a;&lt;span style=&#34;color:#888&#34;&gt;// &amp;amp;a是指针表达式
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;pa;
&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;b;
pa &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array;
pa&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 指针表达式的结果是一个指针，所以也具有指针的4个要素：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指针的类型&lt;/p&gt;
&lt;p&gt;指针指向的类型&lt;/p&gt;
&lt;p&gt;指针指向的内存区&lt;/p&gt;
&lt;p&gt;指针自身占据的内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 一个指针表达式的结果指针已经具有了自身占据的内存的时候，这个指针表达式就是一个左值，否则就不是一个左值。&lt;/p&gt;
&lt;h2 id=&#34;五指针和数组的关系&#34;&gt;五、指针和数组的关系&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; 数组的数组名可以看作是一个指针&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;}, value;
value &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]; &lt;span style=&#34;color:#888&#34;&gt;//or: value = *array;
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;value &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;]; &lt;span style=&#34;color:#888&#34;&gt;//or: value = *(array + 3);
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;声明一个数组TYPE array[n]，则这个数组名有两重含义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代表整个数组，类型是TYPE[n]。&lt;/p&gt;
&lt;p&gt;是一个常量指针，类型是TYPE*，该指针指向的类型是TYPE，该指针的内存区就是数组的第0号单元，且该指针自己占有单独的内存区，且该指针的值不能修改，array++是错误的写法，这不代表array[1]。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;六指针和结构类型的关系&#34;&gt;六、指针和结构类型的关系&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;结构类型还未学习，之后补充&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;七指针和函数的关系&#34;&gt;七、指针和函数的关系&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; 可以把一个指针声明成一个指向函数的指针。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;fun1&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pfun1)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
pfun1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fun1;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pfun1)(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;);&lt;span style=&#34;color:#888&#34;&gt;//通过函数指针调用函数
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以把指针作为函数的形参。在函数表达式中，可以用指针表达式来作为实参。&lt;/p&gt;
&lt;h2 id=&#34;八指针类型转换&#34;&gt;八、指针类型转换&lt;/h2&gt;
&lt;p&gt;初始化一个指针或者给一个指针赋值时，赋值号左边时一个指针，右边是一个指针表达式。绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和表达式所指向的类型是一样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; f &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;12.3&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;fptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;f;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们想让指针p指向实数f，我们应该怎样操作？&lt;/p&gt;
&lt;p&gt;是“ p = &amp;amp;f; ”吗？&lt;/p&gt;
&lt;p&gt;不对，因为左右两侧的指针和指针所指向的类型不同。所以直接赋值不行。&lt;/p&gt;
&lt;p&gt;为了实现这个目的，需要使用强制类型转换：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p = (int*) &amp;amp;f;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个指针p，需要把它指向的类型改为&amp;quot;TYPE&amp;quot;，语法格式为：&lt;code&gt;(TYPE*)p;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样的类型转换得到一个新指针，类型为TYPE*，指向的地址就是原指针指向的地址。原来p的一切属性都没有被修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;九指针的安全问题&#34;&gt;九、指针的安全问题&lt;/h2&gt;
- https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 