<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 07 Dec 2021 17:14:52 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH08 IO库</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/</link>
        <pubDate>Mon, 10 May 2021 21:04:06 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/ -&lt;h2 id=&#34;io库&#34;&gt;IO库&lt;/h2&gt;
&lt;h3 id=&#34;io类&#34;&gt;IO类&lt;/h3&gt;
&lt;p&gt;为了支持不同类型的IO操作，除了iostream外，标准库还定义了其他一些IO类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件iostream：
&lt;ul&gt;
&lt;li&gt;istream, wistream类型，从流读取数据&lt;/li&gt;
&lt;li&gt;ostream, wostream类型，向流写入数据&lt;/li&gt;
&lt;li&gt;iostream, wiostream类型，读写流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件fstream：
&lt;ul&gt;
&lt;li&gt;ifstream类型，从文件读取数据&lt;/li&gt;
&lt;li&gt;ofstream类型，向文件写入数据&lt;/li&gt;
&lt;li&gt;fstream类型，读写文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件sstream
&lt;ul&gt;
&lt;li&gt;istringstream类型：从string读取数据&lt;/li&gt;
&lt;li&gt;ostringstream类型：向string写入数据&lt;/li&gt;
&lt;li&gt;stringstream类型：读写string&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类型前加一个w的类型是为了支持宽字符，用来操纵wchart_t类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO类型之间的关系&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;类型ifstream和istringstream都继承自istream，我们可以向使用istream对象一样来使用ifstream和istringstream。&lt;/p&gt;
&lt;h4 id=&#34;io对象无拷贝或赋值&#34;&gt;IO对象无拷贝或赋值&lt;/h4&gt;
&lt;p&gt;由于不能拷贝IO对象，因此我们也不能将形参或范围类型设置为流类型，进行IO操作额函数通常以&lt;strong&gt;引用&lt;/strong&gt;的方式传递和范围流。读写一个IO对象会改变其状态，因此传递和范围的引用不能是const的。&lt;/p&gt;
&lt;h4 id=&#34;条件状态&#34;&gt;条件状态&lt;/h4&gt;
&lt;p&gt;IO类定义了一些函数和标志，帮助我们访问和操纵流的条件状态：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//strm为一种IO类型，即上一节给出的各个类型
strm::iostate	//提供了表达条件状态的完整功能
strm::badbit	//用来指出流已崩溃
strm::failbit	//用来指出一个IO操作失败
strm::eofbit	//用来指出流到达了文件结束
strm::goodbit	//用来指出流位处于错误状态。
//其余见书
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;管理输出缓冲&#34;&gt;管理输出缓冲&lt;/h4&gt;
&lt;p&gt;每个输出流都管理一个缓冲区。&lt;/p&gt;
&lt;p&gt;导致缓冲刷新的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束，作为return的一部分操作。&lt;/li&gt;
&lt;li&gt;缓冲区满时，需要刷新。&lt;/li&gt;
&lt;li&gt;使用操纵符如endl显示刷新缓冲区。&lt;/li&gt;
&lt;li&gt;每个输出操作后可以用操纵夫unitbuf设置流的内部状态来清空缓冲区。&lt;/li&gt;
&lt;li&gt;一个输出流可能被关联到另一个输出流。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;刷新输出缓冲区：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//输出hi和一个空格，然后刷新缓冲区
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; flush;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//输出hi，然后刷新缓冲区，不附加额外字符
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ends;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//输出hi和一个空字符，然后刷新缓冲区
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;文件输入输出&#34;&gt;文件输入输出&lt;/h3&gt;
&lt;p&gt;头文件定义了如上所示的三个类型来住处文件IO。&lt;/p&gt;
&lt;p&gt;除了继承自iostream类型的行为外，fstream中的定义还增加了新的成员来管理与流关联的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;fstream fstrm;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//创建一个未绑定的流文件fstrm; fstream是头文件fstream中定义的一个类型
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;fstream &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;fstrm&lt;/span&gt;(s);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//创建一个fstream并打开名为s的文件
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;fstream &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;fstrm&lt;/span&gt;(s,mode);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//与上一个相同，但按指定mode打开
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;fstrm.open(s)	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//打开名为s的文件并将文件与fstrm绑定
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;fstrm.close()	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//关闭与fstrm绑定的文件，返回void
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;fstrm.is_open()	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//返回一个bool, 指出关联的文件是否成功打开尚未关闭
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;使用文件流对象&#34;&gt;使用文件流对象&lt;/h4&gt;
&lt;h4 id=&#34;文件模式&#34;&gt;文件模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;mode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以读方式打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;out&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以写方式打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;app&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;每次写操作前均定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ate&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打开文件后立即定位到末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;trunc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;截断文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;以out模式打开文件会丢弃已有数据&#34;&gt;以out模式打开文件会丢弃已有数据&lt;/h4&gt;
&lt;h3 id=&#34;string流&#34;&gt;string流&lt;/h3&gt;- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Altium Designer画图流程记录(简略)</title>
        <link>https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</link>
        <pubDate>Fri, 30 Apr 2021 22:47:47 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/ -&lt;p&gt;之前看过博主&lt;a href=&#34;https://space.bilibili.com/384891&#34;&gt;半夜中暑的羊&lt;/a&gt;的原理图以及PCB绘制&lt;a href=&#34;https://www.bilibili.com/video/BV1JE41127Ks&#34;&gt;教程&lt;/a&gt;，收获颇丰，但是视频比较长而且分为多集，每次有些地方忘记时要去找到很不方便，因此趁着这次画一个简单转接版的机会，把视频中的内容整理成文字版，方便之后查找和复习。这里面只涉及基本的两层版的基本绘制。&lt;/p&gt;
&lt;p&gt;共有以下几部分内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原理图库&lt;/li&gt;
&lt;li&gt;核心模块的原理图&lt;/li&gt;
&lt;li&gt;为原理图添加封装&lt;/li&gt;
&lt;li&gt;PCB布局&lt;/li&gt;
&lt;li&gt;PCB布线&lt;/li&gt;
&lt;li&gt;PCB敷铜&lt;/li&gt;
&lt;li&gt;PCB生成BOM及投板&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;pcb各层简介&#34;&gt;PCB各层简介&lt;/h2&gt;
&lt;p&gt;参考自：&lt;a href=&#34;https://blog.csdn.net/qq_29373285/article/details/85339076&#34;&gt;PCB各层介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mechanical-layer机械层&#34;&gt;Mechanical layer(机械层)&lt;/h3&gt;
&lt;p&gt;Altium Designer提供了16个机械层，它一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。这些信息因设计公司或PCB制造厂家的要求而有所不同。另外，机械层可以附加在其它层上一起输出显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/MechanicalLayer.PNG&#34; alt=&#34;MechanicalLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;keep-out-layer禁止布线层&#34;&gt;Keep out layer(禁止布线层)&lt;/h3&gt;
&lt;p&gt;用于定义在电路板上能够有效放置元件和布线的区域。在该层绘制一个封闭区域作为布线有效区，在该区域外是不能自动布局和布线的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/KeepOutLayer.PNG&#34; alt=&#34;KeepOutLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;signal-layer信号层&#34;&gt;Signal layer(信号层)&lt;/h3&gt;
&lt;p&gt;信号层主要用于布置电路板上的导线。Altium Designer提供了32个信号层，包括Top layer(顶层)，Bottom layer(底层)和32个内电层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SignalLayer.PNG&#34; alt=&#34;SignalLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;internal-plane-layer内部电源接地层&#34;&gt;Internal plane layer(内部电源/接地层)&lt;/h3&gt;
&lt;p&gt;Altium Designer提供了32个内部电源层/接地层。该类型的层仅用于多层板，主要用于布置电源层和接地层。我们称双层板，四层板，六层板，一般指信号层和内部电源/接地层的数目。&lt;/p&gt;
&lt;h3 id=&#34;silkscreen-layer丝印层&#34;&gt;Silkscreen layer(丝印层)&lt;/h3&gt;
&lt;p&gt;丝印层主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。Altium Designer提供了Top Overlay（顶层丝印层）和Bottom Overlay（底层丝印层）两个丝印层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SilkscreenLayer.PNG&#34; alt=&#34;SilkscreenLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;solder-mask-layer阻焊层&#34;&gt;Solder mask layer(阻焊层)&lt;/h3&gt;
&lt;p&gt;在焊盘以外的各部位涂覆一层涂料，我们通常用的有绿油、蓝油等，用于阻止这些部位上锡。阻焊层用于在设计过程中&lt;strong&gt;匹配焊盘&lt;/strong&gt;，是&lt;strong&gt;自动产生&lt;/strong&gt;的。阻焊层是负片输出，阻焊层的地方不盖油，其他地方盖油。Altium Designer提供了**Top Solder(顶层)&lt;strong&gt;和&lt;/strong&gt;Bottom Solder(底层)**两个阻焊层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/SolderMaskLayer.PNG&#34; alt=&#34;SolderMaskLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;paste-mask-layer助焊层smd贴片层&#34;&gt;Paste mask layer(助焊层，SMD贴片层)&lt;/h3&gt;
&lt;p&gt;它和阻焊层的作用相似，不同的是在机器焊接时对应的表面粘贴式元件的焊盘。Altium Designer提供了Top Paste(顶层助焊层)和Bottom Paste(底层助焊层)两个助焊层。主要针对PCB板上的SMD元件。在将SMD元件贴PCB板上以前，必须在每一个SMD焊盘上先涂上锡膏，在涂锡用的钢网就一定需要这个Paste Mask文件,菲林胶片才可以加工出来。Paste Mask层的Gerber输出最重要的一点要清楚，即这个层主要针对SMD元件，同时将这个层与上面介绍的Solder Mask作一比较，弄清两者的不同作用，因为从菲林胶片图中看这两个胶片图很相似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/PasteMaskLayer.PNG&#34; alt=&#34;PasteMaskLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;multi-layer多层&#34;&gt;Multi layer(多层)&lt;/h3&gt;
&lt;p&gt;电路板上焊盘和穿透式过孔要穿透整个电路板，与不同的导电图形层建立电气连接关系，因此系统专门设置了一个抽象的层—多层。一般，焊盘与过孔都要设置在多层上，如果关闭此层，焊盘与过孔就无法显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/MultiLayer.PNG&#34; alt=&#34;MultiLayer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;drill-layer钻孔层&#34;&gt;Drill layer(钻孔层)&lt;/h3&gt;
&lt;p&gt;钻孔层提供电路板制造过程中的钻孔信息(如焊盘，过孔就需要钻孔)。Altium Designer提供了Drill gride(钻孔指示)和Drill drawing(钻孔)两个钻孔层。&lt;/p&gt;
&lt;h2 id=&#34;原理图库器件画法&#34;&gt;原理图库器件画法&lt;/h2&gt;
&lt;p&gt;放置矩形&lt;/p&gt;
&lt;p&gt;添加Pin&lt;/p&gt;
&lt;p&gt;设置器件的Designator（例如P?）&lt;/p&gt;
&lt;h2 id=&#34;器件的pcb封装画法&#34;&gt;器件的PCB封装画法&lt;/h2&gt;
&lt;p&gt;确定是过孔还是焊盘，然后根据坐标放置位置，最后画丝印。&lt;/p&gt;
&lt;h2 id=&#34;批量添加封装并给各种原件命名&#34;&gt;批量添加封装并给各种原件命名&lt;/h2&gt;
&lt;h3 id=&#34;添加封装&#34;&gt;添加封装&lt;/h3&gt;
&lt;p&gt;右键-Find Similar Objects选择相同类型的原件-右键-Properties-修改封装&lt;/p&gt;
&lt;h3 id=&#34;批量命名&#34;&gt;批量命名&lt;/h3&gt;
&lt;p&gt;执行&lt;strong&gt;Tools-Annotation-Annotate Schematic&lt;/strong&gt;(或快捷键&lt;strong&gt;T A A&lt;/strong&gt;)命令打开原理图元件命名管理器&lt;/p&gt;
&lt;p&gt;左上角设置命名顺序&lt;/p&gt;
&lt;p&gt;设置命名范围&lt;/p&gt;
&lt;p&gt;然后单击Update&lt;/p&gt;
&lt;p&gt;可以看到新的命名建议，然后执行有效角的接收更改&lt;/p&gt;
&lt;p&gt;依次单击Validate和Execute（保证两排绿√）&lt;/p&gt;
&lt;p&gt;即可完成命名&lt;/p&gt;
&lt;h2 id=&#34;确定pcb范围并布局&#34;&gt;确定PCB范围并布局&lt;/h2&gt;
&lt;p&gt;根据需要的形状和经验粗略地确定版图的位置边界，然后布局元件位置。&lt;/p&gt;
&lt;h2 id=&#34;布线&#34;&gt;布线&lt;/h2&gt;
&lt;p&gt;注意设置焊盘间的距离，jlc为7mil，以及过孔孔径。&lt;/p&gt;
&lt;p&gt;过孔打法：&lt;code&gt;Alt+Shift+鼠标滚轮向上&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;铺铜&#34;&gt;铺铜&lt;/h2&gt;
&lt;p&gt;使用铺铜管理器进行铺铜：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工具→铺铜→铺铜管理器（快捷键:TGM）&lt;/li&gt;
&lt;li&gt;选择来自&amp;hellip;..的新多边形（New Polygon from &amp;hellip;）→板外形（Board Outline）&lt;/li&gt;
&lt;li&gt;设置网络，哪一层？除去死铜&lt;/li&gt;
&lt;li&gt;最后点击应用，确定，这样顶层的铺地铜就铺好了！&lt;/li&gt;
&lt;li&gt;其他层同样按照上面的步骤进行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;设置板子边界&#34;&gt;设置板子边界&lt;/h2&gt;
&lt;p&gt;首先选中Keep-Out-Layer所定义的边界&lt;/p&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;p&gt;【Design】|【Board shape】|【Define from selected objects】&lt;/p&gt;
&lt;p&gt;快捷键为D+S+D+enter&lt;/p&gt;
&lt;h2 id=&#34;其他一些快捷键&#34;&gt;其他：一些快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+D&lt;/code&gt;: View Configuration，用来配置PCB的显示内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+M&lt;/code&gt;：测量长度，使用&lt;code&gt;shift+C&lt;/code&gt;删除测量得到的线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;批量修改元件&#34;&gt;批量修改元件&lt;/h2&gt;
&lt;p&gt;以命名所有电阻为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先使用过滤器选中所有电阻&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行&lt;strong&gt;工具——Annotation——注解&lt;/strong&gt;（英文为&lt;strong&gt;Tools——Annotation——Annotate Schematic&lt;/strong&gt;，或者快捷键&lt;strong&gt;T A A&lt;/strong&gt;）命令打开原理图元件命名管理器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3d渲染图实现&#34;&gt;3D渲染图实现&lt;/h2&gt;
- https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH07 类</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/</link>
        <pubDate>Tue, 27 Apr 2021 10:08:56 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/ -&lt;p&gt;以一个例子来说明类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;strut Sales_data {
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//构造函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;	Sales_data() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;default&lt;/span&gt;;
	Sales_data(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;s) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; bookNo(s) {}
	Sales_data(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;s, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; n, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; p)&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
		bookNo(s), units_sold(n), revenue(p&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;n) {}
	Sales_data(std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;istream &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);
	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//成员函数：
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;string isbn()	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; {&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; bookNo; }
	Sales_data&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; combine(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; Sales_data&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; avg_price() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt;;
	std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;string bookNo;
	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//类内初始值(数据成员)
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; units_sold &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;;
	&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; revenue &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0.0&lt;/span&gt;;
};
&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//在类的外部定义成员函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; Sales_data&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;avg_price() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; {
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (units_sold)
		&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; revenue &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt; units_sold;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//在类的外部定义构造函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;Sales_data&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;Sales_data(std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;istream &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;is)
{
    read(is, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;this&lt;/span&gt;);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//从is中读取一条信息然后存入this对象中
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;成员函数&#34;&gt;成员函数&lt;/h2&gt;
&lt;p&gt;成员函数的&lt;strong&gt;声明&lt;/strong&gt;必须在&lt;strong&gt;类的内部&lt;/strong&gt;，它的&lt;strong&gt;定义&lt;/strong&gt;既可以在类的内部也可以在类的外部。作为接口的非成员函数，它的定义和声明都在类的外部。&lt;/p&gt;
&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;构造函数的任务时初始化类对象的数据成员，无论何时只要类被创建就会执行构造函数。&lt;/p&gt;
&lt;p&gt;构造函数的名字和&lt;strong&gt;类名&lt;/strong&gt;相同，和其他函数不同，构造函数&lt;strong&gt;没有返回类型&lt;/strong&gt;；除此之外的特性类似于其他函数。&lt;/p&gt;
&lt;p&gt;类可以包含多个构造函数，和其他的&lt;strong&gt;重载函数&lt;/strong&gt;差不多，不同构造函数之间必须在参数数量或参数类型上有所区别。&lt;/p&gt;
&lt;p&gt;构造函数不能被声明成&lt;strong&gt;const&lt;/strong&gt;的。当我们创建类的一个const对象，直到构造函数完成初始化的过程，对象才能真正获得其常量属性。&lt;/p&gt;
&lt;p&gt;在类的外部定义构造函数：如上代码所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数初始值列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就对象的数据成员而言，初始化和赋值也有区别。如果没有在构造函数的初始值列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化。&lt;/p&gt;
&lt;p&gt;如果成员是&lt;strong&gt;const&lt;/strong&gt;或&lt;strong&gt;引用&lt;/strong&gt;的话，必须将其初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;ConstRef&lt;/span&gt; {
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
	ConstRef(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ii);
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ci;
	&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;ri;
};
ConstRef&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;ConstRef(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ii)&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; i(ii), ci(ii), ri(i) {}	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//显示地初始化引用和const成员
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最好避免使用某些成员初始化其他成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;委托构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个委托构造函数可以使用它属类的其他构造函数执行它自己的初始化过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Sales_data&lt;/span&gt; {
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//非委托构造函数使用对应的实参初始化成员
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;	Sales_data(std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;string s, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; cnt, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; price)&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
		bookNo(s), units_sold(cnt), revenue(cnt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;price);
	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//其余构造函数委托给另一个构造函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;	Sales_data()&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; Sales_data(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;) {}	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//默认构造函数，委托给了上面输入3个变量的构造函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;	Sales_data(std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;string s)&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; Sales_data(s, &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;) {}
	Sales_Data(std&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;istrean &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;is)&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; Sales_data() {read(is, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;this&lt;/span&gt;); }	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//委托给了默认构造函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;聚合类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聚合类使得用户可以直接访问其成员并且具有特殊的初始化语法形式。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有成员都是public的。&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数。&lt;/li&gt;
&lt;li&gt;没有类内初始值。&lt;/li&gt;
&lt;li&gt;没有基类，没有virtual函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct Data {
	int ival;
	string s;
};
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;访问控制与封装&#34;&gt;访问控制与封装&lt;/h2&gt;
&lt;p&gt;使用**访问说明符(access specifiers)**加强类的封装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;说明符：定义在其之后的成员在整个程序内可被访问，public成员定义类的接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;说明符：定义在其后的成员可以被类的成员函数访问，但不能被使用该类的代码访问，该种封装隐藏了类的实现细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;struct&lt;/strong&gt;和&lt;strong&gt;class&lt;/strong&gt;关键词的区别：&lt;/p&gt;
&lt;p&gt;我们可以用两个关键词中的任意一个定义类，唯一的区别是两者的&lt;strong&gt;默认访问权限&lt;/strong&gt;不太一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;struct&lt;/code&gt;：定义在第一个访问说明符之前的成员是public的。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;class&lt;/code&gt;：定义在第一个访问说明符之前的成员是private的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;友元&#34;&gt;友元&lt;/h2&gt;
&lt;p&gt;类可以允许其他类或函数访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;，方法是令其他类或函数称为它的友元；如果类想把&lt;strong&gt;一个函数&lt;/strong&gt;作为它的友元，只要增加一条以&lt;code&gt;friend&lt;/code&gt;关键词开头的&lt;strong&gt;函数声明语句&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;友元声明只能出现在&lt;strong&gt;类定义的内部&lt;/strong&gt;，但在类内出现的具体位置不限。&lt;/p&gt;
&lt;p&gt;友元的声明仅仅指定了&lt;strong&gt;访问权限&lt;/strong&gt;，并非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，就必须&lt;strong&gt;在友元声明之外再专门对函数进行一次声明&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;类的作用域&#34;&gt;类的作用域&lt;/h2&gt;
&lt;p&gt;在类的作用域之外，普通的数据和函数成员只能由&lt;strong&gt;对象、引用或指针&lt;/strong&gt;使用**成员访问运算符(&lt;code&gt;. -&amp;gt;&lt;/code&gt;)&lt;strong&gt;来访问；对于类类型成员，则使用&lt;/strong&gt;作用域运算符(&lt;code&gt;::&lt;/code&gt;)**访问。&lt;/p&gt;
&lt;p&gt;一个类就是一个作用域，所以在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; Window_mgr&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;clear(ScreenIndex i)
{
	Screen &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;s &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; screens[i];
	s.contents &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; string(s.height &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; s.width, &lt;span style=&#34;color:#d14&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;类的静态成员&#34;&gt;类的静态成员&lt;/h2&gt;
&lt;p&gt;有时候类需要它的一些成员&lt;strong&gt;与类本身直接相关&lt;/strong&gt;，而不是与类的各个对象保持关联。这是我们可以通过声明静态成员，即在成员的声明前加上关键字&lt;strong&gt;static&lt;/strong&gt;，使得其与类关联在一起。&lt;/p&gt;
&lt;p&gt;静态成员可以是public或private的。&lt;/p&gt;
&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。同样，&lt;strong&gt;类静态成员函数&lt;/strong&gt;也不与任何对象绑定在一起，它们不包含this指针。静态成员函数不能声明成const的，也不能在static函数体内使用this指针。&lt;/p&gt;
&lt;p&gt;使用类的静态成员：&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;作用域运算符&lt;/strong&gt;直接访问静态成员：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; r;
r &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; Account&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;rate();	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//Account为类名
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p&gt;
&lt;p&gt;定义静态成员：&lt;/p&gt;
&lt;p&gt;我们既可以在类内部也可以在类外部&lt;strong&gt;定义静态成员函数&lt;/strong&gt;，在类外部定义时不能重复static关键词，该词只出现在类内部的声明中。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH01-06 基础内容</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</link>
        <pubDate>Sun, 25 Apr 2021 10:08:56 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/ -&lt;p&gt;第1部分：C++基础&lt;/p&gt;
&lt;p&gt;这个分类的博客主要为了记录一下我在学习C++过程中记录的知识笔记，主要参考自《C++  Primer 第5版》。&lt;/p&gt;
&lt;p&gt;第一部分基础部分主要包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量和基本类型&lt;/li&gt;
&lt;li&gt;表达式&lt;/li&gt;
&lt;li&gt;语句&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变量和基本类型&#34;&gt;变量和基本类型&lt;/h2&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;p&gt;变量的声明和定义：&lt;/p&gt;
&lt;p&gt;显示声明时在变量前加上extern。&lt;/p&gt;
&lt;p&gt;声明只规定了变量类型和名字，定义还申请了存储空间，为变量赋一个初始值。&lt;/p&gt;
&lt;p&gt;可以在多个文件重复声明，但只能定义一次。&lt;/p&gt;
&lt;h3 id=&#34;复合类型&#34;&gt;复合类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;左值引用，为对象起了另一个名字；将声明符写成&lt;code&gt;&amp;amp;d&lt;/code&gt;的形式来定义引用类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int ival = 1024;
int &amp;amp;refVal = ival;
int &amp;amp;refVal2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;引用即为对象的别名，引用本身不是一个对象，只是为一个已存在的对象起的另一个名字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针本身就是一个对象，允许对指针赋值和拷贝，无需再定义时赋值，定义指针时将声明符写作&lt;code&gt;*d&lt;/code&gt;形式，d为变量名。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; dp, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;dp2; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//dp2为指向double类型对象的指针
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;取地址符&lt;code&gt;&amp;amp;&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ival &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;42&lt;/span&gt;;
&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;ival;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//p存放ival的地址
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解引用符&lt;code&gt;*&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int ival = 42;
int *p = &amp;amp;ival;//p存放ival的地址
cout &amp;lt;&amp;lt; *p;	//输出指针p所指的对象，42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空指针：不指向任何对象，使用字面值&lt;code&gt;nullptr&lt;/code&gt;来初始化指针。&lt;/p&gt;
&lt;p&gt;给指针赋值：令他存放一个新的地址，从而指向一个新的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void*&lt;/code&gt;指针：一种特殊类型的指针，可用于存放任意对象的地址。&lt;/p&gt;
&lt;p&gt;复合类型的声明：&lt;/p&gt;
&lt;p&gt;变量的定义包含一个基本数据类型和一组声明符；同一条定义中，基本数据类型只有一个，但声明符的形式可以不同，即一条语句可以定义不同类型的变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r = i;
//i是一个int数，p是一个int类型指针，r是一个int类型引用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般把修饰符(&lt;code&gt;&amp;amp;,*&lt;/code&gt;)和变量标识符写在一起。&lt;/p&gt;
&lt;p&gt;指向指针的指针：&lt;/p&gt;
&lt;p&gt;指向指针的引用：&lt;/p&gt;
&lt;h3 id=&#34;const限定符&#34;&gt;const限定符&lt;/h3&gt;
&lt;p&gt;让一种变量的值不变。const对象必须要初始化，任何试图为const对象赋值的行为都将发生错误。&lt;/p&gt;
&lt;p&gt;const对象仅在文件内有效；要想让const对象像其他非常量对象一样在不同文件中工作，即在一个文件中定义const，在其他多个文件中声明并使用它，需要添加&lt;code&gt;extern&lt;/code&gt;关键字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//file.cpp定义并初始化了一个常量
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; bufSize &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; fcn();
&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//file.h头文件，与file.cpp定义的bufSize是同一个
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; bufSize;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;const的引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以把引用绑定到const对象上，但对常量的引用不能用于修改它所绑定的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ci &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1024&lt;/span&gt;;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;r1 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; ci;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//正确：引用及其对应的对象都是常量
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;r1 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;42&lt;/span&gt;; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//错误
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;r2 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; ci; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//错误，试图让一个非常量引用指向一个常量对象
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;引用的类型必须与所引用的对象类型一致，但有例外：&lt;/p&gt;
&lt;p&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能被转换为引用的类型即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;r1 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;42&lt;/span&gt;;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//正确
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;指针和const&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以令指针指向常量或非常量，&lt;strong&gt;指向常量的指针&lt;/strong&gt;不能用于改变其所指对象的值，要想存放常量对象，只能使用&lt;strong&gt;指向常量的指针&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const double pi = 3.14;
double *ptr = &amp;amp;pi; //错误：ptr是普通指针
const double *cptr = &amp;amp;pi;	//正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;顶层const&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顶层const：表示指针本身是个常量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;底层const：表示指针所指的对象是一个常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int i = 0;
int *const p1 = &amp;amp;i;		//顶层const，表示指针p1本身是一个常量，不能改变p1的值
const int *p2 = &amp;amp;ci;	//底层const，表示指针p2指的对象ci的地址是一个常量，p2的值可以改变，对象的值不能改变
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;constexpr和常量表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常量表达式指值不会改变并且在编译过程就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;constexpr变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++11允许将变量声明为constexpr类型以便由编译器验证变量的值是否是一个常量表达式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; mf &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//20是常量表达式
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; size();	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//只有当size是一个constexpr函数是才是一条正确的声明语句
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;字面值类型：声明constexpr时用到的类型。算术类型、引用和指针都属于字面值类型；IO库、string类型不属于字面值类型，不能被定义为constexpr。&lt;/p&gt;
&lt;h3 id=&#34;处理类型&#34;&gt;处理类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;类型别名&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用关键词&lt;code&gt;typedef&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; wages; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//wages是double的同义词
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一种别名声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using SI = Sales_item;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;字符串向量和数组&#34;&gt;字符串、向量和数组&lt;/h2&gt;
&lt;h3 id=&#34;命名空间和using声明&#34;&gt;命名空间和using声明&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;namespace&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;name;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//命名空间::名字
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个名字都需要独立的using声明；头文件不应该包含using声明&lt;/p&gt;
&lt;h3 id=&#34;标准库类型string&#34;&gt;标准库类型string&lt;/h3&gt;
&lt;p&gt;string表示可变长的字符序列&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;string&amp;gt;
using std::string;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义和初始化：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string s1;
string s2(s1);
string s3(&amp;quot;value&amp;quot;);
string s3 = &amp;quot;value&amp;quot;;
string s4(n, &#39;c&#39;); //s4初始化为由连续的n个字符组成的串
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;string对象上的操作：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;os &amp;lt;&amp;lt; s //将s写道输出流os中，返回os
is &amp;gt;&amp;gt; s //从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s)	//从is中读取一行赋给s，返回is
s.empty()
s.size()
s[n]	//返回s中第n个字符的引用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;string::size_type&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;size函数返回的为上述值，是一个无符号类型的值，能存放下任何string类型对象大小。&lt;/p&gt;
&lt;p&gt;处理string对象中的字符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//cctype头文件中的函数
isalnum(c)	//c是数字或字母时为真
isalpha(c)
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;for&lt;/code&gt;处理每个字符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string str(&amp;quot;some string&amp;quot;);
for (auto c : str)
	cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用下标运算符&lt;code&gt;[]&lt;/code&gt;处理一部分字符.&lt;/p&gt;
&lt;h3 id=&#34;标准库类型vector&#34;&gt;标准库类型vector&lt;/h3&gt;
&lt;p&gt;表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，用于访问对象，因为vector容纳着其他对象，所以也被称之为&lt;strong&gt;容器&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;vector&amp;gt;
using std::vector;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vector是一个&lt;strong&gt;类模板&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板&lt;/strong&gt;本身不是类或函数，可以看作编译器生成类或函数编写的一份说明，编译器根据模板创建类或函数的过程称为&lt;strong&gt;实例化&lt;/strong&gt;，使用模板时要指出编译器应该把类或函数实例化成何种类型。需要提供那些信息由模板决定，提供信息的方式是在模板名字后面跟一对尖括号，在括号内放入信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; ivec;	//ivec保存int类型对象
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file; 	//该向量的元素是vector对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;初始化vector对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义和初始化vector对象&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;T&amp;gt; v1;
vector&amp;lt;T&amp;gt; v2(v1);
vector&amp;lt;T&amp;gt; v3(n, val);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以默认初始化vector对象，从而创建一个指定类型的空vector。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; svec;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列表初始化对象：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; v1{&amp;quot;a&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;the&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建指定数量元素：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; ivec(10, -1);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值初始化：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; ivec(10);	//10个元素，每个初始值都为0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;向vector对象中添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用vector的成员函数&lt;code&gt;push_back()&lt;/code&gt;添加。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; str;
string i = &amp;quot;111&amp;quot;;
str.push_back(i);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;其他vector操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;v.empty()	//判断v中是否含有元素，返回布尔值
v.size()	//返回v中元素个数
v.push_back(t)	//向v尾端添加一个值为t的元素
v[n]	//返回v中的n个位置上元素的引用
v1 = v2	//用v2中的元素拷贝替换v1中的元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用下标运算符[]计算vector对象的索引，下标类型是size_type。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; str;
string s = str[0];	//[]中的0为size_type类型
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要使用size_type必须知名它是由哪种类型定义的。vector对象的类型总是包含着元素的类型&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt;::size_type	//正确
vector::size_type	//错误
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不能用下标形式添加元素，以下为错误示范：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;5&lt;/span&gt;;
vector&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; ivec;
ivec[ix] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; ix;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;迭代器iterator&#34;&gt;迭代器iterator&lt;/h3&gt;
&lt;p&gt;迭代器可以用来访问容器的对象。&lt;/p&gt;
&lt;p&gt;有迭代器的类型都拥有名为&lt;code&gt;beign&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的成员函数，end成员返回指向容器尾元素下一位置的迭代器，即一个不存在的尾后元素。&lt;/p&gt;
&lt;p&gt;迭代器运算符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*iter	//返回迭代器iter所指元素的引用
iter-&amp;gt;name	//解引用iter并获取该元素的名为mem的成员
++iter	//令iter指示容器中的下一个元素
--iter	//令iter指示容器中的上一个元素
iter1 == iter2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将迭代器从一个元素移动到另一个元素：&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;++&lt;/code&gt;递增运算符。&lt;/p&gt;
&lt;p&gt;迭代器类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt;::iterator it;	//it能读写vector&amp;lt;int&amp;gt;的元素
vector&amp;lt;int&amp;gt;::const_iterator it3;	//it3只能读元素，不能写元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;某些对vector对象的操作会使迭代器失效&lt;/p&gt;
&lt;p&gt;迭代器运算：移动位置&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;iter + n	//加上一个整数仍然得到一个迭代器，迭代器指示的新位置与原来的位置相比向前移动了若干个元素
iter - n
iter += n
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数组和多维数组&#34;&gt;数组和多维数组&lt;/h3&gt;
&lt;p&gt;数组与vector的不同是，数组的大小确定不变，不能随意向数组中增加元素。大小固定，对某些应用来说程序的运行性能较好，但也损失了一些灵活性。&lt;/p&gt;
&lt;p&gt;随着C++11 标准的提出，通过使用auto和decltype就能尽可能避免在数组前面加上一个指针类型了。&lt;/p&gt;
&lt;h2 id=&#34;表达式&#34;&gt;表达式&lt;/h2&gt;
&lt;h3 id=&#34;成员访问运算符&#34;&gt;成员访问运算符&lt;/h3&gt;
&lt;p&gt;箭头运算符与点运算符有关，表达式&lt;code&gt;ptr-&amp;gt;mem&lt;/code&gt;等价于&lt;code&gt;(*ptr).mem&lt;/code&gt;；&lt;/p&gt;
&lt;h3 id=&#34;条件运算符&#34;&gt;条件运算符&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cond ? expr1 : expr2;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;位运算符&#34;&gt;位运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位求反&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;~expr&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;&amp;lt;&amp;lt;,&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;左移，右移&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;expr1 &amp;lt;&amp;lt; expr2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位或&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;expr1 &amp;amp; expr2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位异或&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;expr1 ^ expr2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位或&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;sizeof运算符&#34;&gt;sizeof运算符&lt;/h3&gt;
&lt;p&gt;返回一条&lt;strong&gt;表达式&lt;/strong&gt;或一个&lt;strong&gt;类型名&lt;/strong&gt;所占的字节数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sizeof data;
sizeof *p;	//指针所占的空间大小
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;逗号运算符&#34;&gt;逗号运算符&lt;/h3&gt;
&lt;p&gt;含有两个运算对象，按从左向右的顺序依次求值。&lt;/p&gt;
&lt;h3 id=&#34;类型转换&#34;&gt;类型转换&lt;/h3&gt;
&lt;p&gt;C++中，如果两个类型可以相互转换，那么他们之间就是关联的。&lt;/p&gt;
&lt;p&gt;隐式转换无需程序员介入，自动完成。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ival &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3.541&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//编译器可能警告损失了运算精度
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;算数转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把一种算术类型转换成另一种算数类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他隐式类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组转换成指针、转换成布尔类型、转换成常量、类类型定义的转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式转换&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;语句&#34;&gt;语句&lt;/h2&gt;
&lt;p&gt;简单的条件语句（if-else）、迭代语句（while、for、范围for、do-while语句）不作具体说明。&lt;/p&gt;
&lt;h3 id=&#34;跳转语句&#34;&gt;跳转语句&lt;/h3&gt;
&lt;p&gt;break：终止离它最近的while，do while，for或switch语句，并从这些语句之后的第一条语句开始执行。&lt;/p&gt;
&lt;p&gt;continue：终止最近的循环中的当前迭代并立即开始下一次迭代。&lt;/p&gt;
&lt;p&gt;goto：（不推荐使用，因此不过多介绍）&lt;/p&gt;
&lt;h3 id=&#34;try语句块和异常处理&#34;&gt;try语句块和异常处理&lt;/h3&gt;
&lt;p&gt;异常指的是一些超出了函数正常功能范围的反常行为。&lt;/p&gt;
&lt;p&gt;C++中异常处理机制包括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;throw表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序的异常检测部分使用throw表达式引发一个异常。表达式半酣关键词throw和紧随其后的一个表达式，其中表达式类型就是抛出的异常类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (item1.isbn() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;!=&lt;/span&gt; item2.isbn())
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;throw&lt;/span&gt; runtime_error(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;Data must refer to same ISBN&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该异常是runtime_error的对象，抛出异常将终止当前函数，把控制权转移给能处理该异常的代码。&lt;/p&gt;
&lt;p&gt;runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;try语句块&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;try&lt;/span&gt; {
	program&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt;statements
} &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;catch&lt;/span&gt; (exception&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt;declaration)	{
	handler&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt;statements
} &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;catch&lt;/span&gt; (exception&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt;declaration)	{
	handler&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt;statements
}	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;跟在try块后的是一个或多个catch子句；catch子句包括三部分：关键词catch、括号内的一个对象的声明(称为异常声明)以及一个块。当选中类某个catch子句处理异常后，执行与之对应的块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标准异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用。这些异常定义在以下几个头文件中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exception&lt;/li&gt;
&lt;li&gt;stdexcept&lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;type_info&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;h3 id=&#34;函数基础&#34;&gt;函数基础&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;形参列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的形参列表可以为空，但不能省略；形参通常用都好隔开，每个形参都是含有一个声明符的声明，即使两个形参的类型相同，也必须把两个类型都写出来。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void f1()	{}
void f2(void)	{}
int f3(int v1, v2)	//这样写是错的
int f4(int v3, int v4)	//这样写正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的声明&lt;strong&gt;无需函数体&lt;/strong&gt;，用一个&lt;strong&gt;分号&lt;/strong&gt;代替。&lt;/p&gt;
&lt;p&gt;一般在&lt;strong&gt;头文件中&lt;/strong&gt;进行&lt;strong&gt;声明&lt;/strong&gt;，在&lt;strong&gt;源文件中&lt;/strong&gt;进行&lt;strong&gt;定义&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;参数传递&#34;&gt;参数传递&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;const形参和实参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当用实参初始化形参时会忽略顶层const&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组形参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组的&lt;strong&gt;不允许拷贝&lt;/strong&gt;和使用时数组通常会将其转换成&lt;strong&gt;指针&lt;/strong&gt;的特殊性质对定义和使用在数组上的函数有很大影响。我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;);
&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;[]);
&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;]);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//这里的维度表示我们期望数组含有的元素数量，实际上不一定。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的三个函数是等价的，每个函数的形参都是const int*类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组引用形参&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;C++允许将变量定义为数组的引用，形参也可以是数组的引用。此时，引用形参绑定到对应实参上，也就是绑定到数组上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;arr)[&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;])
{
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;elem&lt;/span&gt; : arr)
		cout &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; elem &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上为数组的引用而不是引用的数组。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;f(int &amp;amp;arr[10])	//将arr声明为了引用的数组
f(int (&amp;amp;arr)[10])	//arr是具有10个整数的整形数组的引用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;传递多维数组&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;多维数组实际上是数组的数组，将多维数组传递给函数实际上传递的是指向数组首元素的指针。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;matrix)[&lt;span style=&#34;color:#099&#34;&gt;10&lt;/span&gt;], &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; rowSize)	{}
&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;main：处理命令行选项&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;argv[])	{...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假定main函数位于可执行文件prog之内，我们可以向程序传递下面的选项：&lt;/p&gt;
&lt;p&gt;prog -d -o ofile data0&lt;/p&gt;
&lt;p&gt;第二个形参argv是一个数组，其元素为&lt;strong&gt;指向c风格字符串的指针&lt;/strong&gt;；第一个形参argc表示&lt;strong&gt;数组中字符串的数量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当实参传递给main函数后，argc的第一个元素指向程序的名字或一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。&lt;/p&gt;
&lt;h3 id=&#34;函数重载&#34;&gt;函数重载&lt;/h3&gt;
&lt;p&gt;同一作用域内的几个函数名字相同但&lt;strong&gt;形参列表不同&lt;/strong&gt;，称之为&lt;strong&gt;重载函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这些函数接收的形参类型不一样，但执行的操作非常类似，调用时；编译器会根据传递的实参类型推断想要的是哪个函数。&lt;/p&gt;
&lt;p&gt;不允许两个函数除了返回类型外其他所有的要素都相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重载和const形参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Record &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;lookup&lt;/span&gt;(Phone);
Record &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;lookup&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; Phone);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//重复声明了Record lookup(Phone);
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果形参是某种类型的指针或引用，则通过区分指向的是&lt;strong&gt;常量对象&lt;/strong&gt;还是&lt;strong&gt;非常量对象&lt;/strong&gt;可以实现函数的重载，此时的const是底层const。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Record &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;lookup&lt;/span&gt;(Account&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//函数作用于Account的引用
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;Record &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;lookup&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; Account&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//新韩淑，作用于常量的引用
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;特殊用途语言特性&#34;&gt;特殊用途语言特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;默认实参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某些函数的一种形参在函数的多次调用中都被赋予了同一个值，此时我们把这个反复出现的值称为函数的默认实参，为了实现函数既能接纳默认值，又能接受我们具体指定的值，我们定义为如下形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;typedef&lt;/span&gt; string&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;size_type sz;
string &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;screen&lt;/span&gt;(sz ht &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;24&lt;/span&gt;, sz wid &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;80&lt;/span&gt;, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;char&lt;/span&gt; background &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。&lt;/p&gt;
&lt;p&gt;在给定作用域中一个形参只能被赋予一次默认实参。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内联函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把一些规模较小的表达式定义为函数有很多好处：容易读懂、容易修改、能重复利用；但也有缺点：调用函数一般比求等价表达式的值要慢；一次函数调用包含一系列工作：先保存寄存器，在返回时恢复；可能需要拷贝实参。&lt;/p&gt;
&lt;p&gt;使用内联函数可以避免函数调用的开销，例如：&lt;/p&gt;
&lt;p&gt;把shorterString函数定义为内联函数，则如下调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; shorterString(s1, s2) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编译过程中会被展开为如下形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; (s1.size() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; s2.size() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;s1&lt;/span&gt; : s2) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从而消除了函数运行时的开销。只需在函数的返回类型前加上&lt;code&gt;inline&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;内联是向编译器发出的一个请求，编译器可以忽略这个请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调试帮助&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;assert预处理宏&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;assert(expr);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;assert是一种预处理宏，使用一个表达式作为它的条件；对expr求值，如果为0，assert输出信息并终止程序运行；如果为1，assert什么也不做。&lt;/p&gt;
&lt;p&gt;assert宏定义在&lt;code&gt;cassert&lt;/code&gt;头文件中，由预处理器管理，无需提供using声明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NDEBUG预处理变量&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;assert的行为依赖于名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行。&lt;/p&gt;
&lt;p&gt;可以使用一个&lt;code&gt;#define&lt;/code&gt;语句定义NDEBUG，从而关闭调试状态。&lt;/p&gt;
&lt;p&gt;除了使用assert之外，可以使用NDEBUG编写自己的条件调试代码，使用&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; ia[], size_t size)
{
&lt;span style=&#34;color:#999;font-weight:bold;font-style:italic&#34;&gt;#ifndef NDEBUG
&lt;/span&gt;&lt;span style=&#34;color:#999;font-weight:bold;font-style:italic&#34;&gt;&lt;/span&gt;	cerr &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __fun__ &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;:array size is: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; size &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;span style=&#34;color:#999;font-weight:bold;font-style:italic&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#999;font-weight:bold;font-style:italic&#34;&gt;&lt;/span&gt;...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;__fun__&lt;/code&gt;为编译器定义的局部静态变量，用于存放函数名字；预处理器还定义了一些有用的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__FILE__&lt;/code&gt;：存放文件名的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINE__&lt;/code&gt;：存放当前行号的整形字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__TIME__&lt;/code&gt;：存放文件编译时间的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__DATA__&lt;/code&gt;：存放文件编译日期的字符串字面值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用这些值在错误消息中提供更多信息。&lt;/p&gt;
&lt;h3 id=&#34;函数指针&#34;&gt;函数指针&lt;/h3&gt;
&lt;p&gt;函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数类型由其返回类型和形参类型共同决定，与函数名无关。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;lengthCompare&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数的类型是&lt;code&gt;bool(const string &amp;amp;, const string &amp;amp;)&lt;/code&gt;，要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;bool&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;pf) (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我们把函数名作为一个值使用时，该函数自动地转换成指针。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;pf &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lengthCompare;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//pf指向名为lengthCompare的函数
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;pf &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;lengthCompare;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//取地址符是可选的
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;将auto和decltype用于函数指针类型&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;decltype以一个表达式为参数，返回表达式表示的类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;string&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;::&lt;/span&gt;size_type sumLength (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;decltype&lt;/span&gt;(sunLength) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;getFcn(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我们将decltype作用域某个函数时，它返回函数类型而非指针类型，因此我们显式地加上*以表明我们需要返回指针而非函数本身。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>机器学习——线性回归和梯度下降</title>
        <link>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</link>
        <pubDate>Fri, 23 Apr 2021 18:10:29 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/ -&lt;h2 id=&#34;线性回归linear-regression&#34;&gt;线性回归Linear Regression&lt;/h2&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;
&lt;p&gt;线性回归属于监督学习，先给定一个训练集根据训练集学习出一个线性函数，然后测试这个函数训练的好不好，挑选出最好的函数（cost function最小）即可。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为是线性回归，所以学习到的函数为线性函数，即一次直线函数；&lt;/li&gt;
&lt;li&gt;因为是单变量，所以只有一个x；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以能够给出&lt;strong&gt;单变量线性回归&lt;/strong&gt;的模型：
$$
h(x)=b+mx
$$
我们称$x$为feature，$h(x)$为hypothesis。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;代价函数cost-function&#34;&gt;代价函数Cost Function&lt;/h3&gt;
&lt;p&gt;我们需要根据代价函数来确定线性回归拟合的好不好。Cost Function越小，说明线性回归地越好，最小为0，完全拟合。
$$
J(b,m)=\frac{1}{2n}(h(x^{(i)})-y^{(i)})^2
$$
如上所示为代价函数的构造，其中，$x^{(i)}$表示向量x的第i个元素，$y^{(i)}$表示向量y的第i个元素，即表示所有输入的训练集的点。$h(x)$表示已知的假设函数，n为训练集的个数。&lt;/p&gt;
&lt;h2 id=&#34;梯度下降&#34;&gt;梯度下降&lt;/h2&gt;
&lt;p&gt;梯度下降能够找出代价函数Cost Function的最小值，梯度下降的方法步骤如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先确定向下一步的步伐大小，我们称为Learning Rate；&lt;/li&gt;
&lt;li&gt;任意给定初始值b, m；&lt;/li&gt;
&lt;li&gt;确定一个向下的方向，按预定步骤向下走，并且更新b, m；&lt;/li&gt;
&lt;li&gt;当下降高度(循环次数)小于某个定义的值时，停止下降。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;循环下面的式子直到满足终止条件：
$$
b = b - \alpha\frac{\partial}{\partial b}J(b,m) \
m = m - \alpha\frac{\partial}{\partial m}J(b,m)
$$
上式中的$\alpha$为Learning rate，决定了下降的步伐大小；偏导数决定了下降的方向。&lt;/p&gt;
&lt;h3 id=&#34;对cost-function运用梯度下降&#34;&gt;对Cost Function运用梯度下降&lt;/h3&gt;
&lt;p&gt;$$
\mathrm{repeat \ until \ convergence}{ \
b:=b-\alpha \frac{1}{n}\sum_{i=1}^{n}(h(x^{(i)})-y^{(i)}) \
m:=m-\alpha \frac{1}{n}\sum_{i=1}^{n}(h(x^{(i)})-y^{(i)})x^{(i)} \
\ }
$$&lt;/p&gt;
&lt;p&gt;设定好初始值、循环次数、Learning Rate后即可开始拟合，最终得到结果b,m；得到拟合的线性函数。&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;h3 id=&#34;使用sklearn库中的make_regression函数生成训练数据&#34;&gt;使用&lt;code&gt;sklearn&lt;/code&gt;库中的&lt;code&gt;make_regression&lt;/code&gt;函数生成训练数据&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#generate the train data&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;geneData&lt;/span&gt;():
    points &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; []
    xSet, ySet &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; make_regression(n_samples&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;100&lt;/span&gt;, n_features&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, n_targets&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, noise&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;20&lt;/span&gt;)
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; x,y &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;zip&lt;/span&gt;(xSet,ySet):
        x&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;x[&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;]
        point &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; [x,y]
        points&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;append(point)
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; points
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;定义代价函数&#34;&gt;定义代价函数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;costFunction&lt;/span&gt;(b, m, points):
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; point &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; points:
        ErrorTotal &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+=&lt;/span&gt; ((b &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; m&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;point[&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; point[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; ErrorTotal &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;float&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;len&lt;/span&gt;(points)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;定义梯度下降函数&#34;&gt;定义梯度下降函数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;stepGradient&lt;/span&gt;(b_current, m_current, b_gradient, m_gradient, points, learningRate):
    N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;float&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;len&lt;/span&gt;(points))
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; point &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; points:
        x &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; point[&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;]
        y &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; point[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;]
        b_gradient &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+=&lt;/span&gt; (&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;N) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; ((b_current &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; m_current &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; x) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; y)
        m_gradient &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+=&lt;/span&gt; (&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;N) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; x &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; ((b_current &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; m_current &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; x) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; y)
    new_b &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; b_current &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; (learningRate &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; b_gradient)
    new_m &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; m_current &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; (learningRate &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; m_gradient)
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; [new_b, new_m, b_gradient, m_gradient]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;设置初始化参数并循环迭代最后画出结果&#34;&gt;设置初始化参数并循环迭代，最后画出结果&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    iterations &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;100&lt;/span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#迭代次数&lt;/span&gt;
    learningRate &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0.0001&lt;/span&gt;   &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#学习率，决定了下降的步伐大小&lt;/span&gt;
    points &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; geneData() &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#生成训练集&lt;/span&gt;
    b &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;   &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#线性方程参数b,m的初始值&lt;/span&gt;
    m &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;   
    b_gradient &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#代价函数梯度下降结果的初始值&lt;/span&gt;
    m_gradient &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#0086b3&#34;&gt;list&lt;/span&gt;(&lt;span style=&#34;color:#0086b3&#34;&gt;range&lt;/span&gt;(&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, iterations&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;)):  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#循环进行梯度下降，求得结果&lt;/span&gt;
        b,m,b_gradient,m_gradient &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; stepGradient(b,m,b_gradient,m_gradient,points,learningRate)

    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; point &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; points:    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#画出样本点&lt;/span&gt;
        plt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;scatter(point[&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;], point[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;])

    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#画出得到的直线&lt;/span&gt;
    t &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;arange(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#099&#34;&gt;0.01&lt;/span&gt;)
    s &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; b &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; m &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; t
    plt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;scatter(t,s,linewidths&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;0.5&lt;/span&gt;)
    plt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;show()

    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#输出结果&lt;/span&gt;
    &lt;span style=&#34;color:#0086b3&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;b=&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;%&lt;/span&gt;b)
    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;#print(b)&lt;/span&gt;
    &lt;span style=&#34;color:#0086b3&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;m=&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;%&lt;/span&gt;m)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结果展示&#34;&gt;结果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/Gradient_figure1.png&#34; alt=&#34;Gradient_figure1&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;b&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;4.824787&lt;/span&gt;
m&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;46.528725&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;哲学思考&#34;&gt;哲学思考&lt;/h2&gt;
&lt;p&gt;梯度下降是一个一阶最优化算法，通常也称为最陡下降法，要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度的反方向规定的步长距离点进行迭代搜索。&lt;/p&gt;
- https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>串行通信协议详解：SPI、I2C、UART、JTAG</title>
        <link>https://eternityqjl.top/posts/%E4%B8%B2%E5%8F%A3/</link>
        <pubDate>Fri, 05 Feb 2021 18:20:54 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E4%B8%B2%E5%8F%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E4%B8%B2%E5%8F%A3/ -&lt;p&gt;SPI、I2C、UART：串行通信协议&lt;/p&gt;
&lt;p&gt;COM口：串行通信端口，是物理接口形式（硬件），一般有4针杜邦头和D型9针插头两种。可以有很多种协议&lt;/p&gt;
&lt;p&gt;TTL、RS-232指的是电平标准&lt;/p&gt;
&lt;p&gt;TTL电平：低电平为0，高电平为1&lt;/p&gt;
&lt;p&gt;RS-232电平：正电平(+15V)为0，负电平(-15V)为1&lt;/p&gt;
&lt;p&gt;最近在画PCB研究几个MCU的时候遇到引脚连接方面的一些问题，对于MCU进行串行通信传输数据的过程不太了解，因此写一篇博客来学习一下这些通信协议。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;一些概念&#34;&gt;一些概念&lt;/h2&gt;
&lt;h3 id=&#34;同步synchronous和异步asynchronous&#34;&gt;同步(Synchronous)和异步(Asynchronous)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;就是整个处理过程顺序执行，当各个过程都执行完毕后，返回结果。这是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;：是只发送了调用的命令，调用者无需等待被调用的方法完全执行完毕，可以继续执行下面的流程，是一种并行处理的方式。比如页面数据架子啊的过程，不需要等待所有数据获取后再显示页面。&lt;/p&gt;
&lt;p&gt;二者的区别就在于同步需要等待，异步不需要等待。&lt;/p&gt;
&lt;h3 id=&#34;全双工和半双工&#34;&gt;全双工和半双工&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;全双工&lt;/strong&gt;是指可以&lt;strong&gt;同时&lt;/strong&gt;进行&lt;strong&gt;双向信号&lt;/strong&gt;传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;半双工&lt;/strong&gt;是指可以及进行&lt;strong&gt;双向信号传输&lt;/strong&gt;但&lt;strong&gt;同一时刻只能向一个&lt;/strong&gt;方向传输。&lt;/p&gt;
&lt;h2 id=&#34;spi协议&#34;&gt;SPI协议&lt;/h2&gt;
&lt;p&gt;串行外设接口总线（Serial Peripheral Interface Bus，SPI）是一种用于芯片通信的&lt;strong&gt;同步&lt;/strong&gt;串行通信接口规范，设备之间使用&lt;strong&gt;全双工&lt;/strong&gt;模式通信，采用一对一或一对多的主从模式。一般用于短距离通信。&lt;/p&gt;
&lt;h3 id=&#34;spi物理层接口&#34;&gt;SPI物理层接口&lt;/h3&gt;
&lt;p&gt;SPI总线共规定了4个逻辑信号接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCLK/SCK（Serial Clock）：&lt;strong&gt;时钟&lt;/strong&gt;信号线，由主机产生，决定了SPI的通信速率。&lt;/li&gt;
&lt;li&gt;MOSI（Master Output, Slave Input）：&lt;strong&gt;主机输出从机输入&lt;/strong&gt;信号，数据由&lt;strong&gt;主机&lt;/strong&gt;发出。&lt;/li&gt;
&lt;li&gt;MISO（Master Input, Slave Output）：&lt;strong&gt;从机输出主机输入&lt;/strong&gt;信号，数据由&lt;strong&gt;从机&lt;/strong&gt;发出。&lt;/li&gt;
&lt;li&gt;nSS（Slave Select）：&lt;strong&gt;片选&lt;/strong&gt;信号：用于选取SPI从设备，每个从设备独立拥有该条nSS信号线，占据主机的一个引脚，从设备的其他总线是并联到主机的。从设备的nSS引脚被置拉低时表明该从设备被主机选中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SPI_%E4%B8%80%E5%AF%B9%E4%B8%80.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SPI_%E4%B8%80%E5%AF%B9%E5%A4%9A.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（图片来自维基百科&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%91%A8%E9%82%8A%E4%BB%8B%E9%9D%A2&#34;&gt;序列周边接口&lt;/a&gt;）&lt;/p&gt;
&lt;h3 id=&#34;spi协议层&#34;&gt;SPI协议层&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SPI_photo_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（图片来自&lt;a href=&#34;https://blog.csdn.net/qq_29344757/article/details/76855350&#34;&gt;SPI通讯协议介绍&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;如图为SPI的通信时序图，nSS、SCK、MOSI信号均由主机产生，MISO信号由从机产生。当nSS为低电平时信号有效。每个时钟周期MOSI和MISO传输一位数据。偶数边采样。&lt;/p&gt;
&lt;h4 id=&#34;通信起始结束信号&#34;&gt;通信起始/结束信号&lt;/h4&gt;
&lt;p&gt;nSS信号由高电平变为低电平即为通信的起始，由低电平变为高电平即为通信的结束。&lt;/p&gt;
&lt;h4 id=&#34;有效数据的采集&#34;&gt;有效数据的采集&lt;/h4&gt;
&lt;p&gt;上图中SCK为偶数边沿时数据得到有效采样，此时MISO和MOSI的数据有效，高电平表示1，低电平表示0，其他时刻的数据无效。&lt;/p&gt;
&lt;p&gt;数据传输时高位在先还是低位在先SPI协议并未规定，需要双方自行约定，一般采用高位在先（MSB）方式传输。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时钟极性（CPOL）：通信设备处于空闲状态（SPI开始通信前，即nSS无效）时，SCK的状态。
&lt;ul&gt;
&lt;li&gt;CPOL = 0：SCK在空闲时为低电平&lt;/li&gt;
&lt;li&gt;CPOL = 1：SCK在空闲时为高电平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟相位（CPHA）：数据的采样时刻位于SCK的偶数边还是奇数边。
&lt;ul&gt;
&lt;li&gt;CPHA = 0：在SCK的奇数边沿采样&lt;/li&gt;
&lt;li&gt;CPHA = 1：在SCK的偶数边沿采样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，数据的采样时刻并非由上升沿/下降沿所决定；在采样时刻，MOSI和MISO信号不能进行高低电平的变换。&lt;/p&gt;
&lt;p&gt;所以，SPI有如下4种工作模式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;工作模式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CPOL&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CPHA&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;空闲时的SCK时钟&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;采样时钟&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否常用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;奇数次边沿&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;偶数次边沿&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;奇数次边沿&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;偶数次边沿&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;mathrmi2mathrmc协议&#34;&gt;$\mathrm{I}^2\mathrm{C}$协议&lt;/h2&gt;
&lt;p&gt;$\mathrm{I}^2\mathrm{C}$（Inter-Integrated Circuit）集成电路总线，是飞利浦设计的一种简单的双向两线&lt;strong&gt;同步串行&lt;/strong&gt;总线，为全双工，是为了实现有效的IC之间的控制；是一种串行通信总线，为了让嵌入式设备连接低速设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/I2C_trans.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/1024px-I2C.svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;$\mathrm{I}^2\mathrm{C}$只需要两个接口即可通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SDA（Serial Data）&lt;/strong&gt;：串行数据接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SCL（Serial Clock）&lt;/strong&gt;：串行时钟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDA和SCL都是双向线路，都通过一个电流源或上拉电阻接到正的电源电压，总线&lt;strong&gt;空闲&lt;/strong&gt;时，这两条线路都是&lt;strong&gt;高电平&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;$\mathrm{I}^2\mathrm{C}$总线支持任何IC生产过程。两线在连接到总线的器件间传递信息。每个器件都有一个唯一的地址识别，而且都可以作为一个发送器或接收器。&lt;/p&gt;
&lt;p&gt;$\mathrm{I}^2\mathrm{C}$总线是一个&lt;strong&gt;多主机&lt;/strong&gt;的总线，即可以连接多于一个能控制总线的器件到总线。如果两个或多个主机同时尝试初始化传输数据，为了避免产生混乱，发展出了一个&lt;strong&gt;仲裁&lt;/strong&gt;的过程。&lt;/p&gt;
&lt;p&gt;$\mathrm{I}^2\mathrm{C}$的参考设计使用了一个7比特长度的地址空间，但是保留了16个地址，所以一组总线最多可以和112个节点通信。但连接到总线的接口数量其实是由总线电容是400pF的限制决定的（这里不深入了解）。&lt;/p&gt;
&lt;p&gt;$\mathrm{I}^2\mathrm{C}$有几种常见的传输模式，标准模式（100kbps）、低速模式（10kbps），时钟频率可以被降为0，即可以暂停通信。&lt;/p&gt;
&lt;h2 id=&#34;uart串口&#34;&gt;UART串口&lt;/h2&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;
&lt;p&gt;通用&lt;strong&gt;异步&lt;/strong&gt;收发传输器（异步串行通信口）（Universal Asynchronous Receiver/Transmitter），是一种&lt;strong&gt;串行、异步、全双工&lt;/strong&gt;的通信协议。他的工作原理是把数据的字节按照比特顺序发送，另一端的UART把比特组装为字节。&lt;/p&gt;
&lt;p&gt;串行通信是指利用一条传输线将数据一位位地顺序传送，也可以用两个信号线组成全双工通信，如rs232。特点是通信线路简单，利用简单的线缆就可实现通信，降低成本，适用于远距离通信，但传输速度慢的应用场合。&lt;/p&gt;
&lt;h3 id=&#34;数据帧&#34;&gt;数据帧&lt;/h3&gt;
&lt;p&gt;每个字符表示为一个帧(10bit)，异步通信以一个字符为传输单位；两个UART设备之间通信不需要时钟线，需要在两个UART设备上指定相同的传输速率(&lt;strong&gt;波特率，bps&lt;/strong&gt;)，以及&lt;strong&gt;空闲位、起始位、校验位、结束位&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空闲位(1bit)：高电平，指没有数据传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;起始位(1bit)：低电平。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据位(8bit or 7bit)：一般先传输最低位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（可选）奇偶校验位(1bit)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;无校验&lt;/li&gt;
&lt;li&gt;奇校验：如果数据位中1的数目是偶数，则校验位为1；如果1的数目是奇数，则校验位为0&lt;/li&gt;
&lt;li&gt;偶校验：如果数据位中1的数目是偶数，则校验位为0；如果1的数目是奇数，则校验位为1&lt;/li&gt;
&lt;li&gt;mark parity / parity：校验位时钟为1/0。（不常用）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束位(1bit)：高电平。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jtag边界扫描&#34;&gt;JTAG边界扫描&lt;/h2&gt;
&lt;p&gt;JTAG主要用于验证设计和测试印刷电路板。&lt;/p&gt;
&lt;h3 id=&#34;电气特性&#34;&gt;电气特性&lt;/h3&gt;
&lt;p&gt;JTAG的接口是将4/5个接口连接到芯片上，电路板上的很多芯片可以将其JTAG接口通过Daisy Chain（菊花链）的方式连在一起，这样我们就可以访问一块印刷电路板上的所有芯片。&lt;/p&gt;
&lt;p&gt;连接引脚为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDI（Test Data Input）：测试数据输入&lt;/li&gt;
&lt;li&gt;TDO（Test Data Output）：测试数据输出&lt;/li&gt;
&lt;li&gt;TCK（Test Clock Input）：测试时钟&lt;/li&gt;
&lt;li&gt;TMS（Test Model Selection）：测试模式选择&lt;/li&gt;
&lt;li&gt;TRST（测试复位）可选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/Jtag_chain.svg.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（图片来自维基百科&lt;a href=&#34;https://zh.wikipedia.org/wiki/JTAG&#34;&gt;JTAG&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;由于只有一条数据线，所以通信使用的协议应为串行传输；时钟从TCK引脚引入；配置通过TMS引脚采用状态机的方式一次操作一位来实现；TRST引脚是可选的相对待测逻辑低电平有效复位开关，通常为异步，有时也为同步。&lt;/p&gt;
- https://eternityqjl.top/posts/%E4%B8%B2%E5%8F%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>《算法（第4版）》学习笔记——（一）排序</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 23 Jul 2020 14:59:12 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/ -&lt;h2 id=&#34;初级排序算法&#34;&gt;初级排序算法&lt;/h2&gt;
&lt;h3 id=&#34;选择排序&#34;&gt;选择排序&lt;/h3&gt;
&lt;h4 id=&#34;算法描述&#34;&gt;算法描述&lt;/h4&gt;
&lt;p&gt;首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。&lt;/p&gt;
&lt;h4 id=&#34;代码实现&#34;&gt;代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Selection&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//将a按照升序排列
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; min &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++)&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;min&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]))&lt;/span&gt;
                    min &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;min&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;性能分析&#34;&gt;性能分析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。&lt;/li&gt;
&lt;li&gt;该算法运行时间与输入无关，数据的移动是最少的。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;插入排序&#34;&gt;插入排序&lt;/h3&gt;
&lt;h4 id=&#34;算法描述-1&#34;&gt;算法描述&lt;/h4&gt;
&lt;p&gt;插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。&lt;/p&gt;
&lt;h4 id=&#34;代码实现-1&#34;&gt;代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Insertion&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//将相邻两个元素向左依次交换最终使得索引左侧的元素全部向右移动一位
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; 0 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]);&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;--)&lt;/span&gt;
                exch &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;性能分析-1&#34;&gt;性能分析&lt;/h4&gt;
&lt;p&gt;对随机排列长度为$N$且主键不重复的数组，平均插入排序需要$N^2/4$次比较和$N^2/4$次交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分有序数组&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组中每个元素距离它的最终位置都不远&lt;/li&gt;
&lt;li&gt;一个有序大数组接一个小数组&lt;/li&gt;
&lt;li&gt;数组中只有几个元素的位置不正确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插入排序对这样的部分有序数组非常有效。&lt;/p&gt;
&lt;h3 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h3&gt;
&lt;h4 id=&#34;算法描述-2&#34;&gt;算法描述&lt;/h4&gt;
&lt;p&gt;交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序数组排序。&lt;/p&gt;
&lt;p&gt;希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组被称为&lt;strong&gt;h有序数组&lt;/strong&gt;，即h个相互独立的有序数组编织在一起组成的一个数组&lt;/p&gt;
&lt;h4 id=&#34;代码实现-2&#34;&gt;代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Shell&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;srot&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt; 3&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;   h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 3 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++)&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; h&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]);&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-=&lt;/span&gt; h&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
                    exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; h&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; h &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt; 3&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该希尔算法使用了序列$1/2(3^k-1)$，即序列${ 1,4,13 }$，称为&lt;strong&gt;增量序列&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;性能分析-2&#34;&gt;性能分析&lt;/h4&gt;
&lt;p&gt;希尔排序权衡了子数组的规模和有序性，希尔排序比插入排序和选择排序快得多，并且数组越大优势越大。&lt;/p&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;归并&lt;/strong&gt;即将两个有序的数组归并成一个更大的有序数组。&lt;/p&gt;
&lt;h3 id=&#34;原地归并&#34;&gt;原地归并&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;merge&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; mid&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++)&lt;/span&gt;
            aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;

        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; mid&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;                      a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++];&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;                  a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++];&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]))&lt;/span&gt;    a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++];&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt;                              a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++];&lt;/span&gt;     
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;自顶向下的归并排序&#34;&gt;自顶向下的归并排序&lt;/h3&gt;
&lt;h4 id=&#34;算法描述-3&#34;&gt;算法描述&lt;/h4&gt;
&lt;p&gt;对子数组a[lo..hi]进行排序，先将其分为$\mathrm{a}[\mathrm{lo..mid}]$和$\mathrm{a[mid+1..hi]}$两部分，分别通过递归调用将其单独排序，最后将有序的子数组归并为最终的排序结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Merge&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        aux &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;new&lt;/span&gt; Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
        sort&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;hi &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;   &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;hi &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt; 2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        sort &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; mid&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        sort &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; mid &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        merge&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; mid&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;性能分析-3&#34;&gt;性能分析&lt;/h4&gt;
&lt;p&gt;对于长度为$N$的任意数组，自顶向下的归并排序需要$1/2N\lg N$至$N\lg N$次比较，最多需要访问数组$6N\lg N$次。&lt;/p&gt;
&lt;p&gt;所以可知道归并排序所需要的时间与$N\lg N$成正比，主要缺点是辅助数组所使用的额外空间和N的大小成正比。&lt;/p&gt;
&lt;h3 id=&#34;自底向上的归并排序&#34;&gt;自底向上的归并排序&lt;/h3&gt;
&lt;h4 id=&#34;算法描述-4&#34;&gt;算法描述&lt;/h4&gt;
&lt;p&gt;先归并那些微型数组，然后再成对地归并得到的子数组。首先进行两两归并（把每个元素当作一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并为一个有4个元素的数组），然后是八八归并，以此类推。&lt;/p&gt;
&lt;h4 id=&#34;代码实现-3&#34;&gt;代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;MergeBU&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; aux&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        aux &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;new&lt;/span&gt; Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; sz&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; sz&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+=&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; sz&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        		merge&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; Math&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;min&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; sz &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;));&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;性能分析-4&#34;&gt;性能分析&lt;/h4&gt;
&lt;p&gt;对于长度为$N$的任意数组，自底向上的归并排序需要$1/2N\lg N$至$N\lg N$次比较，最多访问数组$6N\lg N$次。&lt;/p&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;h3 id=&#34;快速排序的切分&#34;&gt;快速排序的切分&lt;/h3&gt;
&lt;p&gt;根据切分点&lt;code&gt;j&lt;/code&gt;对数组进行切分，切分后的数组满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a[lo]&lt;/code&gt;到&lt;code&gt;a[j-1]&lt;/code&gt;中的所有元素都不大于&lt;code&gt;a[j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[j+1]&lt;/code&gt;到&lt;code&gt;a[hi]&lt;/code&gt;中的所有元素都不小于&lt;code&gt;a[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//切分
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;partition&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; hi &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    Comparable v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[++&lt;/span&gt;i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt; v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[--&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]))&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基本快速排序算法&#34;&gt;基本快速排序算法&lt;/h3&gt;
&lt;h4 id=&#34;算法描述-5&#34;&gt;算法描述&lt;/h4&gt;
&lt;p&gt;通过递归地调用切分来进行排序。&lt;/p&gt;
&lt;h4 id=&#34;代码实现-4&#34;&gt;代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Quick&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        StdRandom&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;shuffle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//将输入乱序，消除堆输入的依赖
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;        sort&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;hi &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;   &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; partition&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        sort&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        sort&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;性能分析-5&#34;&gt;性能分析&lt;/h4&gt;
&lt;p&gt;将长度为$N$的无重复数组排序，快速排序平均需要$2N\lg N$次比较，即$1/6N\lg N$次交换。&lt;/p&gt;
&lt;h3 id=&#34;三向切分快速排序&#34;&gt;三向切分快速排序&lt;/h3&gt;
&lt;p&gt;在含有大量重复元素时使用该方法。将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。&lt;/p&gt;
&lt;h4 id=&#34;代码实现-5&#34;&gt;代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Quick3way&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;hi &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; lt &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; lo &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; gt &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        Comparable v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;i &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; gt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; cmp &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;].&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;compareTo&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;cmp &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;	exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++,&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++);&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;cmp &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;	exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; gt&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;--);&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; i&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
        sort&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lo&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; lt &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        sort&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; gt &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; hi&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;优先队列&#34;&gt;优先队列&lt;/h2&gt;
&lt;p&gt;优先队列这种&lt;em&gt;数据结构&lt;/em&gt;应支持两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除最大元素&lt;/li&gt;
&lt;li&gt;插入元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初级实现有序数组无序数组链表&#34;&gt;初级实现：有序数组、无序数组、链表&lt;/h3&gt;
&lt;p&gt;这些初级实现中，插入元素和删除最大元素的操作在最坏的情况下需要&lt;strong&gt;线性时间&lt;/strong&gt;来完成，无法满足我们的性能要求。接下来使用&lt;strong&gt;堆&lt;/strong&gt;来实现使这两种操作能更快地执行。&lt;/p&gt;
&lt;h3 id=&#34;基于堆的优先队列&#34;&gt;基于堆的优先队列&lt;/h3&gt;
&lt;h4 id=&#34;堆的定义&#34;&gt;堆的定义&lt;/h4&gt;
&lt;p&gt;数据结构&lt;strong&gt;二叉堆&lt;/strong&gt;满足：每个元素大于等于两个特定位置的元素，这些位置的元素又要大于等于数组中的另外两个元素，这样的数据结构可以通过有序的完全二叉树来表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E6%9C%89%E5%BA%8F%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在一个堆中，位置$k$的节点的父节点的位置为$k/2$，而它的两个子节点的位置为$2k$和$2k+1$。&lt;/p&gt;
&lt;p&gt;我们可以通过计算数组的索引在树中上下移动：从$a[k]$向上一层就令$k=k/2$，向下一层则令$k=2k/2k+1$。&lt;/p&gt;
&lt;h4 id=&#34;堆的算法&#34;&gt;堆的算法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;由下至上的堆有序化（上浮swim）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;swim&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; 1 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;由上至下的堆有序化（下沉sink）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sink&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt;1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;	j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++;&lt;/span&gt;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//选择父节点的两个子节点中较大的作为交换对象
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(!&lt;/span&gt;less&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; j&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//将交换后子节点的位置作为父节点，循环进行下一次交换,继续下沉
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;基于堆的优先队列的代码实现&#34;&gt;基于堆的优先队列的代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;MaxPQ&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;Key &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;extends&lt;/span&gt; Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;key&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; Key&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; pq&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;MaxPQ&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; maxN&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        pq &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Key&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[])&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;new&lt;/span&gt; Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;maxN &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; 0&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;insert&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Key v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//在数组的末尾输入，然后进行上浮swim操作
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        pq&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[++&lt;/span&gt;N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        swim&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;};&lt;/span&gt;
    
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; Key &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;delMax&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        Key max &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; pq&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
        exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;--);&lt;/span&gt;
        pq&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
        sink&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; max&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;基于堆的优先队列性能分析&#34;&gt;基于堆的优先队列性能分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;堆排序&#34;&gt;堆排序&lt;/h3&gt;
&lt;h4 id=&#34;堆的构造&#34;&gt;堆的构造&lt;/h4&gt;
&lt;p&gt;高效的构造堆的方法是从右向左用&lt;code&gt;sink()&lt;/code&gt;函数构造子堆。数组的每个位置都是一个子堆的根结点，如果一个结点的两个子结点都已经是堆了，那么在该结点上调用&lt;code&gt;sink()&lt;/code&gt;可以将它们变成一个堆。我们只需要扫描一半的元素，因为可以跳过大小为1的子堆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E5%A0%86%E7%9A%84%E6%9E%84%E9%80%A0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;下沉排序&#34;&gt;下沉排序&lt;/h4&gt;
&lt;p&gt;将堆中的最大元素删去，然后将其放入堆缩小后数组中空出的位置。&lt;/p&gt;
&lt;h4 id=&#34;堆排序代码实现&#34;&gt;堆排序代码实现&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;sort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Comparable&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt;2&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; k &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;--)&lt;/span&gt;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//构造堆
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;        sink&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; k&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;N &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        exch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;--);&lt;/span&gt;	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//堆排序，按递减顺序循环取出所有的最大值，最后得到排序结果。
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;        sink&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; N&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;堆排序性能分析&#34;&gt;堆排序性能分析&lt;/h4&gt;
&lt;p&gt;将$N$个元素排序，堆排序只需要少于$(2N\lg N+2N)$次比较以及一半的交换次数。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Dijkstra双栈——算术表达式求值</title>
        <link>https://eternityqjl.top/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
        <pubDate>Tue, 21 Jul 2020 20:15:08 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/ -&lt;h2 id=&#34;算数表达式&#34;&gt;算数表达式&lt;/h2&gt;
&lt;p&gt;这里的算术表达式支持常见的二元运算符&lt;code&gt;+-*/&lt;/code&gt;以及接受一个参数的平方根运算符&lt;code&gt;sqrt&lt;/code&gt;。这里我们假定表达式中未省略所有的括号。&lt;/p&gt;
&lt;h2 id=&#34;计算方法&#34;&gt;计算方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将操作数压入&lt;strong&gt;操作数栈&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将运算符压入&lt;strong&gt;运算符栈&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;忽略左括号&lt;/li&gt;
&lt;li&gt;遇到右括号时，弹出一个运算符，弹出需要数量的操作数进行运算，然后将得到的结果再压入操作数栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;edu.princeton.cs.algs4&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Evaluate&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
		Stack&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; ops &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;new&lt;/span&gt; Stack&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;();&lt;/span&gt;
		Stack&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;Double&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; vals &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;new&lt;/span&gt; Stack&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;Double&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;();&lt;/span&gt;
		&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(!&lt;/span&gt;StdIn&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt;
		&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
			&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//读取字符，如果是运算符则压入运算符栈ops
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;			String s &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; StdIn&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;readString&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;));&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    ops&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    ops&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    ops&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    ops&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;sqrt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    ops&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
			
			&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//如果字符为)，则弹出运算符和操作数，计算结果并压入操作数栈vals
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
				String op &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; ops&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
				&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;double&lt;/span&gt; v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
				&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;op&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
				&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;op&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
				&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;op&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt; v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
				&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;op&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;/&lt;/span&gt; v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
				&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;op&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;sqrt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    v &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;sqrt&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
				
				vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;v&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
			&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//如果字符既非运算符又非括号，将其作为double值压入操作数栈vals
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;push&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;Double&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;parseDouble&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;));&lt;/span&gt;
		&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
		StdOut&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;vals&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#008080&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;());&lt;/span&gt;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>计算机网络学习日志（二）——运输层</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
        <pubDate>Wed, 06 May 2020 21:27:10 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/ -&lt;h2 id=&#34;概述和运输层服务&#34;&gt;概述和运输层服务&lt;/h2&gt;
&lt;p&gt;运输层协议在不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;，这并非物理上的实际通信。在发送端，运输层将从应用程序接收到的报文转换成运输层分组，该分组称为&lt;strong&gt;运输层报文段&lt;/strong&gt;，实现方法是将应用报文划分为一个个小的块，为每个块加上运输层首部生成运输层报文段，然后在端系统中传递给网络层，网络层将其封装成网络层分组，向目的地发送。&lt;/p&gt;
&lt;p&gt;因特网由TCP和UDP两种运输层协议。&lt;/p&gt;
&lt;h3 id=&#34;运输层和网络层的关系&#34;&gt;运输层和网络层的关系&lt;/h3&gt;
&lt;p&gt;网络层提供了&lt;strong&gt;主机&lt;/strong&gt;之间的逻辑通信，而运输层为运行在不同主机上的&lt;strong&gt;进程&lt;/strong&gt;之间提供了逻辑通信。&lt;/p&gt;
&lt;p&gt;运输层协议至工作在端系统中，同时网络中的路由器既不处理也不识别运输层加在应用层报文的任何信息。运输层协议能提供的服务常常受制于底层网络层协议，例如，如果网络层协议无法为主机之间发送的运输层报文段提供时延和带宽保证，运输层协议可就无法为&lt;strong&gt;进程之间&lt;/strong&gt;发送的应用程序报文提供时延和带宽保证。&lt;/p&gt;
&lt;h3 id=&#34;运输层概述&#34;&gt;运输层概述&lt;/h3&gt;
&lt;p&gt;首先定义两个名词的意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报文段：运输层分组，即TCP和UDP的分组&lt;/li&gt;
&lt;li&gt;数据报：网络层分组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层的IP被称为不可靠服务。&lt;/p&gt;
&lt;h2 id=&#34;多路复用与多路分解&#34;&gt;多路复用与多路分解&lt;/h2&gt;
&lt;p&gt;在目的主机中，运输层从紧邻其下的网络层接受报文段，并将这些报文段中的数据交付给在主机上运行的对应应用程序进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多路分解&lt;/strong&gt;是指将运输层报文中的数据正确交付给正确的&lt;strong&gt;套接字&lt;/strong&gt;的工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多路复用&lt;/strong&gt;是指在源主机中从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层。&lt;/p&gt;
&lt;p&gt;运输层多路复用的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;套接字有唯一标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个报文段有特殊字段来指示该报文段所要交付到的套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊字段：源端口号字段、目的端口号字段&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;0~1023范围的端口称为&lt;em&gt;周知端口号&lt;/em&gt;，是受限的，它们分配给周知应用层协议来使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;无连接运输udp&#34;&gt;无连接运输：UDP&lt;/h2&gt;
&lt;p&gt;UDP从应用程序得到数据，附加上用于多路复用/分解服务和目的地端口字段号，以及两个其他字段，然后将形成的报文交给网络层，网络层将运输层报文封装到一个一个IP数据报中，然后尽力交付给目的主机。&lt;/p&gt;
&lt;p&gt;UDP被称为&lt;strong&gt;无连接&lt;/strong&gt;运输是因为在发送报文段之前，发送方和接收方的运输层实体之间没有握手。&lt;/p&gt;
&lt;p&gt;一些应用相比于TCP更适合于使用UDP的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于发送什么数据以及何时发送的&lt;strong&gt;应用层控制&lt;/strong&gt;更为精细&lt;/li&gt;
&lt;li&gt;无需建立连接，开始传输数据前不需要握手&lt;/li&gt;
&lt;li&gt;无连接状态。TCP中要实现可靠数据传输服务并提供拥塞控制，状态信息是必须的。&lt;/li&gt;
&lt;li&gt;分组首部占用空间小。每个TCP报文段有20个字节的首部开销，UDP仅有8个字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp报文段结构&#34;&gt;UDP报文段结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/UDP.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;udp检验和&#34;&gt;UDP检验和&lt;/h3&gt;
&lt;p&gt;检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生变化。&lt;/p&gt;
&lt;p&gt;提供差错检验的原因是不能保证源和目的之间的所有链路都提供了差错检测。&lt;/p&gt;
&lt;p&gt;虽然UDP提供了差错检验，但是它对于差错恢复无能为力，它只是丢弃受损的报文段。&lt;/p&gt;
&lt;h2 id=&#34;可靠数据传输原理&#34;&gt;可靠数据传输原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可靠数据传输协议&lt;/strong&gt;是用来实现一种服务的抽象：数据可以通过一条可靠的信道进行传输。可靠传输协议的下层也许是不可靠的，如TCP是在不可靠的端到端网络层(IP)之上实现的可靠数据传输协议。我们目前可将较低层直接视为不可靠的点对点信道。&lt;/p&gt;
&lt;h3 id=&#34;构造可靠数据传输协议&#34;&gt;构造可靠数据传输协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;rdt1.0：经完全可靠信道的可靠数据传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时的底层信道完全可靠，接收端不需要提供任何反馈信息给发送方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/rdt1.svg&#34; alt=&#34;rdt1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有限状态机(Finite-State Machine, FSM)&lt;/strong&gt;：表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
&lt;ul&gt;
&lt;li&gt;FSM描述图中箭头指示了协议从一个状态便签到另一个状态&lt;/li&gt;
&lt;li&gt;横线上方：引起变迁的事件&lt;/li&gt;
&lt;li&gt;横线下方：事件发生时所采取的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送方和接收方有各自的FSM&lt;/p&gt;
&lt;p&gt;rdt1.0的发送端通过&lt;code&gt;rdt_send(data)&lt;/code&gt;事件接受来自叫高层的数据，产生一个包含该数据的分组(由&lt;code&gt;make_pkt(data)&lt;/code&gt;动作产生)，并将分组发送到信道中。&lt;/p&gt;
&lt;p&gt;接收端通过&lt;code&gt;rdt_rcv(packet)&lt;/code&gt;从底层信道接受一个分组，从分组中取出数据(由&lt;code&gt;extract(packet, data)&lt;/code&gt;动作完成)，并将数据上传给叫高层(通过&lt;code&gt;deliver_data(data)&lt;/code&gt;完成)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rdt2.0：经具有比特差错信道的可靠数据传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;底层信道更为实际的模型是可能受损的模型，这样的比特差错通常出现在网络的物理部件中，&lt;strong&gt;自动重传请求协议(Automatic Repeat reQueat, ARQ)&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;肯定确认&lt;/strong&gt;与&lt;strong&gt;否定确认&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;差错检测：第五章会详细说明具体机制&lt;/li&gt;
&lt;li&gt;接收方反馈：接收方向发送方回送**ACK(肯定确认)&lt;strong&gt;或是&lt;/strong&gt;NAK(否定确认)**分组，理论上只需要1比特。&lt;/li&gt;
&lt;li&gt;重传：接收方接收到有差错分组，发送方将重传该分组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/rdt2.svg&#34; alt=&#34;rdt2&#34;&gt;&lt;/p&gt;
&lt;p&gt;rdt2.0的发送端由两个状态，左边的状态中，发送端协议正在等待来自上层传递的数据，当事件&lt;code&gt;rdt_send(data)&lt;/code&gt;出现时，发送方将产生一个带有检验和的分组(sndpkt)，然后发送该分组。右边的状态中，发送方协议等待来自接收方的ACK或NAK分组。如果收到ACK分组，则知道已经正确发送，协议返回到右侧的等待上层数据的状态；如果收到NAK分组，则协议重新上传一个分组并继续等待会送的ACK或NAK。&lt;/p&gt;
&lt;p&gt;当发送方处于右侧的等待状态时，不能从上层获得更多的数据，只有收到ACK分组并离开该状态时才能开始获得上层的数据，所以，rdt2.0这样的协议又被称为&lt;strong&gt;停等&lt;/strong&gt;协议。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;rdt2.0有一个致命的缺陷，没有考虑到ACK或NAK分组受损的可能性。&lt;/p&gt;
&lt;p&gt;一种解决方法是，当发送方收到含糊不清的ACK或NAK分组时，只需&lt;strong&gt;重传&lt;/strong&gt;当前数据分组即可。这种方法在发送方到接收方的信道中引入了&lt;strong&gt;冗余分组&lt;/strong&gt;，但问题在于接收方不知道它上次所发送的ACK或NAK分组是否被正确收到，因此它不知道当前接收到的分组是新的还是一个重传。&lt;/p&gt;
&lt;p&gt;解决该问题的方法是在数据分组中添加一新字段，让发送方对其数据分组进行&lt;strong&gt;编号&lt;/strong&gt;，即将发送数据分组的&lt;strong&gt;序号&lt;/strong&gt;放在该字段，此时接收方只需要检查序号即可确定收到的分组是否一次重传。这里只需要使用1比特的序号就够了，如果当前是正在重传一个分组，则接收到的分组序号与最近的收到的分组序号相同；如果是一个新的分组，则序号与前一个相比发生了变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rtd2.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/rdt2_1_send.svg&#34; alt=&#34;rdt2_1_send&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/rdt2_1_rcv.svg&#34; alt=&#34;rdt2_1_rcv&#34;&gt;&lt;/p&gt;
&lt;p&gt;rdt2.1是解决了上述rdt2.0问题后的新的协议，发送方和接收方的状态数都是之前的两倍，因为协议状态必须反映出此时发送方正在发送的分组或是接收方希望收到的分组的序号是0还是1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rdt3.0：经具有比特差错的丢包信道的可靠数据传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在假定除了比特受损外，底层信道还会丢包，比特受损已经可以通过前面rdt2中的重传解决，而解决丢包需要增加一种新的协议机制。&lt;/p&gt;
&lt;p&gt;假定发送方传输一个数据分组，该分组或者接受方对于该分组的ACK发生了丢失，这两种情况下发送方都收不到响应，发送方需要等一段时间以便确定分组已经丢失，然后重传该分组。注意，如果一个分组经历了一个很大的时延，发送方也可能重传该分组，这就导致引入了&lt;strong&gt;冗余数据分组&lt;/strong&gt;，而前面的rdt2.1协议已经能通过序号的功能来处理这种情况。&lt;/p&gt;
&lt;p&gt;这个等待时间值需要通过一个&lt;strong&gt;倒计数定时器&lt;/strong&gt;来确定，在给定时间量过期后，可中断发送方，所以发送方需要做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次发送一个分组时便启动一个定时器。&lt;/li&gt;
&lt;li&gt;响应定时器中断(采取适当动作)。&lt;/li&gt;
&lt;li&gt;终止定时器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/rdt3.svg&#34; alt=&#34;rdt3&#34;&gt;&lt;/p&gt;
&lt;p&gt;分组序号在0和1之间交替，所以rdt3.0又被称为比特交替协议。&lt;/p&gt;
&lt;h3 id=&#34;流水线可靠数据传输&#34;&gt;流水线可靠数据传输&lt;/h3&gt;
&lt;p&gt;rdt3.0是一个功能正确的协议，但它的性能并不高，这里的核心问题在于它的停等协议。&lt;/p&gt;
&lt;p&gt;在停等协议下，信道的利用率非常低，具体过程见书。&lt;/p&gt;
&lt;p&gt;解决这个问题的方法是：&lt;strong&gt;不以停等方式运行&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;(RTT: Round-Trip Time)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/%E6%B5%81%E6%B0%B4%E7%BA%BF.svg&#34; alt=&#34;流水线&#34;&gt;&lt;/p&gt;
&lt;p&gt;允许发送方方多个分组而无需等待确认，这种技术被称为&lt;strong&gt;流水线&lt;/strong&gt;，流水线对可靠数据传输协议回带来以下影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须增加序号的范围&lt;/li&gt;
&lt;li&gt;协议的发送方和接收方不得不缓存多个分组&lt;/li&gt;
&lt;li&gt;解决流水线差错恢复有两种基本方法：回退N步(Go-Back-N, GBN)、选择重传(Selective Repeat, SR)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;回退n步go-back-n-gbn&#34;&gt;回退N步(Go-Back-N, GBN)&lt;/h3&gt;
&lt;p&gt;GBN协议中，允许发送方发送多个分组不需等待确认的原则受限于在流水线中未确认的分组数不能超过某个最大允许数N。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/GBN.svg&#34; alt=&#34;GBN&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基序号(base)：最早未确认分组的序号&lt;/li&gt;
&lt;li&gt;下一个序号(nextseqnum)：最小未使用序号(下一个待发分组序号)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示，可以将序号范围分割成4段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[0, base - 1]段内的序号对应已发送并确认的分组&lt;/li&gt;
&lt;li&gt;[base, nextseqnum - 1]：已发送但未被确认的分组&lt;/li&gt;
&lt;li&gt;[nextseqnum, base + N - 1]：对应立即要被发送的分组(如果有数据来自上层的话)&lt;/li&gt;
&lt;li&gt;大于等于base + N的序号不能使用，直到当前流水线中未被确认的分组已得到确认&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，N常被称为&lt;strong&gt;窗口长度&lt;/strong&gt;，GBN也常被称为&lt;strong&gt;滑动窗口协议(sliding-window protocol)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展FSM&lt;/strong&gt;：基于ACK、无NAK的GBN协议的发送方和接收方描述。&lt;/p&gt;
&lt;p&gt;(FSM: Finite-State Machine, 有限状态机)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/ExtendedFSM.svg&#34; alt=&#34;ExtendedFSM&#34;&gt;&lt;/p&gt;
&lt;p&gt;GBN发送方必须响应三种类型事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;上层的调用&lt;/em&gt;。当上层调用rdt_send()时，发送方首先检查发送窗口是否已满。如果未满，则产生一个分组并更新变量；如果已满，则发送方将数据返回给上层，隐式地指示窗口已满，过一会儿再试。实际中发送方更可能缓存这些数据或使用同步机制(仅当窗口不满时才允许上层调用rdt_send())。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;收到一个ACK&lt;/em&gt;。对序号为n的分组的确认采取&lt;strong&gt;累计确认&lt;/strong&gt;，表明接收方已正确收到序号为n的之前(包括n)的所有分组。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;超时事件&lt;/em&gt;。发生超时时，发送方重传所有已发送但还未被确认过的分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GBN协议中，接收方丢弃所有的失序分组，即不需要缓存任何失序分组，因为如果分组丢失，发送方会重传丢失的分组和之后的分组。&lt;/p&gt;
&lt;h3 id=&#34;选择重传sr&#34;&gt;选择重传(SR)&lt;/h3&gt;
&lt;p&gt;GBN解决了停等协议中的信道利用率的问题但GBN本身也存在着一些性能问题，当窗口长度和带宽时延都很大时，单个分组的差错就能引起GBN重传大量分组，但许多分组没有必要重传。&lt;/p&gt;
&lt;p&gt;选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。这种方式要求接收方逐个地确认正确接收地分组&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/SR%E6%93%8D%E4%BD%9C.svg&#34; alt=&#34;SR操作&#34;&gt;&lt;/p&gt;
&lt;p&gt;?对于SR协议而言，窗口长度必须小于或等于序号空间大小的一半&lt;/p&gt;
&lt;h2 id=&#34;面向连接的运输tcp&#34;&gt;面向连接的运输：TCP&lt;/h2&gt;
&lt;h3 id=&#34;tcp连接&#34;&gt;TCP连接&lt;/h3&gt;
&lt;p&gt;TCP被称为时&lt;strong&gt;面向连接的&lt;/strong&gt;是因为一个进程向另一个进程发送数据之前，这两个进程必须先相互握手，即相互发送一些预备报文来建立确保数据传输的参数。&lt;/p&gt;
&lt;p&gt;这样的连接不是一条端到端的连接电路，而是&lt;strong&gt;逻辑连接&lt;/strong&gt;，这种链接仅仅存在于两个通信端系统的TCP程序中。TCP协议只在端系统中运行，不在中间的网络元素中运行，中间路由看不到TCP连接，只能看到数据报。&lt;/p&gt;
&lt;p&gt;TCP连接提供的是&lt;strong&gt;全双工&lt;/strong&gt;服务，进程之间的TCP连接可以双向传输数据；TCP是&lt;strong&gt;点对点&lt;/strong&gt;连接，只能在一个发送方和一个接收方之间传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP建立连接的过程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;客户首先发送一个特殊TCP报文段，服务器用另一个特殊报文段响应，最后客户再用第三个特殊报文段作为响应，这种建立连接的过程通常被称为&lt;strong&gt;三次握手&lt;/strong&gt;。第三个报文段可以承载有效荷载(可以包含应用层数据)，前两个不行。&lt;/p&gt;
&lt;p&gt;建立连接后，两个应用程序进程之间就可以相互方数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/TCP%E7%BC%93%E5%AD%98.svg&#34; alt=&#34;TCP缓存&#34;&gt;&lt;/p&gt;
&lt;p&gt;客户进程通过套接字传递数据流，数据一旦通过套接字，就由客户中运行的TCP控制，TCP将这些数据引入&lt;strong&gt;发送缓存&lt;/strong&gt;，并不时地从发送缓存中取出一块数据并将数据传递到网络层。TCP从缓存中取出并放入报文段中的数据数量受到**最大报文段长度(Maximum Segment Size, MSS)**的限制，MSS的典型值为1460字节。&lt;/p&gt;
&lt;h3 id=&#34;tcp报文段结构&#34;&gt;TCP报文段结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/TCPsegmentStructure.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;TCP报文由&lt;strong&gt;首部字段&lt;/strong&gt;和一个&lt;strong&gt;数据字段&lt;/strong&gt;组成。首部一般是20字节，比UDP多12字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP报文段首部&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;源端口号&lt;/strong&gt;和&lt;strong&gt;目的端口号&lt;/strong&gt;：被用于多路复用和多路分解。&lt;/li&gt;
&lt;li&gt;32比特的&lt;strong&gt;序号字段&lt;/strong&gt;和32比特的&lt;strong&gt;确认号字段&lt;/strong&gt;：用来实现可靠传输服务（是以字节来计算，不是按段来计算）&lt;/li&gt;
&lt;li&gt;4比特的&lt;strong&gt;首部长度字段&lt;/strong&gt;：指示TCP首部长度&lt;/li&gt;
&lt;li&gt;6比特的&lt;strong&gt;标志字段&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;ACK比特用于确认字段中的值是有效的&lt;/li&gt;
&lt;li&gt;RST、SYN、FIN比特用于连接的建立和拆除&lt;/li&gt;
&lt;li&gt;CWR、ECE比特在明确拥塞报告中使用&lt;/li&gt;
&lt;li&gt;URG比特用来指示报文段中被发送端的上层实体置为紧急的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;16比特的&lt;strong&gt;接收窗口字段&lt;/strong&gt;：用于指示接收方愿意接收的字节数量&lt;/li&gt;
&lt;li&gt;16比特的&lt;strong&gt;检验和字段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;16比特的&lt;strong&gt;紧急数据指针字段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选项字段：用于发送方和接收方协商最大报文段长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;序号和确认号&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;这两个字段是TCP可靠传输服务的关键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个报文的序号&lt;/strong&gt;是该报文段首字节的字节流编号&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，数据流由一个包含500,000字节的文件组成，其MSS为1000字节，则TCP将为该数据流创建500个报文段，第一个报文段分配的序号是0，第二个报文段的序号是1000，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主机A填充进报文段的&lt;strong&gt;确认号&lt;/strong&gt;是主机A期望从主机B收到的&lt;strong&gt;下一个字节的序号&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，主机A已经收到来自B的编号为0~255的所有字节，它打算发一个报文段给B期望收到256以及之后的所有字节，于是它就在报文段的确认号字段填上256&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;累计确认&lt;/strong&gt;：假设主机A已经先后收到了主机B发送的两个报文段（分别为字节0~535和字节900~1000的报文段），由于一些原因并未收到中间的536~899的报文段，为了完整地建立主机B地数据流，仍在等待字节536及之后的字节，因此A给B发送地下一个报文地确认号字段中包含536，因此TCP只确认该流中第一个丢失字节为止的字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;往返时间的估计与超时&#34;&gt;往返时间的估计与超时&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;估计往返时间&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SampleRTT&lt;/code&gt;：从报文段被发出（交给IP）到收到该报文段的确认之间的时间量，多数TCP只在某个时刻做一次&lt;code&gt;SampleRTT&lt;/code&gt;的测量，不是为每个发送的报文都做测量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：为什么TCP仅为传输一次的报文段测量&lt;code&gt;SampleRTT&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随着网络状态课端系统负载的变化，报文段的SampleRTT在不断地变化，为了找到一个典型地RTT，要采取一种方法对SampleRTT取平均，TCP会根据以下赋值公式来更新EstimatedRTT：
$$
EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT \
在[RFC6298]标准中推荐的a值为0.125
$$
上述的这种计算平均的方法被称为&lt;em&gt;指数加权移动平均&lt;/em&gt;，这个加权平均最最近的样本赋予的权值要大于对旧样本赋予的权值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种方式：测量RTT的变化。[RFC6298]定义了&lt;em&gt;RTT偏差DevRTT&lt;/em&gt;：
$$
DevRTT = (1 - \beta) * DevRTT + \beta * |SampleRTT - EstimatedRTT| \
\beta 的推荐值为0.25
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设置和管理重传超时间隔&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;确认超时间隔的值：
$$
TimeoutInterval = EstimatedRTT + 4 * DevRTT \
推荐的TimeoutInterval初始值为1秒
$$&lt;/p&gt;
&lt;h3 id=&#34;可靠数据传输&#34;&gt;可靠数据传输&lt;/h3&gt;
&lt;h3 id=&#34;流量控制接收窗口字段&#34;&gt;流量控制（接收窗口字段）&lt;/h3&gt;
&lt;p&gt;一条TCP连接的每一侧的主机都为该连接设置了&lt;strong&gt;接收缓存&lt;/strong&gt;，当TCP连接收到正确的、按序的字节后，就会将数据放入缓存，应用程序就会从该缓存中根据实际情况读取数据，接收方可能不会立即读取刚刚放入缓存中的数据，他可能忙于别的服务。因此，可能由于发送方发送得太多太快，接收方读取得太慢导致&lt;strong&gt;缓存溢出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，TCP为其应用程序提供了&lt;strong&gt;流量控制服务&lt;/strong&gt;，来防止接收方的缓存溢出，该服务是一个速度匹配服务，即将发送方的发送速率与接收方的读取速率相匹配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，TCP发送方也可能由于IP网络的拥塞而被遏制，这种形式的对于发送方的控制被称为&lt;strong&gt;拥塞控制&lt;/strong&gt;，它与流量控制是两个完全不相同的概念，它们是针对完全不同的原因而采取的措施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP通过让发送方维护一个&lt;strong&gt;接收窗口&lt;/strong&gt;的变量来进行流量控制，接收窗口用来给发送方指示接收方剩余的缓存空间数量，TCP是双全工的，因此两端的发送方都各自维护一个接收窗口。&lt;/p&gt;
&lt;p&gt;假设主机A通过一条TCP连接向主机B发送一个文件，B为该连接分配了一个接收缓存，用&lt;code&gt;RecBuffer&lt;/code&gt;来表示其大小，定义以下的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LastByteRead&lt;/code&gt;：主机B的应用程序从缓存中读取的数据流的最后一个字节的编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LastByteRcved&lt;/code&gt;：从网络中到达并且已经放入B的缓存中的数据流的最后一个字节的编号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以为了不使缓存溢出，下式必须成立：
$$
LastByteRcved - LastByteRead \le RcvBuffer
$$
接收窗口用&lt;code&gt;rwnd&lt;/code&gt;来表示，根据缓存可用空间大小来设置：
$$
rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]
$$
主机A要轮流跟踪两个变量：&lt;code&gt;LastByteSent&lt;/code&gt;和&lt;code&gt;LastByteAcked&lt;/code&gt;，分别指发送到连接中的数据流的最后一个字节的编号和已经确认接收的数据流的最后一个字节的编号， 因此，两者的差就代表了主机A发送到连接中但还未被确认的数据量，只要将这个数据量控制在值&lt;code&gt;rwnd&lt;/code&gt;以内，就不会使B的接收缓存溢出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意一种特殊情况，假设B的缓存已满即rwnd=0，B将这个消息发送给A后，假设B没有任何的数据要发送给A，此时B的应用程序将通过不断读取数据来清空缓存，TCP并不向主机A发送带有rwnd新值的报文段，这样，A不知道B的接收缓存有新的空间，因为A被阻塞不能发送数据。解决这个问题的方法是：TCP规定当B的接收缓存为0时，A继续发送只有一个字数据的报文，这些报文段将会被B确认，最终缓存开始清空，返回一个具有新rwnd值的报文段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tcp连接管理&#34;&gt;TCP连接管理&lt;/h3&gt;
&lt;p&gt;该节中将详细说明建立和拆除一条TCP连接的全过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3次握手建立TCP连接&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：客户端的TCP首先向服务端TCP发送一个特殊TCP报文段，该报文段不含任何应用层的数据，仅将首部中的一个标志位（&lt;code&gt;SYN&lt;/code&gt;比特）置为1，因此给报文段被称为&lt;em&gt;SYN报文段&lt;/em&gt;。此外客户会随机选择一个&lt;em&gt;初始序号（client_isn）&lt;/em&gt;，将此编号放入起始SYN报文段的序号字段中。最后该报文段被封装在一个IP数据报中，发送给服务器。&lt;/li&gt;
&lt;li&gt;第二步：包含TCP SYN报文段的IP数据包到达服务器后，服务器会从中提取TCP SYN报文段，为该TCP连接分配缓存和变量，并向客户TCP发送允许连接的报文段（该报文段被称为&lt;em&gt;SYNACK报文段&lt;/em&gt;）。该报文段不包含应用层数据，但首部中包含了3个重要信息：
&lt;ul&gt;
&lt;li&gt;SYN比特被置为1&lt;/li&gt;
&lt;li&gt;该TCP报文段首部的确认号字段被置为client_isn + 1&lt;/li&gt;
&lt;li&gt;服务器选择自己的初始序号（server_isn）并将其置放到报文首部的序号字段中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三步：收到SYNACK报文段后，客户也要为该连接分配缓存和变量，然后客户主机向服务器发送另一个报文段，该报文段对连接进行确认（通过将TCP报文段首部的确认字段置为server_isn + 1来完成），因为连接已经建立，所以SYN比特被置为0，这个报文可以携带应用层数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4次挥手终止TCP连接的过程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.eternityqjl.top/TCP%E7%BB%88%E6%AD%A2%E8%BF%9E%E6%8E%A5.svg&#34; alt=&#34;TCP终止连接&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图，客户进程发出一个关闭连接的命令，这会引起客户TCP向服务器TCP发送一个特殊TCP报文段，该报文让其首部中的&lt;code&gt;FIN比特&lt;/code&gt;标志位置为1.&lt;/p&gt;
&lt;p&gt;服务器接收该报文段后，向发送方返回一个确认报文段。&lt;/p&gt;
&lt;p&gt;然后，服务器发送自己的终止报文段，其中&lt;code&gt;FIN比特&lt;/code&gt;被置为1.&lt;/p&gt;
&lt;p&gt;最终客户对这个服务器的终止报文段进行确认，此时两台主机上的资源（缓存和变量）都被释放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SYN洪泛攻击&lt;/p&gt;
&lt;p&gt;客户（攻击者）发送大量TCP SYN报文段，而不完成第三次握手的步骤，这种情况下服务器不断为这些&lt;em&gt;半开连接&lt;/em&gt;分配资源导致服务器的连接资源被消耗殆尽。&lt;/p&gt;
&lt;p&gt;解决方法是使用&lt;strong&gt;SYN cookie&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当服务器收到一个SYN报文段时，并不知道它是合法用户还是SYN洪泛攻击，所以服务器不会为其生成半开连接。相反，服务器生成一个&lt;em&gt;初始TCP序列号&lt;/em&gt;，该序列号是SYN报文段的源和目的IP地址与端口号以及仅有该服务器知道的一个秘密数组成的一个复杂函数，该序列号被称为&lt;em&gt;cookie&lt;/em&gt;。服务器并不记忆该cookie或对应于SYN的其他状态信息。&lt;/li&gt;
&lt;li&gt;若客户合法，它将返回一个ACK报文段，服务器借助cookie验证该ACK于前面发送的某些SYN是否对应。对于合法ACK，其确认字段的值等于SYNACK报文段的序号值（此时为cookie值）加1，以此为依据，如果二者相等，服务器认为该ACK对应于较早的SYN报文段，它是合法的，服务器将生成一个具有套接字的全开连接。&lt;/li&gt;
&lt;li&gt;另一方面，如果客户没有返回ACK报文段，初始SYN并未对服务器产生影响，因为服务器没有为它分配资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;几个特殊通信连接的情况&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;namp端口扫描工具对一台主机的目的端口6789发送一个特殊的TCP SYN报文段，有3中可能的输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源主机从目标主机接收到一个TCPACK报文段，意味着目标主机上一个应用程序使用TCP端口67889运行，nmap返回打开。&lt;/li&gt;
&lt;li&gt;源主机从目标主机接收到一个TCP RST报文段，意味着目标主机没有运行一个使用TCP端口6789的应用程序，但知道发送的报文段没有被中间的任何防火墙阻挡。&lt;/li&gt;
&lt;li&gt;源主机什么也没收到，意味着很可能被防火墙阻挡。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拥塞控制原理&#34;&gt;拥塞控制原理&lt;/h2&gt;
&lt;h3 id=&#34;拥塞控制方法&#34;&gt;拥塞控制方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;端到端拥塞控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该控制方法中，网络层没有为运输层拥塞控制提供显式帮助。端系统必须通过对网络行为的观察来推断网络拥塞1&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>TLS（HTTPS）协议</title>
        <link>https://eternityqjl.top/posts/tls/</link>
        <pubDate>Sun, 19 Apr 2020 16:15:26 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/tls/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/tls/ -&lt;h2 id=&#34;ssltls简介&#34;&gt;SSL/TLS简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TLS&lt;/strong&gt;（&lt;strong&gt;T&lt;/strong&gt;ransport &lt;strong&gt;L&lt;/strong&gt;ayer &lt;strong&gt;S&lt;/strong&gt;ecurity，&lt;strong&gt;传输层安全协议&lt;/strong&gt;），以及它的前身&lt;strong&gt;SSL&lt;/strong&gt;（&lt;strong&gt;S&lt;/strong&gt;ecure &lt;strong&gt;S&lt;/strong&gt;ockets &lt;strong&gt;L&lt;/strong&gt;ayer，&lt;strong&gt;安全套接层&lt;/strong&gt;）是一种安全协议。Netscape公司在1994年推出HTTPS协议，使用SSL进行加密，这是SSL的起源。1999年公布了第一版的TLS协议，类似于SLLv3，只是对其做出了一些更改。&lt;/p&gt;
&lt;p&gt;SSL协议处在计算机网络中的应用层和运输层之间，它不依赖于平台和运行程序的协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几个知名的使用SSL加密的协议&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP over SSL (HTTPS)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简称为HTTPS，它的产生是为了加密网页，HTTP是第一个使用SSL保障安全的应用层协议。HTTPS在RFC2818被标准化，HTTPS工作在443端口，HTTP默认工作在80端口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Email over SSL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于HTTP over SSL，协议如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SMTP、IMAP能够支持SSL&lt;/li&gt;
&lt;li&gt;SMTP over TLS在标准文档RFC2487中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ssl原理详解&#34;&gt;SSL原理详解&lt;/h2&gt;
&lt;h3 id=&#34;基本运行过程&#34;&gt;基本运行过程&lt;/h3&gt;
&lt;p&gt;SSL/TLS协议是采用&lt;strong&gt;公钥加密法&lt;/strong&gt;实现的，客户端先向服务器端索要公钥，用公钥加密信息，服务器收到密文后，用自己的私钥解密；二者协商生成”对话密钥“，采用该”对话密钥“进行加密通信。&lt;/p&gt;
&lt;h3 id=&#34;ssl建立的总过程&#34;&gt;SSL建立的总过程&lt;/h3&gt;
&lt;p&gt;客户端向服务器索要并验证公钥，双方协商生成”对话密钥“的过程又称为”握手阶段“，该阶段涉及&lt;strong&gt;四次握手&lt;/strong&gt;通信，且该阶段的通信都是明文的。以下一一来分析。&lt;/p&gt;
&lt;h4 id=&#34;1-客户端发出请求clienthello&#34;&gt;1. 客户端发出请求（ClientHello）&lt;/h4&gt;
&lt;p&gt;该步客户端（通常为浏览器）向服务器提供以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持的协议&lt;strong&gt;版本（Version）&lt;/strong&gt;，如TLSv1.0&lt;/li&gt;
&lt;li&gt;一个客户端生成的&lt;strong&gt;随机数（Random）&lt;/strong&gt;，之后用于生成”对话密钥“&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;会话ID（Session id）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;如果客户端第一次连接到服务器，那么该字段为空。&lt;/li&gt;
&lt;li&gt;如果该字段不为空，则说明以前与服务器有连接，在此期间，服务器使用Session ID映射对称密钥，并将Session ID存储在客户端浏览器中，为映射设置一个时间限，如果浏览器将来连接到同一台服务器，它将发送Session ID，服务器对映射的Session ID进行验证，并使用以前用过的对称密钥来恢复会话，该情况下不需要握手，也成为&lt;strong&gt;SSL会话恢复&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持的&lt;strong&gt;加密套件（Cipher Suites）&lt;/strong&gt;，这是由客户按优先级排列的，但完全由服务器决定发送与否。服务器会从客户端发送的加密套件中选择一种作为共同的加密套件，如RSA公钥加密。&lt;/li&gt;
&lt;li&gt;支持的&lt;strong&gt;压缩方法&lt;/strong&gt;，这是为了减少带宽。从TLS 1.3开始，协议禁用了TLS压缩，因为使用压缩时攻击可以捕获到用HTTP头发送的参数，该攻击可以劫持Cookie。&lt;/li&gt;
&lt;li&gt;扩展包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-服务器回应serverhello&#34;&gt;2. 服务器回应（ServerHello）&lt;/h4&gt;
&lt;p&gt;该步骤包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认使用的&lt;strong&gt;版本&lt;/strong&gt;，如TLSv1.0，如果浏览器与服务器支持的版本不一致，服务器会关闭加密通信。&lt;/li&gt;
&lt;li&gt;一个服务器生成的&lt;strong&gt;随机数&lt;/strong&gt;，之后用于生成”对话密钥“&lt;/li&gt;
&lt;li&gt;确认使用的&lt;strong&gt;加密套件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;会话ID&lt;/strong&gt;（Session ID）：
&lt;ul&gt;
&lt;li&gt;服务器将约定的Session参数存储在TLS缓存中，并生成与之对应的Session ID，它将与ServerHello一起发送到客户端。客户端可以写入约定的参数到此Session ID，并给定到期时间，客户端将在ClientHello中包含该ID。如果客户端再次连接到该服务器，服务器可以检查与Session ID对应的缓存参数，并重用他们而无需再次握手。这可以节省大量计算成本。&lt;/li&gt;
&lt;li&gt;但在谷歌等大流量应用程序中这种方法存在缺点，每天有数百万人连接到服务器，服务器必须使用Session ID保留所有Session参数的TLS缓存，这是一笔巨大的开销。为解决该问题，在扩展包中加入&lt;strong&gt;Session Tickets&lt;/strong&gt;，在这里客户端可以在ClientHello中指定它是否支持Session Tickets，然后服务器将创建一个新的Session Tickets，并使用只有服务器知道的经过私钥加密的Session参数，该参数存储在客户端中，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展包&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器证书&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当服务器需要确认客户端身份时，就会再包含一个请求，要求客户端提供”客户端证书“。例如金融机构只允许认证客户连入自己的网络，会向正式用户提供USB密钥（U盾），里面包含一张客户端证书。&lt;/p&gt;
&lt;h4 id=&#34;3-客户端回应&#34;&gt;3. 客户端回应&lt;/h4&gt;
&lt;p&gt;客户端收到服务器回应后首先验证服务器的证书，如果证书存在问题，如证书过期、由非可信机构颁布、或证书域名与实际域名不一致，会向客户端访问者发出警告，询问是否继续通信。&lt;/p&gt;
&lt;p&gt;证书没有问题则客户端会从中取出公钥然后发送以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个&lt;strong&gt;随机数（pre-master-key)&lt;/strong&gt;；该随机数用服务器&lt;strong&gt;公钥加密&lt;/strong&gt;，防止被窃听。&lt;/li&gt;
&lt;li&gt;**编码改变通知，**表示随后的信息都将用双方商定的加密方法和密钥发送。&lt;/li&gt;
&lt;li&gt;客户端&lt;strong&gt;结束握手通知&lt;/strong&gt;，该项同时也是前面发送所有内容的哈希值，用来供服务器验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面第一项的随机数是握手阶段出现的第三个随机数，称“pre-master-key”，之后客户端和服务器就同时有了3个随机数，接着用双方事先商定的加密方法&lt;strong&gt;各自生成本次会话用的同一把“会话密钥”&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pre-master-key与前面服务器和客户端在Hello阶段产生的两个随机数结合在一起生成了Master Secret。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;4-服务器的最后回应&#34;&gt;4. 服务器的最后回应&lt;/h4&gt;
&lt;p&gt;服务器收到客户端第三个随机数pre-master-key后，计算生成&lt;strong&gt;本次会话使用的“会话密钥”&lt;/strong&gt;，然后向客户端发送以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。&lt;/li&gt;
&lt;li&gt;服务器握手结束通知，该项同时也是前面发送的所有内容的哈希值，用来供客户端验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此整个握手阶段就结束了，接下来客户端与服务器进入加密通信，就是完全使用普通的HTTP协议，只是使用了“会话密钥”加密内容。&lt;/p&gt;
&lt;h3 id=&#34;ssl协议的结构体系&#34;&gt;SSL协议的结构体系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SSL%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;SSL体系结构包含两个协议子层，底层为&lt;strong&gt;SSL记录协议层&lt;/strong&gt;；高层为&lt;strong&gt;SSL握手协议层&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSL记录协议层&lt;/strong&gt;：记录协议为高层协议提供基本的安全服务，如数据封装、压缩、加密等基本功能。所以我们可以知道，所有的传输数据都被封装在记录中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL握手协议层&lt;/strong&gt;包括：
&lt;ul&gt;
&lt;li&gt;SSL握手协议：协调客户和服务器的状态，是双方能达到状态的同步&lt;/li&gt;
&lt;li&gt;SSL密码参数修改协议：更新用于当前连接的密码组。&lt;/li&gt;
&lt;li&gt;SSL告警协议：发现异常时为对等方传递警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/&#34;&gt;SSL/TLS协议详解|曹世宏的博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&#34;&gt;SSL/TLS协议运行机制的概述|阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/tls/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 