<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sun, 17 Jul 2022 13:32:48 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>计算机网络学习日志（一）——应用层</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</link>
        <pubDate>Thu, 28 Nov 2019 19:23:38 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/ -&lt;p&gt;应用层是计算机网络从上往下的第一层，这一层的主要内容是网络应用的原理和实现，通过学习几种常见的网络应用程序，并且开发运行在TCP和UTP(运输层)上的网络应用程序，这些应用程序包含Web、电子邮件、DNS、P2P等等。&lt;/p&gt;
&lt;h2 id=&#34;应用层协议&#34;&gt;应用层协议&lt;/h2&gt;
&lt;p&gt;开发网络应用程序是要开发运行在不同端系统上并且通过网络(下层协议)彼此通信的程序，这过程中不需要为下层的网络核心设备写程序，因为它们不在应用层上起作用。&lt;/p&gt;
&lt;h3 id=&#34;网络应用程序体系结构&#34;&gt;网络应用程序体系结构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;客户——服务器体系结构&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户：发送主机请求&lt;/li&gt;
&lt;li&gt;服务器：总是打开的主机，接收来自客户的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：Web应用程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P2P体系结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据中心服务器几乎没有依赖。&lt;/li&gt;
&lt;li&gt;应用程序在对等方之间直接通信&lt;/li&gt;
&lt;li&gt;具有自扩展性，报文在主机之间直接发送，服务器用来追踪IP，有安全隐患。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：BitTorrent、Skype&lt;/p&gt;
&lt;h3 id=&#34;进程通信&#34;&gt;进程通信&lt;/h3&gt;
&lt;p&gt;端系统之间的通信实际上是&lt;strong&gt;进程&lt;/strong&gt;，进程通过跨越网络发送&lt;strong&gt;报文&lt;/strong&gt;来进行通信。进程是运行在端系统上的程序，同一个端系统和不同端系统之间的进程都可以进行通信，这里主要讨论不同端系统之间跨越网络的通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户与服务器之间的进程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户-服务器体系中，比如Web服务器，一个进程被标识为客户(Client)，另一个进程被标识为服务器(Server)。&lt;/li&gt;
&lt;li&gt;P2P体系中，一个进程既可以是客户又可以是服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程与网络之间的接口——套接字&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;套接字(端口号)是应用程序和运输层之间的接口，也成为应用程序编程接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程寻址&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;为了向特定的目的地发送报文，需要有目的地主机的相关信息，这些信息为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP地址：用来标识目的地主机。&lt;/li&gt;
&lt;li&gt;端口号：用来指定接受进程(即接受套接字)，例如Web服务器用端口号80标识，邮件服务器进程用25标识。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;供应用程序使用的运输服务&#34;&gt;供应用程序使用的运输服务&lt;/h3&gt;
&lt;p&gt;开发应用程序时，需要选择一种适合的运输层协议，运输层协议能够提供的服务主要有以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可靠数据传输：进程与进程之间的可靠数据传输，有不提供可靠数据传输的应用层协议，使用这种应用层协议的应用被称为&lt;strong&gt;容忍丢失的应用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量：发送进程向接收进程交付比特的速率，所以运输层协议可以提供以特定速率确保的可用吞吐量的服务，对此有需求的应用称为&lt;strong&gt;带宽敏感应用&lt;/strong&gt;，如一些多媒体语音和视频应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时（延迟）：例子：发送方注入比特至套接字到接收方烧到比特的时间不多于100ms，这对于实时交互应用很重要，例如多方射击游戏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;因特网提供和未提供的运输服务&#34;&gt;因特网提供和未提供的运输服务&lt;/h3&gt;
&lt;p&gt;因特网为应用程序提供两个运输层协议，TCP和UDP，开发者必须做出选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP服务&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接服务：报文数据流动前，TCP让客户和服务器交换运输层控制信息(即握手)，之后一个&lt;em&gt;TCP连接&lt;/em&gt;就建立了，这条连接是&lt;em&gt;全双工&lt;/em&gt;的，应用程序运行结束后要拆除该连接。&lt;/li&gt;
&lt;li&gt;可靠数据传输服务：无差错、按顺序交付报文。&lt;/li&gt;
&lt;li&gt;拥塞控制机制&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;安全套接字层(Secure Sockets Layer, SSL)，是加强版的TCP协议，提供了进程之间的安全加密服务，这种强化是在应用层上实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;UDP服务&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;是一种轻量运输协议，进程通信时无握手过程，不保证到达，同时无拥塞控制机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注，这里只是简要的内容，更多详细内容将在第三章运输层中提到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;未提供的服务&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;以上两个协议提供了可靠数据传输、安全性相关的服务，但并未提供2.3中所述的&lt;em&gt;吞吐量和定时&lt;/em&gt;的服务，所以因特网并不提供这两项服务。虽然未提供具体的服务，但因特网已经运行很多年，对于时间敏感的应用已经被设计得尽可能应对这种保证的缺乏。&lt;/p&gt;
&lt;h3 id=&#34;应用层协议总结&#34;&gt;应用层协议总结&lt;/h3&gt;
&lt;p&gt;应用层协议定义了以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换的报文类型，如请求和响应报文&lt;/li&gt;
&lt;li&gt;报文语法&lt;/li&gt;
&lt;li&gt;字段语义&lt;/li&gt;
&lt;li&gt;确定进程何时发送报文&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web和http&#34;&gt;Web和HTTP&lt;/h2&gt;
&lt;h3 id=&#34;http概况&#34;&gt;HTTP概况&lt;/h3&gt;
&lt;p&gt;**超文本传输协议（HyperText Transfer Protocol，HTTP）**是Web的应用层协议，它由客户程序和服务器程序实现，客户和服务器运行在不同端系统中，通过HTTP报文进行会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web页面&lt;/strong&gt;是由对象组成的，一个对象只是一个文件，如一个HTML文件、一张JEPG图片、一段视频，它们可以由URL寻址(URL地址由两部分组成，主机名和路径)。多数Web页面由&lt;strong&gt;一个HTML基本文件&lt;/strong&gt;和&lt;strong&gt;一些对象&lt;/strong&gt;组成。&lt;/p&gt;
&lt;p&gt;HTTP使用&lt;strong&gt;TCP&lt;/strong&gt;作为支撑运输协议，客户首先发起一个与服务器的TCP连接，建立连接后浏览器和服务器就可以通过套接字进行交互。&lt;/p&gt;
&lt;p&gt;HTTP是一个&lt;strong&gt;无状态协议&lt;/strong&gt;，服务器不会储存客户的状态信息，无论用户进行多少次的重复请求，服务器都会做出反应。&lt;/p&gt;
&lt;h3 id=&#34;非持续性连接和持续性连接&#34;&gt;非持续性连接和持续性连接&lt;/h3&gt;
&lt;p&gt;非持续性连接：客户服务器之间的请求和响应都是经一个单独的TCP连接发送。&lt;/p&gt;
&lt;p&gt;持续性连接：二者之间的请求和响应经过相同的TCP连接发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采取非持续性连接的HTTP&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;往返时间&lt;/em&gt;（Round-Trip Time，RTT）：该时间指一个短分组从客户到服务器再返回服务器所花的时间。&lt;/li&gt;
&lt;li&gt;必须为每一个请求的对象建立一个&lt;em&gt;全新的TCP连接&lt;/em&gt;，每个连接都需要在客户和服务器中分为TCP缓冲区和保持TCP变量，这会给服务器带来巨大负担；并且每个对象要经历&lt;em&gt;两倍RTT交付时延&lt;/em&gt;，一个RTT用于创建TCP连接，另一个RTT用于请求和接受一个对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;采取持续性连接的HTTP&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 1.1 连接下，服务器发送响应后保持该TCP连接打开，相同客户和服务器之间，后续的请求和响应报文能够通过相同的连接传送。如果一条连接经过一段时间间隔未使用，则HTTP服务器就会关闭它。&lt;/li&gt;
&lt;li&gt;HTTP/2 允许相同连接中的多个请求和回答相互交错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http报文格式&#34;&gt;HTTP报文格式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;请求报文&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;GET&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;/somedir/page.html&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.1&lt;/span&gt;
Host&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; www.someschool.edu	#指明了对象所在主机
Connection&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; close	#让服务器在发送完被请求对象后就关闭这条连接
User-agent&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Mozilla/5.0		#浏览器类型
Accept-language&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; fr		#语言
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一行为&lt;em&gt;请求行&lt;/em&gt;，共有三个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法字段：可取：GET、POST、HEAD、PUT、DELETE，绝大部分请求使用GET。&lt;/li&gt;
&lt;li&gt;URL字段：带有请求对象的标识&lt;/li&gt;
&lt;li&gt;HTTP版本字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一行后的后继行都叫&lt;em&gt;首部行&lt;/em&gt;，具体意义见程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202111201547032.jpg&#34; alt=&#34;请求报文&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首部行后有一个实体体(entity body)，使用&lt;strong&gt;GET&lt;/strong&gt;请求时实体体为空，而当使用&lt;strong&gt;POST&lt;/strong&gt;方法时才使用该实实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户&lt;strong&gt;提交表单&lt;/strong&gt;时，HTTP客户常常使用POST方法，例如用户向搜索引擎提供搜索关键字时。&lt;/li&gt;
&lt;li&gt;使用POST报文时仍然可以请求Web页面，但Web内容依赖于用户在表单中字段中输入的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;用表单生成的请求报文不是必须使用POST方法，相反也经常使用GET方法，并在所请求的URL中包括输入的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;HEAD方法&lt;/em&gt;类似于GET方法，服务器收到一个HEAD方法的请求时，会用一个HTTP报文进行响应但并不会返回请求的对象，该方法常用在&lt;em&gt;调试跟踪&lt;/em&gt;中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT方法被那些需要向Web服务器上传对象的应用程序使用，DELETE方法允许应用程序删除服务器上的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;响应报文&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#f00;font-weight:bold&#34;&gt;OK&lt;/span&gt;
Connection&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; close	#发送完报文后关闭该TCP连接
Date&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Tue, 18 Aug 2015 15:44:04 GMT		#指示服务器产生并发送该响应报文的日期和时间
Server&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Apache/2.2.3 (CentOS)	#服务器类型及系统，对应于请求报文中的User-agent字段
Last-Modified&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; Tue, 18 Aug 2015 15:11:03 GMT	#对象创建或最后修改的日期和时间
Content-Length&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; 6821	#被发送对象的字节数
Content-Type&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; text/html		#对象类型

(data data data ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;一个初始&lt;strong&gt;状态行&lt;/strong&gt;(第一行)：三个字段，协议版本字段、&lt;strong&gt;状态码&lt;/strong&gt;和相应状态信息&lt;/li&gt;
&lt;li&gt;6个&lt;strong&gt;首部行&lt;/strong&gt;(2至7行)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实体体&lt;/strong&gt;：报文的部分，即包含了所请求的对象本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202111201548133.jpg&#34; alt=&#34;响应报文&#34;&gt;&lt;/p&gt;
&lt;p&gt;状态码和它们对应的短语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK：请求成功&lt;/li&gt;
&lt;li&gt;301 Moved Permanently：请求的对象被永久转移了，新URL定义在响应报文中的&lt;code&gt;Location：&lt;/code&gt;首部行中，客户软件会自动获取新URL&lt;/li&gt;
&lt;li&gt;400 Bad Request：通用差错代码，指请求不能被服务器理解&lt;/li&gt;
&lt;li&gt;404 Not Found：被请求文档不在服务器中&lt;/li&gt;
&lt;li&gt;505 HTTP Version Not Supported：服务器不支持请求报文只用的HTTP协议版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cookie&#34;&gt;cookie&lt;/h3&gt;
&lt;p&gt;HTTP服务器是无状态的，但一个Web站点希望能够识别用户身份，所以HTTP使用cookie允许站点对用户进行追踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie技术组件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP响应报文中的一个cookie首部行&lt;/li&gt;
&lt;li&gt;HTTP请求报文中的一个cookie首部行&lt;/li&gt;
&lt;li&gt;用户端系统中有一个cookie文件，由用户浏览器进行管理&lt;/li&gt;
&lt;li&gt;位于Web站点的一个后端数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一般工作流程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;第一次访问某个Web服务器时，服务器会为用户创建一个ID，这个ID会通过响应报文中的一个首部行传给端系统，记录在cookie文件中，同时这个ID被记录在服务器的后端数据库中；当再次访问这个网站时，浏览器会查询cookie文件并抽取对于该网站的识别码，并放到HTTP请求报文的cookie首部中，此时服务器可以跟踪该用户在站点的活动，显示一些内容，比如浏览购物网站会提供上次加入购物车的内容。&lt;/p&gt;
&lt;h3 id=&#34;web缓存&#34;&gt;Web缓存&lt;/h3&gt;
&lt;p&gt;即使用代理服务器，proxy server；代理服务器是能代表初始Web服务器来满足HTTP请求的网络实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署Web缓存器的原因&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能大大减少对客户请求的响应时间&lt;/li&gt;
&lt;li&gt;减低因特网上的Web流量，改善应用性能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;条件get方法&#34;&gt;条件GET方法&lt;/h3&gt;
&lt;p&gt;虽然高速缓存能减少响应时间，但也有一个问题，存放在缓存器中的对象副本可能是陈旧的，而HTTP有一种机制，允许缓存器证实它的对象是最新的，即条件GET方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件GET&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求报文使用GET方法&lt;/li&gt;
&lt;li&gt;请求报文中包含一个&lt;code&gt;If-Modified-Since:&lt;/code&gt;首部行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代理服务器代表请求浏览器向Web服务器发送一个请求报文，Web服务器向缓存器发送具有请求对象的响应报文，缓存器将对象转发到浏览器的同时也在本地缓存了该对象，重要的是也同时储存占了最后修改日期；一段时间后，另一个用户通过该缓存器请求同一个对象，该对象可能已经被修改了，所以缓存器发送一个条件GET执行最新检查，该条件GET包含&lt;code&gt;If-Modified-Since:&lt;/code&gt;首部行，该报文告诉服务器，只有&lt;strong&gt;当自指定日期后该对象被修改过&lt;/strong&gt;，才发送该对象。&lt;/p&gt;
&lt;h2 id=&#34;dns因特网目录服务&#34;&gt;DNS:因特网目录服务&lt;/h2&gt;
&lt;p&gt;主机可以使用主机名(hostname)或是IP地址来进行标识，显然主机名更容易被人们记住，但路由器更喜欢定长的、有层次地IP地址，所以需要一个能进行主机名到IP地址的转换目录服务。这即是&lt;strong&gt;域名系统(Domain Name System, DNS)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;dns提供的服务&#34;&gt;DNS提供的服务&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DNS组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由分层的DNS服务器实现的&lt;strong&gt;分布式数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使主机能查询分布式数据库的应用层协议，DNS服务器通常是运行BIND软件的UNIX机器&lt;/li&gt;
&lt;li&gt;DNS协议运行在UDP上，使用53号端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主机名到IP地址的转换&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一台主机上运行着DNS应用的客户端&lt;/li&gt;
&lt;li&gt;浏览器从一条URL中抽取出主机名，将主机名传给DNS应用的客户端&lt;/li&gt;
&lt;li&gt;DNS客户端向服务器发出包含主机名的请求&lt;/li&gt;
&lt;li&gt;DNS客户收到回答报文，其中包含对应主机名的IP&lt;/li&gt;
&lt;li&gt;浏览器收到来自DNS的IP地址，向位于该IP地址80端口的HTTP服务器发起一个TCP连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DNS提供的其他服务&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主机别名&lt;/strong&gt;：主机名可以拥有一个或多个别名，最初的主机名称为&lt;em&gt;规范主机名&lt;/em&gt;，浏览器可以通过调用DNS来获得一个主机别名对应的规范主机名以及主机IP地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载分配&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;一个繁忙的站点会被冗余在多台服务器上，每台服务器都有着不同的IP地址；所以由于这些冗余服务器的存在，一个IP地址集合于同一个规范主机名相联系&lt;/li&gt;
&lt;li&gt;当用户对映射到某地址集合的主机名发出DNS请求时，该DNS服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址的次序；客户总是向IP地址排在最前面的服务器发送HTTP请求，所有DNS就在有冗余的Web服务器之间循环分配了负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dns工作机理&#34;&gt;DNS工作机理&lt;/h3&gt;
&lt;p&gt;DNS由分布于全球的大量DNS服务器以及定义了DNS服务器于查询主机之间通信方式的应用层协议组成。集中式DNS设计(全球公用一台DNS服务器)的问题：单点故障、通信容量、远距离延时、维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式、层次数据库&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202111201548508.jpg&#34; alt=&#34;DNS服务器&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图，有三个类型的服务器：根DNS服务器、顶级域DNS服务器、权威DNS服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根DNS服务器：由400多个根名字服务器，由不同组织管理，提供顶级域服务器的IP地址。&lt;/li&gt;
&lt;li&gt;顶级域(Top-Level Domain, TLD)DNS服务器：每个顶级域(包括国家顶级域)都有TLD服务器，提供权威DNS服务器的IP地址。&lt;/li&gt;
&lt;li&gt;权威DNS服务器：具有公共可访问主机的组织机构必须提供公共可访问的DNS记录；一个组织机构可通过：
&lt;ul&gt;
&lt;li&gt;构建自己的权威DNS服务器&lt;/li&gt;
&lt;li&gt;租用服务商提供的权威DNS服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一类称为&lt;strong&gt;本地DNS服务器&lt;/strong&gt;，这类服务器不属于上图所示的层次结构；每个ISP都有一台本地DNS服务器，本地DNS服务器于主机之间距离很近，甚至可能在同一个局域网中，它起代理作用，并将DNS请求转发到DNS服务器层次结构中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS查询&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;DNS查询一般分为两类：&lt;em&gt;递归查询&lt;/em&gt;、&lt;em&gt;迭代查询&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归查询：DNS服务器收到客户机请求时，必须使用一个准确的查询结构回复客户机，如果DNS服务器本地没有储存DNS信息，该服务器会&lt;strong&gt;向其他服务器询问&lt;/strong&gt;，并将返回的查询结果提交给客户机。&lt;/li&gt;
&lt;li&gt;迭代查询：DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址，当客户机发送请求时，DNS服务器&lt;strong&gt;不直接返回结果&lt;/strong&gt;，而是&lt;strong&gt;告诉客户机另一台DNS服务器地址&lt;/strong&gt;，客户机再想这台服务器体提交请求，一次循环到返回查询结果为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202111201548018.JPG&#34; alt=&#34;DNS服务器交互&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以图中&lt;em&gt;请求主机和本地DNS服务器&lt;/em&gt;之间为递归查询，&lt;em&gt;本地DNS服务器和其他DNS服务器&lt;/em&gt;之间为迭代查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS缓存&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;DNS缓存用来改善延时性能并减少在因特网上传输的DNS报文数，例如上图所示，当本地服务器从某个DNS服务器接收到一个回答，他能缓存包含在该回答内的任何信息，当一个主机向本地DNS服务器查询已经缓存的地址时就能够直接将IP地址返回给主机。而主机名与IP地址间的映射不是永久的，DNS服务器一般在一段时间(通常设置为两天)后丢弃缓存信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS记录和报文&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;DNS服务器存储了&lt;em&gt;资源记录(Resource Record, RR)&lt;/em&gt;，RR提供了主机名到IP地址的映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源记录元组&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;(Name, Value, Type, TTL)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TTL是该记录的生存时间，决定了资源记录应当从缓存中删除的时间。&lt;/li&gt;
&lt;li&gt;Name和Value的值取决于Type：
&lt;ul&gt;
&lt;li&gt;Type = A，则Name是主机名，Value是主机名对应的IP地址&lt;/li&gt;
&lt;li&gt;Type = NS，则Name是一个域(如foo.com)，而Value知道如何获得该域中主机IP地址的权威DNS服务器的主机名。&lt;/li&gt;
&lt;li&gt;Type = CNAME，则Value是别名为Name的主机对应的规范主机名，如(foo.com, relay1.bar.foo.com, CNAME)。&lt;/li&gt;
&lt;li&gt;Type = MX，则Value是个别名为Name的邮件服务器对应的规范主机名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DNS报文&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202111201549963.JPG&#34; alt=&#34;DNS报文&#34;&gt;&lt;/p&gt;
&lt;p&gt;DNS报文有查询和回答两种，且两种报文的格式相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首部区域：前12字节为首部区域，有6个字段
&lt;ul&gt;
&lt;li&gt;标识符：16比特的数，用于标识该查询。该标识符会被复制到回答报文中，以便匹配。&lt;/li&gt;
&lt;li&gt;标志字段：有若干标志
&lt;ul&gt;
&lt;li&gt;1比特的“查询/回答”标志位&lt;/li&gt;
&lt;li&gt;1比特的“权威的”标志位&lt;/li&gt;
&lt;li&gt;1比特的“希望递归”标志位，用户在该DNS服务器没有某记录时希望它执行递归查询&lt;/li&gt;
&lt;li&gt;1比特的“递归可用”标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4个有关数量的字段，指出了4类数据区域出现的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题区域：包含正在进行的查询信息
&lt;ul&gt;
&lt;li&gt;名字字段：包含正在查询的主机名字&lt;/li&gt;
&lt;li&gt;类型字段：包含Type的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回答区域：来自DNS服务器的回答报文，包含了对最初请求名字的资源记录，即(Name, Value, Type, TTL)；回答区域可以包含多条RR，所以一个主机名能有多个IP地址。&lt;/li&gt;
&lt;li&gt;权威区域：包含了其他权威服务器的记录。&lt;/li&gt;
&lt;li&gt;附加区域：其他有帮助的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DNS脆弱性，一种针对DNS的攻击时分布式拒绝服务（DDos）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;p2p文件分发&#34;&gt;P2P文件分发&lt;/h2&gt;
&lt;p&gt;P2P体系结构对基础设施服务器几乎没有依赖，成对间歇连接的主机(对等放)彼此直接通信。&lt;/p&gt;
&lt;h3 id=&#34;p2p体系结构的扩展性&#34;&gt;P2P体系结构的扩展性&lt;/h3&gt;
&lt;p&gt;客户——服务器体系和P2P体系的比较，结论为在相同的网络速率环境下，随着分发文件数量的增加，P2P的最小分发时间与客户——服务器体系相比差距越来越大，优势越来越明显。&lt;/p&gt;
&lt;h3 id=&#34;bittorrent&#34;&gt;BitTorrent&lt;/h3&gt;
&lt;p&gt;BT是一种用于文件分发的流行P2P协议，参与一个特定分发文件的所有对等方的集合被称为一个&lt;strong&gt;洪流(torrent)&lt;/strong&gt;，一个洪流中的对等方彼此下载等长度的文件&lt;strong&gt;块&lt;/strong&gt;，典型长度为256KB.&lt;/p&gt;
&lt;p&gt;当一个对等方首次加入一个洪流，它没有块，随着时间的流逝，它累计了越来越多的块，同时也为其他对等放上载了多个块；当对等方获得了整个文件，它也许离开洪流，也许留在洪流中并继续向其他对等方上载块。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;追踪器&lt;/strong&gt;：每个洪流都具有一个的基础设施节点；当一个对等方加入洪流时，他向追踪器注册自己，并周期性地通知追踪器它仍在洪流中。一个给定的洪流可能在任何时刻具有数以百计或千计的对等方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何给定时间，每个对等方将具有来自该文件的块的子集，并且不同对等方有不同子集。一个对等方经TCP连接周期性地询问每个邻近对等方它们所具有的块列表，然后对当前没有的块发出请求。&lt;/p&gt;
&lt;p&gt;那么对等方应该向它的邻居请求哪些块呢？应向哪些向它请求的邻居发送块？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最稀缺优先&lt;/strong&gt;技术：针对自己没有的块，在邻居中寻找这些块的副本最少的，并首先请求这些稀缺的块，这也可以同时均衡每个块在洪流中的副本数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对换算法&lt;/strong&gt;：对等方根据当前能够以最高速率向他提供数据的邻居给出优先权；并且确定向流入速率前四的邻居提供数据，且每隔10秒就重新计算速率并重新确定4个对等方，这4个对等方被称为&lt;strong&gt;疏通&lt;/strong&gt;。每过30秒对换方将重新选择一名新的对换伴侣并开始与那位伴侣进行对换，并且如果二者直接都满足对换算法规则，那么互相将对方放入自己的前4人中，这样能使对等方趋于找到彼此的协调速率上载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;视频流和内容分发网&#34;&gt;视频流和内容分发网&lt;/h2&gt;
&lt;h3 id=&#34;http流和dash&#34;&gt;HTTP流和DASH&lt;/h3&gt;
&lt;p&gt;在HTTP流中，视频是指存储在HTTP服务器中的一个文件，每个文件有特定的URL，用户要看视频时，客户与服务器创建一个TCP连接并对URL发送HTTP GET请求，服务器在HTTP响应报文中发送该视频；在客户一侧，视频字节被收集在客户应用缓存中，当缓存中的字节量超过预先设定的门槛，客户应用程序就开始播放视频。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;经HTTP的动态适应性流(Dynamic Adaptive Streaming over HTTP, DASH)&lt;/strong&gt;：DASH中视频被编码为几个不同版本，每个版本有不同的比特率(画质)，当用户的可用带宽较高时，自然选择来自高速率版本的块，同时可用带宽较低时自然选择低速率的块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;告示文件&lt;/strong&gt;：存在于HTTP服务器中，为每个版本提供一个URL及其比特率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内容分发网&#34;&gt;内容分发网&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内容分发网(Content Distribution Network, CDN)&lt;/strong&gt;：是现在主流视频流公司用来向全世界用户分发视频数据的部署在全球多个地理位置的服务器，服务器中存储了视频和其他相关内容的副本。&lt;/p&gt;
&lt;p&gt;CDN服务器安置原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深入&lt;/strong&gt;：靠近端用户，改善时延和吞吐量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邀请做客&lt;/strong&gt;：通过在少量关键位置建造大集群来邀请ISP做客，通常将这些集群放置在因特网交换点(IXP).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDN集群部署就绪后就可以跨集群复制内容，并进行一系列视频管理操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CDN操作&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;大多数CDN利用&lt;em&gt;DNS来截获和重定向请求&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户访问位于内容提供商的Web页面&lt;/li&gt;
&lt;li&gt;用户点击视频链接时，用户发哦是那个了一个对于该视频链接的DNS请求&lt;/li&gt;
&lt;li&gt;用户的本地DNS服务器（LDNS）将该请求中继到一台权威DNS服务器上，权威服务器并不返回一个IP地址，而是返回自己租用的内容服务器的主机名&lt;/li&gt;
&lt;li&gt;此时DNS请求进入内容服务器专用DNS基础设施，LDNS发送第二个请求，基础设施DNS服务器最终返回内容服务器的IP地址&lt;/li&gt;
&lt;li&gt;客户收到内容服务器的IP地址后，创建一条TCP连接，并发送HTTP GET 请求，若使用了DASH，服务器将首先向客户发送具有URL列表的告示文件，对应了不同版本视频，客户动态地选择不同版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集群选择策略&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如上CDN操作所示，CDN得知该用户LDNS服务器的IP地址后，需要基于IP地址选择一个适当的集群，一般采用专用的集群选择策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;地理上最为邻近的集群&lt;/em&gt;：每个LDNS 的IP地址都映射到一个地理位置，CDN选择地理上最为接近的集群。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;当前流量条件&lt;/em&gt;：CDN能对当前集群和客户之间的时延和丢包性能进行周期性实时测量，基于此来选择。&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>关于</title>
        <link>https://eternityqjl.top/about/</link>
        <pubDate>Thu, 28 Nov 2019 18:09:24 +0000</pubDate>
        
        <guid>https://eternityqjl.top/about/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/about/ -&lt;p&gt;四川大学电气工程学院自动化专业在读。励志成为一个软硬兼修的优秀工程师。还在努力中。。。&lt;/p&gt;
&lt;p&gt;喜欢摄影，尤爱拍飞机。&lt;/p&gt;
&lt;p&gt;然后就是旅行过程中的街拍，以及各种奇奇怪怪的照片。&lt;/p&gt;
&lt;p&gt;还偶尔拍一些火车，但现在已经很少拍。&lt;/p&gt;
&lt;p&gt;写文字是我觉得最有趣的事情之一，希望自己能坚持写一些博客。&lt;/p&gt;
&lt;p&gt;我已经初步建好了自己的飞行博物馆的GitBook，以后会逐渐地更新：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://museum.eternityqjl.top&#34;&gt;My Flight Museum&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;网站于2021年7月从Hexo平台迁移至Hugo。&lt;/p&gt;
- https://eternityqjl.top/about/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>GitBook自动发布脚本</title>
        <link>https://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</link>
        <pubDate>Fri, 18 Oct 2019 13:50:49 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/ -&lt;p&gt;GitBook作为一个非常好用的基于Node.js的命令行工具，可以输出HTML、PDF、eBook等多种格式的电子书，这里就不再详细讲述GitBook的构建以及发布到Github托管的过程，网络上有非常多的教程，可以自行Google查看。&lt;/p&gt;
&lt;p&gt;刚开始在每次更新内容的时候都需要一系列的git命令将原始内容仓库和构建的网页仓库同步到Github上，大概需要10条命令，如果你的更新频率很高的话，发布内容将会是有个痛苦的过程，但这里我们可以通过一个shell脚本只使用&lt;code&gt;$ sh deploy.sh&lt;/code&gt;一条命令完成同步内容和构建网页的所有过程。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;首先，在你的GitBook内容根目录下建一个&lt;code&gt;deploy.sh&lt;/code&gt;文件，使用文本编辑器打开，然后输入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#!bin/sh
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;git checkout master
&lt;span style=&#34;color:#888&#34;&gt;# 切换到master分支，及内容所在的仓库&lt;/span&gt;
git add .
git commit -m &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Update&amp;#34;&lt;/span&gt;
git push -u origin master
&lt;span style=&#34;color:#888&#34;&gt;# 添加、提交到Git仓库，然后push到Github上&lt;/span&gt;
gitbook build
&lt;span style=&#34;color:#888&#34;&gt;# 构建Gitbook&lt;/span&gt;

git checkout gh-pages
&lt;span style=&#34;color:#888&#34;&gt;# 切换到gh-pages分支，即生成的HTML网页的仓库&lt;/span&gt;
cp -r _book/* . 
&lt;span style=&#34;color:#888&#34;&gt;# 复制前面构建的内容&lt;/span&gt;
git add .
git commit -m &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Update&amp;#34;&lt;/span&gt;
git push -u origin gh-pages
&lt;span style=&#34;color:#888&#34;&gt;# 添加、提交到Git仓库，然后push到Github上&lt;/span&gt;
git checkout master
&lt;span style=&#34;color:#888&#34;&gt;# 返回master主分支&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后打开命令行，为这个脚本授权：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ chmod +x deploy.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此就完成了，以后在更新的时候只需要输入一条命令&lt;code&gt;$ sh deploy.sh&lt;/code&gt;就可以完成所有操作了。&lt;/p&gt;
- https://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>储存类别、链接和内存管理</title>
        <link>https://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Fri, 18 Oct 2019 10:59:58 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ -&lt;p&gt;一、储存类别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象：具有一定大小空间的一块内存。&lt;/li&gt;
&lt;li&gt;标识符：用来指定特定对象的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;作用域
&lt;ul&gt;
&lt;li&gt;描述了程序中可访问标识符的区域。&lt;/li&gt;
&lt;li&gt;分类：
&lt;ul&gt;
&lt;li&gt;块作用域&lt;/li&gt;
&lt;li&gt;函数作用域&lt;/li&gt;
&lt;li&gt;文件作用域&lt;/li&gt;
&lt;li&gt;函数原型作用域：从形参定义处到原型声明结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全局变量：也称为文件作用域变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接
&lt;ul&gt;
&lt;li&gt;C变量的三种链接属性：
&lt;ul&gt;
&lt;li&gt;外部链接：该类型变量可以在多文件程序中使用&lt;/li&gt;
&lt;li&gt;内部链接：该类型变量只能在一个翻译单元中使用&lt;/li&gt;
&lt;li&gt;无链接：具有块作用域、函数作用域或函数原型作用域的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;储存类别说明符&lt;code&gt;static&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储期：
&lt;ul&gt;
&lt;li&gt;C对象有4种
&lt;ul&gt;
&lt;li&gt;静态存储期：在程序的执行期间一直存在，文件作用域变量都具有静态存储期。&lt;/li&gt;
&lt;li&gt;线性存储期：用于并发程序设计。&lt;/li&gt;
&lt;li&gt;自动存储期：所有局部变量都有该性质，在函数调用时被创建，离开函数时被销毁。&lt;/li&gt;
&lt;li&gt;动态分配存储期：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动变量
&lt;ul&gt;
&lt;li&gt;属于自动存储类别，有自动存储期、块作用域、无链接。&lt;/li&gt;
&lt;li&gt;可显式使用关键词&lt;code&gt;auto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;块作用域和无链接意味着只有在&lt;strong&gt;变量定义的块中&lt;/strong&gt;才能通过变量名访问该变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寄存器变量
&lt;ul&gt;
&lt;li&gt;特殊的自动变量。也是自动存储期、块作用域、无链接。&lt;/li&gt;
&lt;li&gt;可以显式使用关键词&lt;code&gt;register&lt;/code&gt;，是一种请求，编译器可能会拒绝你的请求，此时就变成了普通变量，但仍然无法访问该变量的内存。&lt;/li&gt;
&lt;li&gt;作用是储存在最快的可用内存中，能够以更快的速度访问。&lt;/li&gt;
&lt;li&gt;存储在寄存器中而非内存中，所以无法获取寄存器变量的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;块作用域的静态变量
&lt;ul&gt;
&lt;li&gt;静态指的是在内存中原地不动，但它的值可以改变。&lt;/li&gt;
&lt;li&gt;具有块作用域、无链接、有静态存储期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在块中&lt;/strong&gt;以&lt;code&gt;static&lt;/code&gt;(提供静态存储期)声明这种变量。&lt;/li&gt;
&lt;li&gt;如果未显式地初始化&lt;strong&gt;静态变量&lt;/strong&gt;，它们会被&lt;strong&gt;初始化为0&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部链接的静态变量
&lt;ul&gt;
&lt;li&gt;具有文件作用域、外部链接、静态存储期。&lt;/li&gt;
&lt;li&gt;有时又称为外部存储类型、该类别地变量被称为&lt;strong&gt;外部变量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;创建过程：在&lt;strong&gt;所有函数外&lt;/strong&gt;面(定义性声明)创建这个外部变量。&lt;/li&gt;
&lt;li&gt;函数使用该变量时，为了&lt;strong&gt;指出使用的是外部变量&lt;/strong&gt;，可以用关键字&lt;code&gt;extern&lt;/code&gt;再次声明。&lt;/li&gt;
&lt;li&gt;如果一个源文件使用的外部变量定义在&lt;strong&gt;其他文件&lt;/strong&gt;中，则必须用&lt;code&gt;extern&lt;/code&gt;在该文件中声明该变量。&lt;/li&gt;
&lt;li&gt;定义式声明、引用式声明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部链接的静态变量
&lt;ul&gt;
&lt;li&gt;具有静态存储期、文件作用域、内部链接。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;所有函数外部&lt;/strong&gt;，用存储类别说明符&lt;code&gt;static&lt;/code&gt;定义该类变量。&lt;/li&gt;
&lt;li&gt;该类型变量只能用于&lt;strong&gt;同一个文件中的函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;可以在函数中使用类别说明符&lt;code&gt;extern&lt;/code&gt;重复声明该类型变量，这并不会改变其链接属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多文件(多翻译单元)
&lt;ul&gt;
&lt;li&gt;程序在多个翻译单元中才能体现区别内部和外部变量的重要性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储类别的选择
&lt;ul&gt;
&lt;li&gt;正常情况下多使用自动存储类别，使用外部变量可能在不经意中修改变量的值，count类型变量除外。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、&lt;/p&gt;
- https://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C语言结构</title>
        <link>https://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/</link>
        <pubDate>Tue, 15 Oct 2019 20:03:54 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/ -&lt;p&gt;1.建立结构变量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; book {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; title[MAXTITL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; author[MAXAUTL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;该结构描述了由两个字符数组和一个float类型变量组成的结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.定义结构变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct book library;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把library声明为一个使用book结构类型的结构变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以struct book 相当于过去的int、double等类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; book {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; title[MAXTITL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; author[MAXAUTL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; value;
} library;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该程序为上面声明的完整版。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; { &lt;span style=&#34;color:#888&#34;&gt;//无结构标记
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; title[MAXTITL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; author[MAXAUTL];
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; value;
} library;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;声明结构和定义结构可以一步完成，如上所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.初始化结构&lt;/p&gt;
&lt;p&gt;4.访问结构成员(点运算符)&lt;/p&gt;
&lt;p&gt;5.结构初始化器&lt;/p&gt;
&lt;p&gt;6.结构数组&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct book library[MAXBKS];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;7.指向结构的指针&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct guy * him;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针可以指向任何现有的guy类型如barney、fellow[0]（一个结构数组的一项即为一个结构变量）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;him = &amp;amp;barney&lt;/code&gt; or &lt;code&gt;him = &amp;amp;fellow[0];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;8.用指针访问成员&lt;/p&gt;
&lt;p&gt;若&lt;code&gt;him == &amp;amp;barney&lt;/code&gt;，那么&lt;code&gt;him-&amp;gt;income&lt;/code&gt;即是&lt;code&gt;barney.income&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;同时，&lt;code&gt;*him&lt;/code&gt;即为指针指向的结构类型。所以，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;barney.income == (*him).income == him-&amp;gt;income&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;9.向函数传递结构的成员、地址、结构本身&lt;/p&gt;
&lt;p&gt;10.其他特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用指针传递信息(作为函数参数)：是使用原始结构进行计算的。&lt;/li&gt;
&lt;li&gt;使用结构作为函数参数：是使用副本进行计算。&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>字符串输入、输出和字符串函数</title>
        <link>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</link>
        <pubDate>Sat, 28 Sep 2019 12:15:42 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/ -&lt;h2 id=&#34;字符串输入&#34;&gt;字符串输入&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;gets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用方法：读取整行输入，直到遇到&lt;strong&gt;换行符&lt;/strong&gt;，然后&lt;strong&gt;丢弃换行符&lt;/strong&gt;，储存其余的字符，并在字符末尾添加一个&lt;strong&gt;空字符&lt;/strong&gt;使之成为一个C字符串。&lt;/li&gt;
&lt;li&gt;使用中存在的问题：&lt;code&gt;gets(words)&lt;/code&gt;（char words[STLEN]）的唯一参数为words，该函数无法检查数组是否装得下输入行。数组名会被转化成该数组首元素的地址，该函数只知道数组的开始处，并不知道数组在何处结束。&lt;/li&gt;
&lt;li&gt;如果输入过长，会导致&lt;strong&gt;缓存区溢出&lt;/strong&gt;，详情见书上内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;code&gt;gets()&lt;/code&gt;的替代品：&lt;code&gt;fgets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fgets()&lt;/code&gt;函数通过第二个参数来限制读入的&lt;strong&gt;字符数&lt;/strong&gt;来解决溢出问题。&lt;/li&gt;
&lt;li&gt;相较于&lt;code&gt;gets()&lt;/code&gt;的区别：
&lt;ul&gt;
&lt;li&gt;第二个参数指明了读入字符的最大数量，若该值为n，那么将读入n-1个字符，或遇到第一个&lt;strong&gt;换行符&lt;/strong&gt;为止。&lt;/li&gt;
&lt;li&gt;第三个参数指明了要读入的文件，如果要从键盘输入，则参数设置为stdin标识符。&lt;/li&gt;
&lt;li&gt;如果读到一个换行符，&lt;code&gt;fgets()&lt;/code&gt;会将其&lt;strong&gt;储存在数组中&lt;/strong&gt;，而不是将其丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;gets_s()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;于&lt;code&gt;fgets()&lt;/code&gt;的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数只从标准输入中读取，所以无需第三个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读到&lt;strong&gt;换行符会将其丢弃&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果读到最大字符数都没有读到换行符，会进行以下操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先设置目标数组的首字符为空字符&lt;/p&gt;
&lt;p&gt;读取并丢弃随后的输入直至读到换行符或文件结尾&lt;/p&gt;
&lt;p&gt;返回空指针&lt;/p&gt;
&lt;p&gt;然后调用依赖实现的“处理函数”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.&lt;code&gt;s_gets()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取整行输入并&lt;strong&gt;用空字符替代换行符&lt;/strong&gt;，或者(在字符串未结束就遇到了空字符)读取一部分输入，并丢弃其余的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;s_gets&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; st, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ret_val;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;

    ret_val &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fgets(st, n, stdin);
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret_val)
    {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (st[i] &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; st[i] &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
            i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (st[i] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
            st[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; 
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (getchar() &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
                &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; ret_val;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.&lt;code&gt;scanf()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以第一个非空白字符座位读取的开始，以第一个空白字符(空行、空格、制表符、换行符)座位字符串的结束。&lt;/li&gt;
&lt;li&gt;其他内容略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串输出&#34;&gt;字符串输出&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;puts()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数显示字符串时会在末尾添加一个&lt;strong&gt;换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;该函数的参数为地址，且用双引号括起来的字符串常量作为参数时，参数被视为该字符串的地址。&lt;/li&gt;
&lt;li&gt;当参数为数组中某个项的地址时，如&lt;code&gt;str[5]&lt;/code&gt;,会从这个位置开始依次输出。&lt;/li&gt;
&lt;li&gt;结束条件为&lt;strong&gt;空字符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;code&gt;fputs()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二个参数要指明写入数据的文件，若要打印在显示器上，则用stdout作为参数。&lt;/li&gt;
&lt;li&gt;该函数&lt;strong&gt;不会在字符串末尾添加换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;printf()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串函数&#34;&gt;字符串函数&lt;/h2&gt;
&lt;p&gt;0.这里只写出书上详细介绍的5组字符串函数：&lt;code&gt;strlen()&lt;/code&gt; | &lt;code&gt;strcat()/strncat()&lt;/code&gt; | &lt;code&gt;strcmp()/strncmp()&lt;/code&gt; | &lt;code&gt;strcpy()/strncpy()&lt;/code&gt; | &lt;code&gt;sprintf()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;strlen&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数用于统计字符串的长度，函数返回值为字符串的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;2.&lt;code&gt;strcat()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本定义
&lt;ul&gt;
&lt;li&gt;该函数用于&lt;strong&gt;拼接字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接受两个字符串作为参数&lt;/li&gt;
&lt;li&gt;把第二个字符串的备份附在第一个字符串的末尾，并把拼接后形成的新字符串作为第一个字符串，第二个字符串不变。&lt;/li&gt;
&lt;li&gt;该函数的函数类型是&lt;code&gt;char *&lt;/code&gt;,即指向&lt;code&gt;char&lt;/code&gt;的指针。&lt;/li&gt;
&lt;li&gt;所以该函数返回第一个参数，即拼接第二个字符串后的第一个字符串的&lt;strong&gt;地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存在的问题
&lt;ul&gt;
&lt;li&gt;无法检查第一个数组是否能容纳第二个字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;code&gt;strncat()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的第三个参数指定了最大添加字符数&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;strncat(bugs, addon, 13)&lt;/code&gt;会把addon字符串的聂荣附加给bugs，加到第13个字符或者遇到空字符的时候停止&lt;/li&gt;
&lt;li&gt;所以，算上空字符(必须要添加空字符，否则就不是字符串了)，bugs数组应该足够大，以容纳原始字符串(不包含空字符)、添加在后面的13个字符、末尾的空字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;4.&lt;code&gt;strcmp()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来把用户的响应于已储存的字符串作比较(比较&lt;strong&gt;两个字符串的内容&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;比较的是字符串的内容而不是字符串的地址，例如
&lt;ul&gt;
&lt;li&gt;定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define ANSWER &amp;quot;Grant&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define SIZE 40&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char try[SIZE]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s_gets(try, SIZE)&lt;/code&gt;\\输入Grant&lt;/li&gt;
&lt;li&gt;如果使用&lt;code&gt;while (try == ANSWER)&lt;/code&gt;,则永远得不到两者相等的结果，因为while比较的是指针，即地址，二者的地址肯定不相同&lt;/li&gt;
&lt;li&gt;但使用&lt;code&gt;strcmp(try, ANSWER)&lt;/code&gt;则能够得到两者内容相等的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：该函数只会比较try中第一个空字符前面的部分，所以该函数可以比较储存在不同大小数组中的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;该函数的返回值：
&lt;ul&gt;
&lt;li&gt;返回实例：
&lt;ul&gt;
&lt;li&gt;比较“A&amp;quot;和本身，返回0&lt;/li&gt;
&lt;li&gt;比较”A&amp;quot;和&amp;quot;B&amp;quot;，返回-1&lt;/li&gt;
&lt;li&gt;比较“B&amp;quot;和”A“，返回1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论：
&lt;ul&gt;
&lt;li&gt;二者相等返回0&lt;/li&gt;
&lt;li&gt;第一个的ASCII码比第二个大就返回负数，比第二个大就返回整数&lt;/li&gt;
&lt;li&gt;返回的整数和负数即为二者的ASCII码之差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;
&lt;li&gt;返回值的具体数值并不重要，重要的是它是0还是非0&lt;/li&gt;
&lt;li&gt;该函数比较的是&lt;strong&gt;字符串而不是字符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限：
&lt;ul&gt;
&lt;li&gt;该函数比较字符串中的字符，直到发现不同的字符为止，这个过程可能会持续到字符串末尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.&lt;code&gt;strncmp()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数可以比较字符不同的地方，也可以只比较第三个参数指定的字符数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如书中的实例：可以限定函数只查找这几个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;6.&lt;code&gt;strcpy()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数是用来拷贝整个字符串的内容，即相当于字符串赋值运算符
&lt;ul&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;str1和str2都是指向字符串的指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str2 = str1;&lt;/code&gt;这个语句拷贝的指针的地址而不是具体内容&lt;/li&gt;
&lt;li&gt;所以要想拷贝整个字符串就要用到该函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;接受两个字符串指针作为参数，可以把第二个指针声明为指针、数组或者字符串常量&lt;/li&gt;
&lt;li&gt;第一个指针应该指向一个数据对象如数组，且该字符串有足够的空间存储源字符串的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他属性：
&lt;ul&gt;
&lt;li&gt;该函数的返回类型是&lt;code&gt;char *&lt;/code&gt;,返回的是第一个参数的值，即一个字符的地址。&lt;/li&gt;
&lt;li&gt;第一个参数不必指向数组的开始，该属性可用于拷贝数组的一部分，详情见书上的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限：
&lt;ul&gt;
&lt;li&gt;与&lt;code&gt;strcat()&lt;/code&gt;一样，不能检查目标空间是否能容纳的下源字符串的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.&lt;code&gt;strncpy()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数的第三个参数指明了可拷贝的最大字符数
&lt;ul&gt;
&lt;li&gt;如果要拷贝的字符超过了指定的参数n，当拷贝了n个字符后就会停止，并且也不会在后面添加空字符，容易出现错误，所以要非常注意。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;8.&lt;code&gt;sprintf()&lt;/code&gt;函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该函数与&lt;code&gt;printf()&lt;/code&gt;函数类似，但这个是把数据写入字符串，而不是打印在显示器上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该函数的第一个参数是目标字符串的地址，其余的与&lt;code&gt;printf()&lt;/code&gt;类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; first[MAX];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; last[MAX];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; formal[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; MAX &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;];
&lt;span style=&#34;color:#888&#34;&gt;//给以上前面两个数组赋值后就可以进行如下的操作
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;sprintf(formal, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s, %-19s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, last, first);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>抽象数据类型</title>
        <link>https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
        <pubDate>Tue, 24 Sep 2019 21:33:07 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ -&lt;h2 id=&#34;一抽象数据类型的实现&#34;&gt;一、抽象数据类型的实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//数据类型的实现
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Counter&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;//实例变量
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; String name&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//构造函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;Counter&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;String id&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; name &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; id&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//实例方法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;++;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;tally&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; count&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;toString&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; count &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; name&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;


&lt;span style=&#34;color:#888&#34;&gt;//测试该数据类型的用例
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#333&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#888&#34;&gt;//创建并初始化对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    Counter heads &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Counter&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;heads&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    Counter tails &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Counter&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;tails&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#888&#34;&gt;//调用实例方法
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;incerment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    tails&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;();&lt;/span&gt;
    
    StdOut&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;heads &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; tails&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    StdOut&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;heads&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;tally&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; tails&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;tally&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例变量：
&lt;ul&gt;
&lt;li&gt;一个实例变量对应了无数的值，因为数据类型的每个实例对象都有有个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造函数：
&lt;ul&gt;
&lt;li&gt;构造函数是用来创建一个对象的表示，即来初始化实例变量。&lt;/li&gt;
&lt;li&gt;它由&lt;strong&gt;可见性修饰符、构造函数名称(即数据类型的名称)、参数变量&lt;/strong&gt;以及初始化实例变量的代码构成。&lt;/li&gt;
&lt;li&gt;上一条加粗的三个组成了签名，例如&lt;code&gt;public Counter (String id) &lt;/code&gt;即为一个签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实例方法：
&lt;ul&gt;
&lt;li&gt;是每个对象的具体行为，即实现数据类型的实例方法。&lt;/li&gt;
&lt;li&gt;与静态方法的唯一区别是它能够访问并操作实力变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域
&lt;ul&gt;
&lt;li&gt;参数变量：作用域为整个方法。&lt;/li&gt;
&lt;li&gt;局部变量：定义后的所有语句(一个花括号内)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例变量&lt;/strong&gt;：整个类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>测试GitBook格式</title>
        <link>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/</link>
        <pubDate>Fri, 20 Sep 2019 21:43:41 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/ -&lt;h1 id=&#34;flightmuseum-gitbook&#34;&gt;FlightMuseum-GitBook&lt;/h1&gt;
&lt;h2 id=&#34;目录层级&#34;&gt;目录层级&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preface&lt;/li&gt;
&lt;li&gt;Airbus
&lt;ul&gt;
&lt;li&gt;A320
&lt;ul&gt;
&lt;li&gt;A319&lt;/li&gt;
&lt;li&gt;A320-200&lt;/li&gt;
&lt;li&gt;A320-200neo&lt;/li&gt;
&lt;li&gt;A321&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A330
&lt;ul&gt;
&lt;li&gt;A330-200&lt;/li&gt;
&lt;li&gt;A330-300&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A350
&lt;ul&gt;
&lt;li&gt;A350-900&lt;/li&gt;
&lt;li&gt;A350-1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boeing
&lt;ul&gt;
&lt;li&gt;B737&lt;/li&gt;
&lt;li&gt;B747&lt;/li&gt;
&lt;li&gt;B767&lt;/li&gt;
&lt;li&gt;B777&lt;/li&gt;
&lt;li&gt;B787
&lt;ul&gt;
&lt;li&gt;B787-8 Dreamliner&lt;/li&gt;
&lt;li&gt;B787-9 Dreamliner&lt;/li&gt;
&lt;li&gt;B787-10 Dreamliner&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;.&lt;/li&gt;
&lt;li&gt;Trains
&lt;ul&gt;
&lt;li&gt;CR&lt;/li&gt;
&lt;li&gt;TRA&lt;/li&gt;
&lt;li&gt;JR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一个具体层级的markdown编辑形式&#34;&gt;一个具体层级的Markdown编辑形式&lt;/h2&gt;
&lt;h3 id=&#34;1cathay-pacific--国泰航空----b-lra&#34;&gt;1.Cathay Pacific | 国泰航空    B-LRA&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/DSCF0361.jpg&#34; alt=&#34;国泰航空A350-900&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Serial Number / 生产序列号&lt;/strong&gt;：29&lt;/li&gt;
&lt;li&gt;**First Flight Date / 首飞日期：**24th. Mar 2016  &lt;strong&gt;/&lt;/strong&gt;  2016年3月24日&lt;/li&gt;
&lt;li&gt;**Age (Shotted Date) / 机龄(拍摄日期)：**3.3 years as of 27th. Jul 2019  &lt;strong&gt;/&lt;/strong&gt;  3.3年  摄于2019年7月27日&lt;/li&gt;
&lt;li&gt;**Shotted Place / 拍摄地：**Hong Kong  &lt;strong&gt;/&lt;/strong&gt;  香港&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cathaypacific.com/cx/sc_CN/travel-information/flying-with-us/aircraft-and-fleet/airbus-a350/900.html&#34;&gt;&lt;strong&gt;Seat Configuration / 座位布局：&lt;/strong&gt;&lt;/a&gt;C38 W28 Y214&lt;/li&gt;
&lt;li&gt;**Engines / 引擎：**2 x RR Trent XWB&lt;/li&gt;
&lt;li&gt;Others：-&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2philippines-airlines--菲律宾航空----rp-c3506&#34;&gt;2.Philippines Airlines | 菲律宾航空    RP-C3506&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/DSCF4874.jpg&#34; alt=&#34;菲律宾航空A350-900&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Serial Number / 生产序列号&lt;/strong&gt;：243&lt;/li&gt;
&lt;li&gt;**First Flight Date / 首飞日期：**11st. Sep 2018  &lt;strong&gt;/&lt;/strong&gt;  2018年9月11日&lt;/li&gt;
&lt;li&gt;**Age (Shotted Date) / 机龄(拍摄日期)：**0.8 years as of 9th. Aug 2019  &lt;strong&gt;/&lt;/strong&gt;  0.8年  摄于2019年8月9日&lt;/li&gt;
&lt;li&gt;**Shotted Place / 拍摄地：**Hong Kong  &lt;strong&gt;/&lt;/strong&gt;  香港&lt;/li&gt;
&lt;li&gt;**Seat Configuration / 座位布局：**C30 W24 Y241&lt;/li&gt;
&lt;li&gt;**Engines / 引擎：**2 x RR Trent XWB&lt;/li&gt;
&lt;li&gt;Others：-&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>什么是数据结构？什么又是算法？</title>
        <link>https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</link>
        <pubDate>Thu, 19 Sep 2019 13:55:19 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/ -&lt;h2 id=&#34;数据结构及相关概念&#34;&gt;数据结构及相关概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0. 要想知道什么是数据结构，首先要了解与“数据”相关的概念，这样才能一步步理解什么是数据结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先用放书这件事情来举例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果正常情况下只有你自己一个人的书，那么你把他们一本一本立起来放在书架上就可以了。&lt;/li&gt;
&lt;li&gt;那么如果有一个图书馆那么多的书应该怎样办么？总不能把他们乱起八糟的立起来放吧？那么是不是应该先按照社会科学、理科类、工科类、外语类等等的分类方式先分类，然后按照具体所属的类别把他们一个个放进去？其实数据结构的相关的概念就是一个这样简单的道理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来进行具体的描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是对客观事物的&lt;strong&gt;符号&lt;/strong&gt;表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。&lt;/li&gt;
&lt;li&gt;其实就对应了&lt;strong&gt;图书馆中的所有书&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 数据元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是&lt;strong&gt;数据的基本单位&lt;/strong&gt;，在计算机程序中通常作为一个整体进行考虑号处理。&lt;/li&gt;
&lt;li&gt;对应的就是&lt;strong&gt;某一本具体的书&lt;/strong&gt;，比如”数据结构与算法“这本书。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 数据项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个数据元素&lt;/strong&gt;可由&lt;strong&gt;若干个数据项&lt;/strong&gt;组成，数据项是数据的不可分割的最小单位。&lt;/li&gt;
&lt;li&gt;数据项不就是对应了&lt;strong&gt;书中的具体信息&lt;/strong&gt;，比如书的作者、章节内容、ISBN编号等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 数据对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是&lt;strong&gt;性质相同的数据元素&lt;/strong&gt;的集合，是数据的子集。&lt;/li&gt;
&lt;li&gt;数据元素是一本具体的书，那么性质相同数据元素的集合不就代表了&lt;strong&gt;一类具体的书籍&lt;/strong&gt;吗，就比如计算机类的书籍，其中包含了”数据机构与算法这本书“。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;看到这儿是不是对这几者的关系还有点儿晕？没关系，我们用思维导图来再次说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/%E6%95%B0%E6%8D%AE.png&#34; alt=&#34;数据.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是由每一个具体的&lt;strong&gt;数据元素&lt;/strong&gt;组成的，相同的数据元素同属于一个&lt;strong&gt;数据对象&lt;/strong&gt;，每个数据元素中又有具体的信息——&lt;strong&gt;数据项&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来让我们再次把这些概念对应到具体的例子”书”中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/%E4%B8%BE%E4%BE%8B_%E4%B8%96%E7%95%8C%E4%B8%8A%E6%89%80%E6%9C%89%E4%B9%A6.png&#34; alt=&#34;举例_世界上所有书.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;世界上所有书就是一个&lt;strong&gt;数据&lt;/strong&gt;，每一本具体的书例如“数据结构与算法”就是一个&lt;strong&gt;数据元素&lt;/strong&gt;，每本书中的具体信息例如“书名、作者、ISBN码&amp;hellip;”就是多个&lt;strong&gt;数据项&lt;/strong&gt;，一些相同类型的书的类型例如“计算机类书籍”就是一个&lt;strong&gt;数据对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在你应该清楚以上4个概念了吧？&lt;/p&gt;
&lt;p&gt;那我们回到最初的问题，什么是&lt;strong&gt;数据结构&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;这里我们同样举例子来说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://py2kq5jlv.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A11%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B9%A6%E7%B1%8D.png&#34; alt=&#34;数据对象1：计算机类书籍.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先，一个类别的书籍中有许多具体的书，如&amp;quot;C语言&amp;quot;、&amp;ldquo;数据结构与算法&amp;rdquo;、&amp;ldquo;编译原理&amp;rdquo;，而这些书之间又有一些&lt;strong&gt;关联&lt;/strong&gt;，比如*&lt;em&gt;某个算法可以用C语言来实现*，&lt;em&gt;&lt;strong&gt;&lt;strong&gt;编译过程中需要用到特定的算法&lt;/strong&gt;等等，这些存在关联的书即&amp;quot;数据元素&amp;quot;的集合就叫做&lt;/strong&gt;数据结构&lt;/em&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相互之间存在一种或多种特定关系的数据元素的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数算法都需要我们适当地组织数据，而为了组织数据就产生了数据结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集合&lt;/p&gt;
&lt;p&gt;线性结构&lt;/p&gt;
&lt;p&gt;树形结构&lt;/p&gt;
&lt;p&gt;网状结构或图状结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;物理结构(储存结构)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序储存结构&lt;/p&gt;
&lt;p&gt;链式储存结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(注：这里不具体展开介绍各个数据结构，在后面的附录里进行介绍)&lt;/p&gt;
&lt;h2 id=&#34;抽象数据类型&#34;&gt;抽象数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指一个数学模型以及定义在该数据模型上的一组操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编写一段计算机程序一般都是实现一种 已有的方法来解决某个问题。这种方法大多 和使用的编程语言无关——它适用于各种计 算机以及编程语言。&lt;/li&gt;
&lt;li&gt;你要在图书馆中找到一本书，需要通过索引查找来确定这本书的位置，这个找书的过程就是一个算法。&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C语言指针</title>
        <link>https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</link>
        <pubDate>Thu, 19 Sep 2019 13:10:25 +0000</pubDate>
        
        <guid>https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/ -&lt;h2 id=&#34;一指针的一些概念&#34;&gt;一、指针的一些概念&lt;/h2&gt;
&lt;h3 id=&#34;1-指针的类型&#34;&gt;1. 指针的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把指针声明语句中的指针名字去掉，剩下的就是&lt;strong&gt;指针本身&lt;/strong&gt;的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-指针所指向的类型&#34;&gt;2. 指针所指向的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把指针声明语句中的指针名字和名字前的指针声明符号*去掉，剩下的就是&lt;strong&gt;指针指向的类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-指针的值指针所指向的内存区或地址&#34;&gt;3. 指针的值——指针所指向的内存区或地址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指针的值是指针本身&lt;strong&gt;存储的数值&lt;/strong&gt;，该值被编译器当作一个地址（在32位程序中，所有类型的指针的值都是一个32位的整数，因为32位程序的内存地址都是32位长。）&lt;/li&gt;
&lt;li&gt;指针所指的&lt;strong&gt;内存区&lt;/strong&gt;就是从指针的值所代表的内存地址开始，长度为&lt;code&gt;sizeof(指针指向的类型)&lt;/code&gt;的一篇内存区。&lt;/li&gt;
&lt;li&gt;我们说&lt;strong&gt;一个指针的值是XX&lt;/strong&gt;，就相当于说&lt;strong&gt;该指针指向了以XX为首地址的一片内存区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;同理，我们说&lt;strong&gt;一个指针指向了某个内存区&lt;/strong&gt;，相当于说&lt;strong&gt;该指针的值是该内存区域的首地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-指针本身所占据的内存区&#34;&gt;4. 指针本身所占据的内存区&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;sizeof(指针的类型)&lt;/code&gt;测试一下就知道了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二指针的算术运算&#34;&gt;二、指针的算术运算&lt;/h2&gt;
&lt;p&gt;**0.**指针可以加上或者减去一个整数，这种运算的意义并不是平常的数值的加减。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example 1&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)a;
ptr&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指针ptr的类型为int*，它指向的类型为int，被初始化为指向整型变量a。&lt;/p&gt;
&lt;p&gt;在第三句中，指针ptr被加上了1，编译器是这样进行处理的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把指针ptr的值加上&lt;code&gt;sizeof(int)&lt;/code&gt;，在32位程序中是被加上了4，因为32位程序中&lt;code&gt;int&lt;/code&gt;占4字节。&lt;/p&gt;
&lt;p&gt;由于地址是用字节作为单位，所以ptr指向的地址由原来的a的地址向高的地方增加了4个地址。&lt;/p&gt;
&lt;p&gt;char类型的长度是一个字节，所以原来的ptr是指向数组a从第0个单元开始的4个字节，现在指向了从第4个单元开始的4个字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;example 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;strong&gt;可以使用&lt;/strong&gt;一个循环&lt;/strong&gt;和&lt;strong&gt;一个指针&lt;/strong&gt;遍历一个数组。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
{
    (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr)&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
    ptr&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该例子中将整形数组中各个单元的值都加1。同时每次循环都将指针加1个单元，所以每次循环都能访问数组的下一个单元。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example 4&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; a[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;You_are_a_girl&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;) a;
ptr &lt;span style=&#34;color:#333&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该例子中，指针ptr被加上了5个单元，编译器这样处理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将char的值加上&lt;code&gt;sizeof(int) * 5&lt;/code&gt;,在32位程序中即乘了4*5=20。&lt;/p&gt;
&lt;p&gt;指针的值代表了该指针以这个值为地址指向了某个内存区，所以指针ptr所指向的地址向高地址的方向移动了20个字节&lt;/p&gt;
&lt;p&gt;然而ptr加上5(即地址增加20个字节后)已经指向了数组a的合法范围之外，虽然应用时会出现问题，但在语法上没有问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;**2.**总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个指针ptrold加或减一个整数n后，结果是一个新的指针ptrnew，两个指针的类型相同，指向的类型也相同。&lt;/p&gt;
&lt;p&gt;ptrnew的值比ptrold的值增加或者减少了&lt;code&gt;n * sizeof(int)&lt;/code&gt;个字节，即ptrnew指向的内存区比ptrold指向的内存区向高或低地址的方向移动了&lt;code&gt;n * sizeof(int)&lt;/code&gt;个字节。&lt;/p&gt;
&lt;p&gt;指针进行加减：两个指针不能进行加法操作，这是非法操作，结果毫无意义。两个类型相同的指针可以进行减法运算，一般在数组上应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三运算符和&#34;&gt;三、运算符&amp;amp;和*&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; &amp;amp;是取地址运算符，*是间接运算符。&lt;/p&gt;
&lt;p&gt;&amp;amp;a 运算的结果是一个指针，指针的类型是 *a，指针指向的类型是a的类型，指针指向的地址是a的地址。&lt;/p&gt;
&lt;p&gt;*p的类型是p指向的类型，所占用的地址是p指向的地址。&lt;/p&gt;
&lt;h2 id=&#34;四指针表达式&#34;&gt;四、指针表达式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; 一个表达式的结果如果叫指针，那么这个表达式就叫指针表达式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;];
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pa;
pa &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;a;&lt;span style=&#34;color:#888&#34;&gt;// &amp;amp;a是指针表达式
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;pa;
&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;b;
pa &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array;
pa&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 指针表达式的结果是一个指针，所以也具有指针的4个要素：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指针的类型&lt;/p&gt;
&lt;p&gt;指针指向的类型&lt;/p&gt;
&lt;p&gt;指针指向的内存区&lt;/p&gt;
&lt;p&gt;指针自身占据的内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 一个指针表达式的结果指针已经具有了自身占据的内存的时候，这个指针表达式就是一个左值，否则就不是一个左值。&lt;/p&gt;
&lt;h2 id=&#34;五指针和数组的关系&#34;&gt;五、指针和数组的关系&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; 数组的数组名可以看作是一个指针&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;9&lt;/span&gt;}, value;
value &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]; &lt;span style=&#34;color:#888&#34;&gt;//or: value = *array;
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;value &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; array[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;]; &lt;span style=&#34;color:#888&#34;&gt;//or: value = *(array + 3);
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;声明一个数组TYPE array[n]，则这个数组名有两重含义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代表整个数组，类型是TYPE[n]。&lt;/p&gt;
&lt;p&gt;是一个常量指针，类型是TYPE*，该指针指向的类型是TYPE，该指针的内存区就是数组的第0号单元，且该指针自己占有单独的内存区，且该指针的值不能修改，array++是错误的写法，这不代表array[1]。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;六指针和结构类型的关系&#34;&gt;六、指针和结构类型的关系&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;结构类型还未学习，之后补充&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;七指针和函数的关系&#34;&gt;七、指针和函数的关系&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;0.&lt;/strong&gt; 可以把一个指针声明成一个指向函数的指针。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;fun1&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pfun1)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
pfun1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fun1;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pfun1)(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;7&lt;/span&gt;);&lt;span style=&#34;color:#888&#34;&gt;//通过函数指针调用函数
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以把指针作为函数的形参。在函数表达式中，可以用指针表达式来作为实参。&lt;/p&gt;
&lt;h2 id=&#34;八指针类型转换&#34;&gt;八、指针类型转换&lt;/h2&gt;
&lt;p&gt;初始化一个指针或者给一个指针赋值时，赋值号左边时一个指针，右边是一个指针表达式。绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和表达式所指向的类型是一样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; f &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;12.3&lt;/span&gt;;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;fptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;f;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们想让指针p指向实数f，我们应该怎样操作？&lt;/p&gt;
&lt;p&gt;是“ p = &amp;amp;f; ”吗？&lt;/p&gt;
&lt;p&gt;不对，因为左右两侧的指针和指针所指向的类型不同。所以直接赋值不行。&lt;/p&gt;
&lt;p&gt;为了实现这个目的，需要使用强制类型转换：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p = (int*) &amp;amp;f;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个指针p，需要把它指向的类型改为&amp;quot;TYPE&amp;quot;，语法格式为：&lt;code&gt;(TYPE*)p;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样的类型转换得到一个新指针，类型为TYPE*，指向的地址就是原指针指向的地址。原来p的一切属性都没有被修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;九指针的安全问题&#34;&gt;九、指针的安全问题&lt;/h2&gt;
- https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 