<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机网络学习日志 on Jialong&#39;s Blog</title>
    <link>http://eternityqjl.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
    <description>Recent content in 计算机网络学习日志 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Thu, 05 Aug 2021 22:23:31 +0800</lastBuildDate><atom:link href="http://eternityqjl.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机网络学习日志（三）——网络层：数据平面</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</link>
      <pubDate>Thu, 05 Aug 2021 22:23:31 +0800</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</guid>
      <description>数据平面指的是网络层中每台路由器的功能，该数据平面功能决定了到达路由器输入链路的数据报如何转发到该路由器的输出链路之一。
而控制平面的功能指的是网络范围的逻辑，控制平面控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。其中包括路由选择算法，以及如今广泛应用的诸如OSPF和BGP等路由选择协议。控制平面和数据平面的功能已经被实现为一个整体，位于一台路由器中。
**软件定义网络（SDN）**通过将这些控制平面的功能作为一种单独的服务，明确分离数据平面和控制平面，控制平面功能通常位于一台远程的控制器中。
网络层概述 转发和路由选择：数据平面和控制平面  转发：将一个分组从路由器的一条输入链路移动到适当的输出链路 路由选择：网络层决定分组从发送方刘翔接收方所采用的路由或路径  转发（forwarding）是路由器本地动作，路由选择（routing）是网络范围处理过程。
路由器通过转发表来实现转发功能。
网络服务模型 网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性：
 确保交付 具有时延上届的确保交付 有序分组交付 确保最小带宽 安全性  因特网的网络层提供了尽力而为服务。并不能对服务做出保证。但尽力而为服务结合适当的玩过带宽已被证明足够好，已被证明能用于大量应用。
路由器工作原理 以下为一个通用的路由器体系结构：
 输入端口：终结输入物理链路的物理层功能；还与位于入链路远端的数据链路层交互来执行数据链路层功能；另外还要执行查找功能，通过查询转发表决定路由器的输出端口 交换结构：将路由器的输入端口连接到它的输出端口 输出端口：从交换结构接收分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组 路由选择处理器：执行控制平面功能。在传统路由器中执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在SDN路由器中，路由选择处理器负责与远程控制器通信，接收其计算的转发表项，并在路由器输入端口安装这些表项。  输入端口处理和基于目的地转发 交换 交换结构是路由器的核心，通过这种交换结构，分组才能实际地从一个输入端口交换到一个输出端口中。
经内存交换：
输入输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。分组到达输入端口时被复制到处理器内存中，路由选择处理器从其首部中提取目的地址，在转发表中找打适当输出端口，并将该分组复制到输出端口的缓存中。该种情况下若内存带宽为每秒可以写进内存或从内存中读出最多B个分组，则总的转发吞吐量必然小于B/2。另外这种方式不同同时转发两个分组，即使它们有不同的分组。
经总线交换：
输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。路由器必须跨过单一总线，所以路由器的交换带宽受总线速率的影响。
经互联网络交换
使用更加复杂的交换网络来客服单一、共享式总线带宽的限制。
例如纵横式交换机就是一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直总线与每条水平总线在交叉点交叉，交叉点通过交换结构控制器控制开启和闭合。
所以纵横式网络能够并行转发多个分组，是非阻塞的。
输出端口处理 选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。
排队 输入排队
输出排队
分组调度 解决排队的分组如何经输出链路传输的问题。
先进先出
FIFO的链路调度规则，如果分组到达时链路正忙，则需要等待链路中的分组传输完成。
优先权排队
不同类型的网络分组有不同的优先权类，每个优先权类通常都有自己的队列。
循环和加权公平排队
在循环排队规则中，分组像使用优先权排队那样被分类，但在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。一个所谓的保持工作排队规则在有分组排队等待传输时，不允许链路保持空闲。当寻找给定的分组但没有找到时，保持工作的循环规则将立即检查循环序列中的下一个类。
一种称为**加权平均排队（Weighted Fair Queuing, WFQ）**规则的通用形式的循环排队已经广泛地实现在路由器中了。WFQ与循环排队的不同在于，每个类在任何时间间隔内可能收到不同数量的服务。每个类i被分配一个权$w_i$，使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接收到的服务部分等于$w_i/(\sum w_j)$，即保证拥有相应权重的带宽。
网际协议IPv4、寻址、IPv6 因特网网络层的网际协议（IP）。
IPv4数据报格式 网络层分组被称为数据报。
  版本号：4比特，规定了数据报的IP协议版本。即区分IPv4和IPv6，路由器根据版本号确定如何处理数据报剩余的部分。
  首部长度：一个IPv4数据报包含一些可变数量的选项，需要用这4比特来确定IP数据报中荷载（被封装的运输层报文）实际开始的地方。大多数数据报不包含选项，所以一般具有20字节的首部长度。
  服务类型：区别不同类型的数据报（例如一些特别要求低时延、高吞吐量或可靠性的数据报）。</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（五）——链路层</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description>概述 将运行链路层协议的设备称为节点，把沿通信链路连接相邻节点的通信信道称为链路。经过特定链路时，节点将数据包封装在链路层帧中，将该帧传送到链路中。
链路层提供的服务：
 成帧：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。 链路接入：**媒体访问控制协议(MAC)**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。 可靠交付：链路层通过确认和重传提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。 差错检验和纠正：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。  链路层协议的实现位置：网络适配器（也成为网卡）来实现。
差错检测和纠正技术 差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。
这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。
奇偶校验 单个奇偶校验位：
  假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。
  接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。
  但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为50%。
  二维奇偶校验：
  将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。
  出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。
  接收方检测和纠正差错的能力被称为前向纠错（Forward Error Correction，FEC）。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。
检验和 将d比特数据当作一个k比特的整数序列处理。因特网检验和是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果是否全为1比特来检验。如果这些比特中存在0比特，则出现差错。
检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。
循环冗余检测（CRC） 冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。
考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为G。我们要求G的最高位有效比特为1.
对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。
用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。
多路访问链路和协议 网络链路的分类：
 点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。 广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。  多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。
因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。
我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。
信道划分协议 时分多路复用（TDM）
假设一个支持N个节点的信道传输速率为R bps。
 TDM将时间划分为时间帧（Frame），并进一步把每个时间帧划分为N个时隙（slot），把每个时隙分配给N个节点中的一个。 无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。 TDM消除了碰撞且非常公平，但存在以下缺点：  节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。 节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。    频分多路复用（FDM）</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（二）——运输层</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
      <pubDate>Wed, 06 May 2020 21:27:10 +0000</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
      <description>&lt;h2 id=&#34;概述和运输层服务&#34;&gt;概述和运输层服务&lt;/h2&gt;
&lt;p&gt;运输层协议在不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;，这并非物理上的实际通信。在发送端，运输层将从应用程序接收到的报文转换成运输层分组，该分组称为&lt;strong&gt;运输层报文段&lt;/strong&gt;，实现方法是将应用报文划分为一个个小的块，为每个块加上运输层首部生成运输层报文段，然后在端系统中传递给网络层，网络层将其封装成网络层分组，向目的地发送。&lt;/p&gt;
&lt;p&gt;因特网由TCP和UDP两种运输层协议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TLS（HTTPS）协议</title>
      <link>http://eternityqjl.top/posts/tls/</link>
      <pubDate>Sun, 19 Apr 2020 16:15:26 +0000</pubDate>
      
      <guid>http://eternityqjl.top/posts/tls/</guid>
      <description>1. SSL/TLS简介 TLS（Transport Layer Security，传输层安全协议），以及它的前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议。Netscape公司在1994年推出HTTPS协议，使用SSL进行加密，这是SSL的起源。1999年公布了第一版的TLS协议，类似于SLLv3，只是对其做出了一些更改。
SSL协议处在计算机网络中的应用层和运输层之间，它不依赖于平台和运行程序的协议。
几个知名的使用SSL加密的协议：
HTTP over SSL (HTTPS)
简称为HTTPS，它的产生是为了加密网页，HTTP是第一个使用SSL保障安全的应用层协议。HTTPS在RFC2818被标准化，HTTPS工作在443端口，HTTP默认工作在80端口。
Email over SSL
类似于HTTP over SSL，协议如下：
 SMTP、IMAP能够支持SSL SMTP over TLS在标准文档RFC2487中  2. SSL原理详解 2.0 基本运行过程 SSL/TLS协议是采用公钥加密法实现的，客户端先向服务器端索要公钥，用公钥加密信息，服务器收到密文后，用自己的私钥解密；二者协商生成”对话密钥“，采用该”对话密钥“进行加密通信。
2.1 SSL建立的总过程 客户端向服务器索要并验证公钥，双方协商生成”对话密钥“的过程又称为”握手阶段“，该阶段涉及四次握手通信，且该阶段的通信都是明文的。以下一一来分析。
1. 客户端发出请求（ClientHello） 该步客户端（通常为浏览器）向服务器提供以下信息：
 支持的协议版本（Version），如TLSv1.0 一个客户端生成的随机数（Random），之后用于生成”对话密钥“ 会话ID（Session id）：  如果客户端第一次连接到服务器，那么该字段为空。 如果该字段不为空，则说明以前与服务器有连接，在此期间，服务器使用Session ID映射对称密钥，并将Session ID存储在客户端浏览器中，为映射设置一个时间限，如果浏览器将来连接到同一台服务器，它将发送Session ID，服务器对映射的Session ID进行验证，并使用以前用过的对称密钥来恢复会话，该情况下不需要握手，也成为SSL会话恢复。   支持的加密套件（Cipher Suites），这是由客户按优先级排列的，但完全由服务器决定发送与否。服务器会从客户端发送的加密套件中选择一种作为共同的加密套件，如RSA公钥加密。 支持的压缩方法，这是为了减少带宽。从TLS 1.3开始，协议禁用了TLS压缩，因为使用压缩时攻击可以捕获到用HTTP头发送的参数，该攻击可以劫持Cookie。 扩展包。  2. 服务器回应（ServerHello） 该步骤包含以下内容：
 确认使用的版本，如TLSv1.0，如果浏览器与服务器支持的版本不一致，服务器会关闭加密通信。 一个服务器生成的随机数，之后用于生成”对话密钥“ 确认使用的加密套件 会话ID（Session ID）：  服务器将约定的Session参数存储在TLS缓存中，并生成与之对应的Session ID，它将与ServerHello一起发送到客户端。客户端可以写入约定的参数到此Session ID，并给定到期时间，客户端将在ClientHello中包含该ID。如果客户端再次连接到该服务器，服务器可以检查与Session ID对应的缓存参数，并重用他们而无需再次握手。这可以节省大量计算成本。 但在谷歌等大流量应用程序中这种方法存在缺点，每天有数百万人连接到服务器，服务器必须使用Session ID保留所有Session参数的TLS缓存，这是一笔巨大的开销。为解决该问题，在扩展包中加入Session Tickets，在这里客户端可以在ClientHello中指定它是否支持Session Tickets，然后服务器将创建一个新的Session Tickets，并使用只有服务器知道的经过私钥加密的Session参数，该参数存储在客户端中，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。   扩展包 服务器证书  当服务器需要确认客户端身份时，就会再包含一个请求，要求客户端提供”客户端证书“。例如金融机构只允许认证客户连入自己的网络，回向正式用户提供USB密钥（U盾），里面包含一张客户端证书。</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（一）——应用层</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</link>
      <pubDate>Thu, 28 Nov 2019 19:23:38 +0000</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
      <description>应用层是计算机网络从上往下的第一层，这一层的主要内容是网络应用的原理和实现，通过学习几种常见的网络应用程序，并且开发运行在TCP和UTP(运输层)上的网络应用程序，这些应用程序包含Web、电子邮件、DNS、P2P等等。
应用层协议 开发网络应用程序是要开发运行在不同端系统上并且通过网络(下层协议)彼此通信的程序，这过程中不需要为下层的网络核心设备写程序，因为它们不在应用层上起作用。
网络应用程序体系结构 客户——服务器体系结构：
 客户：发送主机请求 服务器：总是打开的主机，接收来自客户的请求  举例：Web应用程序
P2P体系结构
 对于数据中心服务器几乎没有依赖。 应用程序在对等方之间直接通信 具有自扩展性，报文在主机之间直接发送，服务器用来追踪IP，有安全隐患。  举例：BitTorrent、Skype
进程通信 端系统之间的通信实际上是进程，进程通过跨越网络发送报文来进行通信。进程是运行在端系统上的程序，同一个端系统和不同端系统之间的进程都可以进行通信，这里主要讨论不同端系统之间跨越网络的通信。
客户与服务器之间的进程：
 客户-服务器体系中，比如Web服务器，一个进程被标识为客户(Client)，另一个进程被标识为服务器(Server)。 P2P体系中，一个进程既可以是客户又可以是服务器。  进程与网络之间的接口——套接字：
套接字(端口号)是应用程序和运输层之间的接口，也成为应用程序编程接口。
进程寻址：
为了向特定的目的地发送报文，需要有目的地主机的相关信息，这些信息为：
 IP地址：用来标识目的地主机。 端口号：用来指定接受进程(即接受套接字)，例如Web服务器用端口号80标识，邮件服务器进程用25标识。  供应用程序使用的运输服务 开发应用程序时，需要选择一种适合的运输层协议，运输层协议能够提供的服务主要有以下：
  可靠数据传输：进程与进程之间的可靠数据传输，有不提供可靠数据传输的应用层协议，使用这种应用层协议的应用被称为容忍丢失的应用。
  吞吐量：发送进程向接收进程交付比特的速率，所以运输层协议可以提供以特定速率确保的可用吞吐量的服务，对此有需求的应用称为带宽敏感应用，如一些多媒体语音和视频应用。
  定时（延迟）：例子：发送方注入比特至套接字到接收方烧到比特的时间不多于100ms，这对于实时交互应用很重要，例如多方射击游戏。
  因特网提供和未提供的运输服务 因特网为应用程序提供两个运输层协议，TCP和UDP，开发者必须做出选择。
TCP服务：
 面向连接服务：报文数据流动前，TCP让客户和服务器交换运输层控制信息(即握手)，之后一个TCP连接就建立了，这条连接是全双工的，应用程序运行结束后要拆除该连接。 可靠数据传输服务：无差错、按顺序交付报文。 拥塞控制机制   安全套接字层(Secure Sockets Layer, SSL)，是加强版的TCP协议，提供了进程之间的安全加密服务，这种强化是在应用层上实现的。
 UDP服务：
是一种轻量运输协议，进程通信时无握手过程，不保证到达，同时无拥塞控制机制。
 注，这里只是简要的内容，更多详细内容将在第三章运输层中提到。
 未提供的服务：
以上两个协议提供了可靠数据传输、安全性相关的服务，但并未提供2.3中所述的吞吐量和定时的服务，所以因特网并不提供这两项服务。虽然未提供具体的服务，但因特网已经运行很多年，对于时间敏感的应用已经被设计得尽可能应对这种保证的缺乏。
应用层协议总结 应用层协议定义了以下内容：
 交换的报文类型，如请求和响应报文 报文语法 字段语义 确定进程何时发送报文  Web和HTTP HTTP概况 **超文本传输协议（HyperText Transfer Protocol，HTTP）**是Web的应用层协议，它由客户程序和服务器程序实现，客户和服务器运行在不同端系统中，通过HTTP报文进行会话。</description>
    </item>
    
  </channel>
</rss>
