<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机网络学习日志 on Jialong&#39;s Blog</title>
    <link>http://eternityqjl.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
    <description>Recent content in 计算机网络学习日志 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sun, 01 Aug 2021 20:20:52 +0800</lastBuildDate><atom:link href="http://eternityqjl.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机网络学习日志（五）——链路层</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description>概述 将运行链路层协议的设备称为节点，把沿通信链路连接相邻节点的通信信道称为链路。经过特定链路时，节点将数据包封装在链路层帧中，将该帧传送到链路中。
链路层提供的服务：
 成帧：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。 链路接入：**媒体访问控制协议（MAC）**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。 可靠交付：链路层通过确认和重传提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。 差错检验和纠正：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。  链路层协议的实现位置：网络适配器（也成为网卡）来实现。
差错检测和纠正技术 差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。
这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。
奇偶校验 单个奇偶校验位：
  假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。
  接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。
  但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为50%。
  二维奇偶校验：
  将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。
  出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。
  接收方检测和纠正差错的能力被称为前向纠错（Forward Error Correction，FEC）。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。
检验和 将d比特数据当作一个k比特的整数序列处理。因特网检验和是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果是否全为1比特来检验。如果这些比特中存在0比特，则出现差错。
检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。
循环冗余检测（CRC） 冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。
考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为G。我们要求G的最高位有效比特为1.
对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。
用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。
多路访问链路和协议 网络链路的分类：
 点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。 广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。  多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。
因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。
我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。
信道划分协议 时分多路复用（TDM）
假设一个支持N个节点的信道传输速率为R bps。
 TDM将时间划分为时间帧（Frame），并进一步把每个时间帧划分为N个时隙（slot），把每个时隙分配给N个节点中的一个。 无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。 TDM消除了碰撞且非常公平，但存在以下缺点：  节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。 节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。    频分多路复用（FDM）</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（二）——运输层</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
      <pubDate>Wed, 06 May 2020 21:27:10 +0000</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
      <description>&lt;h2 id=&#34;概述和运输层服务&#34;&gt;概述和运输层服务&lt;/h2&gt;
&lt;p&gt;运输层协议在不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;，这并非物理上的实际通信。在发送端，运输层将从应用程序接收到的报文转换成运输层分组，该分组称为&lt;strong&gt;运输层报文段&lt;/strong&gt;，实现方法是将应用报文划分为一个个小的块，为每个块加上运输层首部生成运输层报文段，然后在端系统中传递给网络层，网络层将其封装成网络层分组，向目的地发送。&lt;/p&gt;
&lt;p&gt;因特网由TCP和UDP两种运输层协议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TLS（HTTPS）协议</title>
      <link>http://eternityqjl.top/posts/tls/</link>
      <pubDate>Sun, 19 Apr 2020 16:15:26 +0000</pubDate>
      
      <guid>http://eternityqjl.top/posts/tls/</guid>
      <description>1. SSL/TLS简介 TLS（Transport Layer Security，传输层安全协议），以及它的前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议。Netscape公司在1994年推出HTTPS协议，使用SSL进行加密，这是SSL的起源。1999年公布了第一版的TLS协议，类似于SLLv3，只是对其做出了一些更改。
SSL协议处在计算机网络中的应用层和运输层之间，它不依赖于平台和运行程序的协议。
几个知名的使用SSL加密的协议：
HTTP over SSL (HTTPS)
简称为HTTPS，它的产生是为了加密网页，HTTP是第一个使用SSL保障安全的应用层协议。HTTPS在RFC2818被标准化，HTTPS工作在443端口，HTTP默认工作在80端口。
Email over SSL
类似于HTTP over SSL，协议如下：
 SMTP、IMAP能够支持SSL SMTP over TLS在标准文档RFC2487中  2. SSL原理详解 2.0 基本运行过程 SSL/TLS协议是采用公钥加密法实现的，客户端先向服务器端索要公钥，用公钥加密信息，服务器收到密文后，用自己的私钥解密；二者协商生成”对话密钥“，采用该”对话密钥“进行加密通信。
2.1 SSL建立的总过程 客户端向服务器索要并验证公钥，双方协商生成”对话密钥“的过程又称为”握手阶段“，该阶段涉及四次握手通信，且该阶段的通信都是明文的。以下一一来分析。
1. 客户端发出请求（ClientHello） 该步客户端（通常为浏览器）向服务器提供以下信息：
 支持的协议版本（Version），如TLSv1.0 一个客户端生成的随机数（Random），之后用于生成”对话密钥“ 会话ID（Session id）：  如果客户端第一次连接到服务器，那么该字段为空。 如果该字段不为空，则说明以前与服务器有连接，在此期间，服务器使用Session ID映射对称密钥，并将Session ID存储在客户端浏览器中，为映射设置一个时间限，如果浏览器将来连接到同一台服务器，它将发送Session ID，服务器对映射的Session ID进行验证，并使用以前用过的对称密钥来恢复会话，该情况下不需要握手，也成为SSL会话恢复。   支持的加密套件（Cipher Suites），这是由客户按优先级排列的，但完全由服务器决定发送与否。服务器会从客户端发送的加密套件中选择一种作为共同的加密套件，如RSA公钥加密。 支持的压缩方法，这是为了减少带宽。从TLS 1.3开始，协议禁用了TLS压缩，因为使用压缩时攻击可以捕获到用HTTP头发送的参数，该攻击可以劫持Cookie。 扩展包。  2. 服务器回应（ServerHello） 该步骤包含以下内容：
 确认使用的版本，如TLSv1.0，如果浏览器与服务器支持的版本不一致，服务器会关闭加密通信。 一个服务器生成的随机数，之后用于生成”对话密钥“ 确认使用的加密套件 会话ID（Session ID）：  服务器将约定的Session参数存储在TLS缓存中，并生成与之对应的Session ID，它将与ServerHello一起发送到客户端。客户端可以写入约定的参数到此Session ID，并给定到期时间，客户端将在ClientHello中包含该ID。如果客户端再次连接到该服务器，服务器可以检查与Session ID对应的缓存参数，并重用他们而无需再次握手。这可以节省大量计算成本。 但在谷歌等大流量应用程序中这种方法存在缺点，每天有数百万人连接到服务器，服务器必须使用Session ID保留所有Session参数的TLS缓存，这是一笔巨大的开销。为解决该问题，在扩展包中加入Session Tickets，在这里客户端可以在ClientHello中指定它是否支持Session Tickets，然后服务器将创建一个新的Session Tickets，并使用只有服务器知道的经过私钥加密的Session参数，该参数存储在客户端中，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。   扩展包 服务器证书  当服务器需要确认客户端身份时，就会再包含一个请求，要求客户端提供”客户端证书“。例如金融机构只允许认证客户连入自己的网络，回向正式用户提供USB密钥（U盾），里面包含一张客户端证书。</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（一）——应用层</title>
      <link>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</link>
      <pubDate>Thu, 28 Nov 2019 19:23:38 +0000</pubDate>
      
      <guid>http://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
      <description>应用层是计算机网络从上往下的第一层，这一层的主要内容是网络应用的原理和实现，通过学习几种常见的网络应用程序，并且开发运行在TCP和UTP(运输层)上的网络应用程序，这些应用程序包含Web、电子邮件、DNS、P2P等等。
应用层协议 开发网络应用程序是要开发运行在不同端系统上并且通过网络(下层协议)彼此通信的程序，这过程中不需要为下层的网络核心设备写程序，因为它们不在应用层上起作用。
网络应用程序体系结构 客户——服务器体系结构：
 客户：发送主机请求 服务器：总是打开的主机，接收来自客户的请求  举例：Web应用程序
P2P体系结构
 对于数据中心服务器几乎没有依赖。 应用程序在对等方之间直接通信 具有自扩展性，报文在主机之间直接发送，服务器用来追踪IP，有安全隐患。  举例：BitTorrent、Skype
进程通信 端系统之间的通信实际上是进程，进程通过跨越网络发送报文来进行通信。进程是运行在端系统上的程序，同一个端系统和不同端系统之间的进程都可以进行通信，这里主要讨论不同端系统之间跨越网络的通信。
客户与服务器之间的进程：
 客户-服务器体系中，比如Web服务器，一个进程被标识为客户(Client)，另一个进程被标识为服务器(Server)。 P2P体系中，一个进程既可以是客户又可以是服务器。  进程与网络之间的接口——套接字：
套接字(端口号)是应用程序和运输层之间的接口，也成为应用程序编程接口。
进程寻址：
为了向特定的目的地发送报文，需要有目的地主机的相关信息，这些信息为：
 IP地址：用来标识目的地主机。 端口号：用来指定接受进程(即接受套接字)，例如Web服务器用端口号80标识，邮件服务器进程用25标识。  供应用程序使用的运输服务 开发应用程序时，需要选择一种适合的运输层协议，运输层协议能够提供的服务主要有以下：
  可靠数据传输：进程与进程之间的可靠数据传输，有不提供可靠数据传输的应用层协议，使用这种应用层协议的应用被称为容忍丢失的应用。
  吞吐量：发送进程向接收进程交付比特的速率，所以运输层协议可以提供以特定速率确保的可用吞吐量的服务，对此有需求的应用称为带宽敏感应用，如一些多媒体语音和视频应用。
  定时（延迟）：例子：发送方注入比特至套接字到接收方烧到比特的时间不多于100ms，这对于实时交互应用很重要，例如多方射击游戏。
  因特网提供和未提供的运输服务 因特网为应用程序提供两个运输层协议，TCP和UDP，开发者必须做出选择。
TCP服务：
 面向连接服务：报文数据流动前，TCP让客户和服务器交换运输层控制信息(即握手)，之后一个TCP连接就建立了，这条连接是全双工的，应用程序运行结束后要拆除该连接。 可靠数据传输服务：无差错、按顺序交付报文。 拥塞控制机制   安全套接字层(Secure Sockets Layer, SSL)，是加强版的TCP协议，提供了进程之间的安全加密服务，这种强化是在应用层上实现的。
 UDP服务：
是一种轻量运输协议，进程通信时无握手过程，不保证到达，同时无拥塞控制机制。
 注，这里只是简要的内容，更多详细内容将在第三章运输层中提到。
 未提供的服务：
以上两个协议提供了可靠数据传输、安全性相关的服务，但并未提供2.3中所述的吞吐量和定时的服务，所以因特网并不提供这两项服务。虽然未提供具体的服务，但因特网已经运行很多年，对于时间敏感的应用已经被设计得尽可能应对这种保证的缺乏。
应用层协议总结 应用层协议定义了以下内容：
 交换的报文类型，如请求和响应报文 报文语法 字段语义 确定进程何时发送报文  Web和HTTP HTTP概况 **超文本传输协议（HyperText Transfer Protocol，HTTP）**是Web的应用层协议，它由客户程序和服务器程序实现，客户和服务器运行在不同端系统中，通过HTTP报文进行会话。</description>
    </item>
    
  </channel>
</rss>
