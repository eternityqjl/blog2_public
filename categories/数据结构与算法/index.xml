<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构与算法 on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构与算法 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Thu, 23 Jul 2020 14:59:12 +0000</lastBuildDate><atom:link href="https://eternityqjl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《算法（第4版）》学习笔记——（一）排序</title>
      <link>https://eternityqjl.github.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 23 Jul 2020 14:59:12 +0000</pubDate>
      
      <guid>https://eternityqjl.github.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</guid>
      <description>初级排序算法 选择排序 算法描述 首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。
代码实现 public class Selection { public static void sort(Comparable[] a) { //将a按照升序排列  int N = a.length; for (int i = 0; i &amp;lt; N; i++) { int min = i; for (int j = i + 1; j &amp;lt; N; j++) { if (less(a[j], a[min])) min = j; } exch(a, i ,min); } } } 性能分析  对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。 该算法运行时间与输入无关，数据的移动是最少的。  插入排序 算法描述 插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。
代码实现 public class Insertion { public static void sort(Comparable[] a) { int N = a.</description>
    </item>
    
    <item>
      <title>Dijkstra双栈——算术表达式求值</title>
      <link>https://eternityqjl.github.io/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Tue, 21 Jul 2020 20:15:08 +0000</pubDate>
      
      <guid>https://eternityqjl.github.io/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>算数表达式 这里的算术表达式支持常见的二元运算符+-*/以及接受一个参数的平方根运算符sqrt。这里我们假定表达式中未省略所有的括号。
计算方法  将操作数压入操作数栈 将运算符压入运算符栈 忽略左括号 遇到右括号时，弹出一个运算符，弹出需要数量的操作数进行运算，然后将得到的结果再压入操作数栈。  代码实现 package edu.princeton.cs.algs4; public class Evaluate { public static void main(String[] args) { Stack&amp;lt;String&amp;gt; ops = new Stack&amp;lt;String&amp;gt;(); Stack&amp;lt;Double&amp;gt; vals = new Stack&amp;lt;Double&amp;gt;(); while (!StdIn.isEmpty()) { //读取字符，如果是运算符则压入运算符栈ops 	String s = StdIn.readString(); if (s.equals(&amp;#34;(&amp;#34;)); else if (s.equals(&amp;#34;+&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;-&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;*&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;/&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;sqrt&amp;#34;)) ops.push(s); //如果字符为)，则弹出运算符和操作数，计算结果并压入操作数栈vals 	else if (s.equals(&amp;#34;)&amp;#34;)) { String op = ops.</description>
    </item>
    
    <item>
      <title>抽象数据类型</title>
      <link>https://eternityqjl.github.io/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 24 Sep 2019 21:33:07 +0000</pubDate>
      
      <guid>https://eternityqjl.github.io/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>一、抽象数据类型的实现 //数据类型的实现 public class Counter { //实例变量  private final String name; private int count; //构造函数  public void Counter(String id) { name = id; } //实例方法  public void increment() { count++; } public int tally() { return count; } public String toString() { return count + &amp;#34; &amp;#34; + name; } } //测试该数据类型的用例 public static void main(String[] args) { //创建并初始化对象  Counter heads = new Counter(&amp;#34;heads&amp;#34;); Counter tails = new Counter(&amp;#34;tails&amp;#34;); //调用实例方法  heads.</description>
    </item>
    
    <item>
      <title>什么是数据结构？什么又是算法？</title>
      <link>https://eternityqjl.github.io/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 19 Sep 2019 13:55:19 +0000</pubDate>
      
      <guid>https://eternityqjl.github.io/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</guid>
      <description>数据结构及相关概念 0. 要想知道什么是数据结构，首先要了解与“数据”相关的概念，这样才能一步步理解什么是数据结构。
我们首先用放书这件事情来举例。
 如果正常情况下只有你自己一个人的书，那么你把他们一本一本立起来放在书架上就可以了。 那么如果有一个图书馆那么多的书应该怎样办么？总不能把他们乱起八糟的立起来放吧？那么是不是应该先按照社会科学、理科类、工科类、外语类等等的分类方式先分类，然后按照具体所属的类别把他们一个个放进去？其实数据结构的相关的概念就是一个这样简单的道理。  下面我们来进行具体的描述。
1. 数据
 是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 其实就对应了图书馆中的所有书。  2. 数据元素
 是数据的基本单位，在计算机程序中通常作为一个整体进行考虑号处理。 对应的就是某一本具体的书，比如”数据结构与算法“这本书。  3. 数据项
 一个数据元素可由若干个数据项组成，数据项是数据的不可分割的最小单位。 数据项不就是对应了书中的具体信息，比如书的作者、章节内容、ISBN编号等等。  4. 数据对象
 是性质相同的数据元素的集合，是数据的子集。 数据元素是一本具体的书，那么性质相同数据元素的集合不就代表了一类具体的书籍吗，就比如计算机类的书籍，其中包含了”数据机构与算法这本书“。   看到这儿是不是对这几者的关系还有点儿晕？没关系，我们用思维导图来再次说明。
数据是由每一个具体的数据元素组成的，相同的数据元素同属于一个数据对象，每个数据元素中又有具体的信息——数据项。
 接下来让我们再次把这些概念对应到具体的例子”书”中。
世界上所有书就是一个数据，每一本具体的书例如“数据结构与算法”就是一个数据元素，每本书中的具体信息例如“书名、作者、ISBN码&amp;hellip;”就是多个数据项，一些相同类型的书的类型例如“计算机类书籍”就是一个数据对象。
现在你应该清楚以上4个概念了吧？
那我们回到最初的问题，什么是数据结构？
这里我们同样举例子来说明。
首先，一个类别的书籍中有许多具体的书，如&amp;quot;C语言&amp;quot;、&amp;ldquo;数据结构与算法&amp;rdquo;、&amp;ldquo;编译原理&amp;rdquo;，而这些书之间又有一些关联，比如*某个算法可以用C语言来实现*，编译过程中需要用到特定的算法等等，这些存在关联的书即&amp;quot;数据元素&amp;quot;的集合就叫做数据结构。
4. 数据结构
  相互之间存在一种或多种特定关系的数据元素的集合。
  大多数算法都需要我们适当地组织数据，而为了组织数据就产生了数据结构。
  结构
 逻辑结构
 集合
线性结构
树形结构
网状结构或图状结构
 物理结构(储存结构)
 顺序储存结构
链式储存结构
    (注：这里不具体展开介绍各个数据结构，在后面的附录里进行介绍)</description>
    </item>
    
  </channel>
</rss>
