<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/posts/</link>
    <description>Recent content in Posts on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Mon, 06 Dec 2021 20:37:41 +0800</lastBuildDate><atom:link href="https://eternityqjl.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法——基础排序算法的实现</title>
      <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 06 Dec 2021 20:37:41 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>选择排序 void selectSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); for (int i = 0; i &amp;lt; n; i++) { int min = i; for (int j = i+1; j &amp;lt; N; j++) if (a[j] &amp;lt; a[min]) min = j; swap(nums[i], nums[min]); } } 插入排序 void insertSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) { } 时间复杂度为$O(n^2)$，算法稳定。
希尔排序 void shellSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); int = h = n / 2; while (h &amp;gt;= 1) {	//h有序数组  for (int i = h; i &amp;lt; N; i++) { for (int j = i; j &amp;gt;= h &amp;amp;&amp;amp; nums[j] &amp;lt;= nums[j - h]; j -= h) swap() } } } n在某个特定范围内时，希尔排序的时间复杂度约为$O(n^{1.</description>
    </item>
    
    <item>
      <title>算法——堆排序和优先队列</title>
      <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 06 Dec 2021 14:26:53 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
      <description>优先队列 优先队列如同其字面意思，是一种支持删除最大元素和插入元素的一种数据结构。
二叉堆是一棵有序的完全二叉树，可以很好地实现优先队列。使用二叉堆实现优先队列可以保证插入元素和删除最大元素的操作在$\log N$的时间内完成。
我们通常使用数组来实现二叉堆。
堆 堆的有序化 sink——自上而下的有序化
void sink(vector&amp;lt;int&amp;gt;&amp;amp; nums, int i, int heapSize) {	//i为数组下标  while (2i &amp;lt; heapSize) { int j = 2i; if (j &amp;lt; heapSize - 1 &amp;amp;&amp;amp; nums[j] &amp;lt; nums[j+1])	j++; if (!(nums[i] &amp;lt; nums[j]))	break; swap(nums[i], nums[j]); i = j; } } swim——自下而上的有序化
void swim(vector&amp;lt;int&amp;gt;&amp;amp; nums, int x) {//x为插入末尾的元素  nums.push_back(x); int k = nums.size() - 1; while (k &amp;gt; 0 &amp;amp;&amp;amp; nums[k/2] &amp;lt; nums[k]) { swap(nums[k/2], nums[k]); k = k/2; } } 构建大根堆 void buildMaxHeap(vector&amp;lt;int&amp;gt;&amp;amp; nums) {	//使用sink从上向下构建大根堆  int heapSize = nums.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH18 用于大型工程的工具——命名空间</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Fri, 03 Dec 2021 11:21:29 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
      <description>命名空间 大型程序往往使用多个独立开发的库，这些库又会定义大量全局名字，如类、函数、模板。当应用程序使用到多个供应商提供的库时，不可避免会发生某些名字的冲突。多个库名字放置在全局命名空间中会引发命名空间污染。
命名空间提供了防止污染的可控机制。命名空间分隔了全局命名空间，每个命名空间是一个作用域。通过某个命名空间定义库名，可以避免全局名字固有的限制。
定义命名空间 命名空间既可以定义在全局作用域中，也可以定义在其他命名空间中，但不能定义在函数或类的内部。
每个命名空间都是一个作用域
位于该命名空间之外的代码必须明确指出所用的名字属于哪个命名空间。
命名空间可以是不连续的
namespace nsp { //相关声明 } 可能定义了一个新命名空间，可以能为已存在的命名空间添加一些新成员。
因此我们可以将几个独立的接口和实现文件组成一个命名空间。其组织方式类似于我们管理自定义类及函数的方式：
 命名空间中是定义类、声明作为类接口的函数及对象的部分，放置于头文件中，然后将这些头文件包含在使用了这些成员的文件中 命名空间成员的定义部分则置于另外的源文件中  程序中某些实体只能定义一次，如内联函数、变量等。命名空间中的定义也要满足这一要求。即接口与实现分离的机制。
另外，我们不把#include放在命名空间内部。这样做的隐含意思是把头文件中所有名字定义成该命名空间的成员，这很有可能导致错误，例如可能将std命名空间嵌套在自己的命名空间内。
定义命名空间成员
命名空间中的名字可以直接使用名字，此时无需前缀。
另外也可以将命名空间的外部定义该命名空间的成员，需要有完整的前缀。命名空间对于名字的声明必须在作用域内，同时改名字的定义需要明确指出其所属的命名空间。
namespace cpp_primer { std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream&amp;amp; in, Sales_data&amp;amp; s) {} } 模板特例化
模板特例化必须定义在原始模板所属的命名空间中。只要我们在命名空间中声明了特例化，就能在命名空间外部定义它：
namespace std { template &amp;lt;&amp;gt; struct hash&amp;lt;Sales_data&amp;gt;; } template &amp;lt;&amp;gt; struct std::hash&amp;lt;Sales_data&amp;gt; { .... } 全局命名空间
全局作用域中定义的名字即定义在全局命名空间中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。
作用域运算符同样可以用于全局作用域成员：(因为其是隐式地，所以没有名字)
::nember_name 内联命名空间
C++ 11引入的新的嵌套命名空间，称为内联命名空间。内联命名空间中的名字可以被外层命名空间直接使用。即无需在内联命名空间的名字前添加表示该命名空间的前缀。
inline namespace FifthEd { } namespace FifthEd { ... } 关键字inline必须出现在命名空间第一次定义的地方，后续再打开时可以不写inline。
当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常用到内联命名空间。我们可以将当前版本的所有代码都放在一个内联命名空间中，把之前版本的代码都放在一个非内联命名空间中。这样在使用时，使用当前版本的成员的代码无需加前缀，如需使用之前版本的代码，则需加上完整的外层命名空间名字。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH15 面向对象程序设计</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 03 Dec 2021 11:10:28 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。
本章介绍剩余的继承和动态绑定。通过这两种特性我们可以更容易地定义与其他类相似但不完全相同的新类；另外在使用这些彼此相似的类编写函数时。我们可以在一定程度上忽略掉它们的区别。
OOP：概述 继承 通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个基类，其他类别从基类继承而来，这些继承而来的类称为派生类。基类负责定义所有类共同拥有的成员，而每个派生类定义各自特有的成员。
对于某些函数，基类希望它的派生类各自定义适合自己的版本，此时基类就将这些函数声明成虚函数：
class Quote { public: std::string isbn() const; virtual double net_price(std::size_t n)	const; }; 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的。
类派生列表的形式：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类列表前面可以有访问说明符：
class Bulk_quote : public Quote { public: double net_price(std::size_t n)	const override; } 完全可以把Bulk_quote的对象当作Quote的对象来使用。
派生类必须在其内部对所有重新定义的虚函数进行声明。C++11 允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，方法是在该函数的形参列表之后增加一个override关键字。
动态绑定 又称为运行时绑定，根据运行时传入的实参选择函数的版本。通过动态绑定，我们可以用同一段代码分别处理Quote和Bulk_quote的对象。
定义基类和派生类 定义基类 继承关系中的根节点的类通常会定义一个虚析构函数。
对于一些操作，派生类需要提供自己的新定义以覆盖（override）从基类继承而来的就定义。需要覆盖的函数，基类通常将其定义为虚函数。
成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。
任何构造函数之外的非静态函数都可以是虚函数。virtual只能出现在类内部的声明语句。
访问控制与继承
一般情况下派生类可以继承定义在基类中的成员，但派生类的成员函数没有权限访问从基类继承而来的成员，派生类只能访问公有成员，不能访问私有成员。而有一种成员，基类希望它的派生类有权限访问该成员，同时禁止其他用户访问，我们使用受保护的（protected）访问运算符说明该成员。
定义派生类 派生类必须通过使用类派生列表明确指出从哪个（哪些）基类继承而来的。
类派生列表的形式：冒号后紧跟以逗号分隔的基类列表，每个基类前面可以有三个访问说明符中的一个：public、protected或private。
class Bulk_quote : public Quote {	//Bulk_quote继承自Quote  }; 访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。
如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分；此外还能将公有派生类型的对象绑定到基类的引用或指针上。
Quote item;	//基类对象 Bulk_quote bulk;	//派生类对象 Quote *p = &amp;amp;item;	//p指向Quote对象 p = &amp;amp;bulk;	//p指向bulk的Quote部分 Quote &amp;amp;r = bulk;	//r绑定到bulk的Quote部分 派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这样做。</description>
    </item>
    
    <item>
      <title>Cpp程序的内存分配</title>
      <link>https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Thu, 02 Dec 2021 21:54:01 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>栈stack &amp;amp; 堆heap  栈区stack：由编译器自动分配和释放，用来存放函数的参数值、局部变量的值。按内存地址由高往低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。 堆区heap：一般由程序员分配和释放，用来创建动态内存。按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。  .data &amp;amp; .bss &amp;amp; .text  全局区.data(gvar)：程序中已经初始化的非零全局变量、静态变量，程序结束后由系统释放 .bss：存放程序中未初始化的全局变量和静态变量，以及所有被初始化为0的全局或静态变量。目标文件中这个节不占据实际空间，仅仅是一个占位符。 程序代码区.text：存放已编译程序的机器代码  text和data节都在可执行文件中，.bss不在可执行目标文件中，由系统自动生成。
宏定义不占用内存和编译时间。
new与malloc的区别 malloc是面向内存的，想要多大内存就分配多大。而new是面向对象的，根据执行的对象类型来申请空间，并能够内部调用构造函数生成对象。</description>
    </item>
    
    <item>
      <title>typedef和define宏详解</title>
      <link>https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Dec 2021 19:43:11 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/</guid>
      <description>typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。
当const和typedef一起出现时，typedef不会是简单的字符串替换就行。
typedef常用来定义一个标识符及关键字的别名，它是语言编译过程的一部分，但它并不实际分配内存空间
#define为一宏定义语句，通常用它来定义常量(包括无参量与带参量)，以及用来实现那些“表面似和善、背后一长串”的宏，它本身并不在编译过程中进行，而是在这之前(预处理过程)就已经完成了，但也因此难以发现潜在的错误及其它代码维护问题
#define用法详解 无参宏定义 #define 标识符 字符串 预处理命令。
有参宏定义 #define 宏名(形参表) 字符串 宏定义中称为形参，宏调用中称为实参。带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。
宏定义中的特殊操作符 （1）#
希望在字符串中包含宏参数时使用，#作为一个预处理运算符，可以把语言符号转换为字符串，例如：
#define NUM(x) printf(&amp;#34;the number is #x.\n&amp;#34;, x) （2）##
##可以把两个字符串转换成单个字符串。
#define XNAME(n) x##n int XNAME(1) = 12;	//相当于int x1 = 12; （3）可变宏 &amp;hellip;
若要使用可变参数宏，可以在宏定义中将省略号指定为最后一个形参，并且替换标识符可以在定义中用于插入 __VA_ARGS__ 额外的参数。 __VA_ARGS__ 替换为与省略号匹配的所有参数，包括它们之间的逗号。
// variadic_macros.cpp #include &amp;lt;stdio.h&amp;gt;#define EMPTY  #define CHECK1(x, ...) if (!(x)) { printf(__VA_ARGS__); } #define CHECK2(x, ...) if ((x)) { printf(__VA_ARGS__); } #define CHECK3(...) { printf(__VA_ARGS__); } #define MACRO(s, .</description>
    </item>
    
    <item>
      <title>基础算法总结</title>
      <link>https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 30 Nov 2021 22:16:50 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>希望未来一段时间能够手动实现一下这些算法。
线性表 顺序表 链表 栈和队列 栈的顺序、链式存储
队列的顺序、链式存储
双端队列
优先队列（堆排序）
字符串 KMP模式匹配
树与二叉树 二叉树的遍历 前序、中序、后序
二叉排序树 平衡二叉树 哈夫曼树 2-3树和红黑树 图 图的遍历 广度优先搜索和深度优先搜索
最小生成树 Prim、Kruskal
最短路径 Dijkstra、Floyd
拓扑排序 活动的先后顺序
关键路径 查找 顺序查找 折半查找 B树 散列表 排序 插入排序 希尔排序 冒泡排序 快速排序 选择排序 堆排序（优先队列） 删除最大元素、插入元素
构造大根堆、小根堆
归并排序 基数排序 </description>
    </item>
    
    <item>
      <title>算法——红黑树</title>
      <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <pubDate>Sat, 27 Nov 2021 21:03:17 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <description>本节是为了介绍一种二分查找树，无论如何构造，它的运行时间都是对数级别的。在一棵含有N个结点的树中，树的高为$\lg N$。
2-3查找树 允许一个结点保存多个键。一颗2-3查找树由2-结点和3-结点组成。
 2-结点：含有一个键（及其对应键值）和两条链接 3-结点：含有两个键（及其对应键值）和三条链接  同样地，将指向一颗空树的链接称为空链接。
查找 与二叉查找树基本相同，只是可能多了中间结点，从上向下一次递归查找。
插入新键  向2-结点插入新键 向一棵只含有3-结点的树中插入新键 向一个父结点为2-结点的3-结点中插入新键 向一个父结点为3-结点的3-结点中插入新键  全局性质 任意空链接到根结点的路径长度都是相等的。
一棵含有N个结点的2-3树高度在$\lfloor \log_3N\rfloor$（树中全是3-结点）和$\lfloor \lg N\rfloor$（树中全是2-结点）之间。
红黑二叉查找树 用标准二叉查找树和一些额外的信息来表示2-3树。将树中的链接分为两种类型：
 红链接：将两个2-结点连接起来构成一个3-结点 黑链接：2-3树中的普通链接  相当于将3-结点表示为一条左斜的红色链接。这种方法的优点是我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只需对结点进行转换，就可以立即派生出一棵对应的二叉查找树。
一种等价的定义：
红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：
 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡的，即任意空链接到根结点路径上的黑链接数量相同  插入操作的方法：
左旋转、右旋转、颜色转换
红黑树的实现 红黑树的插入算法：
private static final boolean RED = true; private static final boolean BLACK = false; private class Node { Key key; Value val; Node left, right; int N; boolean color; Node(Key key, Value val, int N, boolean color) { this.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH12 动态内存</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
      <pubDate>Thu, 18 Nov 2021 09:20:28 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
      <description>C++支持动态分配对象，动态分配的对象的生存期与它们在哪里创建无关，只有当显示地被释放时，这些对象才会销毁。
静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。
除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称为堆，程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，即动态对象不再使用时，我们的代码必须显示销毁它们。
动态内存与智能指针 动态内存的管理是通过new和delete完成的。new为对象分配空间并返回一个指向该对象的指针，delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
新的标准库提供了两种智能指针类型来管理动态对象，这两种智能指针的区别在于管理底层指针的方式：
shared_ptr允许多个指针指向同一个对象；unique_ptr独占所指向的对象。标准库还顶一个名为weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象。
shared_ptr类 类似于vector，智能指针也是模板，当我们创建一个智能指针时，必须提供额外信息——指针可以指向的类型。
shared_ptr&amp;lt;string&amp;gt; p1;	//可以指向string shared_ptr&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; p2;	//可以指向int的list 默认初始化的智能指针中保存着一个空指针。使用方法与普通指针类似，解引用一个智能指针返回它指向的对象。
make_shared函数 是最安全的用来分配和使用动态内存的标准库函数。
此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。
shared_ptr&amp;lt;int&amp;gt; p3 = make_shared&amp;lt;int&amp;gt;(42); //指向一个值为42的int的shared_ptr 使用make_shared时要指定创建对象的类型，方法与定义模板类相同，在函数名后跟一个尖括号，在其中给出类型，如上所示。另外，make_shared用其参数来构造给定类型的对象。例如调用make_shared&amp;lt;string&amp;gt;时传递参数必须与string的某个构造函数匹配。
一般使用auto来定义一个对象来保存make_shared的结果：
auto p6 = make_shared&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;(); shared_ptr的拷贝和赋值
每个shared_ptr都会记录指向相同对象的其他shared_ptr的数量。
每个shared_ptr都有一个关联的计数器，称其为引用计数。无论何时拷贝一个shared_ptr，计数器都会递增。
当我们给shared_ptr赋予一个新值或shared_ptr被销毁时，计数器就会递减。
一旦一个shared_ptr的计数器变为0，它就会释放自己所管理的对象：
auto r = make_shared&amp;lt;int&amp;gt;(42); r = q;	//给r赋值，令它指向另一个地址；递增q指向的对象的引用次数；递减r原来指向对象的引用次数；r原来指向的对象已经没有引用者，会自动释放 shared_ptr自动销毁所管理的对象
当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。这是通过另一个特殊成员函数——析构函数完成的。析构函数一般用来释放对象多分配的资源。
shared_ptr的析构函数会递减它所指向对象的引用次数，引用次数变为0后shared_ptr的析构函数就会自动销毁对象并释放内存。
由于最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重用，否则程序虽然会正常执行，但会浪费内存。
使用动态内存的原因
 程序不知道自己需要使用多少对象（容器类就是出于这种原因从而使用动态内存） 程序不知道对象的准确类型 程序需要在多个对象间共享数据  直接管理内存 使用运算符new分配内存，delete释放new分配的内存
使用new动态分配和初始化对象
在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：
int *pi = new int;	//pi指向一个动态分配的、未初始化的无名对象 默认情况下动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的。类类型对象将用默认构造函数进行初始化：
string *ps = new string;	//初始化为空string int *pi = new int;	//pi指向一个未初始化的int auto p1 = new auto(obj); 可以通过括号包围的初始化器判断我们想到分配的对象类型，然后使用auto。但只有括号内仅有单一初始化器时才能使用auto。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH11 关联容器</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Mon, 15 Nov 2021 15:32:41 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</guid>
      <description>键值对。
set和map
使用关联容器  map： 关联数组，关键字——值。 set：关键字的简单集合  可以进行列表初始化
关联容器概述 关联容器不支持顺序容器的位置相关的操作，例如push_front，原因是关联容器中的值是按照关键字存储的，这些操作没有意义。
另外无序容器还提供调整哈希性能的操作。
定义关联容器 map&amp;lt;string, size_t&amp;gt; word_count;	//空容器 set&amp;lt;string&amp;gt; exclude = {&amp;#34;the&amp;#34;, &amp;#34;but&amp;#34;, &amp;#34;and&amp;#34;}; map&amp;lt;string, size_t&amp;gt; authors = {{&amp;#34;Joyce&amp;#34;, &amp;#34;James&amp;#34;}, {&amp;#34;Austen&amp;#34;, &amp;#34;Jane&amp;#34;}}; 初始化一个map时必须提供关键字类型和值类型。
关键字类型的要求 对于有序容器map、set、multimap、multiset，关键字类型必须定义元素比较的方法。所提供的操作必须在关键字类型上定义一个严格弱序。
pair类型 定义在头文件utility中。
pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器。
pair&amp;lt;string, string&amp;gt; anon; pair&amp;lt;string, string&amp;gt; author{&amp;#34;James&amp;#34;, &amp;#34;Joyce&amp;#34;}; pair的数据成员是public的，两个成员分别命名为first和second，可以用普通的成员访问符号来访问它们。
cout &amp;lt;&amp;lt; w.first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; w.second &amp;lt;&amp;lt; endl; 关联容器操作 除了之前在顺序容器P295页列出的类型，关联容器还定义了以下类型：
 key_type：此容器类型的关键字类型 mapped_type：每个关键字关联的类型，只适用于map value_type  对于set而言，与key_type相同 对于map而言，为pair&amp;lt;const key_type, mapped_type&amp;gt;    我们使用作用域运算符来提取一个类型的成员，例如：map&amp;lt;string, int&amp;gt;::key_value.</description>
    </item>
    
    <item>
      <title>现代操作系统学习日志——文件系统</title>
      <link>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 13 Nov 2021 19:54:09 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>所有计算机应用程序都需要存储和检索信息。
进程运行时可以在自己的地址空间中存储一定量的信息，但存储容量易受到虚拟地址空间大小的限制。另外，进程终止时，它保存的信息也随之丢失，但对于很多应用（例如数据库）而言，有关信息必须能够保存很长时间甚至永久保留。第三个问题是经常需要多个进程同时访问同一信息，解决方法是使得信息本身独立于任何一个进程。
所以，长期存储信息有以下基本要求：
 能够存储大量信息 使用信息的进程终止时，信息仍旧存在 必须能使多个进程并发访问有关信息  磁盘能够进行长期存储，我们将其当作一种大小固定的块的线性序列，并且支持读块k和写块k的操作。
文件是进程创建的信息逻辑单元，一块磁盘中可以有很多文件，每个文件是独立于其他文件的，文件是对磁盘的建模，而不是对RAM的建模。
进程可以读取已经存在的文件，并在需要时建立新的文件。存储在文件中的信息必须是持久的。
文件 文件命名 大小写
扩展名
文件结构  无结构的字节序列（Windows和Unix采用这种方法） 具有固定长度记录的序列 有一棵树构成的文件结构，每个记录不必具有相同长度，记录的固定位置上有一个键字段（在一些处理商业数据的大型计算机上广泛应用）  文件类型  普通文件  ASCII文件。优势是可以显示和打印，可以用任何文本编辑器进行编辑 二进制文件。有一定的内部结构，使用该文件的程序才了解这种结构   目录：管理文件系统结构的系统文件  另外，Unix还具有：
 字符特殊文件。与I/O有关，用于串行I/O设备。 块特殊文件。用于磁盘设备。  两个普通文件的例子：一个可执行文件、一个存档文件。详情见书上。
文件访问  顺序访问 随机访问文件  read操作给出开始读文件的位置 用seek操作设置当前位置（Windows和UNIX使用这种方式）    文件属性 除了文件名和数据外的与文件相关的信息，称为文件属性或元数据。这些信息在不同系统中有着很大差异。主要具有以下属性类别：
 与文件保护相关的属性。创建者、所有者、口令等。 标志。用于控制或启动某些特殊属性。 用关键字查找记录的文件中的属性：记录长度、键的位置和长度等。 创建时间相关属性。 当前大小。  文件操作 与文件有关的最常用的一些系统调用：
 create delete open close read write append。write的限制格式，只能从文件末尾添加数据。 seek get attributes set attributes rename  一个文件系统调用实现复制的简单程序 详情见书上。</description>
    </item>
    
    <item>
      <title>算法的时间复杂度和空间复杂度</title>
      <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Fri, 13 Aug 2021 16:15:00 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>用来衡量不同算法之间的优劣。
 时间维度：执行当前算法所消耗的时间，用时间复杂度来描述。   空间维度：执行当前算法需要占用的内存空间，我们通常用空间复杂度来描述。  时间复杂度 大O符号表示法 ，即 T(n) = O(f(n))，这是时间复杂度的公式，f(n)表示每行代码执行次数之和，O表示正比例关系。
我们通过以下一个程序举例：
for(i=1; i&amp;lt;=n; ++i) { j = i; j++; } 假设每行代码的执行时间都一样，我们用1颗粒时间来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间，那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)
大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。
如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。
时间复杂度级 常见的时间复杂度级有：
 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n²) 立方阶O(n³) K次方阶O(n^k) 指数阶(2^n)  从上向下时间复杂度越来越大，执行效率越来越低。
下面来选取一些来举例：
常数阶O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：
int i = 1; int j = 2; ++i; j++; int m = i + j; 线性阶O(n) for(i=1; i&amp;lt;=n; ++i) { j = i; j++; } for循环中的代码会执行n遍。</description>
    </item>
    
    <item>
      <title>csapp: 3.程序的机器级表示</title>
      <link>https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Mon, 09 Aug 2021 16:08:05 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid>
      <description>第三章 程序的机器级表示 历史观点 典型的编译器在将C程序结构变换成机器代码时所做的转换。
英特尔X86-64处理器的发展历史。
从8086到Core i7
程序编码 机器级代码 对于机器级编程来说，两种抽象非常重要：
 由指令集体系结构或**指令集架构(ISA, Instruction Set Architecture)**来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，以及每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址。  x86-64机器码中，一些通常对C语言隐藏的处理器状态都是可见的：
 程序计数器(PC，在x86-64中用%rip表示)：给出将要执行的下一条指令在内存中的地址 整数寄存器文件：包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址(对应C语言指针)或整数数据。 条件码寄存器：保存最近执行的算数或逻辑指令的状态信息，用来实现控制或数据流中的条件变化。  x86-64的虚拟地址由64位的字表示，但目前这些地址的高16位必须设为零，相当于可以表示$2^{48}$或256TB内存范围内的一个字节。及目前的64位计算机只使用48位来表示地址范围。
代码示例 机器对产生这些汇编语言指令的源代码几乎一无所知，全都是字节序列。
生成可执行的代码需要对一组目标代码文件运行链接器，这组目标代码文件中必须含有一个main函数。
链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。
反汇编器
关于格式的注解 ATT与Intel汇编代码格式的区别
 Intel代码省略了指示大小的后缀。例如看到的指令为push和mov而不是pushq和movq。 Intel代码胜率了寄存器名字前的%符号。 Intel代码  数据格式 Intel用字(word)表示16位数据类型，因此称32位数为双字，称64位数位四字。
下表给出了C语言基本数据类型对应的x86-64表示：
   C声明 Intel数据类型 汇编代码后缀 大小(字节)     char 字节 b 1   short 字 w 2   int 双字 l 4   long 四字 q 8   char* 四字 q 8   float 单精度 s 4   double 双精度 l 8    大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)、movq(传送四字)。</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（三）——网络层：数据平面</title>
      <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</link>
      <pubDate>Thu, 05 Aug 2021 22:23:31 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</guid>
      <description>数据平面指的是网络层中每台路由器的功能，该数据平面功能决定了到达路由器输入链路的数据报如何转发到该路由器的输出链路之一。
而控制平面的功能指的是网络范围的逻辑，控制平面控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。其中包括路由选择算法，以及如今广泛应用的诸如OSPF和BGP等路由选择协议。控制平面和数据平面的功能已经被实现为一个整体，位于一台路由器中。
**软件定义网络（SDN）**通过将这些控制平面的功能作为一种单独的服务，明确分离数据平面和控制平面，控制平面功能通常位于一台远程的控制器中。
网络层概述 转发和路由选择：数据平面和控制平面  转发：将一个分组从路由器的一条输入链路移动到适当的输出链路 路由选择：网络层决定分组从发送方到接收方所采用的路由或路径  转发（forwarding）是路由器本地动作，路由选择（routing）是网络范围处理过程。
路由器通过转发表来实现转发功能。
网络服务模型 网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性：
 确保交付 具有时延上界的确保交付 有序分组交付 确保最小带宽 安全性  因特网的网络层提供了尽力而为服务。并不能对服务做出保证。但尽力而为服务结合适当的玩过带宽已被证明足够好，已被证明能用于大量应用。
路由器工作原理 以下为一个通用的路由器体系结构：
 输入端口：终结输入物理链路的物理层功能；还与位于入链路远端的数据链路层交互来执行数据链路层功能；另外还要执行查找功能，通过查询转发表决定路由器的输出端口 交换结构：将路由器的输入端口连接到它的输出端口 输出端口：从交换结构接收分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组 路由选择处理器：执行控制平面功能。在传统路由器中执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在SDN路由器中，路由选择处理器负责与远程控制器通信，接收其计算的转发表项，并在路由器输入端口安装这些表项。  输入端口处理和基于目的地转发 交换 交换结构是路由器的核心，通过这种交换结构，分组才能实际地从一个输入端口交换到一个输出端口中。
经内存交换：
输入输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。分组到达输入端口时被复制到处理器内存中，路由选择处理器从其首部中提取目的地址，在转发表中找打适当输出端口，并将该分组复制到输出端口的缓存中。该种情况下若内存带宽为每秒可以写进内存或从内存中读出最多B个分组，则总的转发吞吐量必然小于B/2。另外这种方式不同同时转发两个分组，即使它们有不同的分组。
经总线交换：
输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。路由器必须跨过单一总线，所以路由器的交换带宽受总线速率的影响。
经互联网络交换
使用更加复杂的交换网络来客服单一、共享式总线带宽的限制。
例如纵横式交换机就是一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直总线与每条水平总线在交叉点交叉，交叉点通过交换结构控制器控制开启和闭合。
所以纵横式网络能够并行转发多个分组，是非阻塞的。
输出端口处理 选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。
排队 输入排队
输出排队
分组调度 解决排队的分组如何经输出链路传输的问题。
先进先出
FIFO的链路调度规则，如果分组到达时链路正忙，则需要等待链路中的分组传输完成。
优先权排队
不同类型的网络分组有不同的优先权类，每个优先权类通常都有自己的队列。
循环和加权公平排队
在循环排队规则中，分组像使用优先权排队那样被分类，但在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。一个所谓的保持工作排队规则在有分组排队等待传输时，不允许链路保持空闲。当寻找给定的分组但没有找到时，保持工作的循环规则将立即检查循环序列中的下一个类。
一种称为加权平均排队（Weighted Fair Queuing, WFQ）规则的通用形式的循环排队已经广泛地实现在路由器中了。WFQ与循环排队的不同在于，每个类在任何时间间隔内可能收到不同数量的服务。每个类i被分配一个权$w_i$，使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接收到的服务部分等于$w_i/(\sum w_j)$，即保证拥有相应权重的带宽。
网际协议IP 因特网网络层的网际协议（IP）。
IPv4数据报格式 网络层分组被称为数据报。
  版本号：4比特，规定了数据报的IP协议版本。即区分IPv4和IPv6，路由器根据版本号确定如何处理数据报剩余的部分。
  首部长度：一个IPv4数据报包含一些可变数量的选项，需要用这4比特来确定IP数据报中荷载（被封装的运输层报文）实际开始的地方。大多数数据报不包含选项，所以一般具有20字节的首部长度。
  服务类型：区别不同类型的数据报（例如一些特别要求低时延、高吞吐量或可靠性的数据报）。</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（五）——链路层</title>
      <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description>概述 将运行链路层协议的设备称为节点，把沿通信链路连接相邻节点的通信信道称为链路。经过特定链路时，节点将数据包封装在链路层帧中，将该帧传送到链路中。
链路层提供的服务：
 成帧：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。 链路接入：**媒体访问控制协议(MAC)**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。 可靠交付：链路层通过确认和重传提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。 差错检验和纠正：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。  链路层协议的实现位置：网络适配器（也成为网卡）来实现。
差错检测和纠正技术 差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。
这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。
奇偶校验 单个奇偶校验位：
  假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。
  接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。
  但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为50%。
  二维奇偶校验：
  将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。
  出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。
  接收方检测和纠正差错的能力被称为前向纠错（Forward Error Correction，FEC）。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。
检验和 将d比特数据当作一个k比特的整数序列处理。因特网检验和是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果是否全为1比特来检验。如果这些比特中存在0比特，则出现差错。
检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。
循环冗余检测（CRC） 冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。
考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为G。我们要求G的最高位有效比特为1.
对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。
用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。
多路访问链路和协议 网络链路的分类：
 点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。 广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。  多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。
因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。
我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。
信道划分协议 时分多路复用（TDM）
假设一个支持N个节点的信道传输速率为R bps。
 TDM将时间划分为时间帧（Frame），并进一步把每个时间帧划分为N个时隙（slot），把每个时隙分配给N个节点中的一个。 无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。 TDM消除了碰撞且非常公平，但存在以下缺点：  节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。 节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。    频分多路复用（FDM）</description>
    </item>
    
    <item>
      <title>Linux基础知识</title>
      <link>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 29 Jul 2021 08:44:21 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>系统启动过程  内核的引导：BIOS开机自检，然后读入/boot目录的内核文件 运行init：init进程是所有进程的起点，运行级别确定 系统初始化：rc.sysinit 建立终端 用户登录系统  系统目录结构  /bin：bin是二进制文件的缩写，存放着最常用的命令 /boot：存放启动时的核心文件 /dev：dev是Device的缩写，存放Linux的外部设备 /etc：Etcetera的缩写，用来存放所有系统管理所需的配置文件和子目录 /home：主目录，Linux中，每个用户都有一个自己的目录 /lib：Library的缩写，存放着系统最基本的动态连接共享库 /media：自动识别一些设备，将其挂载到这个目录 /mnt：该目录为了让用户临时挂载别的文件系统 /opt：optional的缩写，给主机额外安装软件所设置的目录 /proc：Processes进程的缩写，是一种虚拟文件系统，存放着当前内核运行状态的一系列特殊文件。该目录不再硬盘上，而是在内存中。 /root：系统管理员主目录 /tmp：temporary的缩写，用来存放临时目录 /usr：unix shared resources共享资源的缩写，用户的很多应用程序和文件存放于此，类似于windows下的program files /usr/bin：系统用户使用的应用程序 /usr/src：内核源代码默认的存放目录 /var：variable的缩写，存放着不断扩充着的东西，将经常被修改的目录放在这个目录下，包括各种日志文件  文件基本属性 Linux系统是一种多用户系统，不同用户有不同权限。
通常使用以下命令来修文件和目录的权限：
 chown(change ownerp)：修改所属用户与组 chmod(change mode)：修改用户的权限  在Linux中使用ll或ls -l来显示一个文件的属性以及文件所属的用户和组。
第一个字符代表这个文件的类型，是目录、文件或连接文件等等：
  d为目录
  -为文件
  l为链接文件
  b为可存储的接口设备
  c为串行端口设备
接下来的字符以三个为一组，为rwx三个参数的组合，r代表可读，w代表可写，x代表可执行，从前到后分别代表user、group、everyone的权限，如果没有权限，则用-表示。
  对于root用户，文件权限不起作用。
chgrp：改变文件属组 用法：
chgrp [-R] 属组名 文件名 -R：recursion，递归，改变目录下所有文件的属性
chown：更改文件属主，也可以同时更改文件属组 用法：</description>
    </item>
    
    <item>
      <title>计算机网络各层级理解</title>
      <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</link>
      <pubDate>Fri, 23 Jul 2021 12:59:05 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</guid>
      <description>一年多前按照层级详细学习了计算机网络的有关内容，包括从应用层、传输层、网络层、数据链路层到物理层的详细信息，并且也学习了一些其他硬件通信协议，比如CAN控制器局域网、SPI等等。在之后的应用和实践中经常对不同层级的网络和网络设备产生疑惑，例如路由器和交换机到底是什么关系？为什么要通过IP地址和MAC地址划分网络层和数据链路层？这里将会详细说明各层网络的具体作用来加深理解和体会。
应用层 应用层是计算机网络体系结构中最高层，意味着这是和人进行交互的层次。
应用层是计算机网络与用户进行交互的接口或界面，直接向用户提供服务；包括Web、E-mail、DNS、DHCP、FTP等等。
应用层要解决的主要问题就是如何为用户提供高效、可靠、满意的服务，工程师要根据不同业务场景使用不同技术方法解决这些问题，比如使用多线程、高并发的Web框架，分布式处理等等。
传输层 负责端到端（进程之间）的通信。位于两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种网络应用进程。
端到端的传输分为两个步骤：
 虚拟传输连接的建立 源端用户数据沿着传输连接传送到目的端  整个数据传输过程中传输层需要完成以下基本功能：传输层寻址、传输连接建立、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和多路分解、崩溃恢复。
网络层 也被称为中转层。他很重要也很复杂，既要解决不同网络的节点通信的路由和协议识别问题，又要通过路由选择策略解决网络拥塞问题。
网络层主要是为了解决不同网络之间数据传输和转发问题。
数据链路层 在原始的、有差错的物理传输线路的基础上，采用差错检测、差错控制和流量控制等方法，将有差错的物理线路改成逻辑上无差错的数据链路，为上一层（网络层）提供高质量服务。
数据链路层主要是为了控制数据传输。
物理层 位于体系结构最底层，负责在物理介质上位数据链路层提供原始比特流传输的物理链接。
物理层解决的问题就是数据传输，所有数据到达物理层都会变成二进制的载波信号。
交换机和路由器 见WLAN基本内容和802.11ax中的内容。</description>
    </item>
    
    <item>
      <title>LaTex环境配置和基本功能模块</title>
      <link>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 18 Jul 2021 20:06:26 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</guid>
      <description>环境配置 我选择使用VS code + Tex Live作为我的LaTex写作环境，具体配置过程参考自：Visual Studio Code (vscode)配置LaTeX
以下是关于使用过程中一些具体模块的讨论：
部分内容参考自：一份其实很短的 LaTeX 入门文档
这里使用xeLatTex进行编译。
基本文档和中英文 基本文档 \documentclass{article} % 这里是导言区 \begin{document} Hello, world! \end{document} Tex以%作为注释标记。若要输出百分号%字符本身，则要在前面加上反斜杠\进行转义（escape）。
中英文混排 目前XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题。至此，我们只需要使用几个简单的宏包，就能完成中文支持了。
我们使用\usepackage{}来调用宏包。
另外，我们使用CTex宏集来处理中文的版式和标点。
\documentclass[UTF8]{ctexart} \begin{document} 你好，world! \end{document} 与开始相比，文档类别变为ctexart，并且增加了文档类选项UTF8.
组织文章基本内容  标题、作者、日期  \documentclass[UTF8]{ctexart} \title{你好，world!} \author{Eternity} \date{\today} \begin{document} \maketitle 你好，world! \end{document} 以上代码中的控制序列\maketitle能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。
可以通过宏包titling修改上述默认格式。
章节和段落  \documentclass[UTF8]{ctexart} \title{你好，world!} \author{Liam} \date{\today} \begin{document} \maketitle \section{你好中国} 中国在East Asia. \subsection{Hello Beijing} 北京是capital of China. \subsubsection{Hello Dongcheng District} \paragraph{Tian&amp;#39;anmen Square} is in the center of Beijing \subparagraph{Chairman Mao} is in the center of 天安门广场。 \subsection{Hello 山东} \paragraph{山东大学} is one of the best university in 山东。 \end{document} 文档类article/ctexart中定义了5个控制序列来调整文章组织结构：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH10 泛型算法</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 18 Jul 2021 09:16:32 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE6%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</guid>
      <description>用来操纵容器。泛型算法独立于任何特定容器，可用于不同类型的容器和不同类型的元素。这些算法是一些经典算法的公共接口，例如排序和搜索。
概述 大多数算法定义在algorithm头文件中，标准库还在numeric中定义了一组数值泛型算法。
一般这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。
算法不依赖于容器，但依赖于元素类型的操作。
基本算法 只读算法 只读取输入范围的元素，不改变元素。
accumulate算法：
其定义在头文件numeric中，接受三个参数，前两个指出了需要求和元素的范围，第三个参数是和的初值。
int sum = accumulate(vec.cbegin(), vec.cend(), 0);	//对vec中元素求和，和的初值设为0 第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。
即序列中的元素必须与第三个参数匹配或能够转换为第三个参数的类型。
equal算法
确定两个序列的值是否保存相同的值，将第一个序列的每个元素与第二个序列的对应元素比较。该算法接受三个迭代器，前两个表示第一个序列的范围，第三个表示第二个序列的首元素。
equal利用迭代器完成操作，因此我们可以调用equal来比较两个不同类型容器中的元素，并且元素类型也可以不同。
写容器元素算法 使用这类算法要保证序列原大小不小于算法写入的元素数目。
fill算法
fill接受一对迭代器和一个值，将这个值赋予输入序列中的每个元素。
fill(vec.begin(), vec.end(), 0); 不能在空容器上调用fill_n.
back_inserter插入迭代器
接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。
back_inserter是一个定义在头文件iterator中的函数。
vector&amp;lt;int&amp;gt; vec;	//空vector auto it = back_inserter(vec);	//通过其赋值将元素添加到vec中 *it = 42; 拷贝算法
copy是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。
该算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。
重排容器元素算法 sort、unique函数
void elimDups(vector&amp;lt;string&amp;gt; &amp;amp;words) { //按字典排序words, 以便查找重复单词 	sort(words.begin(), words.end()); //unique重排输入范围，使每个单词只出现一次 	auto end_unique = unique(words.begin(), words.end()); //使用erase操作删除重复单词 	words.erase(end_unique, words.end()); } sort算法接受两个迭代器，表示要排序的元素范围。</description>
    </item>
    
    <item>
      <title>csapp: 2.信息的表示和处理（部分完成）</title>
      <link>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 12 Jul 2021 21:26:27 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
      <description>第一部分内容：程序结构和执行
我们需要用方法表示基本数据类型，然后考虑机器级指令如何操作这样的数据，以及编译器如何将C程序翻译成这样的指令。接下来研究集中处理器的方法，使得我们能够更好地了解硬件资源如何被用来执行指令。
信息存储 十六进制表示法及转换 二进制和十进制对描述位模式来说都不方便，因此采用16进制数(hex)来表示位模式。
C语言中16进制数以0X或0x开头，字符‘A’~‘F’既可以是大写也可以是小写。
二进制和十六进制之间的转换较为简单，不再赘述。
十进制和十六进制数之间的转换要反复利用乘法和除法进行处理：
 从十进制到十六进制：反复用16除十进制数 从十六进制到十进制：用相应的16的幂乘以每个十六进制数。  字数据大小 字长指明指针数据的标称大小。虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。
对一个字长为w的机器而言，虚拟地址的范围是$0$ ~$2^w-1$，程序最多访问$2^w-1$个字节。
近年，很多机器都从32位字长迁移到了64位字长。大多64位字长机器可以运行32位字长机器编译的程序。32位程序和64位程序的区别在于程序是如何编译成的，而不是运行的机器类型。
寻址和字节顺序 小端法、大端法
对于跨越多个字节的程序对象，我们必须明确：
 这个对象的地址是什么 如何在内存中排列这些字节  一般来说，多字节对象被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
  小端法：将最低有效字节放在最前面(最小地址)存储。（例如一个二进制数最右边的8位是最低有效字节）
  大端法：将最高有效字节放在最前面(最小地址)存储。
  大多Intel兼容机使用小端模式。
以下代码使用强制类型转换来访问和打印不同程序对象的字节表示。
#include &amp;lt;stdio.h&amp;gt; typedef unsigned char *byte_pointer;	//将byte_pointer定义为一个指向类型为unsigned char对象的指针 //指针被强制类型转换为unsigned char *, 这告诉编译器程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。  void show_bytes(byte_pointer start, size_t len) {//按顺序显示出指针指向对象的每个字节内容，可以判断出系统使用的小端法还是大端法 	size_t i; for (i = 0; i &amp;lt; len; i++) printf(&amp;#34;%.2x&amp;#34;, start[i]); printf(&amp;#34;\n&amp;#34;); } //使用sizeof确定对象使用的字节数 void show_int(int x) {//显示int对象的字节内容 	show_bytes((byte_pointer) &amp;amp;x, sizeof(int)); } void show_float(float x) {//显示float对象的字节内容 	show_bytes((byte_pointer) &amp;amp;x, sizeof(float)); } void show_pointer(void *x) {//显示void *对象的字节内容 	show_bytes((byte_pointer) &amp;amp;x, sizeof(void *)); } 表示字符串 对文本进行编码。</description>
    </item>
    
    <item>
      <title>CAN总线</title>
      <link>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</link>
      <pubDate>Mon, 12 Jul 2021 18:16:41 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/can%E6%80%BB%E7%BA%BF/</guid>
      <description>概要 Controller Area Network
CAN总线由BOSCH公司开发，是一种多主控(Multi-Master)的现场总线系统，CAN网络的消息是广播式的，即同一时刻网络上所有节点侦测的数据是一致的，是一种基于消息广播模式的串行通信总线。
CAN总线的很多优点，使得它得到了广泛的应用，如传输速度最高到1Mbps, 通信距离最远到10km，无损位仲裁机制，多主结构。
CAN总线标准规定了物理层和数据链路层，应用层标准由具体应用决定。
CAN物理层 连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的差分电平信号。
节点主要包括Host、控制器和收发器。
Host常集成有CAN控制器，CAN控制器负责处理协议相关功能，以减轻Host的负担。
CAN收发器将控制器连接到传输媒介。通常控制器和总线收发器通过光耦或磁耦隔离，这样即使总线上过压损坏收发器，控制器和Host设备也可以得到保护。
在发送数据时，CAN控制器把要发送的二进制编码通过CAN_Tx线发送到CAN收发器，然后由收发器把这个普通的逻辑电平信号转化成差分信号，通过差分线CAN_High和CAN_Low输出到CAN总线网络。接收数据过程，相反。采用差分信号，可以取得更好的电磁兼容效果。因此，CAN总线物理传输媒介只需要两根线。
下图为一CAN收发器应用的例子：
高速CAN总线最高信号传输速率为1Mbps，支持最长距离40m。ISO11898-2要求在高速CAN总线两段安装端接电阻RL（端接电阻一般为120Ω，因为电缆的特性阻抗为120 Ω，为了模拟无限远的传输线。）以消除反射。低速CAN最高速度只有125Kbps，所以ISO11898-3没有端接要求。
差分信号 CAN总线采用差分信号传输，通常情况下只需要两根信号线就可以进行正常的通信。在差分信号中，逻辑0和逻辑1是用两根差分信号线的电压差来表示。
当处于逻辑1，CAN_High和CAN_Low的电压差小于0.5V时，称为隐性电平（Recessive）；
当处于逻辑0，CAN_High和CAN_Low的电压差大于0.9V，称为显性电平（Dominant）。
CAN总线遵从“线与”机制：“显性”位可以覆 盖“隐性”位；只有所有节点都发 送“隐性”位， 总线才处于“隐性” 状态。这种“线与”机制使CAN总线呈现显性优先的特性。
CAN数据链路层 在SPI通信中，片选、时钟信号、数据输入及数据输出这四个信号都有单独的信号线。而CAN使用的是两条差分信号线，只能表达一个信号。简洁的物理层决定了CAN必然要配上一套更为复杂的协议。如何用一个信号通道实现同样甚至更强大的功能，答案就是对数据或操作命令进行打包。
通信机制 多主机(Multi-Master)：
安全敏感的应用（如汽车动力）对通信系统的可靠性要求很高。将总线能否正常工作归结到单一节点是非常危险的，比较合理的方案是对总线接入的去中心化，即每个节点都有接入总线的能力。这也是CAN总线采用多主控（Multi-Master）线性拓扑结构的原因。
在CAN总线上，每个节点都有往总线上发送消息的能力，而消息的发送不必遵从任何预先设定的时序，通信是事件驱动的。只有当有新的信息传递时，CAN总线才处于忙碌的状态，这使得节点接入总线速度非常快。CAN总线理论最高数据传输速率为1Mbps，对于异步事件反应迅速，基本对于ms级别的实时应用没有任何问题。
寻址机制：
CAN总线不设定节点的地址，而是通过消息的标识符（Identifier）来区别消息。这种机制虽然会增加消息的复杂度（增加标识符），但是节点在此情况下可以无需了解其他节点的状况，而相互间独立工作。在总线上增加节点时仅需关注消息类型，而非系统上其他节点的状况。这种以消息标识符寻址的方式，让总线上增加节点变得更加灵活。
总线访问 CSMA/CD+AMP
多路载波侦听+基于消息优先级的冲突检测和非破坏性的仲裁机制（CSMA/CD+AMP）
  CSMA（Carrie Sense Multiple Access）指的是所有节点必须都等到总线处于空闲状态时才能往总线上发送消息；
  CD+AMP（Collision Detection + Arbitration on Message Priority）指的是如果多个节点往总线上发送消息时，具备最高优先级的消息获得总线。
  多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。
  冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。
  非破坏性仲裁机制：通过ID仲裁，ID数值越小，报文优先级越高。
  发送低优先级报文的节点退出仲裁后，在下次总线空闲时自动重发报文。
高优先级的报文不能中断低优先级报文的发送。
报文接受过滤
CAN控制器大多具有根据ID过滤报文的功能，即只接收某些ID的报文。节点对接收到的报文进行过滤：比较消息ID与选择器（Accepter）中和接受过滤相关位是否相同。如果相同，接收；如果不相同，则过滤。
报文种类及结构 在原始数据段的前面加上传输起始标签、片选（识别）标签、控制标签，在数据的尾段加上CRC校验标签、应答标签和传输结束标签。把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了。</description>
    </item>
    
    <item>
      <title>存储器详解</title>
      <link>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 04 Jul 2021 16:09:50 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;计算机存储器只要分为内存和外存。内存是CPU直接寻址的存储空间，访问频率快，而外存访问慢。&lt;/p&gt;
&lt;h2 id=&#34;易失性存储器随机存取存储器ram&#34;&gt;易失性存储器（随机存取存储器，RAM）&lt;/h2&gt;
&lt;p&gt;Random Access Memory，存储在其中的资料会在电力切断后消失，所以属于易失性存储器。&lt;/p&gt;
&lt;h3 id=&#34;动态随机存取存储器dram&#34;&gt;动态随机存取存储器（DRAM）&lt;/h3&gt;
&lt;p&gt;Dynamic Random Access Memory，主要的作用原理是利用电容内&lt;strong&gt;存储电荷的多寡&lt;/strong&gt;来代表一个二进制比特（bit）是1还是0。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别资料，而导致资料毁损。因此对于DRAM来说，周期性地充电是一个不可避免的条件。由于这种需要&lt;strong&gt;定时刷新&lt;/strong&gt;的特性，因此被称为“动态”存储器。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH09 顺序容器</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 15 Jun 2021 15:36:20 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE4%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>顺序容器
一个容器就是一些特定类型对象的集合。
顺序容器提供了控制元素存储和访问顺序的能力。这种顺序与元素加入容器时的位置相对应。
关联容器与顺序容器有着根本不同，关联容器中的元素是按照关键词来保存和访问的，即Key-Value；与之相对的是顺序容器中的元素按照它们在容器中的位置来顺序保存和访问。
概述 顺序容器都提供了快速顺序访问元素的能力。
   符号 顺序容器类型(名称) 性能     vector 可变大小数组 支持快速随机访问。在尾部之外的位置插入删除元素很慢   deque 双端队列 支持快速随机访问。在头尾插入删除速度很快   list 双向链表 只支持双向顺序访问。在list中任何位置插入删除元素都很快   forward_list 单项链表 只支持单项顺序访问。在forward_list中任何位置插入删除元素都很快   array 固定大小数组 支持快速随机访问。不能添加删除元素   string 与vector相似的容器，专门用于保存字符 随机访问快，在尾部插入删除速度快    除了固定大小的array外，其他容器都提供高效的内存管理。容器保存元素的策略对容器操作的效率有着很大影响。
string和vector将元素保存在连续的内存空间中，因此由元素的下标来计算其地址非常快速。但在这两种容器的中间位置插入和删除元素的速度非常慢，因为一次插入或删除后，需要移动插入、删除位置后的所有元素以保证存储的连续。
list和forward_list两个容器能令任何位置的添加和删除操作都很快，但这两种容器不支持随机访问，因为元素保存的内存空间不连续，只能通过遍历整个容器来访问一个元素。与vector和string相比，额外内存开销也很大。
forward_list与最好的手写单向链表数据结构性能相当，因此没有size操作，因为保存或计算大小会多出额外开销。
deque支持快读随机访问，在该容器中间位置添加或删除元素速度很慢，但在两端很快。
容器库概览 容器类型上的操作分成了层次：
 某些操作式所有容器都提供的； 另外一些操作仅针对顺序容器、关联容器或无序容器； 还有一些操作只适合一小部分容器。  容器通过尖括号指定类型。
容器操作 iterator size_type 迭代器 *iter	//返回迭代器iter所指元素的引用 iter-&amp;gt;name	//解引用iter并获取该元素的名为mem的成员 ++iter	//令iter指示容器中的下一个元素 --iter	//令iter指示容器中的上一个元素 iter1 == iter2 一个迭代器范围由一对迭代器表示，这两个迭代器被称为begin和end，begin指向容器第一个元素，end指向容器的尾后元素，这种元素范围被称为左闭合区间，即[begin, end)。</description>
    </item>
    
    <item>
      <title>csapp: 1.计算机系统漫游</title>
      <link>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link>
      <pubDate>Fri, 11 Jun 2021 12:18:22 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid>
      <description>在本书中我们将会学习到一些使用技巧，比如如何避免由于计算机表示数字的方式引起的错误；通过一些技巧优化C代码，以充分利用现代处理器和存储器系统的设计；了解编译器如何实现过程调用，利用这些知识避免缓冲区溢出错误带来的安全漏洞；学习如何识别和避免链接时的错误；如何编写Unix Shell、动态存储分配包、Web服务器；并发带来的希望和陷阱，对于现在的单芯片集成多个处理器核心非常重要。
我们通过围绕Hello程序执行时的整个生命周期来对系统进行学习：
#include &amp;lt;stdio.h&amp;gt;int main() { printf(&amp;#34;Hello, world\n&amp;#34;); return 0; } 信息就是位+上下文 8位为一个字节。
现代计算机系统使用ASCII标准来表示文本字符。即用一个单字节大小的整数值表示一个符号。
数字的机器表示是对真值的有限近似。
程序被翻译为不同的格式 hello.c中的每条C语句都会转换为一系列低级机器语言指令。这些指令按照可执行目标程序格式打包，以二进制磁盘文件的形式存放。
编译系统：
hello.c(源程序，文本) -&amp;gt; 预处理器(cpp) -&amp;gt; hello.i(修改了的源程序，文本) -&amp;gt; 编译器(ccl) -&amp;gt; hello.s(汇编程序，文本) -&amp;gt; 汇编器 -&amp;gt; hello.o(可重定位目标程序，二进制) -&amp;gt; 链接器 -&amp;gt; hello(可执行目标程序，二进制)
 预处理阶段：预处理器(cpp)根据以字符#开头的命令，修改原始C程序。例如#include &amp;lt;stdio.h&amp;gt;告诉预处理器读取系统头文件的内容，将其插入程序文本中，得到另一个C程序，以.i为扩展名。 编译阶段：编译器(ccl将hello.i翻译为hello.s，其包含了汇编语言程序。 汇编阶段：汇编器(as)将hello.s翻译为机器语言指令，将这些指令打包为可重定位目标程序，将结果保存在hello.o中，该文件为二进制文件。 链接阶段：hello程序调用了printf函数，它是C编译器提供的标准C库中的一个函数，printf函数存在于一个名为printf.o的单独预编译好的目标文件中，这个文件要以某种形式合并到我们的hello.o程序中，链接器(ld)负责这种合并，合并后就得到了可执行目标文件hello，其可以被加载到内存中，由系统执行。  编译器的工作方式 有一些重要原因使得我们必须知道编译器的工作方式：
 优化程序性能。我们需要了解一些机器代码及编译器将不同C语句转化为机器代码的方式，例如一个switch语句是否总比一系列if-else语句高效。 理解链接时出现的错误。 避免安全漏洞。缓冲区溢出错误是大多网络和服务器安全漏洞的主要原因。  处理器读取并解释储存在内存中的指令 要在Unix系统运行可执行目标文件hello，需要将文件名输入shell应用程序中：
linux&amp;gt; ./hello hello,world linux&amp;gt; 系统的硬件组成 总线 贯穿整个系统，负责信息字节在各个部件之间传递。
通常被设计为传送定长的字节块，即字，字中的字节数（即字长）是基本的系统参数，如今大多数机器中字长为8字节(即64位)，4字节(32位)在逐渐被64位取代。
I/O设备 每个I/O设备通过控制器或适配器与I/O总线相连，控制器为I/O设备本身或系统主板上的芯片组，适配器为插在主板插槽上的卡。
主存RAM 临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。由一组动态随机存取存储器(DRAM)芯片组成。逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址从零开始。
处理器 CPU是解释或执行存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备(寄存器)，称为程序计数器(PC)，PC指向主存中的某条机器语言指令（即包含该指令的地址）。
处理器在一直不停地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个简单的指令执行模型来操作的，这个模型是指令集架构决定的。该模型中指令按照严格的顺序执行。执行一条指令包含一系列步骤，处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，循环操作。
这样的简单操作并不多，主要围绕**主存、寄存器文件和ALU(算术逻辑单元)**进行。寄存器文件是一个小型存储设备，由一些单个字长的寄存器组成，ALU计算新的数据和地址值。CPU可能进行以下操作：
 加载：从主存读取一个字到寄存器 存储：从寄存器赋值一个字到主存 操作：将两个寄存器的内容复制到ALU，ALU对两个字进行算术运算，将结果存放到一个寄存器中 跳转：从指令本身抽取一个字，将这个字复制到PC中  指令集架构：每条机器代码指令的效果</description>
    </item>
    
    <item>
      <title>cs231n——1.Nearest Neighbor Classifier</title>
      <link>https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/</link>
      <pubDate>Wed, 09 Jun 2021 17:41:44 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/cs231n1-nearest-neighbor-classifier/</guid>
      <description>图像分类规范化步骤：
 输入：输入带有不同标签的图像作为训练集 学习：使用训练集学习每种类别的抽象特征 评估：通过测试集评估分类器的质量。  Nearest Neighbor Classifier CIFAR-10 dataset:
 10 classes (airplane, automobile, bird, etc) 60,000 tiny images that are 32 pixels high and wide  k-NN通过将一张测试集图片与所有的训练集图片进行比较，预测结果。
L1 distance: $$ d_{1}\left(I_{1}, I_{2}\right)=\sum_{p}\left|I_{1}^{p}-I_{2}^{p}\right| $$
将两张图片分别表示为$I_1, I_2$两个向量，使用L1距离来比较两张图片。
通常使用准确率来评估分类器
Xtr, Ytr, Xte, Yte = load_CIFAR10(&amp;#39;data/cifar10/&amp;#39;) # a magic function we provide # flatten out all images to be one-dimensional Xtr_rows = Xtr.reshape(Xtr.shape[0], 32 * 32 * 3) # Xtr_rows becomes 50000 x 3072 Xte_rows = Xte.</description>
    </item>
    
    <item>
      <title>Python基础和numpy</title>
      <link>https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</link>
      <pubDate>Sun, 06 Jun 2021 13:04:49 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/python%E5%9F%BA%E7%A1%80%E5%92%8Cnumpy/</guid>
      <description>&lt;h2 id=&#34;basic-of-python&#34;&gt;Basic of Python&lt;/h2&gt;
&lt;h3 id=&#34;basic-data-types&#34;&gt;Basic data types&lt;/h3&gt;
&lt;h4 id=&#34;numbers&#34;&gt;Numbers&lt;/h4&gt;
&lt;h4 id=&#34;bolleans&#34;&gt;Bolleans&lt;/h4&gt;
&lt;h4 id=&#34;strings&#34;&gt;Strings&lt;/h4&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;h4 id=&#34;lists&#34;&gt;Lists&lt;/h4&gt;
&lt;h4 id=&#34;slicing&#34;&gt;Slicing&lt;/h4&gt;
&lt;h4 id=&#34;loops&#34;&gt;Loops&lt;/h4&gt;</description>
    </item>
    
    <item>
      <title>WLAN基本内容和802.11ax</title>
      <link>https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</link>
      <pubDate>Thu, 03 Jun 2021 18:09:38 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/</guid>
      <description>&lt;h2 id=&#34;wlan基础内容&#34;&gt;WLAN基础内容&lt;/h2&gt;
&lt;h3 id=&#34;计算机网络概念&#34;&gt;计算机网络概念&lt;/h3&gt;
&lt;p&gt;在学习基本无线网络通信的过程中顺便可以来复习以下计算机网络的相关内容。&lt;/p&gt;
&lt;p&gt;在家庭中我们通常使用路由器联通家中的局域网和外部的广域网，路由器为网络层设备，通过IP和路由表来寻找目的地和转发数据，即为路由功能。&lt;/p&gt;
&lt;p&gt;交换机是数据链路层设备，通过用于在局域网内传输数据，通过MAC地址寻找目的地，数据转发通过硬件来实现，传输速度相较于上一层网络层有很大的性能提升。每个物理设备都具有一个唯一的MAC地址。&lt;/p&gt;
&lt;p&gt;路由器和交换机的不同在于，一个工作在网络层，另一个工作在数据链路层，交换机连接的网络必须使用相同的数据链路层协议，一般即为&lt;strong&gt;802.3(以太网)或802.11(无线局域网)&lt;/strong&gt;。路由器工作在网络层，因此路由器连接的网络必须使用相同的网路层协议，一般为&lt;strong&gt;ip协议&lt;/strong&gt;，但路由器可以连接不同的数据链路层，比如eth2和pppoe，eth2和802.11。&lt;/p&gt;
&lt;p&gt;我们常用的每台终端都有一个MAC地址（即网卡地址），在连接网络后路由器会为其分配一个IP；而一个路由器也拥有一个MAC地址和一个IP。交换机中只有MAC地址表，通过设备的MAC地址来确定数据的目的地。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>字符编码：Unicode, UTF-8</title>
      <link>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/</link>
      <pubDate>Wed, 02 Jun 2021 15:29:29 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/</guid>
      <description>&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;p&gt;计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。通俗的说，按照何种规则将字符存储在计算机中，如&amp;rsquo;a&amp;rsquo;用什么表示，称为&amp;quot;&lt;strong&gt;编码&lt;/strong&gt;&amp;quot;；反之，将存储在计算机中的二进制数解析显示出来，称为&amp;quot;&lt;strong&gt;解码&lt;/strong&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符集(charset)&lt;/strong&gt;：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国文字、标点符号、图形符号、数字等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符编码(character Encoding)&lt;/strong&gt;：即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>机器学习——k近邻(k-NN)算法</title>
      <link>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 12 May 2021 14:57:17 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0k%E8%BF%91%E9%82%BB-k-nn-%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;基本概念及原理&#34;&gt;基本概念及原理&lt;/h2&gt;
&lt;p&gt;k近邻(k-nearest neighbors)算法是一种基本分类和回归方法。&lt;/p&gt;
&lt;p&gt;该算法是给定一个&lt;strong&gt;训练数据集&lt;/strong&gt;，对新的&lt;strong&gt;输入测试集&lt;/strong&gt;，在训练集中找到与该测试实例&lt;strong&gt;最邻近&lt;/strong&gt;的k个实例，这k个实例的多数属于某个类，就把该输入实例分类到这个类中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/blog/220px-KnnClassification.svg.png&#34; alt=&#34;220px-KnnClassification.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;有两类不同样本分别用红色三角形和蓝色正方形表示，途中绿色圆形为待分类的数据。这时我们根据k-近邻的思想进行分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当k=3时，判定样本属于红色三角形这一类；&lt;/li&gt;
&lt;li&gt;当k=5时，判定样本属于蓝色正方形这一类。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH08 IO库</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/</link>
      <pubDate>Mon, 10 May 2021 21:04:06 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE2io%E5%BA%93/</guid>
      <description>&lt;h2 id=&#34;io库&#34;&gt;IO库&lt;/h2&gt;
&lt;h3 id=&#34;io类&#34;&gt;IO类&lt;/h3&gt;
&lt;p&gt;为了支持不同类型的IO操作，除了iostream外，标准库还定义了其他一些IO类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件iostream：
&lt;ul&gt;
&lt;li&gt;istream, wistream类型，从流读取数据&lt;/li&gt;
&lt;li&gt;ostream, wostream类型，向流写入数据&lt;/li&gt;
&lt;li&gt;iostream, wiostream类型，读写流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件fstream：
&lt;ul&gt;
&lt;li&gt;ifstream类型，从文件读取数据&lt;/li&gt;
&lt;li&gt;ofstream类型，向文件写入数据&lt;/li&gt;
&lt;li&gt;fstream类型，读写文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件sstream
&lt;ul&gt;
&lt;li&gt;istringstream类型：从string读取数据&lt;/li&gt;
&lt;li&gt;ostringstream类型：向string写入数据&lt;/li&gt;
&lt;li&gt;stringstream类型：读写string&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类型前加一个w的类型是为了支持宽字符，用来操纵wchart_t类型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Altium Designer画图流程记录(简略)</title>
      <link>https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</link>
      <pubDate>Fri, 30 Apr 2021 22:47:47 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/altium-designer%E7%94%BB%E5%9B%BE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%AE%80%E7%95%A5/</guid>
      <description>之前看过博主半夜中暑的羊的原理图以及PCB绘制教程，收获颇丰，但是视频比较长而且分为多集，每次有些地方忘记时要去找到很不方便，因此趁着这次画一个简单转接版的机会，把视频中的内容整理成文字版，方便之后查找和复习。这里面只涉及基本的两层版的基本绘制。
共有以下几部分内容：
 原理图库 核心模块的原理图 为原理图添加封装 PCB布局 PCB布线 PCB敷铜 PCB生成BOM及投板  PCB各层简介 参考自：PCB各层介绍
Mechanical layer(机械层) Altium Designer提供了16个机械层，它一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。这些信息因设计公司或PCB制造厂家的要求而有所不同。另外，机械层可以附加在其它层上一起输出显示。
Keep out layer(禁止布线层) 用于定义在电路板上能够有效放置元件和布线的区域。在该层绘制一个封闭区域作为布线有效区，在该区域外是不能自动布局和布线的。
Signal layer(信号层) 信号层主要用于布置电路板上的导线。Altium Designer提供了32个信号层，包括Top layer(顶层)，Bottom layer(底层)和32个内电层。
Internal plane layer(内部电源/接地层) Altium Designer提供了32个内部电源层/接地层。该类型的层仅用于多层板，主要用于布置电源层和接地层。我们称双层板，四层板，六层板，一般指信号层和内部电源/接地层的数目。
Silkscreen layer(丝印层) 丝印层主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。Altium Designer提供了Top Overlay（顶层丝印层）和Bottom Overlay（底层丝印层）两个丝印层。
Solder mask layer(阻焊层) 在焊盘以外的各部位涂覆一层涂料，我们通常用的有绿油、蓝油等，用于阻止这些部位上锡。阻焊层用于在设计过程中匹配焊盘，是自动产生的。阻焊层是负片输出，阻焊层的地方不盖油，其他地方盖油。Altium Designer提供了**Top Solder(顶层)和Bottom Solder(底层)**两个阻焊层。
Paste mask layer(助焊层，SMD贴片层) 它和阻焊层的作用相似，不同的是在机器焊接时对应的表面粘贴式元件的焊盘。Altium Designer提供了Top Paste(顶层助焊层)和Bottom Paste(底层助焊层)两个助焊层。主要针对PCB板上的SMD元件。在将SMD元件贴PCB板上以前，必须在每一个SMD焊盘上先涂上锡膏，在涂锡用的钢网就一定需要这个Paste Mask文件,菲林胶片才可以加工出来。Paste Mask层的Gerber输出最重要的一点要清楚，即这个层主要针对SMD元件，同时将这个层与上面介绍的Solder Mask作一比较，弄清两者的不同作用，因为从菲林胶片图中看这两个胶片图很相似。
Multi layer(多层) 电路板上焊盘和穿透式过孔要穿透整个电路板，与不同的导电图形层建立电气连接关系，因此系统专门设置了一个抽象的层—多层。一般，焊盘与过孔都要设置在多层上，如果关闭此层，焊盘与过孔就无法显示出来。
Drill layer(钻孔层) 钻孔层提供电路板制造过程中的钻孔信息(如焊盘，过孔就需要钻孔)。Altium Designer提供了Drill gride(钻孔指示)和Drill drawing(钻孔)两个钻孔层。
原理图库器件画法 放置矩形
添加Pin
设置器件的Designator（例如P?）
器件的PCB封装画法 确定是过孔还是焊盘，然后根据坐标放置位置，最后画丝印。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH07 类</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/</link>
      <pubDate>Tue, 27 Apr 2021 10:08:56 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE5%E7%B1%BB/</guid>
      <description>以一个例子来说明类
strut Sales_data { public: //构造函数 	Sales_data() = default; Sales_data(const std::string &amp;amp;s) : bookNo(s) {} Sales_data(const std::string &amp;amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {} Sales_data(std::istream &amp;amp;); //成员函数： 	std::string isbn()	const {return bookNo; } Sales_data&amp;amp; combine(const Sales_data&amp;amp;); private: double avg_price() const; std::string bookNo; //类内初始值(数据成员) 	unsigned units_sold = 0; double revenue = 0.0; }; //在类的外部定义成员函数 double Sales_data::avg_price() const { if (units_sold) return revenue / units_sold; else return 0; } //在类的外部定义构造函数 Sales_data::Sales_data(std::istream &amp;amp;is) { read(is, *this);	//从is中读取一条信息然后存入this对象中 } 成员函数 成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。作为接口的非成员函数，它的定义和声明都在类的外部。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Primer——CH01-06 基础内容</title>
      <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sun, 25 Apr 2021 10:08:56 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE1%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</guid>
      <description>第1部分：C++基础
这个分类的博客主要为了记录一下我在学习C++过程中记录的知识笔记，主要参考自《C++ Primer 第5版》。
第一部分基础部分主要包含以下内容：
 变量和基本类型 表达式 语句 函数  变量和基本类型 变量 变量的声明和定义：
显示声明时在变量前加上extern。
声明只规定了变量类型和名字，定义还申请了存储空间，为变量赋一个初始值。
可以在多个文件重复声明，但只能定义一次。
复合类型 引用
左值引用，为对象起了另一个名字；将声明符写成&amp;amp;d的形式来定义引用类型。
int ival = 1024; int &amp;amp;refVal = ival; int &amp;amp;refVal2; 引用即为对象的别名，引用本身不是一个对象，只是为一个已存在的对象起的另一个名字。
指针
指针本身就是一个对象，允许对指针赋值和拷贝，无需再定义时赋值，定义指针时将声明符写作*d形式，d为变量名。
double dp, *dp2; //dp2为指向double类型对象的指针 取地址符&amp;amp;：
int ival = 42; int *p = &amp;amp;ival;//p存放ival的地址 解引用符*：
int ival = 42; int *p = &amp;amp;ival;//p存放ival的地址 cout &amp;lt;&amp;lt; *p;	//输出指针p所指的对象，42 空指针：不指向任何对象，使用字面值nullptr来初始化指针。
给指针赋值：令他存放一个新的地址，从而指向一个新的对象。
void*指针：一种特殊类型的指针，可用于存放任意对象的地址。
复合类型的声明：
变量的定义包含一个基本数据类型和一组声明符；同一条定义中，基本数据类型只有一个，但声明符的形式可以不同，即一条语句可以定义不同类型的变量：
int i = 1024, *p = &amp;amp;i, &amp;amp;r = i; //i是一个int数，p是一个int类型指针，r是一个int类型引用 一般把修饰符(&amp;amp;,*)和变量标识符写在一起。</description>
    </item>
    
    <item>
      <title>机器学习——线性回归和梯度下降</title>
      <link>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</link>
      <pubDate>Fri, 23 Apr 2021 18:10:29 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</guid>
      <description>线性回归Linear Regression 简介 线性回归属于监督学习，先给定一个训练集根据训练集学习出一个线性函数，然后测试这个函数训练的好不好，挑选出最好的函数（cost function最小）即可。
注意：
 因为是线性回归，所以学习到的函数为线性函数，即一次直线函数； 因为是单变量，所以只有一个x；  所以能够给出单变量线性回归的模型： $$ h(x)=b+mx $$ 我们称$x$为feature，$h(x)$为hypothesis。
代价函数Cost Function 我们需要根据代价函数来确定线性回归拟合的好不好。Cost Function越小，说明线性回归地越好，最小为0，完全拟合。 $$ J(b,m)=\frac{1}{2n}(h(x^{(i)})-y^{(i)})^2 $$ 如上所示为代价函数的构造，其中，$x^{(i)}$表示向量x的第i个元素，$y^{(i)}$表示向量y的第i个元素，即表示所有输入的训练集的点。$h(x)$表示已知的假设函数，n为训练集的个数。
梯度下降 梯度下降能够找出代价函数Cost Function的最小值，梯度下降的方法步骤如下所示：
 先确定向下一步的步伐大小，我们称为Learning Rate； 任意给定初始值b, m； 确定一个向下的方向，按预定步骤向下走，并且更新b, m； 当下降高度(循环次数)小于某个定义的值时，停止下降。  循环下面的式子直到满足终止条件： $$ b = b - \alpha\frac{\partial}{\partial b}J(b,m) \ m = m - \alpha\frac{\partial}{\partial m}J(b,m) $$ 上式中的$\alpha$为Learning rate，决定了下降的步伐大小；偏导数决定了下降的方向。
对Cost Function运用梯度下降 $$ \mathrm{repeat \ until \ convergence}{ \ b:=b-\alpha \frac{1}{n}\sum_{i=1}^{n}(h(x^{(i)})-y^{(i)}) \ m:=m-\alpha \frac{1}{n}\sum_{i=1}^{n}(h(x^{(i)})-y^{(i)})x^{(i)} \ \ } $$</description>
    </item>
    
    <item>
      <title>串行通信协议详解：SPI、I2C、UART、JTAG</title>
      <link>https://eternityqjl.top/posts/%E4%B8%B2%E5%8F%A3/</link>
      <pubDate>Fri, 05 Feb 2021 18:20:54 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E4%B8%B2%E5%8F%A3/</guid>
      <description>SPI、I2C、UART：串行通信协议
COM口：串行通信端口，是物理接口形式（硬件），一般有4针杜邦头和D型9针插头两种。可以有很多种协议
TTL、RS-232指的是电平标准
TTL电平：低电平为0，高电平为1
RS-232电平：正电平(+15V)为0，负电平(-15V)为1
最近在画PCB研究几个MCU的时候遇到引脚连接方面的一些问题，对于MCU进行串行通信传输数据的过程不太了解，因此写一篇博客来学习一下这些通信协议。
一些概念 同步(Synchronous)和异步(Asynchronous) 同步就是整个处理过程顺序执行，当各个过程都执行完毕后，返回结果。这是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序。
异步：是只发送了调用的命令，调用者无需等待被调用的方法完全执行完毕，可以继续执行下面的流程，是一种并行处理的方式。比如页面数据架子啊的过程，不需要等待所有数据获取后再显示页面。
二者的区别就在于同步需要等待，异步不需要等待。
全双工和半双工 全双工是指可以同时进行双向信号传输。
半双工是指可以及进行双向信号传输但同一时刻只能向一个方向传输。
SPI协议 串行外设接口总线（Serial Peripheral Interface Bus，SPI）是一种用于芯片通信的同步串行通信接口规范，设备之间使用全双工模式通信，采用一对一或一对多的主从模式。一般用于短距离通信。
SPI物理层接口 SPI总线共规定了4个逻辑信号接口：
 SCLK/SCK（Serial Clock）：时钟信号线，由主机产生，决定了SPI的通信速率。 MOSI（Master Output, Slave Input）：主机输出从机输入信号，数据由主机发出。 MISO（Master Input, Slave Output）：从机输出主机输入信号，数据由从机发出。 nSS（Slave Select）：片选信号：用于选取SPI从设备，每个从设备独立拥有该条nSS信号线，占据主机的一个引脚，从设备的其他总线是并联到主机的。从设备的nSS引脚被置拉低时表明该从设备被主机选中。  （图片来自维基百科序列周边接口）
SPI协议层 （图片来自SPI通讯协议介绍）
如图为SPI的通信时序图，nSS、SCK、MOSI信号均由主机产生，MISO信号由从机产生。当nSS为低电平时信号有效。每个时钟周期MOSI和MISO传输一位数据。偶数边采样。
通信起始/结束信号 nSS信号由高电平变为低电平即为通信的起始，由低电平变为高电平即为通信的结束。
有效数据的采集 上图中SCK为偶数边沿时数据得到有效采样，此时MISO和MOSI的数据有效，高电平表示1，低电平表示0，其他时刻的数据无效。
数据传输时高位在先还是低位在先SPI协议并未规定，需要双方自行约定，一般采用高位在先（MSB）方式传输。
 两个概念：
 时钟极性（CPOL）：通信设备处于空闲状态（SPI开始通信前，即nSS无效）时，SCK的状态。  CPOL = 0：SCK在空闲时为低电平 CPOL = 1：SCK在空闲时为高电平   时钟相位（CPHA）：数据的采样时刻位于SCK的偶数边还是奇数边。  CPHA = 0：在SCK的奇数边沿采样 CPHA = 1：在SCK的偶数边沿采样     所以，数据的采样时刻并非由上升沿/下降沿所决定；在采样时刻，MOSI和MISO信号不能进行高低电平的变换。</description>
    </item>
    
    <item>
      <title>《算法（第4版）》学习笔记——（一）排序</title>
      <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 23 Jul 2020 14:59:12 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/</guid>
      <description>初级排序算法 选择排序 算法描述 首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。
代码实现 public class Selection { public static void sort(Comparable[] a) { //将a按照升序排列  int N = a.length; for (int i = 0; i &amp;lt; N; i++) { int min = i; for (int j = i + 1; j &amp;lt; N; j++) { if (less(a[j], a[min])) min = j; } exch(a, i ,min); } } } 性能分析  对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。 该算法运行时间与输入无关，数据的移动是最少的。  插入排序 算法描述 插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。
代码实现 public class Insertion { public static void sort(Comparable[] a) { int N = a.</description>
    </item>
    
    <item>
      <title>Dijkstra双栈——算术表达式求值</title>
      <link>https://eternityqjl.top/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Tue, 21 Jul 2020 20:15:08 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>算数表达式 这里的算术表达式支持常见的二元运算符+-*/以及接受一个参数的平方根运算符sqrt。这里我们假定表达式中未省略所有的括号。
计算方法  将操作数压入操作数栈 将运算符压入运算符栈 忽略左括号 遇到右括号时，弹出一个运算符，弹出需要数量的操作数进行运算，然后将得到的结果再压入操作数栈。  代码实现 package edu.princeton.cs.algs4; public class Evaluate { public static void main(String[] args) { Stack&amp;lt;String&amp;gt; ops = new Stack&amp;lt;String&amp;gt;(); Stack&amp;lt;Double&amp;gt; vals = new Stack&amp;lt;Double&amp;gt;(); while (!StdIn.isEmpty()) { //读取字符，如果是运算符则压入运算符栈ops 	String s = StdIn.readString(); if (s.equals(&amp;#34;(&amp;#34;)); else if (s.equals(&amp;#34;+&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;-&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;*&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;/&amp;#34;)) ops.push(s); else if (s.equals(&amp;#34;sqrt&amp;#34;)) ops.push(s); //如果字符为)，则弹出运算符和操作数，计算结果并压入操作数栈vals 	else if (s.equals(&amp;#34;)&amp;#34;)) { String op = ops.</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（二）——运输层</title>
      <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
      <pubDate>Wed, 06 May 2020 21:27:10 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
      <description>概述和运输层服务 运输层协议在不同主机上的应用进程之间提供了逻辑通信，这并非物理上的实际通信。在发送端，运输层将从应用程序接收到的报文转换成运输层分组，该分组称为运输层报文段，实现方法是将应用报文划分为一个个小的块，为每个块加上运输层首部生成运输层报文段，然后在端系统中传递给网络层，网络层将其封装成网络层分组，向目的地发送。
因特网由TCP和UDP两种运输层协议。
运输层和网络层的关系 网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。
运输层协议至工作在端系统中，同时网络中的路由器既不处理也不识别运输层加在应用层报文的任何信息。运输层协议能提供的服务常常受制于底层网络层协议，例如，如果网络层协议无法为主机之间发送的运输层报文段提供时延和带宽保证，运输层协议可就无法为进程之间发送的应用程序报文提供时延和带宽保证。
运输层概述 首先定义两个名词的意义：
 报文段：运输层分组，即TCP和UDP的分组 数据报：网络层分组  网络层的IP被称为不可靠服务。
多路复用与多路分解 在目的主机中，运输层从紧邻其下的网络层接受报文段，并将这些报文段中的数据交付给在主机上运行的对应应用程序进程。
多路分解是指将运输层报文中的数据正确交付给正确的套接字的工作。
多路复用是指在源主机中从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层。
运输层多路复用的要求：
  套接字有唯一标识
  每个报文段有特殊字段来指示该报文段所要交付到的套接字
 特殊字段：源端口号字段、目的端口号字段   0~1023范围的端口称为周知端口号，是受限的，它们分配给周知应用层协议来使用
   无连接运输：UDP UDP从应用程序得到数据，附加上用于多路复用/分解服务和目的地端口字段号，以及两个其他字段，然后将形成的报文交给网络层，网络层将运输层报文封装到一个一个IP数据报中，然后尽力交付给目的主机。
UDP被称为无连接运输是因为在发送报文段之前，发送方和接收方的运输层实体之间没有握手。
一些应用相比于TCP更适合于使用UDP的原因：
 关于发送什么数据以及何时发送的应用层控制更为精细 无需建立连接，开始传输数据前不需要握手 无连接状态。TCP中要实现可靠数据传输服务并提供拥塞控制，状态信息是必须的。 分组首部占用空间小。每个TCP报文段有20个字节的首部开销，UDP仅有8个字节。  UDP报文段结构 UDP检验和 检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生变化。
提供差错检验的原因是不能保证源和目的之间的所有链路都提供了差错检测。
虽然UDP提供了差错检验，但是它对于差错恢复无能为力，它只是丢弃受损的报文段。
可靠数据传输原理 可靠数据传输协议是用来实现一种服务的抽象：数据可以通过一条可靠的信道进行传输。可靠传输协议的下层也许是不可靠的，如TCP是在不可靠的端到端网络层(IP)之上实现的可靠数据传输协议。我们目前可将较低层直接视为不可靠的点对点信道。
构造可靠数据传输协议 rdt1.0：经完全可靠信道的可靠数据传输
此时的底层信道完全可靠，接收端不需要提供任何反馈信息给发送方。
 有限状态机(Finite-State Machine, FSM)：表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。  FSM描述图中箭头指示了协议从一个状态便签到另一个状态 横线上方：引起变迁的事件 横线下方：事件发生时所采取的动作    发送方和接收方有各自的FSM
rdt1.0的发送端通过rdt_send(data)事件接受来自叫高层的数据，产生一个包含该数据的分组(由make_pkt(data)动作产生)，并将分组发送到信道中。
接收端通过rdt_rcv(packet)从底层信道接受一个分组，从分组中取出数据(由extract(packet, data)动作完成)，并将数据上传给叫高层(通过deliver_data(data)完成)。
rdt2.0：经具有比特差错信道的可靠数据传输
底层信道更为实际的模型是可能受损的模型，这样的比特差错通常出现在网络的物理部件中，自动重传请求协议(Automatic Repeat reQueat, ARQ)：</description>
    </item>
    
    <item>
      <title>TLS（HTTPS）协议</title>
      <link>https://eternityqjl.top/posts/tls/</link>
      <pubDate>Sun, 19 Apr 2020 16:15:26 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/tls/</guid>
      <description>SSL/TLS简介 TLS（Transport Layer Security，传输层安全协议），以及它的前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议。Netscape公司在1994年推出HTTPS协议，使用SSL进行加密，这是SSL的起源。1999年公布了第一版的TLS协议，类似于SLLv3，只是对其做出了一些更改。
SSL协议处在计算机网络中的应用层和运输层之间，它不依赖于平台和运行程序的协议。
几个知名的使用SSL加密的协议：
HTTP over SSL (HTTPS)
简称为HTTPS，它的产生是为了加密网页，HTTP是第一个使用SSL保障安全的应用层协议。HTTPS在RFC2818被标准化，HTTPS工作在443端口，HTTP默认工作在80端口。
Email over SSL
类似于HTTP over SSL，协议如下：
 SMTP、IMAP能够支持SSL SMTP over TLS在标准文档RFC2487中  SSL原理详解 基本运行过程 SSL/TLS协议是采用公钥加密法实现的，客户端先向服务器端索要公钥，用公钥加密信息，服务器收到密文后，用自己的私钥解密；二者协商生成”对话密钥“，采用该”对话密钥“进行加密通信。
SSL建立的总过程 客户端向服务器索要并验证公钥，双方协商生成”对话密钥“的过程又称为”握手阶段“，该阶段涉及四次握手通信，且该阶段的通信都是明文的。以下一一来分析。
1. 客户端发出请求（ClientHello） 该步客户端（通常为浏览器）向服务器提供以下信息：
 支持的协议版本（Version），如TLSv1.0 一个客户端生成的随机数（Random），之后用于生成”对话密钥“ 会话ID（Session id）：  如果客户端第一次连接到服务器，那么该字段为空。 如果该字段不为空，则说明以前与服务器有连接，在此期间，服务器使用Session ID映射对称密钥，并将Session ID存储在客户端浏览器中，为映射设置一个时间限，如果浏览器将来连接到同一台服务器，它将发送Session ID，服务器对映射的Session ID进行验证，并使用以前用过的对称密钥来恢复会话，该情况下不需要握手，也成为SSL会话恢复。   支持的加密套件（Cipher Suites），这是由客户按优先级排列的，但完全由服务器决定发送与否。服务器会从客户端发送的加密套件中选择一种作为共同的加密套件，如RSA公钥加密。 支持的压缩方法，这是为了减少带宽。从TLS 1.3开始，协议禁用了TLS压缩，因为使用压缩时攻击可以捕获到用HTTP头发送的参数，该攻击可以劫持Cookie。 扩展包。  2. 服务器回应（ServerHello） 该步骤包含以下内容：
 确认使用的版本，如TLSv1.0，如果浏览器与服务器支持的版本不一致，服务器会关闭加密通信。 一个服务器生成的随机数，之后用于生成”对话密钥“ 确认使用的加密套件 会话ID（Session ID）：  服务器将约定的Session参数存储在TLS缓存中，并生成与之对应的Session ID，它将与ServerHello一起发送到客户端。客户端可以写入约定的参数到此Session ID，并给定到期时间，客户端将在ClientHello中包含该ID。如果客户端再次连接到该服务器，服务器可以检查与Session ID对应的缓存参数，并重用他们而无需再次握手。这可以节省大量计算成本。 但在谷歌等大流量应用程序中这种方法存在缺点，每天有数百万人连接到服务器，服务器必须使用Session ID保留所有Session参数的TLS缓存，这是一笔巨大的开销。为解决该问题，在扩展包中加入Session Tickets，在这里客户端可以在ClientHello中指定它是否支持Session Tickets，然后服务器将创建一个新的Session Tickets，并使用只有服务器知道的经过私钥加密的Session参数，该参数存储在客户端中，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。   扩展包 服务器证书  当服务器需要确认客户端身份时，就会再包含一个请求，要求客户端提供”客户端证书“。例如金融机构只允许认证客户连入自己的网络，会向正式用户提供USB密钥（U盾），里面包含一张客户端证书。</description>
    </item>
    
    <item>
      <title>PDF转换为SVG</title>
      <link>https://eternityqjl.top/posts/convertpdftosvg/</link>
      <pubDate>Wed, 08 Apr 2020 00:15:48 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/convertpdftosvg/</guid>
      <description>前言 最近在写笔记文档和实验报告的时候遇到一些处理资料图片的问题，PDF电子书或文档中的插图一般为矢量图，自己写笔记如果需要引用这些插图时，一般会直接截图，截图为JEPG或PNG格式，并非矢量图，会在新的文档中出现失真。所以为了解决这个问题，我使用Adobe Acrobat和inkscape两个软件将PDF中的矢量图导出为SVG格式的矢量图。以下为具体步骤：
在Adobe Acrobat中选择编辑PDF选项 选择裁剪页面 框选所需图片的区域 双击框选的区域，按如下所示设置 选择组织页面 选定裁切后的页面 右击后选择打印页面 设置页面：按照PDF页面大小选择纸张来源，这样选择后最终导出的图片范围才是裁切时所选范围。然后打印。 用inkscape打开刚才打印的PDF文件，注意，导入时设置为第一项从Poppler/Cairo导入，类似于PS中的栅格化，这样才能保证图中的字体不发生改变 选择文件$\rightarrow$文档属性，设置自定义尺寸为缩放页面到内容$\rightarrow$缩放页面到绘图或选区 文件$\rightarrow$另存为，选择自己所需的格式，我一般选SVG </description>
    </item>
    
    <item>
      <title>第一次使用LaTex——问题整理</title>
      <link>https://eternityqjl.top/posts/latex-problems1/</link>
      <pubDate>Sun, 29 Mar 2020 00:14:06 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/latex-problems1/</guid>
      <description>0.前言 第一次使用Tex语言完整地完成了一篇实验报告的构建排版，这过程中遇到了各种各样的问题，有些问题虽然解决了，但在原理方面还是一知半解，之后再遇到还希望能多看文档。这篇博客是来记录第一次编写过程中遇到的一些问题。
这是第一次实验报告导出的pdf文档封面展示：
这是tex源代码。
章节标题的特殊符号 当我在章节标题的大括号内输入行内公式时出现了错误，查找后发现pdf书签中不能使用特殊符号，需要用命令\texorpdfstring{}{}分别定义在TEX文档输出的代码和PDF书签处的纯文本形式，第一个括号{}中填写tex文档代码，第二个括号{}填写文本形式的书签，如下所示：
%1.1 \subsection[第3题（1）]{第3题（1）求\texorpdfstring{$x_1(t)=1.5e^{-2t}u(t)$}{x1}， \texorpdfstring{$x_2(t)=cos(t2)[u(t)-u(t-2)]$}{x2}的卷积积分 \texorpdfstring{$y_1(t)=x_1(t)*x_2(t)$}{y1}。 } 代码段的设置 在文章中添加代码段需要用到listings宏包，代码段的基本设置参数如下所示：
 listings宏包文档
 \usepackage{listings} \lstset{ language=Matlab, escapeinside=``, numbers=left, numberstyle=\tiny, breaklines=true, backgroundcolor=\color{lightgray!40!white}, frame=single, framerule=0pt, extendedchars=false, keywordstyle=\color{blue!70}\bfseries, basicstyle=\ttfamily, commentstyle=\ttfamily\color{green!40!black}, showstringspaces=false} 同时，设置代码段颜色高亮时需要用到xcolor宏包。
注意以下几点问题：
 代码段中最好不要出现中文，如果必须要使用中文，需要用逃逸字符` `将中文包括起来，如上面的基本参数中的escapeinside=` ` 所示。 如果代码段中出现tex语言的特殊符号，需要使用转义字符\，如#就需要转换为\#。  如果想要改变代码段中的字体，需要用到fontspec宏包，这个宏包需要用XeLaTex或LuaLaTex进行编译，由于我的实验报告封面使用的有些元素在使用这两者编译时无法识别，我这次就没使用，下次写实验报告一定仔细研究一下，实现这个功能。
数学公式中的align  参考：“Erroneous nesting of equation structures” message- I can&amp;rsquo;t see what&amp;rsquo;s wrong?
 数学公式中需要写等号对齐的公式段是不需要写$$...$$或者begin{equation}...end{equation}，直接将公式写在begin{align}...end{align}的中间即可，如下所示：
\begin{align} y_2[n] &amp;amp;=x_3[n]*x_4[n] \\ &amp;amp;=((-\frac{2}{3})^n u[n-1])*((-1)^{n+1}u[n-1]-(-2)^{n-2}u[n-2]) \\ &amp;amp;=\sum_{k=-\infty}^{+\infty}(-\frac{2}{3})^k u[k-1]((-1)^{n-k+1}u[n-k+1]-(-2)^{n-k-2}u[n-k-2]) \\ &amp;amp;=\sum_{k=1}^{+\infty}(-\frac{2}{3})^k ((-1)^{n-k+1}u[n-k+1]-(-2)^{n-k-2}u[n-k-2]) \\ &amp;amp;= \begin{cases} 0, \ n&amp;lt;0 \\ \sum_{k=1}^{+\infty}(-\frac{2}{3})^k (-1)^{n-k+1}u[n-k+1], \ 0 \leq n \leq 2 \\ \sum_{k=1}^{+\infty}(-\frac{2}{3})^k ((-1)^{n-k+1}u[n-k+1]-(-2)^{n-k-2}u[n-k-2]),\ n&amp;gt;2 \end{cases} \end{align} </description>
    </item>
    
    <item>
      <title>信号与系统学习笔记——Chapter01 信号与系统</title>
      <link>https://eternityqjl.top/posts/signalsystem-ch01/</link>
      <pubDate>Sat, 14 Mar 2020 13:59:44 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/signalsystem-ch01/</guid>
      <description>1.3 指数信号与正弦信号 1.3.1 连续时间复指数信号与正弦信号 连续时间复指数信号有如下形式： $$ x(t)=Ce^{at} $$
实指数信号 上式中的$C$和$a$都为实数的信号。
周期复指数信号和正弦信号 第二种重要的信号为将上式$a$限制为纯虚数的信号（复指数信号）： $$ x(t)=e^{jw_0t} $$ 当基波周期$T_0 = \left| \frac {2\pi} {w_0} \right|$时，该信号是周期信号。
与该信号相关的另一种信号是正弦信号： $$ x(t)=A\cos(w_0t+\phi) $$ 利用欧拉公式，可以将复指数信号用与其相同几波周期的正弦信号来表示： $$ e^{jw_0t}=\cos w_0t + j\sin w_0t $$ $w_0$称为基波频率。
上述复指数信号和正弦信号都是具有无限能量但有有限平均功率的信号。
计算证明： $$ E_{period}=\int_{o}^{T_0} \left| e^{jw_0t} \right|^2 \mathrm{d}t = \int_{o}^{T_0} 1 \cdot \mathrm{d}t = T_0 \ P_{period}= \frac {1}{T_0} E_{period}=1 $$
一般复指数信号 一复指数信号$Ce^{at}$，将复数$C$和$a$分别用指数式（极坐标）和代数式（笛卡尔坐标）表示： $$ C = \left| C \right| e^{j \theta} \ a = r + j\omega_0 $$ 代入得： $$ \begin{align} Ce^{at} &amp;amp; = \left| C \right| e^{j\theta} e^{(r+jw_0)t} \ &amp;amp; = \left| C \right| e^{rt} e^{j(w_0t+\theta)} \ &amp;amp; = \left| C \right| e^{rt} \cos(w_0t+\theta) + j\left| C \right| e^{rt} \sin(w_0t+\theta) \end{align} $$ 若$r=0$，则复指数信号的实部和虚部都是正弦；若$r&amp;gt;0$，则实部和虚部是一个呈指数增长的正弦信号；若$r&amp;lt;0$，则二者都是一个呈指数衰减的正弦信号，该信号被称为阻尼正弦震荡。</description>
    </item>
    
    <item>
      <title>数字签名和数字证书</title>
      <link>https://eternityqjl.top/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Fri, 06 Dec 2019 19:42:38 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</guid>
      <description>理解本文的基础是公钥密码加密，即非对称加密，比如其中一种非对称加密算法RSA。
非对称加密使用一对密钥，一个为公钥Pub，另一个为私钥Priv
明文P经过公钥Pub使用RSA加密算法混淆后变成了密文M，密文M无法用公钥Pub解开，只能用私钥Priv解开
同样的，明文P经过私钥Priv使用RSA加密算法混淆后变成了密文N，密文N只能用公钥Pub解开
信息安全 在信息安全中共有3个需要解决的问题：
 保密性：保证信息在传输时不被泄露 完整性：信息在传输时不被篡改 有效性：信息的使用者是合法的  公钥密码能解决保密性的问题
数字签名能解决完整性和有效性的问题
数字签名(Digital Signature) 真实世界中，签名是为了表示某些内容是签名者写的或者他所认可的。计算机中，数字签名也有着相似的含义，数字签名用来证实消息是某个特定的人发送的，即有效性；同时还能证明消息没有被篡改，即完整性。这些是怎么实现的呢？这就是接下来要介绍有关于数字签名的内容。
数字签名是公钥密码加密的逆向应用：
用私钥加密消息，用公钥解密消息。
 签名：用私钥加密的消息，只有拥有私钥的用户可以生成签名，这也确保了数字签名的发送者是该用户。 验证签名：即用公钥解密签名，因为公钥是公开的，所以任何人都可以验证签名。  生成签名 一般不直接对消息进行签名，而是对消息进行哈希计算后的得到的哈希值进行签名。
 HASH算法是密码学的基础，其中最重要的两条性质是不可逆和无冲突，
 不可逆：当你知道x的HASH值时，无法求出x 无冲突：你知道x，但无法求出一个y使得x与y的HASH值相同  这两个性质在数学上都是不成立的，理论上由无穷多不同的原始值，它们的HASH值都相同。但求逆和求冲突在计算上不可能实现，穷尽人类所有的计算资源都做不到。
 生成签名的步骤如下：
 对消息进行哈希计算，得到哈希值 利用私钥对哈希值进行加密，生成签名 将签名附在消息后，一起发送  验证签名  收到签名后，提取消息中的签名 用公钥对签名进行解密，得到哈希值1 对消息中的正文进行哈希计算，得到哈希值2 比较哈希值1和2，如果相同，则验证成功  注：前面提到，哈希值的计算不可逆，因此才能以这种方式验证签名。
数字证书(Digital Certificate) 数字证书是对公钥进行数字签名，是为了对公钥的合法性提供证明，如果公钥的合法性得不到证明，则就存在中间人攻击的风险。
 中间人攻击（Man-in-the-middle-attack）：
攻击者与通信的两端分别建立独立的联系，并交换所收到的数据。即中间人通过截获两端通讯使用的公钥，并将双方的两个公钥都更改为自己的公钥来达到截获消息的目的。
详情可以参考维基百科：中间人攻击
 我们对于签名的验证需要使用公钥，而公钥的真实合法性就是通过数字证书来的。证书中包含：公钥、公钥的数字签名、公钥拥有者的信息。如果证书验证成功，则代表该公钥是合法的。
但是，验证证书中的数字签名需要另一个公钥，该公钥的合法性又怎样保证呢？该问题可以无限地循环下去，那岂不是解决不了了？我们相信银行是一个可信的机构，可以放心地把钱存在里面，那么同样存在一个可信机构来颁发证书和提供公钥，我们相信这个机构提供的密钥是合法的。
这种机构称为认证机构(Certification Authority, CA)，CA认定“公钥确实属于某个私钥的拥有者”，并能生成公钥的数字签名的组织或机构。
如何生成证书？  证书即为公钥、公钥的数字签名、一些其他服务器信息的集合
  服务器将公钥A交给CA CA通过哈希计算生成公钥A的哈希值，然后用自己的私钥B给公钥A的哈希值加密，生成数字签名A CA把公钥A、数字签名A、一些服务器信息整合，生成证书，发回给服务器  如何验证证书？  客户端得到证书 客户端通过CA得到证书的公钥B 客户端用公钥B对证书中的数字签名A解密，得到哈希值 客户端对公钥A进行哈希值计算 将两个哈希值对比，如果相同，则证书合法  公钥B和上述私钥B是配对的，分别用于解密和加密证书。</description>
    </item>
    
    <item>
      <title>写在2019年的最后一个月的开始</title>
      <link>https://eternityqjl.top/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Sun, 01 Dec 2019 22:06:08 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E5%86%99%E5%9C%A82019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BC%80%E5%A7%8B/</guid>
      <description>转眼间2019年就要结束了，依稀记得2019年的刚开始我还在发空间动态说自己又买了一本日历，然而&amp;hellip;明年就不买了吧，我并没有记得经常去看日历，更别说去每天一张一张地撕它。这一年里经历了非常多的事情，从学习、生活、关于未来的各方各面，我都发生了极大的改变，这源于我不断变化的想法，目标总是飘忽不定，我思考过，也经常迷茫，现在也是。
在写下这些话的时间里，我其实是非常难过和害怕的，这一个周末似乎没干什么事情就又要浑浑噩噩地结束了，直到现在还有一个DDL等着我，明早截止，我还没做完，间歇性拖延症晚期这件事情，一直发生在我身上，毫不夸张地说，我可以不间歇地拖延整整24小时，这过程中总想着做些什么、改变些什么，但除了睡觉，大部分时间眼睛都盯在手机屏幕上，尽管我知道这样做一点儿也不好，但结果还是发生了。我知道学习的重要性，也会去为了一个想要实现的东西不断地思考并找到解决方法，就比如搭建网站这件事情，前前后后花了很多的时间也学习了很多相关知识，基本掌握了中间的原理，结果在我预想的时间之前很久就做出来了，结果还是超乎预期的好。说实话，完成一件能看的到结果的事情能给人的心理带来很大的快感的愉悦，但愉悦过后，又只剩下了迷茫和拖延，并且在为了找到下一个实践目标而苦苦挣扎着。有时候大脑盯着手机屏幕看一些信息的时候，知道这是自己不想接收和浪费时间的，但就是控制不住自己去点开看，这样的人性的弱点也造就了很多的商机，造就了很多企业和公司的成功。
说点儿别的。在关于情感和人际交往方面，我可能是一个与绝大多数人都不一样的人，在情感上，我很少与他人或者是在公开场合表露（包括我的社交媒体，我发现，自己现在很少在社交媒体上表露自己的情感，更多的是分享一些自己的兴趣爱好，比如我热爱的摄影，因而，我也就把自己的空间对所有人开放了，微信这个东西另当别论，说实话，我挺讨厌这个软件的），但我还是知道自己想要的是什么，纵然我在过去的一年里总是带着一些自卑的情感，很久没有与他人进行深入内心的交谈，KY的与陌生人打电话活动也错过了很多次，每次都是在想和别人深入交流的时候才想起来，结果肯定是已经结束了，今后还是要多多关注，想想能与一同关注KY的人打电话是一件挺幸福的事情，也希望自己能早日找到灵魂伴侣。在人际交往方面，我尝试过学校的很多社团和活动，最终无一例外全都放弃了，我觉得也挺好，这也证明了我确实不喜欢过多的浮于表面和拉帮结派建造复杂人际关系的事情，做好自己就最好了，能认识几个朋友还是随缘了，人也并不需要那么多看上去像是朋友的朋友。
扯了这么多，还是回到最重要的学习和事业上吧。12月希望自己能好好学习学校的课程知识，好好地应对一下考试。明年下半年就要大三了，这学期结束以后要为成为一个前端工程师立一些目标，毕竟就快要毕业了，还是希望自己能去做自己喜欢的工作，上研究生这件事就暂时不考虑了，我在经历了一些事情以后对于读研这件事一点儿也不感兴趣了，做好自己就好了。
以上。</description>
    </item>
    
    <item>
      <title>计算机网络学习日志（一）——应用层</title>
      <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</link>
      <pubDate>Thu, 28 Nov 2019 19:23:38 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%80%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
      <description>应用层是计算机网络从上往下的第一层，这一层的主要内容是网络应用的原理和实现，通过学习几种常见的网络应用程序，并且开发运行在TCP和UTP(运输层)上的网络应用程序，这些应用程序包含Web、电子邮件、DNS、P2P等等。
应用层协议 开发网络应用程序是要开发运行在不同端系统上并且通过网络(下层协议)彼此通信的程序，这过程中不需要为下层的网络核心设备写程序，因为它们不在应用层上起作用。
网络应用程序体系结构 客户——服务器体系结构：
 客户：发送主机请求 服务器：总是打开的主机，接收来自客户的请求  举例：Web应用程序
P2P体系结构
 对于数据中心服务器几乎没有依赖。 应用程序在对等方之间直接通信 具有自扩展性，报文在主机之间直接发送，服务器用来追踪IP，有安全隐患。  举例：BitTorrent、Skype
进程通信 端系统之间的通信实际上是进程，进程通过跨越网络发送报文来进行通信。进程是运行在端系统上的程序，同一个端系统和不同端系统之间的进程都可以进行通信，这里主要讨论不同端系统之间跨越网络的通信。
客户与服务器之间的进程：
 客户-服务器体系中，比如Web服务器，一个进程被标识为客户(Client)，另一个进程被标识为服务器(Server)。 P2P体系中，一个进程既可以是客户又可以是服务器。  进程与网络之间的接口——套接字：
套接字(端口号)是应用程序和运输层之间的接口，也成为应用程序编程接口。
进程寻址：
为了向特定的目的地发送报文，需要有目的地主机的相关信息，这些信息为：
 IP地址：用来标识目的地主机。 端口号：用来指定接受进程(即接受套接字)，例如Web服务器用端口号80标识，邮件服务器进程用25标识。  供应用程序使用的运输服务 开发应用程序时，需要选择一种适合的运输层协议，运输层协议能够提供的服务主要有以下：
  可靠数据传输：进程与进程之间的可靠数据传输，有不提供可靠数据传输的应用层协议，使用这种应用层协议的应用被称为容忍丢失的应用。
  吞吐量：发送进程向接收进程交付比特的速率，所以运输层协议可以提供以特定速率确保的可用吞吐量的服务，对此有需求的应用称为带宽敏感应用，如一些多媒体语音和视频应用。
  定时（延迟）：例子：发送方注入比特至套接字到接收方烧到比特的时间不多于100ms，这对于实时交互应用很重要，例如多方射击游戏。
  因特网提供和未提供的运输服务 因特网为应用程序提供两个运输层协议，TCP和UDP，开发者必须做出选择。
TCP服务：
 面向连接服务：报文数据流动前，TCP让客户和服务器交换运输层控制信息(即握手)，之后一个TCP连接就建立了，这条连接是全双工的，应用程序运行结束后要拆除该连接。 可靠数据传输服务：无差错、按顺序交付报文。 拥塞控制机制   安全套接字层(Secure Sockets Layer, SSL)，是加强版的TCP协议，提供了进程之间的安全加密服务，这种强化是在应用层上实现的。
 UDP服务：
是一种轻量运输协议，进程通信时无握手过程，不保证到达，同时无拥塞控制机制。
 注，这里只是简要的内容，更多详细内容将在第三章运输层中提到。
 未提供的服务：
以上两个协议提供了可靠数据传输、安全性相关的服务，但并未提供2.3中所述的吞吐量和定时的服务，所以因特网并不提供这两项服务。虽然未提供具体的服务，但因特网已经运行很多年，对于时间敏感的应用已经被设计得尽可能应对这种保证的缺乏。
应用层协议总结 应用层协议定义了以下内容：
 交换的报文类型，如请求和响应报文 报文语法 字段语义 确定进程何时发送报文  Web和HTTP HTTP概况 **超文本传输协议（HyperText Transfer Protocol，HTTP）**是Web的应用层协议，它由客户程序和服务器程序实现，客户和服务器运行在不同端系统中，通过HTTP报文进行会话。</description>
    </item>
    
    <item>
      <title>GitBook自动发布脚本</title>
      <link>https://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Fri, 18 Oct 2019 13:50:49 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/gitbook%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</guid>
      <description>GitBook作为一个非常好用的基于Node.js的命令行工具，可以输出HTML、PDF、eBook等多种格式的电子书，这里就不再详细讲述GitBook的构建以及发布到Github托管的过程，网络上有非常多的教程，可以自行Google查看。
刚开始在每次更新内容的时候都需要一系列的git命令将原始内容仓库和构建的网页仓库同步到Github上，大概需要10条命令，如果你的更新频率很高的话，发布内容将会是有个痛苦的过程，但这里我们可以通过一个shell脚本只使用$ sh deploy.sh一条命令完成同步内容和构建网页的所有过程。
首先，在你的GitBook内容根目录下建一个deploy.sh文件，使用文本编辑器打开，然后输入以下内容：
#!bin/sh git checkout master # 切换到master分支，及内容所在的仓库 git add . git commit -m &amp;#34;Update&amp;#34; git push -u origin master # 添加、提交到Git仓库，然后push到Github上 gitbook build # 构建Gitbook git checkout gh-pages # 切换到gh-pages分支，即生成的HTML网页的仓库 cp -r _book/* . # 复制前面构建的内容 git add . git commit -m &amp;#34;Update&amp;#34; git push -u origin gh-pages # 添加、提交到Git仓库，然后push到Github上 git checkout master # 返回master主分支 然后打开命令行，为这个脚本授权：
$ chmod +x deploy.sh 至此就完成了，以后在更新的时候只需要输入一条命令$ sh deploy.sh就可以完成所有操作了。</description>
    </item>
    
    <item>
      <title>储存类别、链接和内存管理</title>
      <link>https://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 18 Oct 2019 10:59:58 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>一、储存类别
 对象：具有一定大小空间的一块内存。 标识符：用来指定特定对象的内容。   作用域  描述了程序中可访问标识符的区域。 分类：  块作用域 函数作用域 文件作用域 函数原型作用域：从形参定义处到原型声明结束。   全局变量：也称为文件作用域变量。   链接  C变量的三种链接属性：  外部链接：该类型变量可以在多文件程序中使用 内部链接：该类型变量只能在一个翻译单元中使用 无链接：具有块作用域、函数作用域或函数原型作用域的变量   储存类别说明符static   存储期：  C对象有4种  静态存储期：在程序的执行期间一直存在，文件作用域变量都具有静态存储期。 线性存储期：用于并发程序设计。 自动存储期：所有局部变量都有该性质，在函数调用时被创建，离开函数时被销毁。 动态分配存储期：     自动变量  属于自动存储类别，有自动存储期、块作用域、无链接。 可显式使用关键词auto 块作用域和无链接意味着只有在变量定义的块中才能通过变量名访问该变量。   寄存器变量  特殊的自动变量。也是自动存储期、块作用域、无链接。 可以显式使用关键词register，是一种请求，编译器可能会拒绝你的请求，此时就变成了普通变量，但仍然无法访问该变量的内存。 作用是储存在最快的可用内存中，能够以更快的速度访问。 存储在寄存器中而非内存中，所以无法获取寄存器变量的地址。   块作用域的静态变量  静态指的是在内存中原地不动，但它的值可以改变。 具有块作用域、无链接、有静态存储期。 在块中以static(提供静态存储期)声明这种变量。 如果未显式地初始化静态变量，它们会被初始化为0。   外部链接的静态变量  具有文件作用域、外部链接、静态存储期。 有时又称为外部存储类型、该类别地变量被称为外部变量。 创建过程：在所有函数外面(定义性声明)创建这个外部变量。 函数使用该变量时，为了指出使用的是外部变量，可以用关键字extern再次声明。 如果一个源文件使用的外部变量定义在其他文件中，则必须用extern在该文件中声明该变量。 定义式声明、引用式声明。   内部链接的静态变量  具有静态存储期、文件作用域、内部链接。 在所有函数外部，用存储类别说明符static定义该类变量。 该类型变量只能用于同一个文件中的函数。 可以在函数中使用类别说明符extern重复声明该类型变量，这并不会改变其链接属性。   多文件(多翻译单元)  程序在多个翻译单元中才能体现区别内部和外部变量的重要性。   存储类别的选择  正常情况下多使用自动存储类别，使用外部变量可能在不经意中修改变量的值，count类型变量除外。    二、</description>
    </item>
    
    <item>
      <title>C语言结构</title>
      <link>https://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 15 Oct 2019 20:03:54 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%BB%93%E6%9E%84/</guid>
      <description>1.建立结构变量
struct book { char title[MAXTITL]; char author[MAXAUTL]; float value; }  该结构描述了由两个字符数组和一个float类型变量组成的结构。  2.定义结构变量
struct book library;
  把library声明为一个使用book结构类型的结构变量。
  所以struct book 相当于过去的int、double等类型。
struct book { char title[MAXTITL]; char author[MAXAUTL]; float value; } library; 该程序为上面声明的完整版。
struct { //无结构标记  char title[MAXTITL]; char author[MAXAUTL]; float value; } library; 声明结构和定义结构可以一步完成，如上所示。
  3.初始化结构
4.访问结构成员(点运算符)
5.结构初始化器
6.结构数组
struct book library[MAXBKS];
7.指向结构的指针
struct guy * him;
 指针可以指向任何现有的guy类型如barney、fellow[0]（一个结构数组的一项即为一个结构变量）。  him = &amp;amp;barney or him = &amp;amp;fellow[0];</description>
    </item>
    
    <item>
      <title>字符串输入、输出和字符串函数</title>
      <link>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 28 Sep 2019 12:15:42 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</guid>
      <description>字符串输入 1.gets()函数
 使用方法：读取整行输入，直到遇到换行符，然后丢弃换行符，储存其余的字符，并在字符末尾添加一个空字符使之成为一个C字符串。 使用中存在的问题：gets(words)（char words[STLEN]）的唯一参数为words，该函数无法检查数组是否装得下输入行。数组名会被转化成该数组首元素的地址，该函数只知道数组的开始处，并不知道数组在何处结束。 如果输入过长，会导致缓存区溢出，详情见书上内容。  2.gets()的替代品：fgets()函数
 fgets()函数通过第二个参数来限制读入的字符数来解决溢出问题。 相较于gets()的区别：  第二个参数指明了读入字符的最大数量，若该值为n，那么将读入n-1个字符，或遇到第一个换行符为止。 第三个参数指明了要读入的文件，如果要从键盘输入，则参数设置为stdin标识符。 如果读到一个换行符，fgets()会将其储存在数组中，而不是将其丢弃。    3.gets_s()函数
  于fgets()的区别
  该函数只从标准输入中读取，所以无需第三个参数。
  读到换行符会将其丢弃。
  如果读到最大字符数都没有读到换行符，会进行以下操作：
 首先设置目标数组的首字符为空字符
读取并丢弃随后的输入直至读到换行符或文件结尾
返回空指针
然后调用依赖实现的“处理函数”
     4.s_gets()函数
 读取整行输入并用空字符替代换行符，或者(在字符串未结束就遇到了空字符)读取一部分输入，并丢弃其余的部分。  该函数的代码：
char * s_gets(char * st, int n) { char *ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] !</description>
    </item>
    
    <item>
      <title>抽象数据类型</title>
      <link>https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 24 Sep 2019 21:33:07 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>一、抽象数据类型的实现 //数据类型的实现 public class Counter { //实例变量  private final String name; private int count; //构造函数  public void Counter(String id) { name = id; } //实例方法  public void increment() { count++; } public int tally() { return count; } public String toString() { return count + &amp;#34; &amp;#34; + name; } } //测试该数据类型的用例 public static void main(String[] args) { //创建并初始化对象  Counter heads = new Counter(&amp;#34;heads&amp;#34;); Counter tails = new Counter(&amp;#34;tails&amp;#34;); //调用实例方法  heads.</description>
    </item>
    
    <item>
      <title>测试GitBook格式</title>
      <link>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 21:43:41 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95gitbook%E6%A0%BC%E5%BC%8F/</guid>
      <description>FlightMuseum-GitBook 目录层级  Preface Airbus  A320  A319 A320-200 A320-200neo A321 &amp;hellip;&amp;hellip;..   A330  A330-200 A330-300   A350  A350-900 A350-1000     Boeing  B737 B747 B767 B777 B787  B787-8 Dreamliner B787-9 Dreamliner B787-10 Dreamliner     &amp;hellip;&amp;hellip;. Trains  CR TRA JR     一个具体层级的Markdown编辑形式 1.Cathay Pacific | 国泰航空 B-LRA  Serial Number / 生产序列号：29 **First Flight Date / 首飞日期：**24th.</description>
    </item>
    
    <item>
      <title>什么是数据结构？什么又是算法？</title>
      <link>https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 19 Sep 2019 13:55:19 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF%E7%AE%97%E6%B3%95/</guid>
      <description>数据结构及相关概念 0. 要想知道什么是数据结构，首先要了解与“数据”相关的概念，这样才能一步步理解什么是数据结构。
我们首先用放书这件事情来举例。
 如果正常情况下只有你自己一个人的书，那么你把他们一本一本立起来放在书架上就可以了。 那么如果有一个图书馆那么多的书应该怎样办么？总不能把他们乱起八糟的立起来放吧？那么是不是应该先按照社会科学、理科类、工科类、外语类等等的分类方式先分类，然后按照具体所属的类别把他们一个个放进去？其实数据结构的相关的概念就是一个这样简单的道理。  下面我们来进行具体的描述。
1. 数据
 是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 其实就对应了图书馆中的所有书。  2. 数据元素
 是数据的基本单位，在计算机程序中通常作为一个整体进行考虑号处理。 对应的就是某一本具体的书，比如”数据结构与算法“这本书。  3. 数据项
 一个数据元素可由若干个数据项组成，数据项是数据的不可分割的最小单位。 数据项不就是对应了书中的具体信息，比如书的作者、章节内容、ISBN编号等等。  4. 数据对象
 是性质相同的数据元素的集合，是数据的子集。 数据元素是一本具体的书，那么性质相同数据元素的集合不就代表了一类具体的书籍吗，就比如计算机类的书籍，其中包含了”数据机构与算法这本书“。   看到这儿是不是对这几者的关系还有点儿晕？没关系，我们用思维导图来再次说明。
数据是由每一个具体的数据元素组成的，相同的数据元素同属于一个数据对象，每个数据元素中又有具体的信息——数据项。
 接下来让我们再次把这些概念对应到具体的例子”书”中。
世界上所有书就是一个数据，每一本具体的书例如“数据结构与算法”就是一个数据元素，每本书中的具体信息例如“书名、作者、ISBN码&amp;hellip;”就是多个数据项，一些相同类型的书的类型例如“计算机类书籍”就是一个数据对象。
现在你应该清楚以上4个概念了吧？
那我们回到最初的问题，什么是数据结构？
这里我们同样举例子来说明。
首先，一个类别的书籍中有许多具体的书，如&amp;quot;C语言&amp;quot;、&amp;ldquo;数据结构与算法&amp;rdquo;、&amp;ldquo;编译原理&amp;rdquo;，而这些书之间又有一些关联，比如*某个算法可以用C语言来实现*，编译过程中需要用到特定的算法等等，这些存在关联的书即&amp;quot;数据元素&amp;quot;的集合就叫做数据结构。
4. 数据结构
  相互之间存在一种或多种特定关系的数据元素的集合。
  大多数算法都需要我们适当地组织数据，而为了组织数据就产生了数据结构。
  结构
 逻辑结构
 集合
线性结构
树形结构
网状结构或图状结构
 物理结构(储存结构)
 顺序储存结构
链式储存结构
    (注：这里不具体展开介绍各个数据结构，在后面的附录里进行介绍)</description>
    </item>
    
    <item>
      <title>C语言指针</title>
      <link>https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 19 Sep 2019 13:10:25 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</guid>
      <description>一、指针的一些概念 1. 指针的类型  把指针声明语句中的指针名字去掉，剩下的就是指针本身的类型  2. 指针所指向的类型  把指针声明语句中的指针名字和名字前的指针声明符号*去掉，剩下的就是指针指向的类型  3. 指针的值——指针所指向的内存区或地址  指针的值是指针本身存储的数值，该值被编译器当作一个地址（在32位程序中，所有类型的指针的值都是一个32位的整数，因为32位程序的内存地址都是32位长。） 指针所指的内存区就是从指针的值所代表的内存地址开始，长度为sizeof(指针指向的类型)的一篇内存区。 我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区。 同理，我们说一个指针指向了某个内存区，相当于说该指针的值是该内存区域的首地址。  4. 指针本身所占据的内存区  用sizeof(指针的类型)测试一下就知道了  二、指针的算术运算 **0.**指针可以加上或者减去一个整数，这种运算的意义并不是平常的数值的加减。
 example 1  char a[20] = {0}; int *ptr = (int *)a; ptr++; 指针ptr的类型为int*，它指向的类型为int，被初始化为指向整型变量a。
在第三句中，指针ptr被加上了1，编译器是这样进行处理的：
 把指针ptr的值加上sizeof(int)，在32位程序中是被加上了4，因为32位程序中int占4字节。
由于地址是用字节作为单位，所以ptr指向的地址由原来的a的地址向高的地方增加了4个地址。
char类型的长度是一个字节，所以原来的ptr是指向数组a从第0个单元开始的4个字节，现在指向了从第4个单元开始的4个字节
  example 2  1.可以使用一个循环和一个指针遍历一个数组。
int array[20] = {0}; int *ptr = array; for (i = 0; i &amp;lt; 20; i++) { (*ptr)++; ptr++; } 该例子中将整形数组中各个单元的值都加1。同时每次循环都将指针加1个单元，所以每次循环都能访问数组的下一个单元。</description>
    </item>
    
  </channel>
</rss>
