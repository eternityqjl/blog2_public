<!DOCTYPE html>
<html><head>
<title>Csapp 8 异常控制流</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="书籍《深入理解计算机系统》阅读学习笔记">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="Csapp 8 异常控制流" />
<meta property="og:description" content="书籍《深入理解计算机系统》阅读学习笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-11T15:33:44+08:00" />
<meta property="article:modified_time" content="2022-01-12T17:51:55+08:00" /><meta property="og:site_name" content="My Blog" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Csapp 8 异常控制流"/>
<meta name="twitter:description" content="书籍《深入理解计算机系统》阅读学习笔记"/>







<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>


  




<link rel="icon" href="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/faviconJ.ico">



<link rel="stylesheet" href="https://eternityqjl.top/scss/journal.min.3f72a5fc8f5b5dd732a4b476aced0eece2156958d9d414316494ddb10593ddf7.css" integrity="sha256-P3Kl/I9bXdcypLR2rO0O7OIVaVjZ1BQxZJTdsQWT3fc=" media="screen">



<link rel="stylesheet" href="https://eternityqjl.top/scss/dark-mode.min.c0082f0b082177f6fb3768ff91439a097de49689bd26f4d49f76d94ebb81e02d.css" integrity="sha256-wAgvCwghd/b7N2j/kUOaCX3klom9JvTUn3bZTruB4C0=" media="screen">


<script src="/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>


  
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script"
async
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
MathJax.Hub.Queue(function() {



var all = MathJax.Hub.getAllJax(), i;
for(i = 0; i < all.length; i += 1) {
all[i].SourceElement().parentNode.className += ' has-jax';
}
});
</script>

<style>
code.has-jax {
font: inherit;
font-size: 100%;
background: inherit;
border: inherit;
color: #515151;
}
</style>





  
    <script src="/js/toc.js"></script>
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: '41f4d7bc98749bddfc28',
  clientSecret: '2be261f48bbef3de6eb7c463857986c02f45f72d',
  repo: 'blog2_public',
  owner: 'eternityqjl',
  admin: ['eternityqjl'],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>














</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://eternityqjl.top">
    
        <div class="nav-title">
            Jialong&#39;s Blog
        </div>
        
        <div class="nav-subtitle">
            沉潜 自由 追寻幸福
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                网志
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                分类
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                标签
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about">
                关于
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	2019-2021 By Jialong
	

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e5%bc%82%e5%b8%b8" onclick="onNavClick(`#异常-nav`)" id="异常-nav">
									异常
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" onclick="onNavClick(`#异常处理-nav`)" id="异常处理-nav">
									异常处理
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%bc%82%e5%b8%b8%e7%9a%84%e7%b1%bb%e5%88%ab" onclick="onNavClick(`#异常的类别-nav`)" id="异常的类别-nav">
									异常的类别
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#linuxx86-64%e4%b8%ad%e7%9a%84%e5%bc%82%e5%b8%b8" onclick="onNavClick(`#linuxx86-64中的异常-nav`)" id="linuxx86-64中的异常-nav">
									Linux/x86-64中的异常
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e8%bf%9b%e7%a8%8b" onclick="onNavClick(`#进程-nav`)" id="进程-nav">
									进程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e9%80%bb%e8%be%91%e6%8e%a7%e5%88%b6%e6%b5%81" onclick="onNavClick(`#逻辑控制流-nav`)" id="逻辑控制流-nav">
									逻辑控制流
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%b9%b6%e5%8f%91%e6%b5%81" onclick="onNavClick(`#并发流-nav`)" id="并发流-nav">
									并发流
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%a7%81%e6%9c%89%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" onclick="onNavClick(`#私有地址空间-nav`)" id="私有地址空间-nav">
									私有地址空间
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%94%a8%e6%88%b7%e6%a8%a1%e5%bc%8f%e5%92%8c%e5%86%85%e6%a0%b8%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#用户模式和内核模式-nav`)" id="用户模式和内核模式-nav">
									用户模式和内核模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2" onclick="onNavClick(`#上下文切换-nav`)" id="上下文切换-nav">
									上下文切换
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" onclick="onNavClick(`#系统调用错误处理-nav`)" id="系统调用错误处理-nav">
									系统调用错误处理
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6" onclick="onNavClick(`#进程控制-nav`)" id="进程控制-nav">
									进程控制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e8%8e%b7%e5%8f%96%e8%bf%9b%e7%a8%8bid" onclick="onNavClick(`#获取进程id-nav`)" id="获取进程id-nav">
									获取进程ID
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b" onclick="onNavClick(`#创建和终止进程-nav`)" id="创建和终止进程-nav">
									创建和终止进程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%9b%9e%e6%94%b6%e5%ad%90%e8%bf%9b%e7%a8%8b" onclick="onNavClick(`#回收子进程-nav`)" id="回收子进程-nav">
									回收子进程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%ae%a9%e8%bf%9b%e7%a8%8b%e4%bc%91%e7%9c%a0" onclick="onNavClick(`#让进程休眠-nav`)" id="让进程休眠-nav">
									让进程休眠
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8a%a0%e8%bd%bd%e5%b9%b6%e8%bf%90%e8%a1%8c%e7%a8%8b%e5%ba%8f" onclick="onNavClick(`#加载并运行程序-nav`)" id="加载并运行程序-nav">
									加载并运行程序
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%88%a9%e7%94%a8fork%e5%92%8cexecve%e8%bf%90%e8%a1%8c%e7%a8%8b%e5%ba%8f" onclick="onNavClick(`#利用fork和execve运行程序-nav`)" id="利用fork和execve运行程序-nav">
									利用fork和execve运行程序
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#信号-nav`)" id="信号-nav">
									信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e4%bf%a1%e5%8f%b7%e6%9c%af%e8%af%ad" onclick="onNavClick(`#信号术语-nav`)" id="信号术语-nav">
									信号术语
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8f%91%e9%80%81%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#发送信号-nav`)" id="发送信号-nav">
									发送信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%8e%a5%e6%94%b6%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#接收信号-nav`)" id="接收信号-nav">
									接收信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e9%98%bb%e5%a1%9e%e5%92%8c%e8%a7%a3%e9%99%a4%e9%98%bb%e5%a1%9e%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#阻塞和解除阻塞信号-nav`)" id="阻塞和解除阻塞信号-nav">
									阻塞和解除阻塞信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%bc%96%e5%86%99%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f" onclick="onNavClick(`#编写信号处理程序-nav`)" id="编写信号处理程序-nav">
									编写信号处理程序
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%90%8c%e6%ad%a5%e6%b5%81%e4%bb%a5%e9%81%bf%e5%85%8d%e8%ae%a8%e5%8e%8c%e7%9a%84%e5%b9%b6%e5%8f%91%e9%94%99%e8%af%af" onclick="onNavClick(`#同步流以避免讨厌的并发错误-nav`)" id="同步流以避免讨厌的并发错误-nav">
									同步流以避免讨厌的并发错误
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%98%be%e5%bc%8f%e5%9c%b0%e7%ad%89%e5%be%85%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#显式地等待信号-nav`)" id="显式地等待信号-nav">
									显式地等待信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e9%9d%9e%e6%9c%ac%e5%9c%b0%e8%b7%b3%e8%bd%ac" onclick="onNavClick(`#非本地跳转-nav`)" id="非本地跳转-nav">
									非本地跳转
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%93%8d%e4%bd%9c%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b7%a5%e5%85%b7" onclick="onNavClick(`#操作进程的工具-nav`)" id="操作进程的工具-nav">
									操作进程的工具
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a class="pagination-action" v-on:click="toggleDarkMode">
            <i class="material-icons pagination-action-icon" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons pagination-action-icon" v-else="isDarkMode">
                brightness_7
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    网志
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    分类
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    标签
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about">
                    关于
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e5%bc%82%e5%b8%b8" onclick="onNavClick(`#异常-nav`)" id="异常-nav">
									异常
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" onclick="onNavClick(`#异常处理-nav`)" id="异常处理-nav">
									异常处理
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%bc%82%e5%b8%b8%e7%9a%84%e7%b1%bb%e5%88%ab" onclick="onNavClick(`#异常的类别-nav`)" id="异常的类别-nav">
									异常的类别
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#linuxx86-64%e4%b8%ad%e7%9a%84%e5%bc%82%e5%b8%b8" onclick="onNavClick(`#linuxx86-64中的异常-nav`)" id="linuxx86-64中的异常-nav">
									Linux/x86-64中的异常
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e8%bf%9b%e7%a8%8b" onclick="onNavClick(`#进程-nav`)" id="进程-nav">
									进程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e9%80%bb%e8%be%91%e6%8e%a7%e5%88%b6%e6%b5%81" onclick="onNavClick(`#逻辑控制流-nav`)" id="逻辑控制流-nav">
									逻辑控制流
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%b9%b6%e5%8f%91%e6%b5%81" onclick="onNavClick(`#并发流-nav`)" id="并发流-nav">
									并发流
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%a7%81%e6%9c%89%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" onclick="onNavClick(`#私有地址空间-nav`)" id="私有地址空间-nav">
									私有地址空间
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%94%a8%e6%88%b7%e6%a8%a1%e5%bc%8f%e5%92%8c%e5%86%85%e6%a0%b8%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#用户模式和内核模式-nav`)" id="用户模式和内核模式-nav">
									用户模式和内核模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2" onclick="onNavClick(`#上下文切换-nav`)" id="上下文切换-nav">
									上下文切换
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" onclick="onNavClick(`#系统调用错误处理-nav`)" id="系统调用错误处理-nav">
									系统调用错误处理
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6" onclick="onNavClick(`#进程控制-nav`)" id="进程控制-nav">
									进程控制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e8%8e%b7%e5%8f%96%e8%bf%9b%e7%a8%8bid" onclick="onNavClick(`#获取进程id-nav`)" id="获取进程id-nav">
									获取进程ID
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b" onclick="onNavClick(`#创建和终止进程-nav`)" id="创建和终止进程-nav">
									创建和终止进程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%9b%9e%e6%94%b6%e5%ad%90%e8%bf%9b%e7%a8%8b" onclick="onNavClick(`#回收子进程-nav`)" id="回收子进程-nav">
									回收子进程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%ae%a9%e8%bf%9b%e7%a8%8b%e4%bc%91%e7%9c%a0" onclick="onNavClick(`#让进程休眠-nav`)" id="让进程休眠-nav">
									让进程休眠
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8a%a0%e8%bd%bd%e5%b9%b6%e8%bf%90%e8%a1%8c%e7%a8%8b%e5%ba%8f" onclick="onNavClick(`#加载并运行程序-nav`)" id="加载并运行程序-nav">
									加载并运行程序
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%88%a9%e7%94%a8fork%e5%92%8cexecve%e8%bf%90%e8%a1%8c%e7%a8%8b%e5%ba%8f" onclick="onNavClick(`#利用fork和execve运行程序-nav`)" id="利用fork和execve运行程序-nav">
									利用fork和execve运行程序
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#信号-nav`)" id="信号-nav">
									信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e4%bf%a1%e5%8f%b7%e6%9c%af%e8%af%ad" onclick="onNavClick(`#信号术语-nav`)" id="信号术语-nav">
									信号术语
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8f%91%e9%80%81%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#发送信号-nav`)" id="发送信号-nav">
									发送信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%8e%a5%e6%94%b6%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#接收信号-nav`)" id="接收信号-nav">
									接收信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e9%98%bb%e5%a1%9e%e5%92%8c%e8%a7%a3%e9%99%a4%e9%98%bb%e5%a1%9e%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#阻塞和解除阻塞信号-nav`)" id="阻塞和解除阻塞信号-nav">
									阻塞和解除阻塞信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%bc%96%e5%86%99%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f" onclick="onNavClick(`#编写信号处理程序-nav`)" id="编写信号处理程序-nav">
									编写信号处理程序
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%90%8c%e6%ad%a5%e6%b5%81%e4%bb%a5%e9%81%bf%e5%85%8d%e8%ae%a8%e5%8e%8c%e7%9a%84%e5%b9%b6%e5%8f%91%e9%94%99%e8%af%af" onclick="onNavClick(`#同步流以避免讨厌的并发错误-nav`)" id="同步流以避免讨厌的并发错误-nav">
									同步流以避免讨厌的并发错误
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%98%be%e5%bc%8f%e5%9c%b0%e7%ad%89%e5%be%85%e4%bf%a1%e5%8f%b7" onclick="onNavClick(`#显式地等待信号-nav`)" id="显式地等待信号-nav">
									显式地等待信号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e9%9d%9e%e6%9c%ac%e5%9c%b0%e8%b7%b3%e8%bd%ac" onclick="onNavClick(`#非本地跳转-nav`)" id="非本地跳转-nav">
									非本地跳转
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%93%8d%e4%bd%9c%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b7%a5%e5%85%b7" onclick="onNavClick(`#操作进程的工具-nav`)" id="操作进程的工具-nav">
									操作进程的工具
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://eternityqjl.top">
            Jialong&#39;s Blog
        </a>
        
        <button type="button" class="nav-darkmode-toggle" v-on:click="toggleDarkMode">
            <i class="material-icons" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons" v-else="isDarkMode">
                brightness_7
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://eternityqjl.top">
        <div class="single-column-header-title">Jialong&#39;s Blog</div>
        
        <div class="single-column-header-subtitle">沉潜 自由 追寻幸福</div>
        

    </a>
</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            
                
            

            <div class="post-head-wrapper"
                
                    
                    
                    style="background-image: url('https://github.com/eternityqjl/blogGallery/blob/master/blog/csapp.jpg?raw=true')"
                    
                
            >
                <div class="post-title">
                    Csapp 8 异常控制流
                    
                    <div class="post-subtitle">
                        书籍《深入理解计算机系统》阅读学习笔记
                    </div>
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2022-01-11 15:33
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97">深入理解计算机系统学习日志</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机体系结构</a>
                                &nbsp;
                            
                                <a href="/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81">异常控制流</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <p>系统要对系统状态的变化作出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。</p>
<p>现代系统通过使用<strong>控制流发生突变</strong>来对这些情况作出反应，一般把这些突变称为<strong>异常控制流ECF</strong>。ECF发生在<strong>计算机系统的各个层次</strong>。例如，在<strong>硬件层</strong>，硬件检测到的事件会触发控制突然转移到异常处理程序。在<strong>操作系统层</strong>，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。</p>
<p>理解ECP有很多用处：</p>
<ul>
<li>帮助理解重要的<strong>系统概念</strong>。</li>
<li>理解应用程序如何<strong>与操作系统交互</strong>。应用程序通过使用称为陷阱或系统调用的ECF形式，向操作系统请求服务。例如，向磁盘写数据、从网络读取数据、创建一个新进程，都是通过应用程序调用系统调用实现的。</li>
<li>帮助理解<strong>并发</strong>。ECF是计算机系统中实现并发的基本机制。</li>
<li>帮助理解<strong>软件异常</strong>如何工作。例如C++使用try、catch以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。</li>
</ul>
<h2 id="异常">异常</h2>
<p>异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。</p>
<p>异常就是控制流中的突变，用来响应处理器状态中的某些变化。</p>
<p><strong>事件</strong>（event）：状态的变化。事件可能和当前指令的执行直接相关，比如发生虚拟内存缺页、算术溢出等。</p>
<p>处理器检测到有事件发生时，就通过异常表的跳转表，进行一个间接过程调用，到一个异常处理程序进行处理。处理完后，根据引起异常的事件类型，会发生以下三种情况的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令</li>
<li>处理程序将控制返回给下一条指令</li>
<li>处理程序终止被中断的程序</li>
</ul>
<h3 id="异常处理">异常处理</h3>
<p>系统中可能为每种类型的异常都分配一个唯一的非负整数的<strong>异常号</strong>。其中一些号码由<strong>处理器设计者</strong>提供，另一些由<strong>操作系统内核的设计者</strong>分配。前者的例子包括：缺页、内存访问违规、被零除及算术运算溢出。后者的例子包括：系统调用和来自外部I/O设备的信号。</p>
<p>系统启动时，操作系统分配和初始化一张称为异常表的跳转表。使得表目k包含异常k的处理程序的地址。</p>
<p>运行时（系统执行某个程序）处理器检测到发生了一个事件，并确定了响应的异常号k。随后处理器触发异常，执行间接调用过程，通过异常表的表目k，转到相应的处理程序。</p>
<p>异常号是<strong>到异常表中的索引</strong>，异常表的起始地址放在叫做异常表基址寄存器的特殊CPU寄存器中。</p>
<p>异常与过程调用的区别：</p>
<ul>
<li>返回地址不同：过程调用时，跳转到处理程序之前，处理器将返回地址压入栈中。而根据异常的类型，返回地址要么是当前指令，要么是下一条指令。</li>
<li>异常处理中处理器也把一些额外的处理器状态压入栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。</li>
<li>如果控制从用户程序转移到内核，所有这些项目都被压入内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下，这意味着其对所有系统资源都有完全的访问权限。</li>
</ul>
<p>一旦硬件触发了异常，剩下的工作就由<strong>异常处理程序</strong>在软件中完成。处理完事件后，通过执行一条特殊的从中断返回指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中。如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将控制返回给被中断的程序。</p>
<h3 id="异常的类别">异常的类别</h3>
<p>异常分为中断、陷阱、故障、终止。</p>
<p><strong>中断</strong></p>
<p>中断是<strong>异步</strong>发生的，是来自处理器<strong>外部的I/O设备的信号</strong>的结果。硬件中断<strong>不是由任何一条专门的指令</strong>造成的，因此它是异步的。硬件中观的异常处理程序常称为中断处理程序。</p>
<p>当前只能怪执行完后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，就将控制返回给下一条指令。结果是程序继续运行，就好像没有发生过中断一样。</p>
<p>剩下的异常类型是<strong>同步</strong>发生的，是执行当前指令的结果，把这类指令称为<strong>故障指令</strong>。</p>
<p><strong>陷阱和系统调用</strong></p>
<p>陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在<strong>用户程序和内核之间</strong>提供一个像过程一样的接口，称为系统调用。</p>
<p>用户经常要向内核请求服务，比如读一个文件（read）、创建一个新进程（fork）、加载一个新程序（execve），或终止当前程序（exit）。为了允许对这些内核服务的受控访问，处理器提供了一条特殊的<code>syscall n</code>的指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个程序解析参数，并调用适当的内核程序。</p>
<p><strong>故障</strong></p>
<p>故障是由错误引起的，他可能<strong>被故障处理程序修正</strong>。故障发生时，处理器将控制转移给故障处理程序。如果故障处理程序能够修正这个错误，他就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，该例程会终止引起故障的应用程序。</p>
<p>一个经典的故障示例是缺页异常。</p>
<p><strong>终止</strong></p>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，例如DRAM或SRAM位被损坏时发生的奇偶错误。</p>
<h3 id="linuxx86-64中的异常">Linux/x86-64中的异常</h3>
<p>x86-64有256种不同类型的异常，0~31号对应的由Intel架构师定义的异常，对任何x86-64系统都是一样的。32~255号对应的是操作系统定义的中断和陷阱。</p>
<p><strong>Linux/x86-64故障和终止</strong></p>
<ul>
<li>除法错误（异常0）：Unix不会试图从除法错误中恢复，而是选择终止程序。</li>
<li>一般保护故障（异常13）：通常因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这些故障。</li>
<li>缺页（异常14）：会重新执行产生故障的指令的一个示例。</li>
<li>机器检查（异常18）：在导致故障的指令执行中检测到致命的硬件错误时发生的。</li>
</ul>
<p><strong>Linux/x86-64系统调用</strong></p>
<p>Linux提供几百种系统调用，以下为一些常见的系统调用：</p>
<p><img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201071509742.png" alt="Linux常见系统调用"></p>
<p>每个系统调用都有唯一的整数号，对应于一个到内核中跳转表的偏移量。</p>
<p>C程序用syscall函数可以直接调用任何系统调用。而实际中没必要这样做，对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用函数。</p>
<p>处理器ISA规范通常会区分异步中断和同步异常，但并不提供表述这些非常相似的概念的概括性的术语。为了避免混乱，我们使用异常作为通用术语，只要在必要时才区分异步异常（中断）和同步异常（陷阱、故障和终止）。</p>
<h2 id="进程">进程</h2>
<p>进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流：提供我们的程序<strong>独占地使用处理器</strong>的假象</li>
<li>一个私有的地址空间：提供我们的程序<strong>独占地使用内存系统</strong>的假象</li>
</ul>
<h3 id="逻辑控制流">逻辑控制流</h3>
<p>进程为每个程序提供了一种假象，好像程序在独占地使用处理器。</p>
<p>进程轮流使用处理器。每个进程执行它的流的一部分，然后被抢占，然后轮到其他进程。</p>
<h3 id="并发流">并发流</h3>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发地运行。</p>
<p>多个流并发地执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。</p>
<h3 id="私有地址空间">私有地址空间</h3>
<p>进程为每个程序提供它自己的私有地址空间。和这个空间中某个地址相关联的哪个内存字节是不能被其他进程读和写的。</p>
<p>尽管每个私有地址空间相关联的内存一般是不同的，但每个这样的空间都有相同的通用结构。</p>
<h3 id="用户模式和内核模式">用户模式和内核模式</h3>
<p>处理器提供了一种限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常用某个控制寄存器中的一个模式位来提供这种功能，该寄存器描述了当前享有的特权。设置了模式位后，进程就运行在内核模式中。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>
<p>未设置模式位时，进程运行在用户模式。用户模式中的进程不允许执行特权指令，例如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。</p>
<h3 id="上下文切换">上下文切换</h3>
<p>操作系统内核使用一种称为上下文切换的较高层形式的异常流控制来实现多任务切换。</p>
<p>内核为每个进程维持一个上下文。上下文就是内核重启一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，如页表、进程表和文件表。</p>
<p>进程执行的某些时刻，内核可以抢占当前当前进程，并重新开始一个先前被抢占的进程，这种决策称为<strong>调度</strong>。由内核中的调度器的代码处理的。</p>
<p>上下文切换：</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程被保存的上下文</li>
<li>将控制传递给这个新的恢复进程</li>
</ul>
<p>中断可以引发上下文切换。例如从磁盘取完数据之后的中断。</p>
<h2 id="系统调用错误处理">系统调用错误处理</h2>
<p>当Unix系统级函数遇到错误时，通常会返回-1，并设置全局整数变量errno来表示出现什么错误。</p>
<p>fork函数检查错误的方法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#080;font-weight:bold">if</span> ((pid <span style="color:#333">=</span> fork()) <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">0</span>) {
	fprintf(stderr, <span style="background-color:#fff0f0">&#34;fork error: %s</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\n</span><span style="background-color:#fff0f0">&#34;</span>, strerror(errno));
	exit(<span style="color:#00d;font-weight:bold">0</span>);
}
</code></pre></div><p>strerror函数返回一个文本串，描述了和某个errno值相关联的错误。通过定义以下函数，来简化代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">unix_error</span>(<span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>msg) <span style="color:#888">/* Unix-style error */</span>
{
    fprintf(stderr, <span style="background-color:#fff0f0">&#34;%s: %s</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\n</span><span style="background-color:#fff0f0">&#34;</span>, msg, strerror(errno));
    exit(<span style="color:#00d;font-weight:bold">0</span>);
}
</code></pre></div><p>此时对fork的调用缩减到2行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#080;font-weight:bold">if</span> ((pid <span style="color:#333">=</span> fork()) <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">0</span>)
	unix_error(<span style="background-color:#fff0f0">&#34;fork error&#34;</span>);
</code></pre></div><p>使用csapp.h定义的处理包装函数可以进一步简化代码。</p>
<h2 id="进程控制">进程控制</h2>
<p>描述Unix提供的大量从C程序中操作进程的系统调用函数。</p>
<h3 id="获取进程id">获取进程ID</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">pid_t <span style="color:#06b;font-weight:bold">getpid</span>(<span style="color:#339;font-weight:bold">void</span>);
</code></pre></div><h3 id="创建和终止进程">创建和终止进程</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">exit</span>(<span style="color:#339;font-weight:bold">int</span> status);
pid_t <span style="color:#06b;font-weight:bold">fork</span>(<span style="color:#339;font-weight:bold">void</span>);
</code></pre></div><p>exit函数以status退出状态来终止进程。</p>
<p>父进程通过调用fork函数创建一个新的运行的子进程。</p>
<h3 id="回收子进程">回收子进程</h3>
<p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。进程被保持在一种已终止的状态，直到被它的父进程回收。当父进程回收已经终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被会回收的进程称为僵死进程。</p>
<h3 id="让进程休眠">让进程休眠</h3>
<p>sleep函数将一个进程挂起一段指定的时间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">include <span style="color:#333">&lt;</span>unistd.h<span style="color:#333">&gt;</span>
<span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">int</span> sleep(<span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">int</span> secs);
</code></pre></div><p>如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。</p>
<p>还有一个有用的函数pause，该函数让调用函数休眠，直到该进程收到一个信号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">pause</span>(<span style="color:#339;font-weight:bold">void</span>);
</code></pre></div><h3 id="加载并运行程序">加载并运行程序</h3>
<p>execve函数在当前进程的上下文中加载并运行一个新程序。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;unistd.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">execve</span>(<span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>filename, <span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>argv[],
			<span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>envp[]);
</code></pre></div><p>该函数加载并运行<strong>可执行目标文件filename</strong>，且带<strong>参数列表argv</strong>和<strong>环境变量列表envp</strong>。只有出现错误时才返回到调用程序。execve调用一次并从不返回。</p>
<p><img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201092346534.png" alt="execve函数参数列表和环境变量列表"></p>
<p>在execve加载了filename后，调用<a href="https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/#%e5%8a%a0%e8%bd%bd%e5%8f%af%e6%89%a7%e8%a1%8c%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6">7.9 加载可执行目标文件</a>中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数main，该函数有以下形式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>(<span style="color:#339;font-weight:bold">int</span> argc, <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>argv[], <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>envp[]);
<span style="color:#888">//或者等价的
</span><span style="color:#888"></span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>(<span style="color:#339;font-weight:bold">int</span> argc, <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">**</span>argv, <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">**</span>envp);
</code></pre></div><p>main开始执行时，用户栈的组织结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201092354435.png" alt="新程序开始时的用户栈"></p>
<p>从栈底（高地址）到栈顶（低地址）的方向依次有：</p>
<ul>
<li>以null结尾的指针数组，其中每个指针都指向栈中的一个<strong>环境变量字符串</strong>。全局变量environ指向这些指针中的第一个envp[0]</li>
<li>以null结尾的argv[]数组，其中每个元素都指向栈中的一个<strong>参数字符串</strong>。</li>
<li>栈顶是系统启动函数libc_start_main的栈帧。</li>
</ul>
<p>main函数的三个参数：</p>
<ul>
<li>argc：给出argv[]数组中非空指针的数量</li>
<li>argv：指向argv[]数组中的第一个条目</li>
<li>envp：指向envp[]数组中的第一个条目</li>
</ul>
<h3 id="利用fork和execve运行程序">利用fork和execve运行程序</h3>
<p>Unix shell这样的程序大量使用了fork和execve函数。shell是一个交互型的应用程序，他代表用户运行其他程序。最早的shell是sh程序，shell执行一系列的<strong>读/求值</strong>步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#888">/* $begin shellmain */</span>
<span style="color:#579">#include</span> <span style="color:#579">&#34;csapp.h&#34;</span><span style="color:#579">
</span><span style="color:#579">#define MAXARGS   128
</span><span style="color:#579"></span>
<span style="color:#888">/* Function prototypes */</span>
<span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">eval</span>(<span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>cmdline);
<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">parseline</span>(<span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>buf, <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">**</span>argv);
<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">builtin_command</span>(<span style="color:#339;font-weight:bold">char</span> <span style="color:#333">**</span>argv); 

<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() 
{
    <span style="color:#339;font-weight:bold">char</span> cmdline[MAXLINE]; <span style="color:#888">/* Command line */</span>

    <span style="color:#080;font-weight:bold">while</span> (<span style="color:#00d;font-weight:bold">1</span>) {
	<span style="color:#888">/* Read */</span>
	printf(<span style="background-color:#fff0f0">&#34;&gt; &#34;</span>);                   
	Fgets(cmdline, MAXLINE, stdin); 
	<span style="color:#080;font-weight:bold">if</span> (feof(stdin))
	    exit(<span style="color:#00d;font-weight:bold">0</span>);

	<span style="color:#888">/* Evaluate */</span>
	eval(cmdline);
    } 
}
<span style="color:#888">/* $end shellmain */</span>
</code></pre></div><p>以上为一个简单的shell的main例程。shell打印一个命令行提示符，等待用户在stdin上输入命令，然后对这个命令行求值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#888">/* $begin eval */</span>
<span style="color:#888">/* eval - Evaluate a command line */</span>
<span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">eval</span>(<span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>cmdline) 
{
    <span style="color:#339;font-weight:bold">char</span> <span style="color:#333">*</span>argv[MAXARGS]; <span style="color:#888">/* Argument list execve() */</span>
    <span style="color:#339;font-weight:bold">char</span> buf[MAXLINE];   <span style="color:#888">/* Holds modified command line */</span>
    <span style="color:#339;font-weight:bold">int</span> bg;              <span style="color:#888">/* Should the job run in bg or fg? */</span>
    pid_t pid;           <span style="color:#888">/* Process id */</span>
    
    strcpy(buf, cmdline);
    bg <span style="color:#333">=</span> parseline(buf, argv); 
    <span style="color:#080;font-weight:bold">if</span> (argv[<span style="color:#00d;font-weight:bold">0</span>] <span style="color:#333">==</span> <span style="color:#007020">NULL</span>)  
	<span style="color:#080;font-weight:bold">return</span>;   <span style="color:#888">/* Ignore empty lines */</span>

    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>builtin_command(argv)) { 
        <span style="color:#080;font-weight:bold">if</span> ((pid <span style="color:#333">=</span> Fork()) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {   <span style="color:#888">/* Child runs user job */</span>
            <span style="color:#080;font-weight:bold">if</span> (execve(argv[<span style="color:#00d;font-weight:bold">0</span>], argv, environ) <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">0</span>) {
                printf(<span style="background-color:#fff0f0">&#34;%s: Command not found.</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\n</span><span style="background-color:#fff0f0">&#34;</span>, argv[<span style="color:#00d;font-weight:bold">0</span>]);
                exit(<span style="color:#00d;font-weight:bold">0</span>);
            }
        }

	<span style="color:#888">/* Parent waits for foreground job to terminate */</span>
	<span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>bg) {
	    <span style="color:#339;font-weight:bold">int</span> status;
	    <span style="color:#080;font-weight:bold">if</span> (waitpid(pid, <span style="color:#333">&amp;</span>status, <span style="color:#00d;font-weight:bold">0</span>) <span style="color:#333">&lt;</span> <span style="color:#00d;font-weight:bold">0</span>)
		unix_error(<span style="background-color:#fff0f0">&#34;waitfg: waitpid error&#34;</span>);
	}
	<span style="color:#080;font-weight:bold">else</span>
	    printf(<span style="background-color:#fff0f0">&#34;%d %s&#34;</span>, pid, cmdline);
    }
    <span style="color:#080;font-weight:bold">return</span>;
}

<span style="color:#888">/* If first arg is a builtin command, run it and return true */</span>
<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">builtin_command</span>(<span style="color:#339;font-weight:bold">char</span> <span style="color:#333">**</span>argv) 
{
    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>strcmp(argv[<span style="color:#00d;font-weight:bold">0</span>], <span style="background-color:#fff0f0">&#34;quit&#34;</span>)) <span style="color:#888">/* quit command */</span>
	exit(<span style="color:#00d;font-weight:bold">0</span>);  
    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>strcmp(argv[<span style="color:#00d;font-weight:bold">0</span>], <span style="background-color:#fff0f0">&#34;&amp;&#34;</span>))    <span style="color:#888">/* Ignore singleton &amp; */</span>
	<span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span>;
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">0</span>;                     <span style="color:#888">/* Not a builtin command */</span>
}
<span style="color:#888">/* $end eval */</span>
</code></pre></div><p>以上为对命令行求值的代码。首要任务是调用parseline函数，该函数解析了以空格分隔的命令行参数，并构造最终会传递给execve的argv向量。第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。</p>
<p>如果最后一个参数是&amp;，那么parseline返回1，表示在后台执行该程序。否则返回0，表示在前台执行该程序。</p>
<p>解析了命令行后，eval函数调用builtin_command函数，该函数检查第一个命令行参数是否是一个内置的shell命令。如果是，就立即解释这个命令，并返回1，否则返回0。简单的shell只有一个内置命令——quit命令，该命令会终止shell。</p>
<p>如果builtin_command返回0，那么shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止。当作业终止时，shell开始下一轮迭代。</p>
<h2 id="信号">信号</h2>
<p>前面的异常控制流的学习中，我们已经看到了硬件和软件如何合作以提供基本的低层异常机制，以及操作系统如何利用异常来支持进程上下文切换的异常控制流形式。本节中将研究<strong>更高层的软件形式的异常</strong>，称为Linux信号，其允许进程和内核中断其他进程。</p>
<p>一个信号就是一条小消息，他通知进程系统中发生了一个某种类型的事件。</p>
<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下是对用户进程不可见的。信号提供了一种机制，通知用户进程发生了这些异常。例如如果一个进程试图除以0，那么内核就发送给它一个SIGFPE信号。</p>
<h3 id="信号术语">信号术语</h3>
<p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li>发送信号。内核通过更新目的进程上下文的<strong>某个状态</strong>，发送（传递）一个信号给目的进程。发送信号可能有以下原因：
<ul>
<li>内核检测到一个系统事件，例如除零错误</li>
<li>一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给自己</li>
</ul>
</li>
<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接受了信号。进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号。</li>
</ul>
<p>一个发出而没有被接收的信号叫作待处理信号。</p>
<p>任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都会被直接丢弃。一个进程可以有选择地阻塞接收某种信号。</p>
<h3 id="发送信号">发送信号</h3>
<p>Unix基于进程组提供了大量向进程发送信号的机制。</p>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，进程组由一个正整数进程组ID来标识。getpgrp函数返回当前进程的进程组ID：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;unistd.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span>pid_t <span style="color:#06b;font-weight:bold">getpgrp</span>(<span style="color:#339;font-weight:bold">void</span>);
</code></pre></div><p>一个进程与其子进程属于同一个进程组，一个进程也可以通过使用set-pgid函数来改变自己或其他进程的进程组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;unistd.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">setpgid</span>(pid_t pid, pid_t pgid);
</code></pre></div><p>将进程pid的进程组改为pgid。如果pid为0就是用当前进程的PID。如果pgid是0就用pid指定的进程的PID作为进程组ID。</p>
<p><strong>用/bin/kill程序发送信号</strong></p>
<p>/bin/kill可以向另外的进程发送任意信号。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">linux&gt; /bin/kill -9 <span style="color:#60e;font-weight:bold">15213</span>
</code></pre></div><p>发送信号9(SIGKILL)给进程15213.</p>
<p><strong>从键盘发送信号</strong></p>
<p>Unix shell使用<strong>作业</strong>这个抽象概念来表示为<strong>对一条命令行求值而创建的进程</strong>。在任何时刻至多只有<strong>一个前台作业和0个或多个后台作业</strong>。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">linux&gt; ls | sort
</code></pre></div><p>会创建一个由两个进程组成的前台作业，这两个进程通过Unix管道连接起来：一个进程运行ls程序，另一个进程运行sort程序。shell为每个作业创建一个独立的进程组。进程组ID通常取自作业中父进程中的一个。</p>
<p>在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下是终止前台作业。类似地，输入Ctrl+Z会发送一个SIGTSTP信号到前台中的每个进程。默认情况下是停止（挂起）前台作业。</p>
<p><strong>用kill函数发送信号</strong></p>
<p>进程通过调用kill函数发送信号给其他进程（包括自己）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;sys/types.h&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;signal.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">kill</span>(pid_t pid, <span style="color:#339;font-weight:bold">int</span> sig);
</code></pre></div><p>如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，kill发送信号sig给进程组|pid|中的每个进程。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#888">/* $begin kill */</span>
<span style="color:#579">#include</span> <span style="color:#579">&#34;csapp.h&#34;</span><span style="color:#579">
</span><span style="color:#579"></span>
<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() 
{
    pid_t pid;

    <span style="color:#888">/* Child sleeps until SIGKILL signal received, then dies */</span>   
    <span style="color:#080;font-weight:bold">if</span> ((pid <span style="color:#333">=</span> Fork()) <span style="color:#333">==</span> <span style="color:#00d;font-weight:bold">0</span>) {   
	Pause();  <span style="color:#888">/* Wait for a signal to arrive */</span>  
	printf(<span style="background-color:#fff0f0">&#34;control should never reach here!</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\n</span><span style="background-color:#fff0f0">&#34;</span>);
	exit(<span style="color:#00d;font-weight:bold">0</span>);
    }

    <span style="color:#888">/* Parent sends a SIGKILL signal to a child */</span>
    Kill(pid, SIGKILL);
    exit(<span style="color:#00d;font-weight:bold">0</span>);
}
<span style="color:#888">/* $end kill */</span>
</code></pre></div><p>该示例中，父进程用kill函数发送SIGKILL信号给它的子进程。</p>
<p><strong>用allarm函数发送信号</strong></p>
<p>进程可以通过调用alarm函数向它自己发送SIGALARM信号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;unistd.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span><span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">alarm</span>(<span style="color:#339;font-weight:bold">unsigned</span> <span style="color:#339;font-weight:bold">int</span> secs);
</code></pre></div><p>alarm函数安排内核在secs秒后发送一个SIGALARM信号给调用进程。如果secs是零，那么不会调度安排新的闹钟。</p>
<p>任何情况下，对alarm的调用都将取消任何待处理的（pending）闹钟，并返回任何待处理的闹钟在被发送前还剩下的秒数。如果没有任何待处理的闹钟就返回零。</p>
<h3 id="接收信号">接收信号</h3>
<p>当内核把进程p从内核模式切换到用户模式（从系统调用返回或完成了一次上下文切换）时，它会检查进程p的未被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到p的逻辑控制流中的下一条指令。如果集合是非空，那么内核选择集合中的某个信号k，并强制p接收信号k。收到这个信号会触发进程采取某种行为。一旦进程完成这种行为，控制就传递回p的逻辑控制流中的下一条指令。每个信号都有一个预定义的默认行为：</p>
<ul>
<li>进程终止</li>
<li>进程终止并转储内存</li>
<li>进程停止（挂起）直到被SIGCONT信号重启</li>
<li>进程忽略该信号</li>
</ul>
<p>进程可以通过使用signal函数修改和信号相关联的默认行为。例外是SIGSTOP和SIGKILL，他们的默认行为不能更改。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;signal.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span><span style="color:#080;font-weight:bold">typedef</span> <span style="color:#06b;font-weight:bold">void</span> (<span style="color:#333">*</span>sighandler_t) (<span style="color:#339;font-weight:bold">int</span>);
sighandler_t <span style="color:#06b;font-weight:bold">signal</span>(<span style="color:#339;font-weight:bold">int</span> signum, sighandler_t handler);
</code></pre></div><p>若成功则返回指向前次处理程序的指针，若出错则为SIG_ERR。</p>
<h3 id="阻塞和解除阻塞信号">阻塞和解除阻塞信号</h3>
<p>Linux提供了阻塞信号的隐式和显式的机制。</p>
<ul>
<li>隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。</li>
<li>显式阻塞机制：应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</li>
</ul>
<h3 id="编写信号处理程序">编写信号处理程序</h3>
<p>信号处理是Linux系统编程最棘手的一个问题。处理程序有几个属性使其很难推理分析：</p>
<ul>
<li>处理程序与主程序并发运行，共享同样的全局变量，可能与主程序和其他处理程序互相干扰</li>
<li>如何以及何时接收信号的规则常常有违直觉</li>
<li>不同系统有不同的信号处理语义</li>
</ul>
<p>以下是信号处理程序的一些基本规则：</p>
<p><strong>安全的信号处理</strong></p>
<p><strong>正确的信号处理</strong></p>
<p><strong>可移植的信号处理</strong></p>
<h3 id="同步流以避免讨厌的并发错误">同步流以避免讨厌的并发错误</h3>
<p>以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。</p>
<h3 id="显式地等待信号">显式地等待信号</h3>
<p>有时候主程序需要显式地等待某个信号处理程序运行。例如当Linux shell创建一个前台作业时，在接受下一条用户命令前，它必须等待作业终止，被SIGCHLD处理程序回收。</p>
<h2 id="非本地跳转">非本地跳转</h2>
<p>C语言提供了一种用户级异常控制流形式，称为非本地跳转，它将控制从一个函数转移到另一个当前正在执行的函数，不需要经过正常的调用-返回序列。非本地跳转通过setjmp和longjmp函数来提供。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#579">#include</span> <span style="color:#579">&lt;setjmp.h&gt;</span><span style="color:#579">
</span><span style="color:#579"></span><span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">setjmp</span>(jmp_buf env);
<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">sigsetjmp</span>(sigjmp_buf env, <span style="color:#339;font-weight:bold">int</span> savesigs);
</code></pre></div><p>setjmp函数在env缓冲区保存<strong>当前调用环境</strong>，以供后面的longjmp使用，并返回0.调用环境包括程序计数器、栈指针和通用目的寄存器。</p>
<h2 id="操作进程的工具">操作进程的工具</h2>
<p>Linux系统提供的大量的监控和操作进程的有用工具。</p>
<ul>
<li>
<p>STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</p>
</li>
<li>
<p>PS：列出当前系统中的进程</p>
</li>
<li>
<p>TOP：打印出关于当前进程资源使用的信息</p>
</li>
<li>
<p>PMAP：显示进程的内存映射</p>
</li>
<li>
<p>/proc：一个虚拟文件系统，以ASCII文本格式输出大量<strong>内核数据结构的内容</strong>，用户程序可以读取这些内容。</p>
</li>
</ul>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">最后修改于 2022-01-12</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">
			下回<br>Cpp继承和多态
                </a>
                
                
                
                <a class="older-posts" href="https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/">
			上回<br>八股文——操作系统相关
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>









            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	2019-2021 By Jialong
	
</div>
            </div>
    <script>
let app;

app = new Vue({
    el: '#app',
    data: {
        scrollY: 0,
        navOpacity: 0,
        isDrawerOpen: false,
        mounted: false,
        isDarkMode: false
    },
    methods: {
            sgn(t, x) {
                let k = 1. / (1. - 2 * t);
                if (x <= t) return 0;
                else if (x >= 1 - t) return 1;
                else {
                    return k * (x - t);
                }
            },
            handleScroll() {
                this.scrollY = window.scrollY;
                this.navOpacity = this.sgn(.0, Math.min(1, Math.max(0, window.scrollY / (this.pageHeadHeight() - this.navBarHeight() * 0.8))));
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;

                if (this.navOpacity >= 1) {
                    navBackground.style.opacity = 1;
                    navTitle.style.opacity = 1;
                } else {
                    navBackground.style.opacity = 0;
                    navTitle.style.opacity = 0;
                }
            },
            handleResize() {
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;
                extraContainer.style.left = (streamContainer.offsetWidth - extraContainer.offsetWidth) + 'px';
            },
            navBarHeight() {
                return this.$refs.navBar.offsetHeight;
            },
            pageHeadHeight() {
                return this.$refs.pageHead.offsetHeight;
            },
            toggleDrawer() {
                this.isDrawerOpen = !this.isDrawerOpen;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            closeDrawer() {
                this.isDrawerOpen = false;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode==true){
                    document.cookie = "night=1;path=/";
                    document.body.classList.add("night");
                } else {
                    document.cookie = "night=0;path=/";
                    document.body.classList.remove("night");
                }
            },
            debounce(func, wait, options) {
                let lastArgs,
                    lastThis,
                    maxWait,
                    result,
                    timerId,
                    lastCallTime

                let lastInvokeTime = 0
                let leading = false
                let maxing = false
                let trailing = true

                
                const useRAF = (!wait && wait !== 0 && typeof root.requestAnimationFrame === 'function')

                if (typeof func !== 'function') {
                    throw new TypeError('Expected a function')
                }
                function isObject(value) {
                    const type = typeof value
                    return value != null && (type === 'object' || type === 'function')
                }

                wait = +wait || 0
                if (isObject(options)) {
                    leading = !!options.leading
                    maxing = 'maxWait' in options
                    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
                    trailing = 'trailing' in options ? !!options.trailing : trailing
                }

                function invokeFunc(time) {
                    const args = lastArgs
                    const thisArg = lastThis

                    lastArgs = lastThis = undefined
                    lastInvokeTime = time
                    result = func.apply(thisArg, args)
                    return result
                }

                function startTimer(pendingFunc, wait) {
                    if (useRAF) {
                    root.cancelAnimationFrame(timerId)
                    return root.requestAnimationFrame(pendingFunc)
                    }
                    return setTimeout(pendingFunc, wait)
                }

                function cancelTimer(id) {
                    if (useRAF) {
                    return root.cancelAnimationFrame(id)
                    }
                    clearTimeout(id)
                }

                function leadingEdge(time) {
                    
                    lastInvokeTime = time
                    
                    timerId = startTimer(timerExpired, wait)
                    
                    return leading ? invokeFunc(time) : result
                }

                function remainingWait(time) {
                    const timeSinceLastCall = time - lastCallTime
                    const timeSinceLastInvoke = time - lastInvokeTime
                    const timeWaiting = wait - timeSinceLastCall

                    return maxing
                    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
                    : timeWaiting
                }

                function shouldInvoke(time) {
                    const timeSinceLastCall = time - lastCallTime
                    const timeSinceLastInvoke = time - lastInvokeTime

                    
                    
                    
                    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait))
                }

                function timerExpired() {
                    const time = Date.now()
                    if (shouldInvoke(time)) {
                    return trailingEdge(time)
                    }
                    
                    timerId = startTimer(timerExpired, remainingWait(time))
                }

                function trailingEdge(time) {
                    timerId = undefined

                    
                    
                    if (trailing && lastArgs) {
                    return invokeFunc(time)
                    }
                    lastArgs = lastThis = undefined
                    return result
                }

                function cancel() {
                    if (timerId !== undefined) {
                    cancelTimer(timerId)
                    }
                    lastInvokeTime = 0
                    lastArgs = lastCallTime = lastThis = timerId = undefined
                }

                function flush() {
                    return timerId === undefined ? result : trailingEdge(Date.now())
                }

                function pending() {
                    return timerId !== undefined
                }

                function debounced(...args) {
                    const time = Date.now()
                    const isInvoking = shouldInvoke(time)

                    lastArgs = args
                    lastThis = this
                    lastCallTime = time

                    if (isInvoking) {
                    if (timerId === undefined) {
                        return leadingEdge(lastCallTime)
                    }
                    if (maxing) {
                        
                        timerId = startTimer(timerExpired, wait)
                        return invokeFunc(lastCallTime)
                    }
                    }
                    if (timerId === undefined) {
                    timerId = startTimer(timerExpired, wait)
                    }
                    return result
                }
                debounced.cancel = cancel
                debounced.flush = flush
                debounced.pending = pending
                return debounced
                }

    },
    created() {
        window.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        window._nonDesktop = function () {
            let check = false;
            (function (a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };
        
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        if (night==""){
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                
            }
        }else{
            
            if (night=="1") {
                this.toggleDarkMode();
            }
        }
    },
    mounted() {
        this.handleScroll();
        this.handleResize();
        this.mounted = true;

        
        
        

        document.querySelectorAll("table").forEach(function(elem){
            elem.classList.add("table-striped");
            elem.classList.add("table");
            elem.classList.add("table-responsive");
            elem.classList.add("table-hover");
        })

        
        spy();
        window.addEventListener('scroll', this.debounce(spy, 250, { 'maxWait': 250 }), false);
        
        
    },
    destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
        window.removeEventListener('resize', this.handleResize);
    }
});



</script>
    </body>
</html>
