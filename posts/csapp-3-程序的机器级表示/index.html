<!doctype html><html><head><title>csapp: 3.程序的机器级表示</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content="书籍《深入理解计算机系统》阅读学习笔记"><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="csapp: 3.程序的机器级表示"><meta property="og:description" content="书籍《深入理解计算机系统》阅读学习笔记"><meta property="og:type" content="article"><meta property="og:url" content="https://eternityqjl.github.io/blog2_public/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-09T16:08:05+08:00"><meta property="article:modified_time" content="2021-08-09T16:08:05+08:00"><meta property="og:site_name" content="My Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="csapp: 3.程序的机器级表示"><meta name=twitter:description content="书籍《深入理解计算机系统》阅读学习笔记"><link type=text/css rel=stylesheet href=/blog2_public/vendor/css/bootstrap.min.css><script src=/blog2_public/vendor/js/vue.min.js></script><link rel=icon href=https://raw.githubusercontent.com/eternityqjl/blogGallery/master/faviconJ.ico><link rel=stylesheet href=https://eternityqjl.github.io/blog2_public/scss/journal.min.3f72a5fc8f5b5dd732a4b476aced0eece2156958d9d414316494ddb10593ddf7.css integrity="sha256-P3Kl/I9bXdcypLR2rO0O7OIVaVjZ1BQxZJTdsQWT3fc=" media=screen><link rel=stylesheet href=https://eternityqjl.github.io/blog2_public/scss/dark-mode.min.c0082f0b082177f6fb3768ff91439a097de49689bd26f4d49f76d94ebb81e02d.css integrity="sha256-wAgvCwghd/b7N2j/kUOaCX3klom9JvTUn3bZTruB4C0=" media=screen><script src=/blog2_public/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js>MathJax.Hub.Queue(function(){var b=MathJax.Hub.getAllJax(),a;for(a=0;a<b.length;a+=1)b[a].SourceElement().parentNode.className+=' has-jax'})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script src=/blog2_public/js/toc.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/blog2_public/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'df0192f05fd975a4e951',clientSecret:'f1ff41cecd43fac4792ed8be020aeb337494c340',repo:'eternityqjl.github.io',owner:'eternityqjl',admin:['eternityqjl'],id:md5(location.pathname),distractionFreeMode:'false'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://eternityqjl.github.io/blog2_public><div class=nav-title>Jialong's Blog</div><div class=nav-subtitle>沉潜 自由 追寻幸福</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/blog2_public/posts>网志</a>
<a class="a-block nav-link-item false" href=/blog2_public/categories>分类</a>
<a class="a-block nav-link-item false" href=/blog2_public/tags>标签</a>
<a class="a-block nav-link-item false" href=/blog2_public/about>关于</a>
<a class="a-block nav-link-item false" href=/blog2_public/index.xml>RSS</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2019-2021 By Jialong</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><li><a href=#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%9c%ba%e5%99%a8%e7%ba%a7%e8%a1%a8%e7%a4%ba onclick="onNavClick(`#第三章-程序的机器级表示-nav`)" id=第三章-程序的机器级表示-nav>第三章 程序的机器级表示</a></li><ul><li><a href=#%e5%8e%86%e5%8f%b2%e8%a7%82%e7%82%b9 onclick="onNavClick(`#历史观点-nav`)" id=历史观点-nav>历史观点</a></li><li><a href=#%e7%a8%8b%e5%ba%8f%e7%bc%96%e7%a0%81 onclick="onNavClick(`#程序编码-nav`)" id=程序编码-nav>程序编码</a></li><ul><li><a href=#%e6%9c%ba%e5%99%a8%e7%ba%a7%e4%bb%a3%e7%a0%81 onclick="onNavClick(`#机器级代码-nav`)" id=机器级代码-nav>机器级代码</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b onclick="onNavClick(`#代码示例-nav`)" id=代码示例-nav>代码示例</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e6%a0%bc%e5%bc%8f%e7%9a%84%e6%b3%a8%e8%a7%a3 onclick="onNavClick(`#关于格式的注解-nav`)" id=关于格式的注解-nav>关于格式的注解</a></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f onclick="onNavClick(`#数据格式-nav`)" id=数据格式-nav>数据格式</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e4%bf%a1%e6%81%af onclick="onNavClick(`#访问信息-nav`)" id=访问信息-nav>访问信息</a></li><ul><li><a href=#%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8c%87%e7%a4%ba%e7%ac%a6 onclick="onNavClick(`#操作数指示符-nav`)" id=操作数指示符-nav>操作数指示符</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e6%8c%87%e4%bb%a4 onclick="onNavClick(`#数据传送指令-nav`)" id=数据传送指令-nav>数据传送指令</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 onclick="onNavClick(`#数据传送示例代码-nav`)" id=数据传送示例代码-nav>数据传送示例代码</a></li><li><a href=#%e5%8e%8b%e5%85%a5%e5%92%8c%e5%bc%b9%e5%87%ba%e6%a0%88%e6%95%b0%e6%8d%ae onclick="onNavClick(`#压入和弹出栈数据-nav`)" id=压入和弹出栈数据-nav>压入和弹出栈数据</a></li></ul><li><a href=#%e7%ae%97%e6%95%b0%e5%92%8c%e9%80%bb%e8%be%91%e6%93%8d%e4%bd%9c onclick="onNavClick(`#算数和逻辑操作-nav`)" id=算数和逻辑操作-nav>算数和逻辑操作</a></li><ul><li><a href=#%e5%8a%a0%e8%bd%bd%e6%9c%89%e6%95%88%e5%9c%b0%e5%9d%80leaq onclick="onNavClick(`#加载有效地址leaq-nav`)" id=加载有效地址leaq-nav>加载有效地址leaq</a></li><li><a href=#%e4%b8%80%e5%85%83%e5%92%8c%e4%ba%8c%e5%85%83%e6%93%8d%e4%bd%9c onclick="onNavClick(`#一元和二元操作-nav`)" id=一元和二元操作-nav>一元和二元操作</a></li><li><a href=#%e7%a7%bb%e4%bd%8d%e6%93%8d%e4%bd%9c onclick="onNavClick(`#移位操作-nav`)" id=移位操作-nav>移位操作</a></li><li><a href=#%e4%b9%98%e6%b3%95%e5%92%8c%e9%99%a4%e6%b3%95 onclick="onNavClick(`#乘法和除法-nav`)" id=乘法和除法-nav>乘法和除法</a></li></ul><li><a href=#%e6%8e%a7%e5%88%b6 onclick="onNavClick(`#控制-nav`)" id=控制-nav>控制</a></li><ul><li><a href=#%e6%9d%a1%e4%bb%b6%e7%a0%81 onclick="onNavClick(`#条件码-nav`)" id=条件码-nav>条件码</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e6%9d%a1%e4%bb%b6%e7%a0%81 onclick="onNavClick(`#访问条件码-nav`)" id=访问条件码-nav>访问条件码</a></li><li><a href=#%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4 onclick="onNavClick(`#跳转指令-nav`)" id=跳转指令-nav>跳转指令</a></li><li><a href=#%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4%e7%9a%84%e7%bc%96%e7%a0%81 onclick="onNavClick(`#跳转指令的编码-nav`)" id=跳转指令的编码-nav>跳转指令的编码</a></li><li><a href=#%e7%94%a8%e6%9d%a1%e4%bb%b6%e6%8e%a7%e5%88%b6%e6%9d%a5%e5%ae%9e%e7%8e%b0%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af onclick="onNavClick(`#用条件控制来实现条件分支-nav`)" id=用条件控制来实现条件分支-nav>用条件控制来实现条件分支</a></li><li><a href=#%e7%94%a8%e6%9d%a1%e4%bb%b6%e4%bc%a0%e9%80%81%e5%ae%9e%e7%8e%b0%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af onclick="onNavClick(`#用条件传送实现条件分支-nav`)" id=用条件传送实现条件分支-nav>用条件传送实现条件分支</a></li><li><a href=#%e5%be%aa%e7%8e%af onclick="onNavClick(`#循环-nav`)" id=循环-nav>循环</a></li><li><a href=#switch%e8%af%ad%e5%8f%a5 onclick="onNavClick(`#switch语句-nav`)" id=switch语句-nav>switch语句</a></li></ul><li><a href=#%e8%bf%87%e7%a8%8b onclick="onNavClick(`#过程-nav`)" id=过程-nav>过程</a></li><ul><li><a href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%a0%88 onclick="onNavClick(`#运行时栈-nav`)" id=运行时栈-nav>运行时栈</a></li><li><a href=#%e8%bd%ac%e7%a7%bb%e6%8e%a7%e5%88%b6 onclick="onNavClick(`#转移控制-nav`)" id=转移控制-nav>转移控制</a></li></ul><li><a href=#%e6%95%b0%e7%bb%84%e5%88%86%e9%85%8d%e5%92%8c%e8%ae%bf%e9%97%ae onclick="onNavClick(`#数组分配和访问-nav`)" id=数组分配和访问-nav>数组分配和访问</a></li><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99 onclick="onNavClick(`#基本原则-nav`)" id=基本原则-nav>基本原则</a></li><li><a href=#%e6%8c%87%e9%92%88%e8%bf%90%e7%ae%97 onclick="onNavClick(`#指针运算-nav`)" id=指针运算-nav>指针运算</a></li><li><a href=#%e5%b5%8c%e5%a5%97%e7%9a%84%e6%95%b0%e7%bb%84 onclick="onNavClick(`#嵌套的数组-nav`)" id=嵌套的数组-nav>嵌套的数组</a></li><li><a href=#%e5%ae%9a%e9%95%bf%e6%95%b0%e7%bb%84 onclick="onNavClick(`#定长数组-nav`)" id=定长数组-nav>定长数组</a></li><li><a href=#%e5%8f%98%e9%95%bf%e6%95%b0%e7%bb%84 onclick="onNavClick(`#变长数组-nav`)" id=变长数组-nav>变长数组</a></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84struct%e5%92%8cunion onclick="onNavClick(`#数据结构struct和union-nav`)" id=数据结构struct和union-nav>数据结构struct和union</a></li><ul><li><a href=#%e7%bb%93%e6%9e%84 onclick="onNavClick(`#结构-nav`)" id=结构-nav>结构</a></li><li><a href=#%e8%81%94%e5%90%88 onclick="onNavClick(`#联合-nav`)" id=联合-nav>联合</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%af%b9%e9%bd%90 onclick="onNavClick(`#数据对齐-nav`)" id=数据对齐-nav>数据对齐</a></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%92%8c%e6%8e%a7%e5%88%b6%e7%9a%84%e4%ba%a4%e4%ba%92 onclick="onNavClick(`#数据和控制的交互-nav`)" id=数据和控制的交互-nav>数据和控制的交互</a></li><ul><li><a href=#%e6%8c%87%e9%92%88 onclick="onNavClick(`#指针-nav`)" id=指针-nav>指针</a></li><li><a href=#gdb%e8%b0%83%e8%af%95%e5%99%a8 onclick="onNavClick(`#gdb调试器-nav`)" id=gdb调试器-nav>GDB调试器</a></li><li><a href=#%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba onclick="onNavClick(`#缓冲区溢出-nav`)" id=缓冲区溢出-nav>缓冲区溢出</a></li><li><a href=#%e6%94%af%e6%8c%81%e5%8f%98%e9%95%bf%e6%a0%88%e5%b8%a7 onclick="onNavClick(`#支持变长栈帧-nav`)" id=支持变长栈帧-nav>支持变长栈帧</a></li></ul><li><a href=#%e6%b5%ae%e7%82%b9%e4%bb%a3%e7%a0%81 onclick="onNavClick(`#浮点代码-nav`)" id=浮点代码-nav>浮点代码</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/blog2_public/posts>网志</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/categories>分类</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/tags>标签</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/about>关于</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/index.xml>RSS</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><li><a href=#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%9c%ba%e5%99%a8%e7%ba%a7%e8%a1%a8%e7%a4%ba onclick="onNavClick(`#第三章-程序的机器级表示-nav`)" id=第三章-程序的机器级表示-nav>第三章 程序的机器级表示</a></li><ul><li><a href=#%e5%8e%86%e5%8f%b2%e8%a7%82%e7%82%b9 onclick="onNavClick(`#历史观点-nav`)" id=历史观点-nav>历史观点</a></li><li><a href=#%e7%a8%8b%e5%ba%8f%e7%bc%96%e7%a0%81 onclick="onNavClick(`#程序编码-nav`)" id=程序编码-nav>程序编码</a></li><ul><li><a href=#%e6%9c%ba%e5%99%a8%e7%ba%a7%e4%bb%a3%e7%a0%81 onclick="onNavClick(`#机器级代码-nav`)" id=机器级代码-nav>机器级代码</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b onclick="onNavClick(`#代码示例-nav`)" id=代码示例-nav>代码示例</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e6%a0%bc%e5%bc%8f%e7%9a%84%e6%b3%a8%e8%a7%a3 onclick="onNavClick(`#关于格式的注解-nav`)" id=关于格式的注解-nav>关于格式的注解</a></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f onclick="onNavClick(`#数据格式-nav`)" id=数据格式-nav>数据格式</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e4%bf%a1%e6%81%af onclick="onNavClick(`#访问信息-nav`)" id=访问信息-nav>访问信息</a></li><ul><li><a href=#%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8c%87%e7%a4%ba%e7%ac%a6 onclick="onNavClick(`#操作数指示符-nav`)" id=操作数指示符-nav>操作数指示符</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e6%8c%87%e4%bb%a4 onclick="onNavClick(`#数据传送指令-nav`)" id=数据传送指令-nav>数据传送指令</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 onclick="onNavClick(`#数据传送示例代码-nav`)" id=数据传送示例代码-nav>数据传送示例代码</a></li><li><a href=#%e5%8e%8b%e5%85%a5%e5%92%8c%e5%bc%b9%e5%87%ba%e6%a0%88%e6%95%b0%e6%8d%ae onclick="onNavClick(`#压入和弹出栈数据-nav`)" id=压入和弹出栈数据-nav>压入和弹出栈数据</a></li></ul><li><a href=#%e7%ae%97%e6%95%b0%e5%92%8c%e9%80%bb%e8%be%91%e6%93%8d%e4%bd%9c onclick="onNavClick(`#算数和逻辑操作-nav`)" id=算数和逻辑操作-nav>算数和逻辑操作</a></li><ul><li><a href=#%e5%8a%a0%e8%bd%bd%e6%9c%89%e6%95%88%e5%9c%b0%e5%9d%80leaq onclick="onNavClick(`#加载有效地址leaq-nav`)" id=加载有效地址leaq-nav>加载有效地址leaq</a></li><li><a href=#%e4%b8%80%e5%85%83%e5%92%8c%e4%ba%8c%e5%85%83%e6%93%8d%e4%bd%9c onclick="onNavClick(`#一元和二元操作-nav`)" id=一元和二元操作-nav>一元和二元操作</a></li><li><a href=#%e7%a7%bb%e4%bd%8d%e6%93%8d%e4%bd%9c onclick="onNavClick(`#移位操作-nav`)" id=移位操作-nav>移位操作</a></li><li><a href=#%e4%b9%98%e6%b3%95%e5%92%8c%e9%99%a4%e6%b3%95 onclick="onNavClick(`#乘法和除法-nav`)" id=乘法和除法-nav>乘法和除法</a></li></ul><li><a href=#%e6%8e%a7%e5%88%b6 onclick="onNavClick(`#控制-nav`)" id=控制-nav>控制</a></li><ul><li><a href=#%e6%9d%a1%e4%bb%b6%e7%a0%81 onclick="onNavClick(`#条件码-nav`)" id=条件码-nav>条件码</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e6%9d%a1%e4%bb%b6%e7%a0%81 onclick="onNavClick(`#访问条件码-nav`)" id=访问条件码-nav>访问条件码</a></li><li><a href=#%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4 onclick="onNavClick(`#跳转指令-nav`)" id=跳转指令-nav>跳转指令</a></li><li><a href=#%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4%e7%9a%84%e7%bc%96%e7%a0%81 onclick="onNavClick(`#跳转指令的编码-nav`)" id=跳转指令的编码-nav>跳转指令的编码</a></li><li><a href=#%e7%94%a8%e6%9d%a1%e4%bb%b6%e6%8e%a7%e5%88%b6%e6%9d%a5%e5%ae%9e%e7%8e%b0%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af onclick="onNavClick(`#用条件控制来实现条件分支-nav`)" id=用条件控制来实现条件分支-nav>用条件控制来实现条件分支</a></li><li><a href=#%e7%94%a8%e6%9d%a1%e4%bb%b6%e4%bc%a0%e9%80%81%e5%ae%9e%e7%8e%b0%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af onclick="onNavClick(`#用条件传送实现条件分支-nav`)" id=用条件传送实现条件分支-nav>用条件传送实现条件分支</a></li><li><a href=#%e5%be%aa%e7%8e%af onclick="onNavClick(`#循环-nav`)" id=循环-nav>循环</a></li><li><a href=#switch%e8%af%ad%e5%8f%a5 onclick="onNavClick(`#switch语句-nav`)" id=switch语句-nav>switch语句</a></li></ul><li><a href=#%e8%bf%87%e7%a8%8b onclick="onNavClick(`#过程-nav`)" id=过程-nav>过程</a></li><ul><li><a href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%a0%88 onclick="onNavClick(`#运行时栈-nav`)" id=运行时栈-nav>运行时栈</a></li><li><a href=#%e8%bd%ac%e7%a7%bb%e6%8e%a7%e5%88%b6 onclick="onNavClick(`#转移控制-nav`)" id=转移控制-nav>转移控制</a></li></ul><li><a href=#%e6%95%b0%e7%bb%84%e5%88%86%e9%85%8d%e5%92%8c%e8%ae%bf%e9%97%ae onclick="onNavClick(`#数组分配和访问-nav`)" id=数组分配和访问-nav>数组分配和访问</a></li><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99 onclick="onNavClick(`#基本原则-nav`)" id=基本原则-nav>基本原则</a></li><li><a href=#%e6%8c%87%e9%92%88%e8%bf%90%e7%ae%97 onclick="onNavClick(`#指针运算-nav`)" id=指针运算-nav>指针运算</a></li><li><a href=#%e5%b5%8c%e5%a5%97%e7%9a%84%e6%95%b0%e7%bb%84 onclick="onNavClick(`#嵌套的数组-nav`)" id=嵌套的数组-nav>嵌套的数组</a></li><li><a href=#%e5%ae%9a%e9%95%bf%e6%95%b0%e7%bb%84 onclick="onNavClick(`#定长数组-nav`)" id=定长数组-nav>定长数组</a></li><li><a href=#%e5%8f%98%e9%95%bf%e6%95%b0%e7%bb%84 onclick="onNavClick(`#变长数组-nav`)" id=变长数组-nav>变长数组</a></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84struct%e5%92%8cunion onclick="onNavClick(`#数据结构struct和union-nav`)" id=数据结构struct和union-nav>数据结构struct和union</a></li><ul><li><a href=#%e7%bb%93%e6%9e%84 onclick="onNavClick(`#结构-nav`)" id=结构-nav>结构</a></li><li><a href=#%e8%81%94%e5%90%88 onclick="onNavClick(`#联合-nav`)" id=联合-nav>联合</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%af%b9%e9%bd%90 onclick="onNavClick(`#数据对齐-nav`)" id=数据对齐-nav>数据对齐</a></li></ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%92%8c%e6%8e%a7%e5%88%b6%e7%9a%84%e4%ba%a4%e4%ba%92 onclick="onNavClick(`#数据和控制的交互-nav`)" id=数据和控制的交互-nav>数据和控制的交互</a></li><ul><li><a href=#%e6%8c%87%e9%92%88 onclick="onNavClick(`#指针-nav`)" id=指针-nav>指针</a></li><li><a href=#gdb%e8%b0%83%e8%af%95%e5%99%a8 onclick="onNavClick(`#gdb调试器-nav`)" id=gdb调试器-nav>GDB调试器</a></li><li><a href=#%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba onclick="onNavClick(`#缓冲区溢出-nav`)" id=缓冲区溢出-nav>缓冲区溢出</a></li><li><a href=#%e6%94%af%e6%8c%81%e5%8f%98%e9%95%bf%e6%a0%88%e5%b8%a7 onclick="onNavClick(`#支持变长栈帧-nav`)" id=支持变长栈帧-nav>支持变长栈帧</a></li></ul><li><a href=#%e6%b5%ae%e7%82%b9%e4%bb%a3%e7%a0%81 onclick="onNavClick(`#浮点代码-nav`)" id=浮点代码-nav>浮点代码</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://eternityqjl.github.io/blog2_public>Jialong's Blog</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://eternityqjl.github.io/blog2_public><div class=single-column-header-title>Jialong's Blog</div><div class=single-column-header-subtitle>沉潜 自由 追寻幸福</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper style="background-image:url(https://github.com/eternityqjl/blogGallery/blob/master/blog/csapp.jpg?raw=true)"><div class=post-title>csapp: 3.程序的机器级表示<div class=post-subtitle>书籍《深入理解计算机系统》阅读学习笔记</div><div class=post-meta><time itemprop=datePublished>2021-08-09 16:08</time>
<i class=material-icons>folder</i>
<a href=/blog2_public/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97>深入理解计算机系统学习日志</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/blog2_public/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84>计算机体系结构</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=第三章-程序的机器级表示>第三章 程序的机器级表示</h1><h2 id=历史观点>历史观点</h2><p>典型的编译器在将C程序结构变换成机器代码时所做的转换。</p><p>英特尔X86-64处理器的发展历史。</p><p>从8086到Core i7</p><h2 id=程序编码>程序编码</h2><h3 id=机器级代码>机器级代码</h3><p>对于机器级编程来说，两种抽象非常重要：</p><ul><li>由<strong>指令集体系结构</strong>或**指令集架构(ISA, Instruction Set Architecture)**来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是<strong>虚拟地址</strong>。</li></ul><p>x86-64机器码中，一些通常对C语言隐藏的处理器状态都是可见的：</p><ul><li><strong>程序计数器</strong>(PC，在x86-64中用%rip表示)：给出将要执行的下一条指令在内存中的地址</li><li><strong>整数寄存器</strong>文件：包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址(对应C语言指针)或整数数据。</li><li><strong>条件码寄存器</strong>：保存最近执行的算数或逻辑指令的状态信息，用来实现控制或数据流中的条件变化。</li></ul><p>x86-64的虚拟地址由64位的字表示，但目前这些地址的<strong>高16位</strong>必须设为零，相当于可以表示$2^{48}$或256TB内存范围内的一个字节。及目前的64位计算机只使用48位来表示地址范围。</p><h3 id=代码示例>代码示例</h3><p>机器对产生这些汇编语言指令的源代码几乎一无所知，全都是字节序列。</p><p>生成可执行的代码需要对一组目标代码文件运行链接器，这组目标代码文件中必须含有一个main函数。</p><p>链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。</p><p>反汇编器</p><h3 id=关于格式的注解>关于格式的注解</h3><p>ATT与Intel汇编代码格式的区别</p><ul><li>Intel代码省略了指示大小的后缀。例如看到的指令为push和mov而不是pushq和movq。</li><li>Intel代码胜率了寄存器名字前的%符号。</li><li>Intel代码</li></ul><h2 id=数据格式>数据格式</h2><p>Intel用<strong>字(word)<strong>表示</strong>16位</strong>数据类型，因此称<strong>32位</strong>数为<strong>双字</strong>，称<strong>64位</strong>数位<strong>四字</strong>。</p><p>下表给出了C语言基本数据类型对应的x86-64表示：</p><table><thead><tr><th style=text-align:center>C声明</th><th style=text-align:center>Intel数据类型</th><th style=text-align:center>汇编代码后缀</th><th style=text-align:center>大小(字节)</th></tr></thead><tbody><tr><td style=text-align:center>char</td><td style=text-align:center>字节</td><td style=text-align:center>b</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>short</td><td style=text-align:center>字</td><td style=text-align:center>w</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>int</td><td style=text-align:center>双字</td><td style=text-align:center>l</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>long</td><td style=text-align:center>四字</td><td style=text-align:center>q</td><td style=text-align:center>8</td></tr><tr><td style=text-align:center>char*</td><td style=text-align:center>四字</td><td style=text-align:center>q</td><td style=text-align:center>8</td></tr><tr><td style=text-align:center>float</td><td style=text-align:center>单精度</td><td style=text-align:center>s</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>double</td><td style=text-align:center>双精度</td><td style=text-align:center>l</td><td style=text-align:center>8</td></tr></tbody></table><p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明<strong>操作数的大小</strong>。例如数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)、movq(传送四字)。</p><p>浮点数和整数使用一组完全不同的指令和寄存器。</p><h2 id=访问信息>访问信息</h2><p>一个x86-64CPU包含一组<strong>16个</strong>存储64位值的<strong>通用寄存器</strong>，用来存储整数数据和指针。最初的8086有8个16位的通用寄存器，发展到现在的x86-64后，原来的8个寄存器扩展为了64位，标号从%rax到%rsp，除此之外还新增了8个寄存器，从%r8到%r15。</p><p>在常见程序中不同寄存器扮演不同的角色，最特别的是栈指针%rsp，用来指明运行时栈的结束位置。</p><p>另外15个寄存器的用法更加灵活，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值、以及存储局部和临时数据。</p><h3 id=操作数指示符>操作数指示符</h3><p>大多数指令具有一个或多个<strong>操作数</strong>，指示出一个操作中要使用的源数据值以及放置结果的目的位置。源数据值可以以常数的形式给出，或从寄存器或内存中读出。结果可以存放在寄存器或内存中。操作数可以分为三类，分别为：</p><ul><li><strong>立即数</strong>：用来表示常数值，在ATT编码格式中，立即数是<code>$</code>后跟一个用标准C表示法表示的整数，例如<code>$0x1F</code>。</li><li><strong>寄存器</strong>：表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应8位、16位、32位或64位。用符号$r_a$来表示任意寄存器$a$，用引用$R[r_a]$表示它的值。即将寄存器集合看作一个数组R，用寄存器标识符作为引用。</li><li><strong>内存引用</strong>：根据计算出的地址访问某个内存位置。用符号$M_b[\text{Addr}]$表示对存储在内存中从Addr地址开始的b个字节值的引用，实际中一般省去下表b。</li></ul><p>有多种不同的<strong>寻址模式</strong>，最通用的形式为：$Imm(r_b,r_i,s)$，Imm表示一个立即数偏移，$r_b$表示一个基址寄存器，$r_i$表示一个变址寄存器，s表示一个比例因子，操作数值即有效地址为$M[Imm+R[r_b]+R[r_i]\cdot s]$。其他形式都是这种通用形式的特殊情况。</p><h3 id=数据传送指令>数据传送指令</h3><p>最频繁使用的指令是将数据从一个位置复制到另一个位置。这里会介绍很多种数据传送指令，他们或者源和目的类型不同，或者执行的转换不同，或者具有一些副作用。把许多不同指令划分为<strong>指令类</strong>，每类中的指令执行相同操作，只不过操作数大小不同。</p><p><strong>MOV类指令</strong></p><p>MOV类由四条指令组成，movb(字节), movw(字), movl(双字), movq(四字)。主要区别为他们操作的数据大小不同。</p><p><code>MOV S, D</code>：将S(source)传送到D(destination)</p><p>源操作数指定的值是一个<strong>立即数</strong>，存储在寄存器或内存中；目的操作数指定一个<strong>位置</strong>，要么是一个寄存器，要么是一个内存地址。</p><p>x86-64的两个操作数<strong>不能都指向内存位置</strong>，如果要将一个值从内存的一个位置复制到另一个位置，要先将该值读入寄存器，再将寄存器的值写入目标内存。</p><p>movabsq指令能以任意64位立即数值作为源操作数，并且只能以寄存器为目的。</p><p><strong>将较小源值复制到较大目的：使用MOVZ和MOVS</strong></p><p>MOVZ：把目的中剩余的字节填充为0</p><p>MOVS：通过符号扩展来填充，把源操作的最高位进行复制</p><h3 id=数据传送示例代码>数据传送示例代码</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#339;font-weight:700>long</span> <span style=color:#06b;font-weight:700>exchange</span>(<span style=color:#339;font-weight:700>long</span> <span style=color:#333>*</span>xp, <span style=color:#339;font-weight:700>long</span> y)
{
	<span style=color:#339;font-weight:700>long</span> x <span style=color:#333>=</span> <span style=color:#333>*</span>xp;	<span style=color:#888>//解引用操作符，把指针xp指向地址的数值放入寄存器x
</span><span style=color:#888></span>	<span style=color:#333>*</span>xp <span style=color:#333>=</span> y;	<span style=color:#888>//指针符号，把数y放入指针xp指向的地址
</span><span style=color:#888></span>	<span style=color:#080;font-weight:700>return</span> x;
}
</code></pre></div><pre><code class=language-assembly data-lang=assembly>;xp in %rdi, y in %rsi
exchange:
	movq (%rdi), %rax
	movq %rsi, (%rdi)
	ret
</code></pre><p>该例子说明了利用MOV指令从内存中读值到寄存器以及从寄存器写入内存。</p><p>局部变量x通常保存在寄存器中，速度较快。</p><h3 id=压入和弹出栈数据>压入和弹出栈数据</h3><p>将数据压入程序栈中以及从程序栈中弹出数据。栈是一种数据结构，遵循<strong>后进先出</strong>。弹出的值是最近被压入且仍在栈中的值。</p><p>栈可以实现为一个数组，总是从数组的一端插入和删除值，这一端被称为<strong>栈顶</strong>。</p><p>程序栈存放于内存的一个区域，栈向下增长，即栈顶元素的地址是<strong>最低</strong>的，根据惯例倒过来画栈，即栈顶在图的底部。栈指针%rsp保存着栈顶元素的地址。</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>效果</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>pushq S</td><td style=text-align:center>R[%rsp]$\leftarrow$R[%rsp]-8; M[R[%rsp]]$\leftarrow$S</td><td style=text-align:center>将四字压入栈</td></tr><tr><td style=text-align:center>popq D</td><td style=text-align:center>D$\leftarrow$M[R[%rsp]]; R[%rsp]$\leftarrow$R[%rsp]+8</td><td style=text-align:center>将四字弹出栈</td></tr></tbody></table><h2 id=算数和逻辑操作>算数和逻辑操作</h2><h3 id=加载有效地址leaq>加载有效地址leaq</h3><p>leaq指令能执行加法和有限形式的乘法，实际上是movq指令的变形。</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>效果</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>leaq S,D</td><td style=text-align:center>D $\leftarrow$&S</td><td style=text-align:center>加载有效地址</td></tr></tbody></table><p>该指令实际并未引用内存，而是将有效地址写入到目的操作数。&为取地址符，即产生一个指针。</p><p>例如如果寄存器%rdx的值为x，指令<code>leaq 7(%rdx,%rdx,4),%rax</code>将寄存器%rax的值设置为5x+7。这种用法与有效地址的计算无关。</p><p>目的操作数必须是一个寄存器。</p><h3 id=一元和二元操作>一元和二元操作</h3><p>一元操作指令和效果：</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>效果</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>INC D</td><td style=text-align:center>D$\leftarrow$D+1</td><td style=text-align:center>加1</td></tr><tr><td style=text-align:center>DEC D</td><td style=text-align:center>D$\leftarrow$D-1</td><td style=text-align:center>减1</td></tr><tr><td style=text-align:center>NEG D</td><td style=text-align:center>D$\leftarrow$-D</td><td style=text-align:center>取负</td></tr><tr><td style=text-align:center>NOT D</td><td style=text-align:center>D$\leftarrow$~D</td><td style=text-align:center>取补</td></tr></tbody></table><p>只有一个操作数，这个操作数可以是一个寄存器或内存位置。</p><p>二元操作指令和效果：</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>效果</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>ADD S,D</td><td style=text-align:center>D$\leftarrow$D+S</td><td style=text-align:center>加</td></tr><tr><td style=text-align:center>SUB S,D</td><td style=text-align:center>D$\leftarrow$D-S</td><td style=text-align:center>减</td></tr><tr><td style=text-align:center>IMUL S,D</td><td style=text-align:center>D$\leftarrow$D*S</td><td style=text-align:center>乘</td></tr><tr><td style=text-align:center>XOR S,D</td><td style=text-align:center>D$\leftarrow$D^S</td><td style=text-align:center>异或</td></tr><tr><td style=text-align:center>OR S,D</td><td style=text-align:center>D$\leftarrow$D|S</td><td style=text-align:center>或</td></tr><tr><td style=text-align:center>AND S,D</td><td style=text-align:center>D$\leftarrow$D&S</td><td style=text-align:center>与</td></tr></tbody></table><p>第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。</p><p>当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写入内存。</p><h3 id=移位操作>移位操作</h3><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>效果</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>SAL k,D</td><td style=text-align:center>D$\leftarrow$D&#171;k</td><td style=text-align:center>左移</td></tr><tr><td style=text-align:center>SHL k,D</td><td style=text-align:center>D$\leftarrow$D&#171;k</td><td style=text-align:center>左移(等同于SAL)</td></tr><tr><td style=text-align:center>SAR k,D</td><td style=text-align:center>D$\leftarrow$D$&#187;_A$k</td><td style=text-align:center>算数右移</td></tr><tr><td style=text-align:center>SHR k,D</td><td style=text-align:center>D$\leftarrow$D$&#187;_L$k</td><td style=text-align:center>逻辑右移</td></tr></tbody></table><p>先给出移位量k，第二项给出的是要移位的数。</p><p>移位量可以是<strong>立即数</strong>，或放在<strong>单字节寄存器%cl</strong>中。目标操作数可以是一个寄存器或一个内存位置。</p><h3 id=乘法和除法>乘法和除法</h3><p>INTEL把16字节的数称为8字。</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>效果</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>imulq S</td><td style=text-align:center>$R[%\text{rdx}]: R[%\text{rax}]\leftarrow S\times R[%\text{rax}]$</td><td style=text-align:center>有符号全乘法</td></tr><tr><td style=text-align:center>mulq S</td><td style=text-align:center>$R[%\text{rdx}]: R[%\text{rax}]\leftarrow S\times R[%\text{rax}]$</td><td style=text-align:center>无符号全乘法</td></tr><tr><td style=text-align:center>cqto</td><td style=text-align:center></td><td style=text-align:center>转换为八字</td></tr><tr><td style=text-align:center>idivq S</td><td style=text-align:center>$R[%\text{rdx}]\leftarrow R[%\text{rdx}] : R[%\text{rax}] \ \text{mod} \ S$</td><td style=text-align:center>有符号除法</td></tr><tr><td style=text-align:center>divq S</td><td style=text-align:center>$R[%\text{rdx}]\leftarrow R[%\text{rdx}] : R[%\text{rax}] \ \text{mod} \ S$</td><td style=text-align:center>无符号除法</td></tr></tbody></table><p>imulq指令有两种不同形式：</p><ul><li><strong>双操作数</strong>乘法指令：是IMUL的一种形式，从两个64位操作数产生一个64位乘积</li><li><strong>单操作数</strong>乘法指令：计算两个64位值的全128位乘积，一个是无符号数乘法(mulq)，另一个是补码乘法(imulq)，这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数即如上所示的S给出。乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。</li></ul><p>cqto指令：隐含读出%rax的符号位，并将其复制到%rdx的所有位。</p><p>汇编器能通过计算操作数数目，分辨想用哪条指令。</p><p>乘法代码示例：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#579>#include</span> <span style=color:#579>&lt;inttypes.h&gt;</span><span style=color:#579>
</span><span style=color:#579></span><span style=color:#080;font-weight:700>typedef</span> <span style=color:#339;font-weight:700>unsigned</span> __int128 uint128_t;
<span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>store_uprod</span>(uint128_t <span style=color:#333>*</span>dest, <span style=color:#339;font-weight:700>uint64_t</span> x, <span style=color:#339;font-weight:700>uint64_t</span> y) {
    <span style=color:#333>*</span>dest <span style=color:#333>=</span> x <span style=color:#333>*</span> (uint128_t) y;
}
</code></pre></div><p>将x和y显式地声明为64位数字。使用GCC提供的128位整数支持。这段代码指明得到的乘积应该存放在指针dest指向的16字节处。</p><p>生成的汇编代码如下：</p><pre><code class=language-assembly data-lang=assembly>;dest in %rdi, x in %rsi, y in %rdx
store_uprod:
	movq %rsi, %rax
	mulq %rdx
	movq %rax, (%rdi)
	movq %rdx, 8(%rdi)
	ret
</code></pre><p>存储乘积需要两个movq，一个存储低8个字节，另一个存储高8个字节；由于该机器是小端法及其，所以高位字节存储在大地址。</p><p>除法操作由<strong>单操作数除法指令</strong>来实现的。</p><p>有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax，将余数存储在寄存器%rdx。</p><p>除法代码示例：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>remdiv</span>(<span style=color:#339;font-weight:700>long</span> x, <span style=color:#339;font-weight:700>long</span> y, <span style=color:#339;font-weight:700>long</span> <span style=color:#333>*</span>qp, <span style=color:#339;font-weight:700>long</span> <span style=color:#333>*</span>rp) {
	<span style=color:#339;font-weight:700>long</span> q <span style=color:#333>=</span> x<span style=color:#333>/</span>y;
	<span style=color:#339;font-weight:700>long</span> r <span style=color:#333>=</span> x<span style=color:#333>%</span>y;
	<span style=color:#333>*</span>qp <span style=color:#333>=</span> q;
	<span style=color:#333>*</span>rp <span style=color:#333>=</span> r;
}
</code></pre></div><p>生成的汇编代码如下：</p><pre><code class=language-assembly data-lang=assembly>;x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
	movq %rdx, %r8
	movq %rdx, %rax
	cqto
	idivq %rsi
	movq %rax, (%r8)
	movq %rdx, (%rcx)
	ret
</code></pre><h2 id=控制>控制</h2><p>条件和跳转。</p><p>C语言中某些结构例如条件语句、循环语句和分支语句，要求有条件地执行，根据数据测试结果来改变控制流或数据流。</p><h3 id=条件码>条件码</h3><p>CPU除了整数寄存器还维护着一组单个位的<strong>条件码寄存器</strong>，描述了最近的算术和逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。</p><ul><li>CF：进位标志。最近的操作使<strong>最高位产生了进位</strong>则<strong>置为1</strong>。可用来检测无符号操作的溢出。(carry)</li><li>ZF：零标志。最近的操作得出的<strong>结果为0</strong>则置为1。(zero)</li><li>SF：符号标志。最近的操作得到的<strong>结果为负数</strong>则置为1。(symbol)</li><li>OF：溢出标志。最近的操作导致一个<strong>补码溢出</strong>则置为1。(overflow)</li></ul><p>(F代指Flag)</p><h3 id=访问条件码>访问条件码</h3><p>条件码通常不会直接读取，常用方法有：</p><ul><li>根据条件码的某种组合，将一个字节设置为0或1</li><li>可以条件跳转到程序的某个其他部分</li><li>可以有条件地传输数据</li></ul><p>SET指令：第一种情况，根据条件码的某种组合，将一个字节设置为0或1。不同后缀的set指令指明了其所考虑的<strong>条件码组合</strong>，不是指操作数的大小。</p><p>一条SET指令的<strong>目的操作数</strong>是<strong>低位单字节寄存器</strong>元素之一，或<strong>一个字节的内存位置</strong>，指令会将这个字节设置为0或1.</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>同义名</th><th style=text-align:center>效果</th><th style=text-align:center>设置条件</th></tr></thead><tbody><tr><td style=text-align:center>sete D</td><td style=text-align:center>setz</td><td style=text-align:center>D$\leftarrow$ZF</td><td style=text-align:center>相等（差为0）</td></tr><tr><td style=text-align:center>setne D</td><td style=text-align:center></td><td style=text-align:center>D$\leftarrow$~ZF</td><td style=text-align:center>不相等（差不为0）</td></tr><tr><td style=text-align:center>sets D</td><td style=text-align:center></td><td style=text-align:center>D$\leftarrow$SF</td><td style=text-align:center>负数</td></tr><tr><td style=text-align:center>setns D</td><td style=text-align:center></td><td style=text-align:center>D$\leftarrow$~SF</td><td style=text-align:center>非负数</td></tr><tr><td style=text-align:center>setg D</td><td style=text-align:center></td><td style=text-align:center>D$\leftarrow$~(SF^OF)&~ZF</td><td style=text-align:center>大于（有符号>）</td></tr><tr><td style=text-align:center>setge D</td><td style=text-align:center></td><td style=text-align:center>D$\leftarrow$~(SF^OF)</td><td style=text-align:center>大于等于（有符号>=）</td></tr><tr><td style=text-align:center>setl D</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>小于（有符号&lt;）</td></tr><tr><td style=text-align:center>setle D</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>小于等于（有符号&lt;=）</td></tr><tr><td style=text-align:center>seta D</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>超过（无符号>）</td></tr><tr><td style=text-align:center>setae D</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>超过或相等（无符号>=）</td></tr><tr><td style=text-align:center>setb D</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>低于（无符号&lt;）</td></tr><tr><td style=text-align:center>setbe D</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>低于或相等（无符号&lt;=）</td></tr></tbody></table><p>注：^代指异或运算。</p><p>各个SET命令的描述都是用的情况是：执行比较指令，根据t=a-b设置条件码。</p><ul><li>对于有符号比较的测试来说，假设a、b、t分别是变量a、b和t的补码形式表示的整数，因此t<ul><li>溢出位OF和符号位SF的EXCLUSIVE-OR提供了a&lt;b是否为真的测试，其他有符号比较测试基于SF异或OF和ZF的其他组合。</li></ul></li><li>对于无符号比较的测试来说，使用的是进位标志CF和零标志ZF的组合。</li></ul><h3 id=跳转指令>跳转指令</h3><p>跳转(jump)指令会导致执行<strong>切换到程序中一个全新的位置</strong>，汇编代码中这些跳转目的地通常用一个**标号(label)**指明。</p><p>汇编器会确定所有带标号指令的地址，并将<strong>跳转目标</strong>编码为跳转指令的一部分。</p><p>跳转指令分为有条件条状和无条件跳转。</p><p><strong>无条件跳转</strong>：</p><p>jmp指令可以是：</p><ul><li>直接跳转：跳转目标作为指令的一部分编码，即直接给出一个标号作为跳转目标</li><li>间接跳转：跳转目标是从寄存器或内存位置中读出</li></ul><p>间接跳转的写法是<code>*</code>后面跟一个操作数指示符，例如：<code>jmp *%rax</code></p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>跳转条件</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>jmp Label</td><td style=text-align:center>1</td><td style=text-align:center>直接跳转</td></tr><tr><td style=text-align:center>jmp *Operand</td><td style=text-align:center>1</td><td style=text-align:center>间接跳转</td></tr></tbody></table><p><strong>有条件跳转</strong>：</p><p>根据<strong>条件码的某种组合</strong>，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字后缀与SET指令相匹配。</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>同义名</th><th style=text-align:center>跳转条件</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>je Label</td><td style=text-align:center>jz</td><td style=text-align:center>ZF==1</td><td style=text-align:center>相等（零）</td></tr><tr><td style=text-align:center>jne Label</td><td style=text-align:center>jnz</td><td style=text-align:center>~ZF==1</td><td style=text-align:center>不相等（非零）</td></tr><tr><td style=text-align:center>js</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>负数</td></tr><tr><td style=text-align:center>jns</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>非负数</td></tr><tr><td style=text-align:center>jg</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>大于（有符号>）</td></tr><tr><td style=text-align:center>jge</td><td style=text-align:center>jnl</td><td style=text-align:center></td><td style=text-align:center>大于或等于</td></tr><tr><td style=text-align:center>jl</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>小于（有符号&lt;）</td></tr><tr><td style=text-align:center>jle</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>小于或等于</td></tr><tr><td style=text-align:center>ja</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>超过（无符号>）</td></tr><tr><td style=text-align:center>jae</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>超过或相等（无符号>=）</td></tr><tr><td style=text-align:center>jb</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>低于（无符号&lt;）</td></tr><tr><td style=text-align:center>jbe</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>低于或相等</td></tr></tbody></table><h3 id=跳转指令的编码>跳转指令的编码</h3><p>对于链接的理解非常重要，同时也能帮助理解反汇编器的输出。</p><p>跳转指令最常用的是<strong>PC相对编码</strong>。即将目标指令的地址与紧跟在跳转指令后的那条指令的地址之差作为编码，这些地址偏移量可以编码为1、2或4字节。</p><p>rep指令用来实现重复的字符串操作，可以忽略。</p><h3 id=用条件控制来实现条件分支>用条件控制来实现条件分支</h3><p>将条件表达式从C语言翻译为机器码，最常用的方式是结合<strong>有条件和无条件跳转</strong>。</p><p>C语言的if-else语句通用模板：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#080;font-weight:700>if</span> (test<span style=color:#333>-</span>expr)
	then<span style=color:#333>-</span>statement
<span style=color:#080;font-weight:700>else</span>
	<span style=color:#080;font-weight:700>else</span><span style=color:#333>-</span>statement
</code></pre></div><p>汇编使用以下形式实现，这里用C语法来描述控制流：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>t <span style=color:#333>=</span> test<span style=color:#333>-</span>expr;
<span style=color:#080;font-weight:700>if</span> (<span style=color:#333>!</span>t)
	<span style=color:#080;font-weight:700>goto</span> <span style=color:#007020>false</span>;
then<span style=color:#333>-</span>statement
<span style=color:#080;font-weight:700>goto</span> done;
<span style=color:#007020>false</span><span style=color:#333>:</span>
	<span style=color:#080;font-weight:700>else</span><span style=color:#333>-</span>statement
<span style=color:#970;font-weight:700>done</span>:
</code></pre></div><p>汇编器位then-statement和else-statement产生了各自的代码块，它会插入条件和无条件分支，保证能执行正确代码块。</p><h3 id=用条件传送实现条件分支>用条件传送实现条件分支</h3><p>实现条件操作的传统方法是使用<strong>控制</strong>的条件转移，当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单，但在现代处理器中非常低效。</p><p>替代策略是使用<strong>数据</strong>的条件转移。这种方法计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。</p><p>举例：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#339;font-weight:700>long</span> <span style=color:#06b;font-weight:700>absdiff</span>(<span style=color:#339;font-weight:700>long</span> x, <span style=color:#339;font-weight:700>long</span> y)
{
	<span style=color:#339;font-weight:700>long</span> result;
	<span style=color:#080;font-weight:700>if</span> (x <span style=color:#333>&lt;</span> y)
		result <span style=color:#333>=</span> y <span style=color:#333>-</span> x;
	<span style=color:#080;font-weight:700>else</span>
		result <span style=color:#333>=</span> x <span style=color:#333>-</span> y;
	<span style=color:#080;font-weight:700>return</span> result;
}
</code></pre></div><p>产生的汇编代码为：</p><pre><code class=language-assembly data-lang=assembly>;x in %rdi, y in &amp;rsi
absdiff:
	movq %rsi, %rax
	subq %rdi, %rax		;rval = y - x
	movq %rdi, %rdx
	subq %rsi, %rdx		;eval = x - y
	cmpq %rsi, %rdi		;Compare x:y
	cmovge %rdx, %rax	;If &gt;=, rval = eval
	ret					;Return rval
</code></pre><p>条件传送指令：指令的结果取决于条件码的值，<strong>当传送条件满足时，指令把源值S复制到目的R</strong>。</p><p>每条指令都有两个操作数：源寄存器或内存地址S，和目的寄存器D</p><p>源和目的的值可以为16、32或64位，不支持单字传送。</p><table><thead><tr><th>指令</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>comove S,R</td><td></td><td></td><td></td></tr><tr><td>cmovne S,R</td><td></td><td></td><td></td></tr><tr><td>cmovs S,R</td><td></td><td></td><td></td></tr><tr><td>cmovns S,R</td><td></td><td></td><td></td></tr><tr><td>cmovg S,R</td><td></td><td></td><td></td></tr><tr><td>cmovge S,R</td><td></td><td></td><td></td></tr><tr><td>cmovl</td><td></td><td></td><td></td></tr><tr><td>cmovle</td><td></td><td></td><td></td></tr><tr><td>cmova</td><td></td><td></td><td></td></tr><tr><td>cmovae</td><td></td><td></td><td></td></tr><tr><td>cmovb</td><td></td><td></td><td></td></tr></tbody></table><p>同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读取源值，检查条件码，然后要么更新目的寄存器，要么保持不变。</p><h3 id=循环>循环</h3><p>汇编中没有相应的循环指令，可以使用条件测试和跳转组合起来实现。</p><p><strong>do-while</strong>循环</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#970;font-weight:700>loop</span>:
	body<span style=color:#333>-</span>statement
	t <span style=color:#333>=</span> test<span style=color:#333>-</span>expr;
	<span style=color:#080;font-weight:700>if</span> (t)
		<span style=color:#080;font-weight:700>goto</span> loop;
</code></pre></div><p><strong>while</strong>循环</p><p>两种方法：</p><ol><li>跳转到中间</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#080;font-weight:700>goto</span> test;
<span style=color:#970;font-weight:700>loop</span>:
	body<span style=color:#333>-</span>statement
<span style=color:#970;font-weight:700>test</span>:
	t <span style=color:#333>=</span> test<span style=color:#333>-</span>expr;
	<span style=color:#080;font-weight:700>if</span> (t)
		<span style=color:#080;font-weight:700>goto</span> loop;
</code></pre></div><ol start=2><li>guarded-do</li></ol><p>首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>t <span style=color:#333>-</span> test<span style=color:#333>-</span>expr;
<span style=color:#080;font-weight:700>if</span> (<span style=color:#333>!</span>t)
	<span style=color:#080;font-weight:700>goto</span> done;
<span style=color:#970;font-weight:700>loop</span>:
	body<span style=color:#333>-</span>statement
	t <span style=color:#333>=</span> test<span style=color:#333>-</span>expr;
	<span style=color:#080;font-weight:700>if</span> (t)
		<span style=color:#080;font-weight:700>goto</span> loop;
</code></pre></div><p><strong>for</strong>循环</p><p>for循环的通用形式为：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#080;font-weight:700>for</span> (init<span style=color:#333>-</span>expr; test<span style=color:#333>-</span>expr; update<span style=color:#333>-</span>expr)	body<span style=color:#333>-</span>statement
</code></pre></div><p>将其改写为使用while循环的形式：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>init<span style=color:#333>-</span>expr;<span style=color:#080;font-weight:700>while</span> (test<span style=color:#333>-</span>expr) {	body<span style=color:#333>-</span>statement	update<span style=color:#333>-</span>expr;}
</code></pre></div><h3 id=switch语句>switch语句</h3><p>switch语句可以根据一个<strong>整数索引值</strong>进行多重分支。而且可以通过使用<strong>跳转表</strong>这种数据结构使得实现更加高效。</p><p>跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。</p><p>使用跳转表的优点是执行开关语句的时间<strong>与开关情况的数量无关</strong>。</p><h2 id=过程>过程</h2><p>提供了一种封装代码的方式，相当于<strong>函数接口</strong>。用一组指定的参数和一个可选的返回值实现了某种功能。</p><p>要提供对过程的机器级支持，必须要处理许多不同属性。假设过程P调用过程Q，Q执行后返回到P。这些动作包含以下一个或多个机制：</p><ul><li><strong>传递控制</strong>：进入过程Q时，<strong>程序计数器</strong>必须被设置为Q的代码的起始位置，然后在返回时，把程序计数器设置为P中调用Q后面那条指令的地址。</li><li><strong>传递数据</strong>：P必须能够向Q提供一个或多个参数，Q必须向P返回一个值。</li><li><strong>分配和释放内存</strong>：开始时Q可能要为<strong>局部变量</strong>分配空间，在返回前又必须释放这些空间。</li></ul><h3 id=运行时栈>运行时栈</h3><p>C语言过程调用机制使用了栈数据结构提供后进先出的内存管理原则。</p><p>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。</p><h3 id=转移控制>转移控制</h3><p>当控制从函数P转移到函数Q时，只需要简单地把程序计数器(PC)设置为Q的代码的起始位值，稍后从Q返回时，处理器必须记录好他需要继续P的执行的代码位置。在x86-64中，这个信息用指令<code>call Q</code>调用过程Q来记录。</p><h2 id=数组分配和访问>数组分配和访问</h2><p>C语言可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译为地址计算。</p><h3 id=基本原则>基本原则</h3><p>对于数据类型T和整型常数N，数组声明如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>T A[N];
</code></pre></div><p>起始位置为$x_A$，在内存中分配一个$L \cdot N$字节的连续区域，L为数据类型T的大小，其次，引入标识符A，可以用A作为指向数组开头的指针，该指针的值为$x_A$。</p><p>例如：<code>char A[12];</code>，数组A由12个单字节(char)元素组成。</p><h3 id=指针运算>指针运算</h3><h3 id=嵌套的数组>嵌套的数组</h3><p>二维数组可以以嵌套声明，例如：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#339;font-weight:700>int</span> A[<span style=color:#00d;font-weight:700>5</span>][<span style=color:#00d;font-weight:700>3</span>];
</code></pre></div><p>等价于：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#080;font-weight:700>typedef</span> <span style=color:#339;font-weight:700>int</span> row3_t[<span style=color:#00d;font-weight:700>3</span>];
row3_t A[<span style=color:#00d;font-weight:700>5</span>];
</code></pre></div><p>二维数组一般按照行优先顺序进行排列。</p><h3 id=定长数组>定长数组</h3><p>一般使用<code>#define</code>声明将常数与一个名字联系起来，然后一直使用这个名字代替常数的数值。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#579>#define N 16
</span><span style=color:#579></span><span style=color:#080;font-weight:700>typedef</span> <span style=color:#339;font-weight:700>int</span> fix_matrix[N][N];
</code></pre></div><h3 id=变长数组>变长数组</h3><p>ISO C99引入一种功能，允许数组的维度是表达式，在数组被分配时才计算出来。</p><p>例如：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>var_ele</span>(<span style=color:#339;font-weight:700>long</span> n, <span style=color:#339;font-weight:700>int</span> A[n][n], <span style=color:#339;font-weight:700>long</span> i, <span style=color:#339;font-weight:700>long</span> j){
	<span style=color:#080;font-weight:700>return</span> A[i][j];
}
</code></pre></div><p>参数<code>n</code>必须在参数<code>A[n][n]</code>之前.</p><h2 id=数据结构struct和union>数据结构struct和union</h2><p>结构用struct来声明，将多个对象集合到一个单位中。</p><p>联合用union来声明，允许用几种不同类型来引用一个对象。</p><h3 id=结构>结构</h3><p>C语言的struct声明创建一个将不同类型的对象集合到一个对象中的数据类型。<strong>用名字来引用</strong>结构的各个组成部分，类似于数组的实现。</p><p>结构的所有组成部分都放在内存中的一段<strong>连续区域</strong>，指向结构的指针就是结构<strong>第一个字节的地址</strong>。</p><p>编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。</p><blockquote><p>面向对象的C++和Java的对象要比C语言中的结构要复杂精细得多，因为他们将一组方法与一个对象联系起来</p></blockquote><p>为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。</p><p>要产生一个指向结构内部对象的指针，只需将结构的地址加上该字段的偏移量。</p><h3 id=联合>联合</h3><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），union占用的内存等于最长的成员占用的内存。union使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><h3 id=数据对齐>数据对齐</h3><p>一些计算机对<strong>基本数据类型的合法地址</strong>作出了限制，要求某种类型对象的地址必须是某个值K(通常是2、4、8)的倍数。这种内存对齐限制简化了处理器和内存之间接口的硬件设计。例如，一个处理器每次总是从内存中读取8个字节，则地址必须为8的倍数；如果我们保证double类型数据的地址对其成8的倍数，那么就可以用一次内存操作来读或写值，否则可能执行两次内存访问，因为对象可能被放在两个8字节内存块中。</p><p>内存地址对其是通过编译器来控制的。对于大多数x86-64指令来说，保持数据对其能提高效率，不会影响程序行为。</p><h2 id=数据和控制的交互>数据和控制的交互</h2><h3 id=指针>指针</h3><p>下面是一些指针和它们映射到机器代码的关键原则。</p><ul><li>每个指针都<strong>对应一个类型</strong>。类型表明指针指向对象的类型。指针类型不是机器代码的一部分，是C语言提供的一种抽象，帮助我们避免寻址错误。</li><li>每个指针都有一个值。这个值是某个指定类型对象的地址。</li><li>指针用取地址符<code>&</code>创建。leaq指令用来计算内存引用的地址，&运算符的机器代码实现常用leaq指令来计算表达式的值。</li><li>*解引用符号用于间接引用指针，结果为一个值。</li><li>数组与指针联系紧密。一个数组名可以像一个指针变量一样引用。</li><li>将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值。</li><li>指针也可以指向函数。函数指针的值是该函数机器代码表示中第一条指令的地址。</li></ul><h3 id=gdb调试器>GDB调试器</h3><h3 id=缓冲区溢出>缓冲区溢出</h3><p>C对数组引用不进行任何边界检查，局部变量和状态信息都存放在栈中，这就可能导致严重错误。对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，制图重新加载寄存器或执行ret执行时就会发生严重错误。</p><p>常见的状态破坏成为缓冲区溢出。例如，在栈中分配一个字符数组保存一个字符串，但字符串的长度超出了为数组分配的空间。</p><p>缓冲区溢出让程序执行它本来不愿意执行的函数。例如，输入一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码</p><h3 id=支持变长栈帧>支持变长栈帧</h3><h2 id=浮点代码>浮点代码</h2><hr width=100% id=EOF><p style=color:#777>最后修改于 2021-08-09</p></div></div><nav class=post-pagination><a class=newer-posts href=https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/>下回<br>算法的时间复杂度和空间复杂度</a>
<a class=older-posts href=https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/>上回<br>计算机网络学习日志（三）——网络层：数据平面</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2019-2021 By Jialong</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:!1,mounted:!1,isDarkMode:!1},methods:{sgn(a,b){let c=1/(1-2*a);return b<=a?0:b>=1-a?1:c*(b-a)},handleScroll(){this.scrollY=window.scrollY,this.navOpacity=this.sgn(0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*.8))));const{navBar:c,navBackground:a,navTitle:b,extraContainer:d,streamContainer:e}=this.$refs;this.navOpacity>=1?(a.style.opacity=1,b.style.opacity=1):(a.style.opacity=0,b.style.opacity=0)},handleResize(){const{navBar:c,navBackground:d,navTitle:e,extraContainer:a,streamContainer:b}=this.$refs;a.style.left=b.offsetWidth-a.offsetWidth+'px'},navBarHeight(){return this.$refs.navBar.offsetHeight},pageHeadHeight(){return this.$refs.pageHead.offsetHeight},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},closeDrawer(){this.isDrawerOpen=!1,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},toggleDarkMode(){this.isDarkMode=!this.isDarkMode,this.isDarkMode==!0?(document.cookie="night=1;path=/",document.body.classList.add("night")):(document.cookie="night=0;path=/",document.body.classList.remove("night"))},debounce(t,b,f){let e,g,l,d,a,c,i=0,q=!1,h=!1,n=!0;const s=!b&&b!==0&&typeof root.requestAnimationFrame=='function';if(typeof t!='function')throw new TypeError('Expected a function');function w(a){const b=typeof a;return a!=null&&(b==='object'||b==='function')}b=+b||0,w(f)&&(q=!!f.leading,h='maxWait'in f,l=h?Math.max(+f.maxWait||0,b):l,n='trailing'in f?!!f.trailing:n);function o(a){const b=e,c=g;return e=g=void 0,i=a,d=t.apply(c,b),d}function k(b,c){return s?(root.cancelAnimationFrame(a),root.requestAnimationFrame(b)):setTimeout(b,c)}function v(a){if(s)return root.cancelAnimationFrame(a);clearTimeout(a)}function A(c){return i=c,a=k(m,b),q?o(c):d}function u(a){const e=a-c,f=a-i,d=b-e;return h?Math.min(d,l-f):d}function r(a){const d=a-c,e=a-i;return c===void 0||d>=b||d<0||h&&e>=l}function m(){const b=Date.now();if(r(b))return p(b);a=k(m,u(b))}function p(b){return a=void 0,n&&e?o(b):(e=g=void 0,d)}function x(){a!==void 0&&v(a),i=0,e=c=g=a=void 0}function y(){return a===void 0?d:p(Date.now())}function z(){return a!==void 0}function j(...i){const f=Date.now(),j=r(f);if(e=i,g=this,c=f,j){if(a===void 0)return A(c);if(h)return a=k(m,b),o(c)}return a===void 0&&(a=k(m,b)),d}return j.cancel=x,j.flush=y,j.pending=z,j}},created(){window.addEventListener('scroll',this.handleScroll),window.addEventListener('resize',this.handleResize),window._nonDesktop=function(){let a=!1;return function(b){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(b)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(b.substr(0,4)))&&(a=!0)}(navigator.userAgent||navigator.vendor||window.opera),a};var a=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");a==""?window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches:a=="1"&&this.toggleDarkMode()},mounted(){this.handleScroll(),this.handleResize(),this.mounted=!0,document.querySelectorAll("table").forEach(function(a){a.classList.add("table-striped"),a.classList.add("table"),a.classList.add("table-responsive"),a.classList.add("table-hover")}),spy(),window.addEventListener('scroll',this.debounce(spy,250,{maxWait:250}),!1)},destroyed(){window.removeEventListener('scroll',this.handleScroll),window.removeEventListener('resize',this.handleResize)}})</script></body></html>