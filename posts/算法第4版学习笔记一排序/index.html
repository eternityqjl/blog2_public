<!doctype html><html><head><title>《算法（第4版）》学习笔记——（一）排序</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="《算法（第4版）》学习笔记——（一）排序"><meta property="og:description" content="初级排序算法 选择排序 算法描述 首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。
代码实现 public class Selection { public static void sort(Comparable[] a) { //将a按照升序排列  int N = a.length; for (int i = 0; i < N; i++) { int min = i; for (int j = i + 1; j < N; j++) { if (less(a[j], a[min])) min = j; } exch(a, i ,min); } } } 性能分析  对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。 该算法运行时间与输入无关，数据的移动是最少的。  插入排序 算法描述 插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。
代码实现 public class Insertion { public static void sort(Comparable[] a) { int N = a."><meta property="og:type" content="article"><meta property="og:url" content="https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%AC%AC4%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E6%8E%92%E5%BA%8F/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-23T14:59:12+00:00"><meta property="article:modified_time" content="2020-07-23T14:59:12+00:00"><meta property="og:site_name" content="My Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="《算法（第4版）》学习笔记——（一）排序"><meta name=twitter:description content="初级排序算法 选择排序 算法描述 首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。
代码实现 public class Selection { public static void sort(Comparable[] a) { //将a按照升序排列  int N = a.length; for (int i = 0; i < N; i++) { int min = i; for (int j = i + 1; j < N; j++) { if (less(a[j], a[min])) min = j; } exch(a, i ,min); } } } 性能分析  对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。 该算法运行时间与输入无关，数据的移动是最少的。  插入排序 算法描述 插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。
代码实现 public class Insertion { public static void sort(Comparable[] a) { int N = a."><link type=text/css rel=stylesheet href=/blog2_public/vendor/css/bootstrap.min.css><script src=/blog2_public/vendor/js/vue.min.js></script><link rel=icon href=https://raw.githubusercontent.com/eternityqjl/blogGallery/master/faviconJ.ico><link rel=stylesheet href=https://eternityqjl.github.io/blog2_public/scss/journal.min.3f72a5fc8f5b5dd732a4b476aced0eece2156958d9d414316494ddb10593ddf7.css integrity="sha256-P3Kl/I9bXdcypLR2rO0O7OIVaVjZ1BQxZJTdsQWT3fc=" media=screen><link rel=stylesheet href=https://eternityqjl.github.io/blog2_public/scss/dark-mode.min.c0082f0b082177f6fb3768ff91439a097de49689bd26f4d49f76d94ebb81e02d.css integrity="sha256-wAgvCwghd/b7N2j/kUOaCX3klom9JvTUn3bZTruB4C0=" media=screen><script src=/blog2_public/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js>MathJax.Hub.Queue(function(){var b=MathJax.Hub.getAllJax(),a;for(a=0;a<b.length;a+=1)b[a].SourceElement().parentNode.className+=' has-jax'})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script src=/blog2_public/js/toc.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/blog2_public/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'df0192f05fd975a4e951',clientSecret:'f1ff41cecd43fac4792ed8be020aeb337494c340',repo:'eternityqjl.github.io',owner:'eternityqjl',admin:['eternityqjl'],id:md5(location.pathname),distractionFreeMode:'false'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://eternityqjl.github.io/blog2_public><div class=nav-title>Jialong's Blog</div><div class=nav-subtitle>沉潜 自由 追寻幸福</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/blog2_public/posts>网志</a>
<a class="a-block nav-link-item false" href=/blog2_public/categories>分类</a>
<a class="a-block nav-link-item false" href=/blog2_public/tags>标签</a>
<a class="a-block nav-link-item false" href=/blog2_public/about>关于</a>
<a class="a-block nav-link-item false" href=/blog2_public/index.xml>RSS</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2019-2021 By Jialong</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e5%88%9d%e7%ba%a7%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95 onclick="onNavClick(`#初级排序算法-nav`)" id=初级排序算法-nav>初级排序算法</a></li><ul><li><a href=#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f onclick="onNavClick(`#选择排序-nav`)" id=选择排序-nav>选择排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0 onclick="onNavClick(`#算法描述-nav`)" id=算法描述-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 onclick="onNavClick(`#代码实现-nav`)" id=代码实现-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 onclick="onNavClick(`#性能分析-nav`)" id=性能分析-nav>性能分析</a></li></ul><li><a href=#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f onclick="onNavClick(`#插入排序-nav`)" id=插入排序-nav>插入排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-1 onclick="onNavClick(`#算法描述-1-nav`)" id=算法描述-1-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1 onclick="onNavClick(`#代码实现-1-nav`)" id=代码实现-1-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-1 onclick="onNavClick(`#性能分析-1-nav`)" id=性能分析-1-nav>性能分析</a></li></ul><li><a href=#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f onclick="onNavClick(`#希尔排序-nav`)" id=希尔排序-nav>希尔排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-2 onclick="onNavClick(`#算法描述-2-nav`)" id=算法描述-2-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2 onclick="onNavClick(`#代码实现-2-nav`)" id=代码实现-2-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-2 onclick="onNavClick(`#性能分析-2-nav`)" id=性能分析-2-nav>性能分析</a></li></ul></ul><li><a href=#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f onclick="onNavClick(`#归并排序-nav`)" id=归并排序-nav>归并排序</a></li><ul><li><a href=#%e5%8e%9f%e5%9c%b0%e5%bd%92%e5%b9%b6 onclick="onNavClick(`#原地归并-nav`)" id=原地归并-nav>原地归并</a></li><li><a href=#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b%e7%9a%84%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f onclick="onNavClick(`#自顶向下的归并排序-nav`)" id=自顶向下的归并排序-nav>自顶向下的归并排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-3 onclick="onNavClick(`#算法描述-3-nav`)" id=算法描述-3-nav>算法描述</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-3 onclick="onNavClick(`#性能分析-3-nav`)" id=性能分析-3-nav>性能分析</a></li></ul><li><a href=#%e8%87%aa%e5%ba%95%e5%90%91%e4%b8%8a%e7%9a%84%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f onclick="onNavClick(`#自底向上的归并排序-nav`)" id=自底向上的归并排序-nav>自底向上的归并排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-4 onclick="onNavClick(`#算法描述-4-nav`)" id=算法描述-4-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3 onclick="onNavClick(`#代码实现-3-nav`)" id=代码实现-3-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-4 onclick="onNavClick(`#性能分析-4-nav`)" id=性能分析-4-nav>性能分析</a></li></ul></ul><li><a href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f onclick="onNavClick(`#快速排序-nav`)" id=快速排序-nav>快速排序</a></li><ul><li><a href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e7%9a%84%e5%88%87%e5%88%86 onclick="onNavClick(`#快速排序的切分-nav`)" id=快速排序的切分-nav>快速排序的切分</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95 onclick="onNavClick(`#基本快速排序算法-nav`)" id=基本快速排序算法-nav>基本快速排序算法</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-5 onclick="onNavClick(`#算法描述-5-nav`)" id=算法描述-5-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4 onclick="onNavClick(`#代码实现-4-nav`)" id=代码实现-4-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-5 onclick="onNavClick(`#性能分析-5-nav`)" id=性能分析-5-nav>性能分析</a></li></ul><li><a href=#%e4%b8%89%e5%90%91%e5%88%87%e5%88%86%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f onclick="onNavClick(`#三向切分快速排序-nav`)" id=三向切分快速排序-nav>三向切分快速排序</a></li><ul><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-5 onclick="onNavClick(`#代码实现-5-nav`)" id=代码实现-5-nav>代码实现</a></li></ul></ul><li><a href=#%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97 onclick="onNavClick(`#优先队列-nav`)" id=优先队列-nav>优先队列</a></li><ul><li><a href=#%e5%88%9d%e7%ba%a7%e5%ae%9e%e7%8e%b0%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e6%97%a0%e5%ba%8f%e6%95%b0%e7%bb%84%e9%93%be%e8%a1%a8 onclick="onNavClick(`#初级实现有序数组无序数组链表-nav`)" id=初级实现有序数组无序数组链表-nav>初级实现：有序数组、无序数组、链表</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e7%9a%84%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97 onclick="onNavClick(`#基于堆的优先队列-nav`)" id=基于堆的优先队列-nav>基于堆的优先队列</a></li><ul><li><a href=#%e5%a0%86%e7%9a%84%e5%ae%9a%e4%b9%89 onclick="onNavClick(`#堆的定义-nav`)" id=堆的定义-nav>堆的定义</a></li><li><a href=#%e5%a0%86%e7%9a%84%e7%ae%97%e6%b3%95 onclick="onNavClick(`#堆的算法-nav`)" id=堆的算法-nav>堆的算法</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e7%9a%84%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e7%9a%84%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 onclick="onNavClick(`#基于堆的优先队列的代码实现-nav`)" id=基于堆的优先队列的代码实现-nav>基于堆的优先队列的代码实现</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e7%9a%84%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 onclick="onNavClick(`#基于堆的优先队列性能分析-nav`)" id=基于堆的优先队列性能分析-nav>基于堆的优先队列性能分析</a></li></ul><li><a href=#%e5%a0%86%e6%8e%92%e5%ba%8f onclick="onNavClick(`#堆排序-nav`)" id=堆排序-nav>堆排序</a></li><ul><li><a href=#%e5%a0%86%e7%9a%84%e6%9e%84%e9%80%a0 onclick="onNavClick(`#堆的构造-nav`)" id=堆的构造-nav>堆的构造</a></li><li><a href=#%e4%b8%8b%e6%b2%89%e6%8e%92%e5%ba%8f onclick="onNavClick(`#下沉排序-nav`)" id=下沉排序-nav>下沉排序</a></li><li><a href=#%e5%a0%86%e6%8e%92%e5%ba%8f%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 onclick="onNavClick(`#堆排序代码实现-nav`)" id=堆排序代码实现-nav>堆排序代码实现</a></li><li><a href=#%e5%a0%86%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 onclick="onNavClick(`#堆排序性能分析-nav`)" id=堆排序性能分析-nav>堆排序性能分析</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/blog2_public/posts>网志</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/categories>分类</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/tags>标签</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/about>关于</a>
<a class="a-block drawer-menu-item false" href=/blog2_public/index.xml>RSS</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e5%88%9d%e7%ba%a7%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95 onclick="onNavClick(`#初级排序算法-nav`)" id=初级排序算法-nav>初级排序算法</a></li><ul><li><a href=#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f onclick="onNavClick(`#选择排序-nav`)" id=选择排序-nav>选择排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0 onclick="onNavClick(`#算法描述-nav`)" id=算法描述-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 onclick="onNavClick(`#代码实现-nav`)" id=代码实现-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 onclick="onNavClick(`#性能分析-nav`)" id=性能分析-nav>性能分析</a></li></ul><li><a href=#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f onclick="onNavClick(`#插入排序-nav`)" id=插入排序-nav>插入排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-1 onclick="onNavClick(`#算法描述-1-nav`)" id=算法描述-1-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1 onclick="onNavClick(`#代码实现-1-nav`)" id=代码实现-1-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-1 onclick="onNavClick(`#性能分析-1-nav`)" id=性能分析-1-nav>性能分析</a></li></ul><li><a href=#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f onclick="onNavClick(`#希尔排序-nav`)" id=希尔排序-nav>希尔排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-2 onclick="onNavClick(`#算法描述-2-nav`)" id=算法描述-2-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2 onclick="onNavClick(`#代码实现-2-nav`)" id=代码实现-2-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-2 onclick="onNavClick(`#性能分析-2-nav`)" id=性能分析-2-nav>性能分析</a></li></ul></ul><li><a href=#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f onclick="onNavClick(`#归并排序-nav`)" id=归并排序-nav>归并排序</a></li><ul><li><a href=#%e5%8e%9f%e5%9c%b0%e5%bd%92%e5%b9%b6 onclick="onNavClick(`#原地归并-nav`)" id=原地归并-nav>原地归并</a></li><li><a href=#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b%e7%9a%84%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f onclick="onNavClick(`#自顶向下的归并排序-nav`)" id=自顶向下的归并排序-nav>自顶向下的归并排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-3 onclick="onNavClick(`#算法描述-3-nav`)" id=算法描述-3-nav>算法描述</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-3 onclick="onNavClick(`#性能分析-3-nav`)" id=性能分析-3-nav>性能分析</a></li></ul><li><a href=#%e8%87%aa%e5%ba%95%e5%90%91%e4%b8%8a%e7%9a%84%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f onclick="onNavClick(`#自底向上的归并排序-nav`)" id=自底向上的归并排序-nav>自底向上的归并排序</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-4 onclick="onNavClick(`#算法描述-4-nav`)" id=算法描述-4-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3 onclick="onNavClick(`#代码实现-3-nav`)" id=代码实现-3-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-4 onclick="onNavClick(`#性能分析-4-nav`)" id=性能分析-4-nav>性能分析</a></li></ul></ul><li><a href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f onclick="onNavClick(`#快速排序-nav`)" id=快速排序-nav>快速排序</a></li><ul><li><a href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e7%9a%84%e5%88%87%e5%88%86 onclick="onNavClick(`#快速排序的切分-nav`)" id=快速排序的切分-nav>快速排序的切分</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95 onclick="onNavClick(`#基本快速排序算法-nav`)" id=基本快速排序算法-nav>基本快速排序算法</a></li><ul><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-5 onclick="onNavClick(`#算法描述-5-nav`)" id=算法描述-5-nav>算法描述</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4 onclick="onNavClick(`#代码实现-4-nav`)" id=代码实现-4-nav>代码实现</a></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90-5 onclick="onNavClick(`#性能分析-5-nav`)" id=性能分析-5-nav>性能分析</a></li></ul><li><a href=#%e4%b8%89%e5%90%91%e5%88%87%e5%88%86%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f onclick="onNavClick(`#三向切分快速排序-nav`)" id=三向切分快速排序-nav>三向切分快速排序</a></li><ul><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-5 onclick="onNavClick(`#代码实现-5-nav`)" id=代码实现-5-nav>代码实现</a></li></ul></ul><li><a href=#%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97 onclick="onNavClick(`#优先队列-nav`)" id=优先队列-nav>优先队列</a></li><ul><li><a href=#%e5%88%9d%e7%ba%a7%e5%ae%9e%e7%8e%b0%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e6%97%a0%e5%ba%8f%e6%95%b0%e7%bb%84%e9%93%be%e8%a1%a8 onclick="onNavClick(`#初级实现有序数组无序数组链表-nav`)" id=初级实现有序数组无序数组链表-nav>初级实现：有序数组、无序数组、链表</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e7%9a%84%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97 onclick="onNavClick(`#基于堆的优先队列-nav`)" id=基于堆的优先队列-nav>基于堆的优先队列</a></li><ul><li><a href=#%e5%a0%86%e7%9a%84%e5%ae%9a%e4%b9%89 onclick="onNavClick(`#堆的定义-nav`)" id=堆的定义-nav>堆的定义</a></li><li><a href=#%e5%a0%86%e7%9a%84%e7%ae%97%e6%b3%95 onclick="onNavClick(`#堆的算法-nav`)" id=堆的算法-nav>堆的算法</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e7%9a%84%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e7%9a%84%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 onclick="onNavClick(`#基于堆的优先队列的代码实现-nav`)" id=基于堆的优先队列的代码实现-nav>基于堆的优先队列的代码实现</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e7%9a%84%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 onclick="onNavClick(`#基于堆的优先队列性能分析-nav`)" id=基于堆的优先队列性能分析-nav>基于堆的优先队列性能分析</a></li></ul><li><a href=#%e5%a0%86%e6%8e%92%e5%ba%8f onclick="onNavClick(`#堆排序-nav`)" id=堆排序-nav>堆排序</a></li><ul><li><a href=#%e5%a0%86%e7%9a%84%e6%9e%84%e9%80%a0 onclick="onNavClick(`#堆的构造-nav`)" id=堆的构造-nav>堆的构造</a></li><li><a href=#%e4%b8%8b%e6%b2%89%e6%8e%92%e5%ba%8f onclick="onNavClick(`#下沉排序-nav`)" id=下沉排序-nav>下沉排序</a></li><li><a href=#%e5%a0%86%e6%8e%92%e5%ba%8f%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 onclick="onNavClick(`#堆排序代码实现-nav`)" id=堆排序代码实现-nav>堆排序代码实现</a></li><li><a href=#%e5%a0%86%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 onclick="onNavClick(`#堆排序性能分析-nav`)" id=堆排序性能分析-nav>堆排序性能分析</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://eternityqjl.github.io/blog2_public>Jialong's Blog</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://eternityqjl.github.io/blog2_public><div class=single-column-header-title>Jialong's Blog</div><div class=single-column-header-subtitle>沉潜 自由 追寻幸福</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>《算法（第4版）》学习笔记——（一）排序<div class=post-meta><time itemprop=datePublished>2020-07-23 14:59</time>
<i class=material-icons>folder</i>
<a href=/blog2_public/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/blog2_public/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95>排序算法</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h2 id=初级排序算法>初级排序算法</h2><h3 id=选择排序>选择排序</h3><h4 id=算法描述>算法描述</h4><p>首先找到数组中最小的一个元素，将其与数组的第一个元素进行交换；再在剩余的元素找到最小的一个元素，将其与数组的第二个元素进行交换。如此循环往复，直到将整个数字排序。</p><h4 id=代码实现>代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Selection</span> <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#888>//将a按照升序排列
</span><span style=color:#888></span>        <span style=color:#339;font-weight:700>int</span> N <span style=color:#333>=</span> a<span style=color:#333>.</span><span style=color:#00c>length</span><span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> 0<span style=color:#333>;</span> i <span style=color:#333>&lt;</span> N<span style=color:#333>;</span> i<span style=color:#333>++)</span>
        <span style=color:#333>{</span>
            <span style=color:#339;font-weight:700>int</span> min <span style=color:#333>=</span> i<span style=color:#333>;</span>
            <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> j <span style=color:#333>=</span> i <span style=color:#333>+</span> 1<span style=color:#333>;</span> j <span style=color:#333>&lt;</span> N<span style=color:#333>;</span> j<span style=color:#333>++)</span>
            <span style=color:#333>{</span>
                <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>less<span style=color:#333>(</span>a<span style=color:#333>[</span>j<span style=color:#333>],</span> a<span style=color:#333>[</span>min<span style=color:#333>]))</span>
                    min <span style=color:#333>=</span> j<span style=color:#333>;</span>
            <span style=color:#333>}</span>
            exch<span style=color:#333>(</span>a<span style=color:#333>,</span> i <span style=color:#333>,</span>min<span style=color:#333>);</span>
        <span style=color:#333>}</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=性能分析>性能分析</h4><ul><li>对长度为$N$的数组，选择排序大概需要$N^2/2$次比较和$N$次交换。</li><li>该算法运行时间与输入无关，数据的移动是最少的。</li></ul><h3 id=插入排序>插入排序</h3><h4 id=算法描述-1>算法描述</h4><p>插入排序当前索引左边的所有元素都是有序的，但他们的最终位置还不确定，为了给更小的元素腾出空间，他们可能会被向右移动，当索引到达数组的最右端时，排序就完成了。</p><h4 id=代码实现-1>代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Insertion</span> <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#339;font-weight:700>int</span> N <span style=color:#333>=</span> a<span style=color:#333>.</span><span style=color:#00c>length</span><span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> 1<span style=color:#333>;</span> i <span style=color:#333>&lt;</span> N<span style=color:#333>;</span> i<span style=color:#333>++)</span>
        <span style=color:#333>{</span>
            <span style=color:#888>//将相邻两个元素向左依次交换最终使得索引左侧的元素全部向右移动一位
</span><span style=color:#888></span>            <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> j <span style=color:#333>=</span> i<span style=color:#333>;</span> j <span style=color:#333>&gt;</span> 0 <span style=color:#333>&amp;&amp;</span> less<span style=color:#333>(</span>a<span style=color:#333>[</span>j<span style=color:#333>],</span> a<span style=color:#333>[</span>j <span style=color:#333>-</span> 1<span style=color:#333>]);</span> j<span style=color:#333>--)</span>
                exch <span style=color:#333>(</span>a<span style=color:#333>,</span> j<span style=color:#333>,</span> j <span style=color:#333>-</span> 1<span style=color:#333>);</span>
        <span style=color:#333>}</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=性能分析-1>性能分析</h4><p>对随机排列长度为$N$且主键不重复的数组，平均插入排序需要$N^2/4$次比较和$N^2/4$次交换。</p><p><strong>部分有序数组</strong>：</p><ul><li>数组中每个元素距离它的最终位置都不远</li><li>一个有序大数组接一个小数组</li><li>数组中只有几个元素的位置不正确</li></ul><p>插入排序对这样的部分有序数组非常有效。</p><h3 id=希尔排序>希尔排序</h3><h4 id=算法描述-2>算法描述</h4><p>交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序数组排序。</p><p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组被称为<strong>h有序数组</strong>，即h个相互独立的有序数组编织在一起组成的一个数组</p><h4 id=代码实现-2>代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Shell</span> <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>srot</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#339;font-weight:700>int</span> N <span style=color:#333>=</span> a<span style=color:#333>.</span><span style=color:#00c>length</span><span style=color:#333>;</span>
        <span style=color:#339;font-weight:700>int</span> h <span style=color:#333>=</span> 1<span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>h <span style=color:#333>&lt;</span> N <span style=color:#333>/</span> 3<span style=color:#333>)</span>   h <span style=color:#333>=</span> 3 <span style=color:#333>*</span> h <span style=color:#333>+</span> 1<span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>h <span style=color:#333>&gt;</span> 1<span style=color:#333>)</span>
        <span style=color:#333>{</span>
            <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> h<span style=color:#333>;</span> i <span style=color:#333>&lt;</span> N<span style=color:#333>;</span> i<span style=color:#333>++)</span>
            <span style=color:#333>{</span>
                <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> j <span style=color:#333>=</span> i<span style=color:#333>;</span> j <span style=color:#333>&gt;=</span> h <span style=color:#333>&amp;&amp;</span> less<span style=color:#333>(</span>a<span style=color:#333>[</span>j<span style=color:#333>],</span> a<span style=color:#333>[</span>j <span style=color:#333>-</span> h<span style=color:#333>]);</span> j <span style=color:#333>-=</span> h<span style=color:#333>)</span>
                    exch<span style=color:#333>(</span>a<span style=color:#333>,</span> j<span style=color:#333>,</span> j <span style=color:#333>-</span> h<span style=color:#333>);</span>
            <span style=color:#333>}</span>
            h <span style=color:#333>=</span> h <span style=color:#333>/</span> 3<span style=color:#333>;</span>
        <span style=color:#333>}</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><p>该希尔算法使用了序列$1/2(3^k-1)$，即序列${ 1,4,13 }$，称为<strong>增量序列</strong>。</p><h4 id=性能分析-2>性能分析</h4><p>希尔排序权衡了子数组的规模和有序性，希尔排序比插入排序和选择排序快得多，并且数组越大优势越大。</p><h2 id=归并排序>归并排序</h2><p><strong>归并</strong>即将两个有序的数组归并成一个更大的有序数组。</p><h3 id=原地归并>原地归并</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>merge</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> lo<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> mid<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> hi<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> lo<span style=color:#333>,</span> j <span style=color:#333>=</span> mid <span style=color:#333>+</span> 1<span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> k <span style=color:#333>=</span> lo<span style=color:#333>;</span> k <span style=color:#333>&lt;=</span> hi<span style=color:#333>;</span> k<span style=color:#333>++)</span>
            aux<span style=color:#333>[</span>k<span style=color:#333>]</span> <span style=color:#333>=</span> a<span style=color:#333>[</span>k<span style=color:#333>];</span>

        <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> k <span style=color:#333>=</span> lo<span style=color:#333>;</span> k <span style=color:#333>&lt;=</span> hi<span style=color:#333>;</span> k<span style=color:#333>++)</span>
        <span style=color:#333>{</span>
            <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>i <span style=color:#333>&gt;</span> mid<span style=color:#333>)</span>                      a<span style=color:#333>[</span>k<span style=color:#333>]</span> <span style=color:#333>=</span> aux<span style=color:#333>[</span>j<span style=color:#333>++];</span>
            <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>j <span style=color:#333>&gt;</span> hi<span style=color:#333>)</span>                  a<span style=color:#333>[</span>k<span style=color:#333>]</span> <span style=color:#333>=</span> aux<span style=color:#333>[</span>i<span style=color:#333>++];</span>
            <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>less<span style=color:#333>(</span>aux<span style=color:#333>[</span>j<span style=color:#333>],</span> aux<span style=color:#333>[</span>i<span style=color:#333>]))</span>    a<span style=color:#333>[</span>k<span style=color:#333>]</span> <span style=color:#333>=</span> aux<span style=color:#333>[</span>j<span style=color:#333>++];</span>
            <span style=color:#080;font-weight:700>else</span>                              a<span style=color:#333>[</span>k<span style=color:#333>]</span> <span style=color:#333>=</span> aux<span style=color:#333>[</span>i<span style=color:#333>++];</span>     
        <span style=color:#333>}</span>
    <span style=color:#333>}</span>
</code></pre></div><h3 id=自顶向下的归并排序>自顶向下的归并排序</h3><h4 id=算法描述-3>算法描述</h4><p>对子数组a[lo..hi]进行排序，先将其分为$\mathrm{a}[\mathrm{lo..mid}]$和$\mathrm{a[mid+1..hi]}$两部分，分别通过递归调用将其单独排序，最后将有序的子数组归并为最终的排序结果。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Merge</span> <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> Comparable<span style=color:#333>[]</span> aux<span style=color:#333>;</span>
    
    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        aux <span style=color:#333>=</span> <span style=color:#080;font-weight:700>new</span> Comparable<span style=color:#333>[</span>a<span style=color:#333>.</span><span style=color:#00c>length</span><span style=color:#333>];</span>
        sort<span style=color:#333>(</span>a<span style=color:#333>,</span> 0<span style=color:#333>,</span> a<span style=color:#333>.</span><span style=color:#00c>length</span> <span style=color:#333>-</span> 1<span style=color:#333>);</span>
    <span style=color:#333>}</span>

    <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> lo<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> hi<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>hi <span style=color:#333>&lt;=</span> lo<span style=color:#333>)</span>   <span style=color:#080;font-weight:700>return</span><span style=color:#333>;</span>
        <span style=color:#339;font-weight:700>int</span> mid <span style=color:#333>=</span> lo <span style=color:#333>+</span> <span style=color:#333>(</span>hi <span style=color:#333>-</span> lo<span style=color:#333>)</span> <span style=color:#333>/</span> 2<span style=color:#333>;</span>
        sort <span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> mid<span style=color:#333>);</span>
        sort <span style=color:#333>(</span>a<span style=color:#333>,</span> mid <span style=color:#333>+</span> 1<span style=color:#333>,</span> hi<span style=color:#333>);</span>
        merge<span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> mid<span style=color:#333>,</span> hi<span style=color:#333>);</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=性能分析-3>性能分析</h4><p>对于长度为$N$的任意数组，自顶向下的归并排序需要$1/2N\lg N$至$N\lg N$次比较，最多需要访问数组$6N\lg N$次。</p><p>所以可知道归并排序所需要的时间与$N\lg N$成正比，主要缺点是辅助数组所使用的额外空间和N的大小成正比。</p><h3 id=自底向上的归并排序>自底向上的归并排序</h3><h4 id=算法描述-4>算法描述</h4><p>先归并那些微型数组，然后再成对地归并得到的子数组。首先进行两两归并（把每个元素当作一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并为一个有4个元素的数组），然后是八八归并，以此类推。</p><h4 id=代码实现-3>代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>MergeBU</span> <span style=color:#333>{</span>
	<span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> Comparable<span style=color:#333>[]</span> aux<span style=color:#333>;</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span> <span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#339;font-weight:700>int</span> N <span style=color:#333>=</span> a<span style=color:#333>.</span><span style=color:#00c>length</span><span style=color:#333>;</span>
        aux <span style=color:#333>=</span> <span style=color:#080;font-weight:700>new</span> Comparable<span style=color:#333>[</span>N<span style=color:#333>];</span>
        <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> sz <span style=color:#333>=</span> 1<span style=color:#333>;</span> sz <span style=color:#333>&lt;</span> N<span style=color:#333>;</span> sz <span style=color:#333>=</span> sz <span style=color:#333>+</span> sz<span style=color:#333>)</span>
        	<span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> lo <span style=color:#333>=</span> 0<span style=color:#333>;</span> lo <span style=color:#333>&lt;</span> N <span style=color:#333>-</span> sz<span style=color:#333>;</span> lo <span style=color:#333>+=</span> sz <span style=color:#333>+</span> sz<span style=color:#333>)</span>
        		merge<span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> lo <span style=color:#333>+</span> sz <span style=color:#333>-</span> 1<span style=color:#333>,</span> Math<span style=color:#333>.</span><span style=color:#00c>min</span><span style=color:#333>(</span>lo <span style=color:#333>+</span> sz <span style=color:#333>+</span> sz <span style=color:#333>-</span> 1<span style=color:#333>,</span> N <span style=color:#333>-</span> 1<span style=color:#333>));</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=性能分析-4>性能分析</h4><p>对于长度为$N$的任意数组，自底向上的归并排序需要$1/2N\lg N$至$N\lg N$次比较，最多访问数组$6N\lg N$次。</p><h2 id=快速排序>快速排序</h2><h3 id=快速排序的切分>快速排序的切分</h3><p>根据切分点<code>j</code>对数组进行切分，切分后的数组满足：</p><ul><li><code>a[lo]</code>到<code>a[j-1]</code>中的所有元素都不大于<code>a[j]</code></li><li><code>a[j+1]</code>到<code>a[hi]</code>中的所有元素都不小于<code>a[j]</code></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#888>//切分
</span><span style=color:#888></span><span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>partition</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> lo<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> hi<span style=color:#333>)</span>
<span style=color:#333>{</span>
    <span style=color:#339;font-weight:700>int</span> i <span style=color:#333>=</span> lo<span style=color:#333>,</span> j <span style=color:#333>=</span> hi <span style=color:#333>+</span> 1<span style=color:#333>;</span>
    Comparable v <span style=color:#333>=</span> a<span style=color:#333>[</span>lo<span style=color:#333>];</span>
    <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span><span style=color:#080;font-weight:700>true</span><span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>less<span style=color:#333>(</span>a<span style=color:#333>[++</span>i<span style=color:#333>],</span> v<span style=color:#333>))</span>
        <span style=color:#333>{</span>
            <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>i <span style=color:#333>==</span> hi<span style=color:#333>)</span>    <span style=color:#080;font-weight:700>break</span><span style=color:#333>;</span>
        <span style=color:#333>}</span>
        <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>less<span style=color:#333>(</span>v<span style=color:#333>,</span> a<span style=color:#333>[--</span>j<span style=color:#333>]))</span>
        <span style=color:#333>{</span>
            <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>j <span style=color:#333>==</span> lo<span style=color:#333>)</span>    <span style=color:#080;font-weight:700>break</span><span style=color:#333>;</span>
        <span style=color:#333>}</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>i <span style=color:#333>&gt;=</span> j<span style=color:#333>)</span>    <span style=color:#080;font-weight:700>break</span><span style=color:#333>;</span>
        exch<span style=color:#333>(</span>a<span style=color:#333>,</span> i<span style=color:#333>,</span> j<span style=color:#333>);</span>
    <span style=color:#333>}</span>
    exch<span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> j<span style=color:#333>);</span>

    <span style=color:#080;font-weight:700>return</span> j<span style=color:#333>;</span>
<span style=color:#333>}</span>
</code></pre></div><h3 id=基本快速排序算法>基本快速排序算法</h3><h4 id=算法描述-5>算法描述</h4><p>通过递归地调用切分来进行排序。</p><h4 id=代码实现-4>代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Quick</span> <span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        StdRandom<span style=color:#333>.</span><span style=color:#00c>shuffle</span><span style=color:#333>(</span>a<span style=color:#333>);</span>	<span style=color:#888>//将输入乱序，消除堆输入的依赖
</span><span style=color:#888></span>        sort<span style=color:#333>(</span>a<span style=color:#333>,</span> 0<span style=color:#333>,</span> a<span style=color:#333>.</span><span style=color:#00c>length</span> <span style=color:#333>-</span> 1<span style=color:#333>);</span>
    <span style=color:#333>}</span>

    <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span> <span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> lo<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> hi<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>hi <span style=color:#333>&lt;=</span> lo<span style=color:#333>)</span>   <span style=color:#080;font-weight:700>return</span><span style=color:#333>;</span>
        <span style=color:#339;font-weight:700>int</span> j <span style=color:#333>=</span> partition<span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> hi<span style=color:#333>);</span>
        sort<span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> j <span style=color:#333>-</span> 1<span style=color:#333>);</span>
        sort<span style=color:#333>(</span>a<span style=color:#333>,</span> j <span style=color:#333>+</span> 1<span style=color:#333>,</span> hi<span style=color:#333>);</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=性能分析-5>性能分析</h4><p>将长度为$N$的无重复数组排序，快速排序平均需要$2N\lg N$次比较，即$1/6N\lg N$次交换。</p><h3 id=三向切分快速排序>三向切分快速排序</h3><p>在含有大量重复元素时使用该方法。将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。</p><h4 id=代码实现-5>代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>Quick3way</span>
<span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> lo<span style=color:#333>,</span> <span style=color:#339;font-weight:700>int</span> hi<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>hi <span style=color:#333>&lt;=</span> lo<span style=color:#333>)</span>	<span style=color:#080;font-weight:700>return</span><span style=color:#333>;</span>
        <span style=color:#339;font-weight:700>int</span> lt <span style=color:#333>=</span> lo<span style=color:#333>,</span> i <span style=color:#333>=</span> lo <span style=color:#333>+</span> 1<span style=color:#333>;</span> gt <span style=color:#333>=</span> hi<span style=color:#333>;</span>
        Comparable v <span style=color:#333>=</span> a<span style=color:#333>[</span>lo<span style=color:#333>];</span>
        <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>i <span style=color:#333>&lt;=</span> gt<span style=color:#333>)</span>
        <span style=color:#333>{</span>
            <span style=color:#339;font-weight:700>int</span> cmp <span style=color:#333>=</span> a<span style=color:#333>[</span>i<span style=color:#333>].</span><span style=color:#00c>compareTo</span><span style=color:#333>(</span>v<span style=color:#333>);</span>
            <span style=color:#080;font-weight:700>if</span><span style=color:#333>(</span>cmp <span style=color:#333>&lt;</span> 0<span style=color:#333>)</span>	exch<span style=color:#333>(</span>a<span style=color:#333>,</span> lt<span style=color:#333>++,</span> i<span style=color:#333>++);</span>
            <span style=color:#080;font-weight:700>else</span> <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>cmp <span style=color:#333>&gt;</span> 0<span style=color:#333>)</span>	exch<span style=color:#333>(</span>a<span style=color:#333>,</span> i<span style=color:#333>,</span> gt<span style=color:#333>--);</span>
            <span style=color:#080;font-weight:700>else</span> i<span style=color:#333>++;</span>
        <span style=color:#333>}</span>
        sort<span style=color:#333>(</span>a<span style=color:#333>,</span> lo<span style=color:#333>,</span> lt <span style=color:#333>-</span> 1<span style=color:#333>);</span>
        sort<span style=color:#333>(</span>a<span style=color:#333>,</span> gt <span style=color:#333>+</span> 1<span style=color:#333>,</span> hi<span style=color:#333>);</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h2 id=优先队列>优先队列</h2><p>优先队列这种<em>数据结构</em>应支持两种操作：</p><ul><li>删除最大元素</li><li>插入元素</li></ul><h3 id=初级实现有序数组无序数组链表>初级实现：有序数组、无序数组、链表</h3><p>这些初级实现中，插入元素和删除最大元素的操作在最坏的情况下需要<strong>线性时间</strong>来完成，无法满足我们的性能要求。接下来使用<strong>堆</strong>来实现使这两种操作能更快地执行。</p><h3 id=基于堆的优先队列>基于堆的优先队列</h3><h4 id=堆的定义>堆的定义</h4><p>数据结构<strong>二叉堆</strong>满足：每个元素大于等于两个特定位置的元素，这些位置的元素又要大于等于数组中的另外两个元素，这样的数据结构可以通过有序的完全二叉树来表示。</p><p><img src=https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E6%9C%89%E5%BA%8F%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG alt></p><p>在一个堆中，位置$k$的节点的父节点的位置为$k/2$，而它的两个子节点的位置为$2k$和$2k+1$。</p><p>我们可以通过计算数组的索引在树中上下移动：从$a[k]$向上一层就令$k=k/2$，向下一层则令$k=2k/2k+1$。</p><h4 id=堆的算法>堆的算法</h4><p><strong>由下至上的堆有序化（上浮swim）</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>private</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>swim</span><span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> k<span style=color:#333>)</span>
<span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>k <span style=color:#333>&gt;</span> 1 <span style=color:#333>&amp;&amp;</span> less<span style=color:#333>(</span>k<span style=color:#333>/</span>2<span style=color:#333>,</span> k<span style=color:#333>))</span>
    <span style=color:#333>{</span>
        exch<span style=color:#333>(</span>k<span style=color:#333>/</span>2<span style=color:#333>,</span> k<span style=color:#333>);</span>
        k <span style=color:#333>=</span> k<span style=color:#333>/</span>2<span style=color:#333>;</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><p><strong>由上至下的堆有序化（下沉sink）</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>private</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sink</span><span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> k<span style=color:#333>)</span>
<span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>2<span style=color:#333>*</span>k <span style=color:#333>&lt;=</span> N<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        <span style=color:#339;font-weight:700>int</span> j <span style=color:#333>=</span> 2<span style=color:#333>*</span>k<span style=color:#333>;</span>
        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(</span>j <span style=color:#333>&lt;</span> N <span style=color:#333>&amp;&amp;</span> less<span style=color:#333>(</span>j<span style=color:#333>,</span> j<span style=color:#333>+</span>1<span style=color:#333>))</span>	j<span style=color:#333>++;</span>	<span style=color:#888>//选择父节点的两个子节点中较大的作为交换对象
</span><span style=color:#888></span>        <span style=color:#080;font-weight:700>if</span> <span style=color:#333>(!</span>less<span style=color:#333>(</span>k<span style=color:#333>,</span> j<span style=color:#333>))</span>	<span style=color:#080;font-weight:700>break</span><span style=color:#333>;</span>
        exch<span style=color:#333>(</span>k<span style=color:#333>,</span> j<span style=color:#333>);</span>
        k <span style=color:#333>=</span> j<span style=color:#333>;</span>	<span style=color:#888>//将交换后子节点的位置作为父节点，循环进行下一次交换,继续下沉
</span><span style=color:#888></span>    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=基于堆的优先队列的代码实现>基于堆的优先队列的代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>MaxPQ</span><span style=color:#333>&lt;</span>Key <span style=color:#080;font-weight:700>extends</span> Comparable<span style=color:#333>&lt;</span>key<span style=color:#333>&gt;&gt;</span>
<span style=color:#333>{</span>
    <span style=color:#080;font-weight:700>private</span> Key<span style=color:#333>[]</span> pq<span style=color:#333>;</span>
    <span style=color:#080;font-weight:700>private</span> <span style=color:#339;font-weight:700>int</span> N <span style=color:#333>=</span> 0<span style=color:#333>;</span>
    
    <span style=color:#080;font-weight:700>public</span> <span style=color:#06b;font-weight:700>MaxPQ</span><span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> maxN<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        pq <span style=color:#333>=</span> <span style=color:#333>(</span>Key<span style=color:#333>[])</span> <span style=color:#080;font-weight:700>new</span> Comparable<span style=color:#333>[</span>maxN <span style=color:#333>+</span> 1<span style=color:#333>];</span>
    <span style=color:#333>}</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>boolean</span> <span style=color:#06b;font-weight:700>isEmpty</span><span style=color:#333>()</span>
    <span style=color:#333>{</span>
        <span style=color:#080;font-weight:700>return</span> N <span style=color:#333>==</span> 0<span style=color:#333>;</span>
    <span style=color:#333>}</span>
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>size</span><span style=color:#333>()</span>
    <span style=color:#333>{</span>
        <span style=color:#080;font-weight:700>return</span> N<span style=color:#333>;</span>
    <span style=color:#333>}</span>
    
    <span style=color:#080;font-weight:700>public</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>insert</span><span style=color:#333>(</span>Key v<span style=color:#333>)</span>	<span style=color:#888>//在数组的末尾输入，然后进行上浮swim操作
</span><span style=color:#888></span>    <span style=color:#333>{</span>
        pq<span style=color:#333>[++</span>N<span style=color:#333>]</span> <span style=color:#333>=</span> v<span style=color:#333>;</span>
        swim<span style=color:#333>(</span>N<span style=color:#333>)</span>
    <span style=color:#333>};</span>
    
    <span style=color:#080;font-weight:700>public</span> Key <span style=color:#06b;font-weight:700>delMax</span><span style=color:#333>()</span>
    <span style=color:#333>{</span>
        Key max <span style=color:#333>=</span> pq<span style=color:#333>[</span>1<span style=color:#333>];</span>
        exch<span style=color:#333>(</span>1<span style=color:#333>,</span> N<span style=color:#333>--);</span>
        pq<span style=color:#333>[</span>N<span style=color:#333>++]</span> <span style=color:#333>=</span> <span style=color:#080;font-weight:700>null</span><span style=color:#333>;</span>
        sink<span style=color:#333>(</span>1<span style=color:#333>);</span>
        <span style=color:#080;font-weight:700>return</span> max<span style=color:#333>;</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=基于堆的优先队列性能分析>基于堆的优先队列性能分析</h4><p><img src=https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.PNG alt></p><h3 id=堆排序>堆排序</h3><h4 id=堆的构造>堆的构造</h4><p>高效的构造堆的方法是从右向左用<code>sink()</code>函数构造子堆。数组的每个位置都是一个子堆的根结点，如果一个结点的两个子结点都已经是堆了，那么在该结点上调用<code>sink()</code>可以将它们变成一个堆。我们只需要扫描一半的元素，因为可以跳过大小为1的子堆。</p><p><img src=https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E5%A0%86%E7%9A%84%E6%9E%84%E9%80%A0.png alt></p><h4 id=下沉排序>下沉排序</h4><p>将堆中的最大元素删去，然后将其放入堆缩小后数组中空出的位置。</p><h4 id=堆排序代码实现>堆排序代码实现</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#339;font-weight:700>void</span> <span style=color:#06b;font-weight:700>sort</span><span style=color:#333>(</span>Comparable<span style=color:#333>[]</span> a<span style=color:#333>)</span>
<span style=color:#333>{</span>
    <span style=color:#339;font-weight:700>int</span> N <span style=color:#333>=</span> a<span style=color:#333>.</span><span style=color:#00c>length</span><span style=color:#333>;</span>
    <span style=color:#080;font-weight:700>for</span> <span style=color:#333>(</span><span style=color:#339;font-weight:700>int</span> k <span style=color:#333>=</span> N<span style=color:#333>/</span>2<span style=color:#333>;</span> k <span style=color:#333>&gt;=</span> 1<span style=color:#333>;</span> k<span style=color:#333>--)</span>	<span style=color:#888>//构造堆
</span><span style=color:#888></span>        sink<span style=color:#333>(</span>a<span style=color:#333>,</span> k<span style=color:#333>,</span> N<span style=color:#333>);</span>
    <span style=color:#080;font-weight:700>while</span> <span style=color:#333>(</span>N <span style=color:#333>&gt;</span> 1<span style=color:#333>)</span>
    <span style=color:#333>{</span>
        exch<span style=color:#333>(</span>a<span style=color:#333>,</span> 1<span style=color:#333>,</span> N<span style=color:#333>--);</span>	<span style=color:#888>//堆排序，按递减顺序循环取出所有的最大值，最后得到排序结果。
</span><span style=color:#888></span>        sink<span style=color:#333>(</span>a<span style=color:#333>,</span> 1<span style=color:#333>,</span> N<span style=color:#333>);</span>
    <span style=color:#333>}</span>
<span style=color:#333>}</span>
</code></pre></div><h4 id=堆排序性能分析>堆排序性能分析</h4><p>将$N$个元素排序，堆排序只需要少于$(2N\lg N+2N)$次比较以及一半的交换次数。</p><hr width=100% id=EOF><p style=color:#777>最后修改于 2020-07-23</p></div></div><nav class=post-pagination><a class=newer-posts href=https://eternityqjl.github.io/blog2_public/posts/%E4%B8%B2%E5%8F%A3/>下回<br>串行通信协议详解：SPI、I2C、UART、JTAG</a>
<a class=older-posts href=https://eternityqjl.github.io/blog2_public/posts/dijkstra%E5%8F%8C%E6%A0%88%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/>上回<br>Dijkstra双栈——算术表达式求值</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2019-2021 By Jialong</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:!1,mounted:!1,isDarkMode:!1},methods:{sgn(a,b){let c=1/(1-2*a);return b<=a?0:b>=1-a?1:c*(b-a)},handleScroll(){this.scrollY=window.scrollY,this.navOpacity=this.sgn(0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*.8))));const{navBar:c,navBackground:a,navTitle:b,extraContainer:d,streamContainer:e}=this.$refs;this.navOpacity>=1?(a.style.opacity=1,b.style.opacity=1):(a.style.opacity=0,b.style.opacity=0)},handleResize(){const{navBar:c,navBackground:d,navTitle:e,extraContainer:a,streamContainer:b}=this.$refs;a.style.left=b.offsetWidth-a.offsetWidth+'px'},navBarHeight(){return this.$refs.navBar.offsetHeight},pageHeadHeight(){return this.$refs.pageHead.offsetHeight},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},closeDrawer(){this.isDrawerOpen=!1,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},toggleDarkMode(){this.isDarkMode=!this.isDarkMode,this.isDarkMode==!0?(document.cookie="night=1;path=/",document.body.classList.add("night")):(document.cookie="night=0;path=/",document.body.classList.remove("night"))},debounce(t,b,f){let e,g,l,d,a,c,i=0,q=!1,h=!1,n=!0;const s=!b&&b!==0&&typeof root.requestAnimationFrame=='function';if(typeof t!='function')throw new TypeError('Expected a function');function w(a){const b=typeof a;return a!=null&&(b==='object'||b==='function')}b=+b||0,w(f)&&(q=!!f.leading,h='maxWait'in f,l=h?Math.max(+f.maxWait||0,b):l,n='trailing'in f?!!f.trailing:n);function o(a){const b=e,c=g;return e=g=void 0,i=a,d=t.apply(c,b),d}function k(b,c){return s?(root.cancelAnimationFrame(a),root.requestAnimationFrame(b)):setTimeout(b,c)}function v(a){if(s)return root.cancelAnimationFrame(a);clearTimeout(a)}function A(c){return i=c,a=k(m,b),q?o(c):d}function u(a){const e=a-c,f=a-i,d=b-e;return h?Math.min(d,l-f):d}function r(a){const d=a-c,e=a-i;return c===void 0||d>=b||d<0||h&&e>=l}function m(){const b=Date.now();if(r(b))return p(b);a=k(m,u(b))}function p(b){return a=void 0,n&&e?o(b):(e=g=void 0,d)}function x(){a!==void 0&&v(a),i=0,e=c=g=a=void 0}function y(){return a===void 0?d:p(Date.now())}function z(){return a!==void 0}function j(...i){const f=Date.now(),j=r(f);if(e=i,g=this,c=f,j){if(a===void 0)return A(c);if(h)return a=k(m,b),o(c)}return a===void 0&&(a=k(m,b)),d}return j.cancel=x,j.flush=y,j.pending=z,j}},created(){window.addEventListener('scroll',this.handleScroll),window.addEventListener('resize',this.handleResize),window._nonDesktop=function(){let a=!1;return function(b){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(b)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(b.substr(0,4)))&&(a=!0)}(navigator.userAgent||navigator.vendor||window.opera),a};var a=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");a==""?window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches:a=="1"&&this.toggleDarkMode()},mounted(){this.handleScroll(),this.handleResize(),this.mounted=!0,document.querySelectorAll("table").forEach(function(a){a.classList.add("table-striped"),a.classList.add("table"),a.classList.add("table-responsive"),a.classList.add("table-hover")}),spy(),window.addEventListener('scroll',this.debounce(spy,250,{maxWait:250}),!1)},destroyed(){window.removeEventListener('scroll',this.handleScroll),window.removeEventListener('resize',this.handleResize)}})</script></body></html>