<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>异常控制流 on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
    <description>Recent content in 异常控制流 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 11 Jan 2022 15:33:44 +0800</lastBuildDate><atom:link href="https://eternityqjl.top/tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Csapp 8 异常控制流</title>
      <link>https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Tue, 11 Jan 2022 15:33:44 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>系统要对系统状态的变化作出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。
现代系统通过使用控制流发生突变来对这些情况作出反应，一般把这些突变称为异常控制流ECF。ECF发生在计算机系统的各个层次。例如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。
理解ECP有很多用处：
 帮助理解重要的系统概念。 理解应用程序如何与操作系统交互。应用程序通过使用称为陷阱或系统调用的ECF形式，向操作系统请求服务。例如，向磁盘写数据、从网络读取数据、创建一个新进程，都是通过应用程序调用系统调用实现的。 帮助理解并发。ECF是计算机系统中实现并发的基本机制。 帮助理解软件异常如何工作。例如C++使用try、catch以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。  异常 异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。
异常就是控制流中的突变，用来响应处理器状态中的某些变化。
事件（event）：状态的变化。事件可能和当前指令的执行直接相关，比如发生虚拟内存缺页、算术溢出等。
处理器检测到有事件发生时，就通过异常表的跳转表，进行一个间接过程调用，到一个异常处理程序进行处理。处理完后，根据引起异常的事件类型，会发生以下三种情况的一种：
 处理程序将控制返回给当前指令 处理程序将控制返回给下一条指令 处理程序终止被中断的程序  异常处理 系统中可能为每种类型的异常都分配一个唯一的非负整数的异常号。其中一些号码由处理器设计者提供，另一些由操作系统内核的设计者分配。前者的例子包括：缺页、内存访问违规、被零除及算术运算溢出。后者的例子包括：系统调用和来自外部I/O设备的信号。
系统启动时，操作系统分配和初始化一张称为异常表的跳转表。使得表目k包含异常k的处理程序的地址。
运行时（系统执行某个程序）处理器检测到发生了一个事件，并确定了响应的异常号k。随后处理器触发异常，执行间接调用过程，通过异常表的表目k，转到相应的处理程序。
异常号是到异常表中的索引，异常表的起始地址放在叫做异常表基址寄存器的特殊CPU寄存器中。
异常与过程调用的区别：
 返回地址不同：过程调用时，跳转到处理程序之前，处理器将返回地址压入栈中。而根据异常的类型，返回地址要么是当前指令，要么是下一条指令。 异常处理中处理器也把一些额外的处理器状态压入栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。 如果控制从用户程序转移到内核，所有这些项目都被压入内核栈中，而不是压到用户栈中。 异常处理程序运行在内核模式下，这意味着其对所有系统资源都有完全的访问权限。  一旦硬件触发了异常，剩下的工作就由异常处理程序在软件中完成。处理完事件后，通过执行一条特殊的从中断返回指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中。如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将控制返回给被中断的程序。
异常的类别 异常分为中断、陷阱、故障、终止。
中断
中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，因此它是异步的。硬件中观的异常处理程序常称为中断处理程序。
当前只能怪执行完后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，就将控制返回给下一条指令。结果是程序继续运行，就好像没有发生过中断一样。
剩下的异常类型是同步发生的，是执行当前指令的结果，把这类指令称为故障指令。
陷阱和系统调用
陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，称为系统调用。
用户经常要向内核请求服务，比如读一个文件（read）、创建一个新进程（fork）、加载一个新程序（execve），或终止当前程序（exit）。为了允许对这些内核服务的受控访问，处理器提供了一条特殊的syscall n的指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个程序解析参数，并调用适当的内核程序。
故障
故障是由错误引起的，他可能被故障处理程序修正。故障发生时，处理器将控制转移给故障处理程序。如果故障处理程序能够修正这个错误，他就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，该例程会终止引起故障的应用程序。
一个经典的故障示例是缺页异常。
终止
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，例如DRAM或SRAM位被损坏时发生的奇偶错误。
Linux/x86-64中的异常 x86-64有256种不同类型的异常，0~31号对应的由Intel架构师定义的异常，对任何x86-64系统都是一样的。32~255号对应的是操作系统定义的中断和陷阱。
Linux/x86-64故障和终止
 除法错误（异常0）：Unix不会试图从除法错误中恢复，而是选择终止程序。 一般保护故障（异常13）：通常因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这些故障。 缺页（异常14）：会重新执行产生故障的指令的一个示例。 机器检查（异常18）：在导致故障的指令执行中检测到致命的硬件错误时发生的。  Linux/x86-64系统调用
Linux提供几百种系统调用，以下为一些常见的系统调用：
每个系统调用都有唯一的整数号，对应于一个到内核中跳转表的偏移量。
C程序用syscall函数可以直接调用任何系统调用。而实际中没必要这样做，对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用函数。
处理器ISA规范通常会区分异步中断和同步异常，但并不提供表述这些非常相似的概念的概括性的术语。为了避免混乱，我们使用异常作为通用术语，只要在必要时才区分异步异常（中断）和同步异常（陷阱、故障和终止）。
进程 进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。
进程提供给应用程序的关键抽象：
 一个独立的逻辑控制流：提供我们的程序独占地使用处理器的假象 一个私有的地址空间：提供我们的程序独占地使用内存系统的假象  逻辑控制流 进程为每个程序提供了一种假象，好像程序在独占地使用处理器。</description>
    </item>
    
  </channel>
</rss>
