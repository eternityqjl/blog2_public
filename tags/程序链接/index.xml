<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序链接 on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/tags/%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5/</link>
    <description>Recent content in 程序链接 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sat, 11 Dec 2021 21:38:11 +0800</lastBuildDate><atom:link href="https://eternityqjl.top/tags/%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Csapp：7.链接</title>
      <link>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 11 Dec 2021 21:38:11 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</guid>
      <description>编译器驱动程序 编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。
main.c$\rightarrow$main.i$\rightarrow$main.s$\rightarrow$main.o$\rightarrow$prog
源程序$\rightarrow$中间文件$\rightarrow$汇编语言文件$\rightarrow$可重定位目标文件$\rightarrow$可执行目标文件
依次使用了：预处理器、编译器、汇编器 、链接器
shell执行可执行文件时调用操作系统中的加载器函数，将prog中的代码和数据复制到内存中，然后将控制转移到这个程序的开头。
静态链接 静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。
为了构造可执行文件，链接器必须完成连个任务：
 符号解析：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。将每个符号引用正好和一个符号定义关联起来。（每个符号对应于一个函数、一个全局变量或一个静态变量） 重定位。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使它们指向这个内存位置。  目标文件 共有三种：
 可重定位目标文件：二进制代码和数据，可在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 可执行目标文件：二进制代码和数据，其形式可以直接被复制到内存中并执行。 共享目标文件：特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。  目标文件是按照特定目标文件格式来组织的，各个系统的目标文件格式都不相同。
可重定位目标文件 一个典型的ELF可重定位目标文件：
首先是16B的ELF头，描述了生成该文件的系统的字的大小和字节顺序。
然后是节：一个典型的ELF可重定位目标文件包含以下几个节：
 .text：已编译程序的机器代码 .rodata：只读数据 .data：已初始化的全局和静态C变量 .bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量 .symtab：一个符号表，存放在程序中定义和引用的函数和全局变量的信息 .debug：调试符号表  符号和符号表 每个可重定位目标模块都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文，有三种不同符号：
 由模块m定义并能被其他模块引用的全局符号：对应非静态的C函数和全局变量。 由其他模块定义并被m引用的全局符号，称为外部符号：对应其他模块中定义的非静态的C函数和全局变量 只被模块m定义和引用的局部符号：对应于带static属性的C函数和全局变量。  本地非静态程序变量的符号在运行时在栈中被管理，不在符号表.symtab中。
C中源文件扮演模块的角色，static属性就像C++使用的public和private一样。
尽可能用static属性来保护变量和函数。
符号解析 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。
对于引用和定义在相同模块中的局部符号（即对应static变量）的引用，符号解析非常简洁明了。编译器只允许每个局部符号有一个定义。
对于全局符号的引用较为复杂，当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表，交给链接器处理。如果链接器在其他任何模块中都找不到这个被引用的符号，就输出一条错误信息并终止。
 编译器通过重整的编码方式来区分重载的函数
 链接器解析多重定义的全局符号 编译器向汇编器输出每个全局符号，或是强或是弱的，而汇编器把这些信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。
Linux使用以下规则处理多重定义的符号名：
 不允许由多个同名强符号 如果一个强符号和多个弱符号同名，选择强符号 如果有多个弱符号同名，从这些弱符号中任意选一个  与静态库链接 所有编译器都有一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，它可以用作链接器的输入。链接器构造一个输出的可执行文件时，只复制静态库里被应用程序引用的目标模块。
Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小，存档文件名由后缀.a标识。
链接器如何使用静态库来解析引用 链接器从左到右按照在命令行上出现的顺序来扫描可重定位目标文件和存档文件。（编译器驱动程序自动将.c文件翻译为.0文件。在扫描中，链接器维护一个可重定位目标文件的集合E，一个未解析的符号集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U、D均为空。
 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果时目标文件则将其添加到E中，修改U和D来反映f中的符号引用和定义 如果f是存档文件，链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m定义了一个符号来解析U中的一个引用，那么就把m加到E中，并修改U和D来反映m中的符号定义和引用。对存档文件依次重复这个过程直到U和D不发生变化。 如果链接器完成对命令行输入文件的扫描后，U是非空的，则链接器输出错误并终止。否则，合并然后重定位E中的文件，构建可执行文件。  重定位 链接器完成符号解析这一步后，就把代码中的每个符号引用和一个符号定义关联起来，此时链接器就知道它的输入目标模块中的代码和数据节的确切大小。然后就可以开始重定位步骤了，该步骤将合并输入模块，并为每个符号分配运行时地址。共分为两步：</description>
    </item>
    
  </channel>
</rss>
