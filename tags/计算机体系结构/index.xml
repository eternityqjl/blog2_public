<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机体系结构 on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 计算机体系结构 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 04 Jan 2022 14:59:16 +0800</lastBuildDate><atom:link href="https://eternityqjl.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Csapp：9.虚拟内存</title>
      <link>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 04 Jan 2022 14:59:16 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>物理和虚拟寻址 物理地址PA、虚拟地址VA、内存管理单元MMU（利用存放在主存中的查询表来动态地翻译虚拟地址，该表的内容由操作系统管理）。
地址空间 非负整数地址的有序集合。
目前x86使用39位物理地址空间、49位虚拟地址空间。
虚拟内存作为缓存的工具 VM系统通过将虚拟内存分割为大小为$P=2^p$字节的虚拟页来处理，同样地，物理内存也被分割为大小为P的物理页（页帧）。
任意时刻，虚拟页面的集合都分为三个不相交的子集：
 未分配的 缓存的 未缓存的  DRAM缓存的组织结构 使用术语SRAM缓存来表示位于CPU和主存之间的L1、L2和L3高速缓存；用术语DRAM缓存表示虚拟内存系统的缓存，它在主存中缓存虚拟页。
在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。DRAM比SRAM慢大约10倍，磁盘比DRAM慢大约100000倍。DRAM缓存的不命中（缺页）比SRAM缓存的不命中要昂贵的多。
与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。
页表 虚拟内存系统必须有方法判断一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。
页表就是一个页表条目（PET）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE由一个有效位和一个n位地址字段组成的。有效位表明该虚拟页当前是否被缓存在DRAM中。
页命中 缺页 分配页面 虚拟内存作为内存管理的工具 虚拟内存大大简化了内存管理，并提供了一种自然的保护内存的方法。
操作系统实际上为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。
多个虚拟页面可以映射到同一个共享的物理页面上。
VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。
简化链接 独立的地址空间允许每个进程的内存映射使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。
一个给定的Linux系统上的每个进程都使用类似的内存格式。对于64位地址空间，代码段总是从虚拟地址0x400000开始。数据段跟在代码段后，中间有一段符号要求的对齐空白。栈占用用户地址空间最高的部分，并向下生长。
这样的一致性简化了链接器的设计和实现。允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。
简化加载 虚拟内存使得很容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器位代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。在每个页被初次引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。
将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。详见后面小节。
简化共享 一般情况下，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程进行共享的。但在另一些情况下，需要进程来共享数据和代码。例如，每个进程必须调用相同的操作系统内核代码，操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本。
简化内存分配 虚拟内存为用户进程提供了一个简单的分配额外内存的机制。当一个运行在用户进程的程序要求额外的堆空间时（调用malloc），操作系统分配一个适当数字大小的连续的虚拟内存页面，并将其映射到物理内存中任意位置的k个任意的物理页面。
虚拟内存作为内存管理的工具 提供独立的地址空间使得区分不同进程的私有内存变得容易。但时地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每个CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE上添加一些额外的许可位开控制对一个虚拟页面内容的访问十分简单。
例如：
每个PTE添加了三个许可位：
 SUP位：进程是否必须运行在内核（超级用户）模式下才能访问该页 READ位和WRITE位控制对页面的读和写访问  如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。
地址翻译 页面命中时CPU硬件执行的步骤：
 处理器生成一个虚拟地址，将其传送给MMU MMU生成PTE（Page Table Entry）地址，并从高速缓存/主存请求得到它 高速缓存/主存向MMU返回PTE MMU构造物理地址，并把它传送给高速缓存/主存 高速缓存/主存返回所请求的数据字给处理器  页面命中完全由硬件来处理，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。步骤如下：
 第1-3步：与页面命中时的前三步相同 PTE中的有效位为0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 缺页处理程序确定出物理内存中的牺牲页，如果该页面已经被修改，则把它换出到磁盘。 缺页处理程序页面调入新的页面，并更新内存中的PTE。 缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。虚拟页面现在缓存在物理内存中，所以就会命中。  结合高速缓存和虚拟内存 在任何既使用高速缓存SRAM又使用虚拟内存的系统中，一般使用物理内存来访问高速缓存。
使用物理内存，多个进程同时在高速缓存中由存储块和共享来自相同虚拟页面的块非常简单。并且高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</description>
    </item>
    
    <item>
      <title>Csapp：7.链接</title>
      <link>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 11 Dec 2021 21:38:11 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</guid>
      <description>链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载到内存并执行。
链接可以执行于编译时、加载时、运行时。
链接使得分离编译成为可能。可以将巨大的源文件分解为更小的模块，可以独立地修改和编译这些模块。当我们改变其中的一个模块时，只需简单地将其重新编译并链接，无需重新编译其他文件。
理解链接器的作用：
 帮助构造大型程序 避免一些危险的编程错误。例如错误地定义多个全局变量的程序将通过链接器，不产生任何警告。 理解语言的作用域规则。如：全局和局部变量的区别；static属性的变量和函数的意义。 帮助理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色。 帮助我们利用共享库。  编译器驱动程序 编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。例如我们经常使用的gcc驱动程序。
main.c$\rightarrow$main.i$\rightarrow$main.s$\rightarrow$main.o$\rightarrow$prog
源程序$\rightarrow$中间文件$\rightarrow$汇编语言文件$\rightarrow$可重定位目标文件$\rightarrow$可执行目标文件
依次使用了：预处理器、编译器、汇编器 、链接器
shell执行可执行文件时调用操作系统中的加载器函数，将prog中的代码和数据复制到内存中，然后将控制转移到这个程序的开头。
linux&amp;gt; ./prog 静态链接 可重定位目标文件由不同的代码和数据节组成，每一节都是一个连续的字节序列。
静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。
为了构造可执行文件，链接器必须完成连个任务：
 符号解析：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。将每个符号引用正好和一个符号定义关联起来。（每个符号对应于一个函数、一个全局变量或一个静态变量） 重定位。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使它们指向这个内存位置。  目标文件 共有三种：
 可重定位目标文件：二进制代码和数据，可在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 可执行目标文件：二进制代码和数据，其形式可以直接被复制到内存中并执行。 共享目标文件：特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。  目标文件是按照特定目标文件格式来组织的，各个系统的目标文件格式都不相同。
可重定位目标文件 一个典型的ELF可重定位目标文件：
首先是16B的ELF头，描述了生成该文件的系统的字的大小和字节顺序。
然后是节：一个典型的ELF可重定位目标文件包含以下几个节：
 .text：已编译程序的机器代码 .rodata：只读数据 .data：已初始化的全局和静态C变量 .bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量 .symtab：一个符号表，存放在程序中定义和引用的函数和全局变量的信息 .rel.text .rel.data .debug：调试符号表，以-g选项调用编译器驱动程序时才会得到这张表。 .line：原始C程序的行号和.text节中的机器指令之间的映射，以-g选项调用编译器驱动程序时才会得到这张表。 .strtab：一个字符串表，其中内容包括.symtab和.debug节中的符号表，以及节头部中的节名称。  符号和符号表 每个可重定位目标模块都有一个符号表.symtab，它包含m定义和引用的符号的信息。在链接器的上下文，有三种不同符号：
 由模块m定义并能被其他模块引用的全局符号：对应非静态的C函数和全局变量。 由其他模块定义并被m引用的全局符号，称为外部符号：对应其他模块中定义的非静态的C函数和全局变量 只被模块m定义和引用的局部符号：对应于带static属性的C函数和全局变量。  本地非静态程序变量的符号在运行时在栈中被管理，不在符号表.symtab中。
C中源文件扮演模块的角色，static属性就像C++使用的public和private一样。
尽可能用static属性来保护变量和函数。
符号表由汇编器构造，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。以下为符号表中每个符号条目的格式：
typedef struct { int name; char type:4, binding:4; char reserved; short section; long value; long size; } Elf64_Symbol; name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符号的地址。对于可重定位目标文件来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时的地址。size是目标的大小。type通常代表数据或函数。符号表还可以包含各个节的条目。binging字段表示符号是本地还是全局。</description>
    </item>
    
    <item>
      <title>csapp: 3.程序的机器级表示</title>
      <link>https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Mon, 09 Aug 2021 16:08:05 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid>
      <description>第三章 程序的机器级表示 历史观点 典型的编译器在将C程序结构变换成机器代码时所做的转换。
英特尔X86-64处理器的发展历史。
从8086到Core i7
程序编码 机器级代码 对于机器级编程来说，两种抽象非常重要：
 由指令集体系结构或**指令集架构(ISA, Instruction Set Architecture)**来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，以及每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址。  x86-64机器码中，一些通常对C语言隐藏的处理器状态都是可见的：
 程序计数器(PC，在x86-64中用%rip表示)：给出将要执行的下一条指令在内存中的地址 整数寄存器文件：包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址(对应C语言指针)或整数数据。 条件码寄存器：保存最近执行的算数或逻辑指令的状态信息，用来实现控制或数据流中的条件变化。  x86-64的虚拟地址由64位的字表示，但目前这些地址的高16位必须设为零，相当于可以表示$2^{48}$或256TB内存范围内的一个字节。及目前的64位计算机只使用48位来表示地址范围。
代码示例 机器对产生这些汇编语言指令的源代码几乎一无所知，全都是字节序列。
生成可执行的代码需要对一组目标代码文件运行链接器，这组目标代码文件中必须含有一个main函数。
链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。
反汇编器
关于格式的注解 ATT与Intel汇编代码格式的区别
 Intel代码省略了指示大小的后缀。例如看到的指令为push和mov而不是pushq和movq。 Intel代码胜率了寄存器名字前的%符号。 Intel代码  数据格式 Intel用字(word)表示16位数据类型，因此称32位数为双字，称64位数位四字。
下表给出了C语言基本数据类型对应的x86-64表示：
   C声明 Intel数据类型 汇编代码后缀 大小(字节)     char 字节 b 1   short 字 w 2   int 双字 l 4   long 四字 q 8   char* 四字 q 8   float 单精度 s 4   double 双精度 l 8    大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)、movq(传送四字)。</description>
    </item>
    
    <item>
      <title>csapp: 2.信息的表示和处理（部分完成）</title>
      <link>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 12 Jul 2021 21:26:27 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
      <description>第一部分内容：程序结构和执行
我们需要用方法表示基本数据类型，然后考虑机器级指令如何操作这样的数据，以及编译器如何将C程序翻译成这样的指令。接下来研究集中处理器的方法，使得我们能够更好地了解硬件资源如何被用来执行指令。
信息存储 十六进制表示法及转换 二进制和十进制对描述位模式来说都不方便，因此采用16进制数(hex)来表示位模式。
C语言中16进制数以0X或0x开头，字符‘A’~‘F’既可以是大写也可以是小写。
二进制和十六进制之间的转换较为简单，不再赘述。
十进制和十六进制数之间的转换要反复利用乘法和除法进行处理：
 从十进制到十六进制：反复用16除十进制数 从十六进制到十进制：用相应的16的幂乘以每个十六进制数。  字数据大小 字长指明指针数据的标称大小。虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。
对一个字长为w的机器而言，虚拟地址的范围是$0$ ~$2^w-1$，程序最多访问$2^w-1$个字节。
近年，很多机器都从32位字长迁移到了64位字长。大多64位字长机器可以运行32位字长机器编译的程序。32位程序和64位程序的区别在于程序是如何编译成的，而不是运行的机器类型。
寻址和字节顺序 小端法、大端法
对于跨越多个字节的程序对象，我们必须明确：
 这个对象的地址是什么 如何在内存中排列这些字节  一般来说，多字节对象被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
  小端法：将最低有效字节放在最前面(最小地址)存储。（例如一个二进制数最右边的8位是最低有效字节）
  大端法：将最高有效字节放在最前面(最小地址)存储。
  大多Intel兼容机使用小端模式。
以下代码使用强制类型转换来访问和打印不同程序对象的字节表示。
#include &amp;lt;stdio.h&amp;gt; typedef unsigned char *byte_pointer;	//将byte_pointer定义为一个指向类型为unsigned char对象的指针 //指针被强制类型转换为unsigned char *, 这告诉编译器程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。  void show_bytes(byte_pointer start, size_t len) {//按顺序显示出指针指向对象的每个字节内容，可以判断出系统使用的小端法还是大端法 	size_t i; for (i = 0; i &amp;lt; len; i++) printf(&amp;#34;%.2x&amp;#34;, start[i]); printf(&amp;#34;\n&amp;#34;); } //使用sizeof确定对象使用的字节数 void show_int(int x) {//显示int对象的字节内容 	show_bytes((byte_pointer) &amp;amp;x, sizeof(int)); } void show_float(float x) {//显示float对象的字节内容 	show_bytes((byte_pointer) &amp;amp;x, sizeof(float)); } void show_pointer(void *x) {//显示void *对象的字节内容 	show_bytes((byte_pointer) &amp;amp;x, sizeof(void *)); } 表示字符串 对文本进行编码。</description>
    </item>
    
    <item>
      <title>csapp: 1.计算机系统漫游</title>
      <link>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link>
      <pubDate>Fri, 11 Jun 2021 12:18:22 +0000</pubDate>
      
      <guid>https://eternityqjl.top/posts/csapp-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid>
      <description>在本书中我们将会学习到一些使用技巧，比如如何避免由于计算机表示数字的方式引起的错误；通过一些技巧优化C代码，以充分利用现代处理器和存储器系统的设计；了解编译器如何实现过程调用，利用这些知识避免缓冲区溢出错误带来的安全漏洞；学习如何识别和避免链接时的错误；如何编写Unix Shell、动态存储分配包、Web服务器；并发带来的希望和陷阱，对于现在的单芯片集成多个处理器核心非常重要。
我们通过围绕Hello程序执行时的整个生命周期来对系统进行学习：
#include &amp;lt;stdio.h&amp;gt;int main() { printf(&amp;#34;Hello, world\n&amp;#34;); return 0; } 信息就是位+上下文 8位为一个字节。
现代计算机系统使用ASCII标准来表示文本字符。即用一个单字节大小的整数值表示一个符号。
数字的机器表示是对真值的有限近似。
程序被翻译为不同的格式 hello.c中的每条C语句都会转换为一系列低级机器语言指令。这些指令按照可执行目标程序格式打包，以二进制磁盘文件的形式存放。
编译系统：
hello.c(源程序，文本) -&amp;gt; 预处理器(cpp) -&amp;gt; hello.i(修改了的源程序，文本) -&amp;gt; 编译器(ccl) -&amp;gt; hello.s(汇编程序，文本) -&amp;gt; 汇编器 -&amp;gt; hello.o(可重定位目标程序，二进制) -&amp;gt; 链接器 -&amp;gt; hello(可执行目标程序，二进制)
 预处理阶段：预处理器(cpp)根据以字符#开头的命令，修改原始C程序。例如#include &amp;lt;stdio.h&amp;gt;告诉预处理器读取系统头文件的内容，将其插入程序文本中，得到另一个C程序，以.i为扩展名。 编译阶段：编译器(ccl将hello.i翻译为hello.s，其包含了汇编语言程序。 汇编阶段：汇编器(as)将hello.s翻译为机器语言指令，将这些指令打包为可重定位目标程序，将结果保存在hello.o中，该文件为二进制文件。 链接阶段：hello程序调用了printf函数，它是C编译器提供的标准C库中的一个函数，printf函数存在于一个名为printf.o的单独预编译好的目标文件中，这个文件要以某种形式合并到我们的hello.o程序中，链接器(ld)负责这种合并，合并后就得到了可执行目标文件hello，其可以被加载到内存中，由系统执行。  编译器的工作方式 有一些重要原因使得我们必须知道编译器的工作方式：
 优化程序性能。我们需要了解一些机器代码及编译器将不同C语句转化为机器代码的方式，例如一个switch语句是否总比一系列if-else语句高效。 理解链接时出现的错误。 避免安全漏洞。缓冲区溢出错误是大多网络和服务器安全漏洞的主要原因。  处理器读取并解释储存在内存中的指令 要在Unix系统运行可执行目标文件hello，需要将文件名输入shell应用程序中：
linux&amp;gt; ./hello hello,world linux&amp;gt; 系统的硬件组成 总线 贯穿整个系统，负责信息字节在各个部件之间传递。
通常被设计为传送定长的字节块，即字，字中的字节数（即字长）是基本的系统参数，如今大多数机器中字长为8字节(即64位)，4字节(32位)在逐渐被64位取代。
I/O设备 每个I/O设备通过控制器或适配器与I/O总线相连，控制器为I/O设备本身或系统主板上的芯片组，适配器为插在主板插槽上的卡。
主存RAM 临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。由一组动态随机存取存储器(DRAM)芯片组成。逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址从零开始。
处理器 CPU是解释或执行存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备(寄存器)，称为程序计数器(PC)，PC指向主存中的某条机器语言指令（即包含该指令的地址）。
处理器在一直不停地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个简单的指令执行模型来操作的，这个模型是指令集架构决定的。该模型中指令按照严格的顺序执行。执行一条指令包含一系列步骤，处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，循环操作。
这样的简单操作并不多，主要围绕**主存、寄存器文件和ALU(算术逻辑单元)**进行。寄存器文件是一个小型存储设备，由一些单个字长的寄存器组成，ALU计算新的数据和地址值。CPU可能进行以下操作：
 加载：从主存读取一个字到寄存器 存储：从寄存器赋值一个字到主存 操作：将两个寄存器的内容复制到ALU，ALU对两个字进行算术运算，将结果存放到一个寄存器中 跳转：从指令本身抽取一个字，将这个字复制到PC中  指令集架构：每条机器代码指令的效果</description>
    </item>
    
  </channel>
</rss>
