<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数字证书 on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.github.io/blog2_public/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</link>
    <description>Recent content in 数字证书 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Fri, 06 Dec 2019 19:42:38 +0000</lastBuildDate><atom:link href="https://eternityqjl.github.io/blog2_public/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数字签名和数字证书</title>
      <link>https://eternityqjl.github.io/blog2_public/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Fri, 06 Dec 2019 19:42:38 +0000</pubDate>
      
      <guid>https://eternityqjl.github.io/blog2_public/posts/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</guid>
      <description>理解本文的基础是公钥密码加密，即非对称加密，比如其中一种非对称加密算法RSA。
非对称加密使用一对密钥，一个为公钥Pub，另一个为私钥Priv
明文P经过公钥Pub使用RSA加密算法混淆后变成了密文M，密文M无法用公钥Pub解开，只能用私钥Priv解开
同样的，明文P经过私钥Priv使用RSA加密算法混淆后变成了密文N，密文N只能用公钥Pub解开
1.信息安全 在信息安全中共有3个需要解决的问题：
 保密性：保证信息在传输时不被泄露 完整性：信息在传输时不被篡改 有效性：信息的使用者是合法的  公钥密码能解决保密性的问题
数字签名能解决完整性和有效性的问题
2.数字签名(Digital Signature) 真实世界中，签名是为了表示某些内容是签名者写的或者他所认可的。计算机中，数字签名也有着相似的含义，数字签名用来证实消息是某个特定的人发送的，即有效性；同时还能证明消息没有被篡改，即完整性。这些是怎么实现的呢？这就是接下来要介绍有关于数字签名的内容。
数字签名是公钥密码加密的逆向应用：
用私钥加密消息，用公钥解密消息。
 签名：用私钥加密的消息，只有拥有私钥的用户可以生成签名，这也确保了数字签名的发送者是该用户。 验证签名：即用公钥解密签名，因为公钥是公开的，所以任何人都可以验证签名。  2.1 生成签名 一般不直接对消息进行签名，而是对消息进行哈希计算后的得到的哈希值进行签名。
 HASH算法是密码学的基础，其中最重要的两条性质是不可逆和无冲突，
 不可逆：当你知道x的HASH值时，无法求出x 无冲突：你知道x，但无法求出一个y使得x与y的HASH值相同  这两个性质在数学上都是不成立的，理论上由无穷多不同的原始值，它们的HASH值都相同。但求逆和求冲突在计算上不可能实现，穷尽人类所有的计算资源都做不到。
 生成签名的步骤如下：
 对消息进行哈希计算，得到哈希值 利用私钥对哈希值进行加密，生成签名 将签名附在消息后，一起发送  2.2 验证签名  收到签名后，提取消息中的签名 用公钥对签名进行解密，得到哈希值1 对消息中的正文进行哈希计算，得到哈希值2 比较哈希值1和2，如果相同，则验证成功  注：前面提到，哈希值的计算不可逆，因此才能以这种方式验证签名。
3.数字证书(Digital Certificate) 数字证书是对公钥进行数字签名，是为了对公钥的合法性提供证明，如果公钥的合法性得不到证明，则就存在中间人攻击的风险。
 中间人攻击（Man-in-the-middle-attack）：
攻击者与通讯的两端分别建立滴露的联系，并交换所受到的数据。即中间人通过截获两端通讯使用的公钥，并将双方的两个公钥都更改为自己的公钥来达到截获消息的目的。
详情可以参考维基百科：中间人攻击
 我们对于签名的验证需要使用公钥，而公钥的真实合法性就是通过数字证书来的。证书中包含：公钥、公钥的数字签名、公钥拥有者的信息。如果证书验证成功，则代表该公钥是合法的。
但是，验证证书中的数字签名需要另一个公钥，该公钥的合法性又怎样保证呢？该问题可以无限地循环下去，那岂不是解决不了了？我们相信银行是一个可信的机构，可以放心地把钱存在里面，那么同样存在一个可信机构来颁发证书和提供公钥，我们相信这个机构提供的密钥是合法的。
这种机构称为认证机构(Certification Authority, CA)，CA认定“公钥确实属于某个私钥的拥有者”，并能生成公钥的数字签名的组织或机构。
3.1 如何生成证书？  证书即为公钥、公钥的数字签名、一些其他服务器信息的集合
  服务器将公钥A交给CA CA通过哈希计算生成公钥A的哈希值，然后用自己的私钥B给公钥A的哈希值加密，生成数字签名A CA把公钥A、数字签名A、一些服务器信息整合，生成证书，发回给服务器  3.</description>
    </item>
    
  </channel>
</rss>
