<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>线程 on Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/tags/%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 线程 on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 07 Dec 2021 17:14:52 +0800</lastBuildDate><atom:link href="https://eternityqjl.top/tags/%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>现代操作系统学习日志——进程与线程</title>
      <link>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 07 Dec 2021 17:14:52 +0800</pubDate>
      
      <guid>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>0. 操作系统概念 进程 地址空间 文件 输入输出 保护 shell 进程是操作系统中的最核心的概念，它是对正在运行程序的一个抽象。
进程 在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使得每个进程各运行几十至几百毫秒。在某一瞬间，CPU只运行一个进程，但在1秒内CPU可能运行多个进程。
进程模型 计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程。一个进程就是一个正在执行程序的实例。
进程的创建 进程的终止 进程的层次结构 UNIX中进程和它的所有子进程及后裔共同组成一个进程组。
UNIX启动时初始化自己的方式：一个称为init的特殊进程出现在启动映像中，开始运行时读入一个说明终端数量的文件，接着为每个终端创建一个新进程，这些进程等待用户登陆，如果有一个用户登录成功，该登录进程就执行一个shell准备接受命令，所接受的这些命令会启动更多进程。以此类推，在整个系统中，所有进程都是属于以init为根的一棵树。
Windows中没有进程层次的概念，所有进程都是低位相等的。
进程的状态  运行态：该时刻进程实际占用CPU 就绪态：可运行，但因为其他进程正在运行而暂时停止 阻塞态：除非某种外部事件发生，否则进程不能运行  进程的实现 线程 每个进程有一个地址空间和一个控制线程；但是，经常存在同一个地址空间中准并行运行多个控制线程的情况，这些线程就像是分离的进程（除共享地址空间外）。
线程的使用 并行实体拥有共享同一个地址空间和所有可用数据的能力，而多进程模型的地址空间不同。
线程比进程更轻量级，更容易创建、也更容易撤销。
另外如果存在大量计算和I/O处理，多个线程允许这些活动彼此重叠进行，加快执行速度。
举例
 字处理软件：  与用户交互线程 格式处理线程 处理磁盘备份线程    经典的线程模型 在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。前一种情形下，多个线程共享共享同一地址空间和其他资源，后一种情形中，多个进程共享物理内存、磁盘、打印机和其他资源。因此由于线程具有进程的某些性质，所以有时被称为轻量级进程。
多线程用来描述在同一个进程中允许多个线程的情形，一些CPU已经有直接硬件支持多线程，允许线程切换在纳秒级完成。
所有线程共享同一地址空间，意味着它们也共享同样的全局变量。各个线程可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或清除另一个线程的堆栈。线程之间是没有保护的，因为同一个进程的多个线程是为了相互合作的。除了共享地址空间，所有线程还共享同一个打开文件、子进程、定时器及相关信号。
每个进程中的内容：
 地址空间 全局变量 打开文件 子进程 定时器 信号与信号处理程序 账户信息  每个线程中的内容：
 程序计数器 寄存器 堆栈 状态  和传统进程一样，线程可以处于若干种状态的任何一个：运行、阻塞、就绪或终止。正在运行的线程拥有CPU并且是活跃的，被阻塞线程正在等待某个释放它的事件。
认识到每个线程有其自己的堆栈很重要。每个线程的堆栈有一个帧，供各个被调用但还没有从中返回的过程使用。在该栈帧中存放了响应过程的局部变量以及过程调用完后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，因此每个线程需要有自己的堆栈。
一个常见的系统调用：thread_yield，允许线程自动放弃CPU而让另一个线程运行。这样的调用很重要，因为不同于进程，线程库无法利用时钟中断强制线程让出CPU。所以设法使线程随着事件推移自动交出CPU，并让其他线程有机会使用，就非常重要。
POSIX线程 为实现可移植的线程程序，IEEE定义了线程的标准。它定义的线程包叫做pthread。大部分UNIX系统都支持该标准，这个标准定义了超过60个函数调用。所有pthread线程都有某些特性，每一个都含有一个标识符、一组寄存器和一个存储在结构中的属性。这些属性包括堆栈大小、调度参数以及其他线程需要的项目。
以下是一些线程调用举例：
 pthread_create：创建新线程并返回标识符，线程标识符为了让其他线程引用该线程 pthread_exit：结束调用的线程 pthread_join：等待一个特定线程的推出 pthread_yield：释放CPU来运行另一个线程 pthread_attr_init：创建并初始化一个线程的属性结构 pthread_attr_destroy：删除一个线程的属性结构  在用户空间中实现线程 有两种主要的方法实现线程包：在用户空间中和在内核中。</description>
    </item>
    
  </channel>
</rss>
