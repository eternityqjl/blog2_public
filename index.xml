<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Tue, 04 Jan 2022 14:59:16 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Csapp：9.虚拟内存</title>
        <link>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
        <pubDate>Tue, 04 Jan 2022 14:59:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ -&lt;h2 id=&#34;物理和虚拟寻址&#34;&gt;物理和虚拟寻址&lt;/h2&gt;
&lt;p&gt;物理地址PA、虚拟地址VA、内存管理单元MMU（利用存放在主存中的查询表来动态地翻译虚拟地址，该表的内容由操作系统管理）。&lt;/p&gt;
&lt;h2 id=&#34;地址空间&#34;&gt;地址空间&lt;/h2&gt;
&lt;p&gt;非负整数地址的有序集合。&lt;/p&gt;
&lt;p&gt;目前x86使用39位物理地址空间、49位虚拟地址空间。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为缓存的工具&#34;&gt;虚拟内存作为缓存的工具&lt;/h2&gt;
&lt;p&gt;VM系统通过将虚拟内存分割为大小为$P=2^p$字节的虚拟页来处理，同样地，物理内存也被分割为大小为P的物理页（页帧）。&lt;/p&gt;
&lt;p&gt;任意时刻，虚拟页面的集合都分为三个不相交的子集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未分配的&lt;/li&gt;
&lt;li&gt;缓存的&lt;/li&gt;
&lt;li&gt;未缓存的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dram缓存的组织结构&#34;&gt;DRAM缓存的组织结构&lt;/h3&gt;
&lt;p&gt;使用术语&lt;code&gt;SRAM缓存&lt;/code&gt;来表示位于CPU和主存之间的L1、L2和L3高速缓存；用术语&lt;code&gt;DRAM缓存&lt;/code&gt;表示虚拟内存系统的缓存，它在主存中缓存虚拟页。&lt;/p&gt;
&lt;p&gt;在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。DRAM比SRAM慢大约10倍，磁盘比DRAM慢大约100000倍。DRAM缓存的不命中（缺页）比SRAM缓存的不命中要昂贵的多。&lt;/p&gt;
&lt;p&gt;与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。&lt;/p&gt;
&lt;h3 id=&#34;页表&#34;&gt;页表&lt;/h3&gt;
&lt;p&gt;虚拟内存系统必须有方法判断一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。&lt;/p&gt;
&lt;p&gt;页表就是一个页表条目（PET）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE由一个有效位和一个n位地址字段组成的。有效位表明该虚拟页当前是否被缓存在DRAM中。&lt;/p&gt;
&lt;h3 id=&#34;页命中&#34;&gt;页命中&lt;/h3&gt;
&lt;h3 id=&#34;缺页&#34;&gt;缺页&lt;/h3&gt;
&lt;h3 id=&#34;分配页面&#34;&gt;分配页面&lt;/h3&gt;
&lt;h2 id=&#34;虚拟内存作为内存管理的工具&#34;&gt;虚拟内存作为内存管理的工具&lt;/h2&gt;
&lt;p&gt;虚拟内存大大简化了内存管理，并提供了一种自然的保护内存的方法。&lt;/p&gt;
&lt;p&gt;操作系统实际上为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。&lt;/p&gt;
&lt;p&gt;多个虚拟页面可以映射到同一个共享的物理页面上。&lt;/p&gt;
&lt;p&gt;VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。&lt;/p&gt;
&lt;h3 id=&#34;简化链接&#34;&gt;简化链接&lt;/h3&gt;
&lt;p&gt;独立的地址空间允许每个进程的内存映射使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。&lt;/p&gt;
&lt;p&gt;一个给定的Linux系统上的每个进程都使用类似的内存格式。对于64位地址空间，代码段总是从虚拟地址0x400000开始。数据段跟在代码段后，中间有一段符号要求的对齐空白。栈占用用户地址空间最高的部分，并向下生长。&lt;/p&gt;
&lt;p&gt;这样的一致性简化了链接器的设计和实现。允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。&lt;/p&gt;
&lt;h3 id=&#34;简化加载&#34;&gt;简化加载&lt;/h3&gt;
&lt;p&gt;虚拟内存使得很容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器位代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。在每个页被初次引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。&lt;/p&gt;
&lt;p&gt;将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。详见后面小节。&lt;/p&gt;
&lt;h3 id=&#34;简化共享&#34;&gt;简化共享&lt;/h3&gt;
&lt;p&gt;一般情况下，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程进行共享的。但在另一些情况下，需要进程来共享数据和代码。例如，每个进程必须调用相同的操作系统内核代码，操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本。&lt;/p&gt;
&lt;h3 id=&#34;简化内存分配&#34;&gt;简化内存分配&lt;/h3&gt;
&lt;p&gt;虚拟内存为用户进程提供了一个简单的分配额外内存的机制。当一个运行在用户进程的程序要求额外的堆空间时（调用malloc），操作系统分配一个适当数字大小的连续的虚拟内存页面，并将其映射到物理内存中任意位置的k个任意的物理页面。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为内存管理的工具-1&#34;&gt;虚拟内存作为内存管理的工具&lt;/h2&gt;
&lt;p&gt;提供独立的地址空间使得区分不同进程的私有内存变得容易。但时地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每个CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE上添加一些&lt;strong&gt;额外的许可位&lt;/strong&gt;开控制对一个虚拟页面内容的访问十分简单。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201041455041.png&#34; alt=&#34;虚拟内存提供的页面级内存保护&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个PTE添加了三个许可位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SUP位：进程是否必须运行在内核（超级用户）模式下才能访问该页&lt;/li&gt;
&lt;li&gt;READ位和WRITE位控制对页面的读和写访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。&lt;/p&gt;
&lt;h2 id=&#34;地址翻译&#34;&gt;地址翻译&lt;/h2&gt;
&lt;p&gt;页面命中时CPU&lt;strong&gt;硬件&lt;/strong&gt;执行的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器生成一个虚拟地址，将其传送给MMU&lt;/li&gt;
&lt;li&gt;MMU生成PTE（Page Table Entry）地址，并从高速缓存/主存请求得到它&lt;/li&gt;
&lt;li&gt;高速缓存/主存向MMU返回PTE&lt;/li&gt;
&lt;li&gt;MMU构造物理地址，并把它传送给高速缓存/主存&lt;/li&gt;
&lt;li&gt;高速缓存/主存返回所请求的数据字给处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;页面命中完全由硬件来处理，与之不同的是，处理缺页要求&lt;strong&gt;硬件和操作系统内核&lt;/strong&gt;协作完成。步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1-3步：与页面命中时的前三步相同&lt;/li&gt;
&lt;li&gt;PTE中的有效位为0，所以MMU触发了一次异常，传递CPU中的控制到&lt;strong&gt;操作系统内核中的缺页异常处理程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;缺页处理程序确定出物理内存中的牺牲页，如果该页面已经被修改，则把它换出到磁盘。&lt;/li&gt;
&lt;li&gt;缺页处理程序页面调入新的页面，并更新内存中的PTE。&lt;/li&gt;
&lt;li&gt;缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。虚拟页面现在缓存在物理内存中，所以就会命中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结合高速缓存和虚拟内存&#34;&gt;结合高速缓存和虚拟内存&lt;/h3&gt;
&lt;p&gt;在任何既使用高速缓存SRAM又使用虚拟内存的系统中，一般使用物理内存来访问高速缓存。&lt;/p&gt;
&lt;p&gt;使用物理内存，多个进程同时在高速缓存中由存储块和共享来自相同虚拟页面的块非常简单。并且高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。&lt;/p&gt;
&lt;h3 id=&#34;利用tlb加速地址翻译&#34;&gt;利用TLB加速地址翻译&lt;/h3&gt;
&lt;h3 id=&#34;多级页表&#34;&gt;多级页表&lt;/h3&gt;
&lt;p&gt;用来压缩页表的常用方法是使用层次结构的页表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201032140608.png&#34; alt=&#34;两级页表结构&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;案例研究linux虚拟内存系统&#34;&gt;案例研究：Linux虚拟内存系统&lt;/h2&gt;
&lt;p&gt;Linux为&lt;strong&gt;每个进程&lt;/strong&gt;维护了一个单独的虚拟地址空间。内核虚拟内存位于&lt;strong&gt;用户栈之上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图中为一个Linux进程的虚拟内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011847831.png&#34; alt=&#34;一个Linux进程的虚拟内存&#34;&gt;&lt;/p&gt;
&lt;p&gt;内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。内核虚拟内存的其他区域包含每个进程都不相同的数据，比如，页表、内核在进程的上下文执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。&lt;/p&gt;
&lt;h3 id=&#34;linux虚拟内存区域&#34;&gt;Linux虚拟内存区域&lt;/h3&gt;
&lt;p&gt;Linux将虚拟内存组织成一些区域（又称段）的集合。一个区域就是已存在的虚拟内存的连续片。代码段、数据段、堆、共享库以及用户栈都是不同的区域。每个虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域很重要，因为其允许虚拟地址空间有间隙。&lt;/p&gt;
&lt;p&gt;下图强调了记录&lt;strong&gt;一个进程中虚拟内存区域的内核数据结构&lt;/strong&gt;。内核为系统中的每个进程维护一个单独的&lt;strong&gt;任务结构&lt;code&gt;task_struct&lt;/code&gt;&lt;/strong&gt;。任务结构中的元素包含或指向内核&lt;strong&gt;运行该进程所需要的所有信息&lt;/strong&gt;（如PID、指向用户栈的指针、可执行目标文件的名字以及程序计数器）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011858154.png&#34; alt=&#34;Linux一个进程中虚拟内存区域的内核数据结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;任务结构中的一个条目指向&lt;code&gt;mm_struct&lt;/code&gt;，它描述了虚拟内存的当前状态。我们想了解的是pgd和mmap两个字段。pgd指向第一级页表的基址，mmap指向一个&lt;code&gt;vm_area_structs&lt;/code&gt;的链表，其中每个&lt;code&gt;vm_area_structs&lt;/code&gt;都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就把pgd存放在CR3控制寄存器中。&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;具体区域&lt;/strong&gt;的区域结构包含以下字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vm_start&lt;/code&gt;：指向该区域的起始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_end&lt;/code&gt;：指向该区域的结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_port&lt;/code&gt;：描述这个区域内包含的所有页的读写许可权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_flags&lt;/code&gt;：描述这个区域内的页面是与其他进程共享的还是这个进程私有的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_next&lt;/code&gt;：指向链表中下一个区域的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux缺页异常处理&#34;&gt;Linux缺页异常处理&lt;/h3&gt;
&lt;p&gt;假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序执行以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断&lt;strong&gt;虚拟地址A&lt;/strong&gt;是否合法？即A是否在某个区域结构定义的区域内。为了找到答案，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的&lt;code&gt;vm_start&lt;/code&gt;和&lt;code&gt;vm_end&lt;/code&gt;作比较。如果该指令不合法，则触发一个段错误，从而终止该进程。由于一个进程可以创建任意数量的新虚拟内存，因此顺序搜索链表的开销可能很大，Linux在链表中构建一棵树，并在这棵树上查找。&lt;/li&gt;
&lt;li&gt;试图进行的&lt;strong&gt;内存访问&lt;/strong&gt;是否合法？即进程是否有读、写或执行这个区域内页面的权限。如果试图进行的访问是不合法的，缺页处理程序就会触发一个保护异常，从而终止这个进程。&lt;/li&gt;
&lt;li&gt;此时内核知道这个缺页是由于&lt;strong&gt;对合法的虚拟内存进行合法的操作&lt;/strong&gt;造成的。这样进行处理：选择一个&lt;strong&gt;牺牲页面&lt;/strong&gt;，如果该页面被修改过，则将其交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送A到MMU。此时MMU就能正常翻译A，不会再产生缺页中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011920465.png&#34; alt=&#34;Linux缺页处理&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存映射&#34;&gt;内存映射&lt;/h2&gt;
&lt;p&gt;内存映射：Linux通过一个&lt;strong&gt;虚拟内存区域&lt;/strong&gt;与一个&lt;strong&gt;磁盘上的对象&lt;/strong&gt;关联起来，以初始化这个虚拟内存区域的内容。虚拟内存区域可以映射到两种类型的对象中的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux文件系统中的普通文件&lt;/li&gt;
&lt;li&gt;匿名文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的**交换文件(swap file)**之间换来换去。交换文件也叫做交换空间或交换区域。&lt;/p&gt;
&lt;h3 id=&#34;共享对象&#34;&gt;共享对象&lt;/h3&gt;
&lt;p&gt;许多程序要访问只读运行时库代码的相同副本，例如每个C程序都需要来自标准C库的诸如printf这样的函数。如果每个进程都在物理内存中保存这些常用代码的副本，就是极端的浪费。&lt;/p&gt;
&lt;p&gt;内存映射为我们提供了一种清晰的机制，用来控制多个进程如何共享对象。&lt;/p&gt;
&lt;p&gt;一个对象可以被映射到虚拟内存的一个区域，要么作为&lt;strong&gt;共享对象&lt;/strong&gt;，要么作为&lt;strong&gt;私有对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么该进程对这个地址区域的任何写操作，对于那些同样将该共享对象映射到自己的虚拟内存的进程也是可见的。这些变化会反映在磁盘的原始对象上。另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域的任何写操作都不会反映在磁盘的对象中。&lt;/p&gt;
&lt;p&gt;私有对象使用一种称为&lt;strong&gt;写时复制&lt;/strong&gt;的技术被映射到虚拟内存中。私有对象来时生命周期的方式基本与共享对象相同，在物理内存中只保存私有对象的一份副本。两个进程将一个私有对象映射到它们的虚拟内存的不同区域，但共享这个对象的同一物理副本。对于每个映射私有对象的进程，响应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。&lt;/p&gt;
&lt;p&gt;通过这种延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。&lt;/p&gt;
&lt;h3 id=&#34;fork函数&#34;&gt;fork函数&lt;/h3&gt;
&lt;p&gt;fork函数创建一个带有自己独立虚拟地址空间的新进程。&lt;/p&gt;
&lt;p&gt;当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的&lt;code&gt;mm_struct&lt;/code&gt;、区域结构和页表的原样&lt;strong&gt;副本&lt;/strong&gt;。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的&lt;strong&gt;写时复制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当fork函数在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的一个后来进程写操作时，写时复制就会创建新页面，因此为每个进程保持了私有地址空间的概念。&lt;/p&gt;
&lt;h3 id=&#34;execve函数&#34;&gt;execve函数&lt;/h3&gt;
&lt;p&gt;虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。&lt;/p&gt;
&lt;p&gt;假设在当前进程中的程序执行了如下的execve调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;execve(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;a.out&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载该程序需要以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除已存在的用户区域。&lt;/li&gt;
&lt;li&gt;映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域时请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。&lt;/li&gt;
&lt;li&gt;映射共享区域。如果a.out程序与共享对象或目标链接（比如标准C库libc.so），那么这些对象都是动态连接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。&lt;/li&gt;
&lt;li&gt;设置程序计数器PC。设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了加载器如何映射用户地址空间区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201022200703.png&#34; alt=&#34;加载器映射用户地址空间区域&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用mmap函数的用户级内存映射&#34;&gt;使用mmap函数的用户级内存映射&lt;/h3&gt;
&lt;h2 id=&#34;动态内存分配&#34;&gt;动态内存分配&lt;/h2&gt;
&lt;p&gt;动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，指向堆的顶部。&lt;/p&gt;
&lt;p&gt;分配器将堆视为一组不同大小的块的集合，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。&lt;/p&gt;
&lt;p&gt;分配器有两种基本风格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显式&lt;/strong&gt;分配器：要求应用显式地释放任何已有的块。C标准库提供称为malloc程序包的显式分配器，C程序通过调用malloc分配内存，通过调用free释放一个块。C++通过new和delete分配和释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式&lt;/strong&gt;分配器：又称为垃圾收集器。自动释放未使用的已分配的块的过程称为垃圾收集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来主要讨论显式分配器的设计与实现。&lt;/p&gt;
&lt;h3 id=&#34;malloc和free函数&#34;&gt;malloc和free函数&lt;/h3&gt;
&lt;p&gt;C标准库提供成为malloc的显示分配器，程序通过调用malloc函数来从堆中分配块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;malloc&lt;/span&gt;(size_t size);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;malloc函数返回一个指针，指向大小至少为size字节的额内存块。&lt;/p&gt;
&lt;p&gt;如果malloc遇到问题（例如程序要求的内存块比可用的虚拟内存还要大），那么它就返回NULL，并设置errno。&lt;/p&gt;
&lt;p&gt;动态分配器还可以使用sbrk函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sbrk&lt;/span&gt;(intptr_t incr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sbrk函数通过将内核的brk指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1，并将errno设置为ENOMEM。如果incr为零，那么sbrk就返回brk的当前值。&lt;/p&gt;
&lt;p&gt;程序通过调用free函数来释放已分配的堆块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;free&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用动态内存分配的原因&#34;&gt;使用动态内存分配的原因&lt;/h3&gt;
&lt;p&gt;经常直到程序实际运行时，才知道某些数据结构的大小。&lt;/p&gt;
&lt;h3 id=&#34;分配器的要求和目标&#34;&gt;分配器的要求和目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;处理任意请求序列&lt;/li&gt;
&lt;li&gt;立即响应请求&lt;/li&gt;
&lt;li&gt;只使用堆&lt;/li&gt;
&lt;li&gt;对齐块&lt;/li&gt;
&lt;li&gt;不修改已分配的块&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;碎片&#34;&gt;碎片&lt;/h3&gt;
&lt;p&gt;造成堆利用率很低的主要原因是一种称为碎片的现象，当虽然有未使用的内存但不能用来满足分配请求时，就会发发生这种现象。由以下两种碎片：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部碎片：已分配块的大小和它们的有效荷载大小之差的和。内部碎片的数量取决于以前请求的模式和分配器的实现方式。比如分配器可能增加块大小以满足对齐约束条件。&lt;/li&gt;
&lt;li&gt;外部碎片：当空闲内存合计起来足够满足一个分配请求，但没有一个单独的空闲块足够大可以来处理这个请求。如果不向内核请求额外的虚拟内存就无法满足这个请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块。&lt;/p&gt;
&lt;h3 id=&#34;实现问题&#34;&gt;实现问题&lt;/h3&gt;
&lt;p&gt;要实现一个在吞吐率和利用率之间把握好平衡的分配器，要考虑以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲块组织&lt;/li&gt;
&lt;li&gt;放置&lt;/li&gt;
&lt;li&gt;分割&lt;/li&gt;
&lt;li&gt;合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;隐式空闲链表&#34;&gt;隐式空闲链表&lt;/h3&gt;
&lt;p&gt;分配器需要一些数据结构，允许它来区分块边界，以及区别已分配和空闲块。大都数分配器将这些信息嵌入块本身。&lt;/p&gt;
&lt;p&gt;一个块由一个字（4B）的头部、有效荷载以及可能的一些额外的填充组成。头部编码了这个快的大小以及这个快是已分配的还是空闲的。&lt;/p&gt;
&lt;h3 id=&#34;放置已分配的块&#34;&gt;放置已分配的块&lt;/h3&gt;
&lt;p&gt;应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求快的空闲块。这种搜索方式是由放置策略确定的。常见的策略有首次适配、下一次适配和最佳适配。&lt;/p&gt;
&lt;h3 id=&#34;分隔空闲块&#34;&gt;分隔空闲块&lt;/h3&gt;
&lt;h3 id=&#34;获取额外的堆内存&#34;&gt;获取额外的堆内存&lt;/h3&gt;
&lt;h3 id=&#34;合并空闲块&#34;&gt;合并空闲块&lt;/h3&gt;
&lt;h3 id=&#34;带边界标记的合并&#34;&gt;带边界标记的合并&lt;/h3&gt;
&lt;h3 id=&#34;显式空闲链表&#34;&gt;显式空闲链表&lt;/h3&gt;
&lt;h3 id=&#34;分离的空闲链表&#34;&gt;分离的空闲链表&lt;/h3&gt;
&lt;h2 id=&#34;垃圾收集&#34;&gt;垃圾收集&lt;/h2&gt;
&lt;p&gt;未能释放已分配的块是一种常见的编程错误。&lt;/p&gt;
&lt;p&gt;垃圾收集器是一种动态内存分配器，它自动释放不再需要的已分配块。这些块被称为垃圾。在一个支持垃圾收集的系统中，应用显式地分配块，但从不显式地释放它们。&lt;/p&gt;
&lt;p&gt;这里讨论McCarthy独创的标记、清除算法，这个算法可以建立在已存在的malloc包的基础之上，为C/C++提供垃圾收集。&lt;/p&gt;
&lt;h2 id=&#34;c语言常见的与内存有关的错误&#34;&gt;C语言常见的与内存有关的错误&lt;/h2&gt;
&lt;h3 id=&#34;间接引用坏指针&#34;&gt;间接引用坏指针&lt;/h3&gt;
&lt;p&gt;常见的是经典的scanf错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;scanf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;val);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用scanf从stdin读取一个整数到一个变量。很容易错误地传递val的内容而不是它的地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;scanf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, val);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;scanf将把val的内容解释为一个地址，并试图将一个字写到这个位置。在最糟糕的情况下，val的内容对应于虚拟内存的合法读/写区域，于是我们就覆盖了这块内存，这在相当长一段时间后会造成灾难性后果。&lt;/p&gt;
&lt;h3 id=&#34;读未初始化的内存&#34;&gt;读未初始化的内存&lt;/h3&gt;
&lt;p&gt;虽然bss内存位置总是被加载器初始化为零，但对于堆内存并不是这样。一个常见的错误就是假设堆内存被初始化为零。我们在使用堆内存的变量是要先将其初始化。&lt;/p&gt;
&lt;h3 id=&#34;允许栈缓冲区溢出&#34;&gt;允许栈缓冲区溢出&lt;/h3&gt;
&lt;p&gt;如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;bufferflow&lt;/span&gt;() {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;64&lt;/span&gt;];
	gets(buf);
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数就有缓冲区溢出错误，因为gets函数复制一个任意长度的串到缓冲区。为了纠正这个错误，必须使用fgets函数，该函数限制了输入串的大小。&lt;/p&gt;
&lt;h3 id=&#34;假设指针和它们指向的对象是相同大小的&#34;&gt;假设指针和它们指向的对象是相同大小的&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;makeArray1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; m) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;A &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;)Malloc(n &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
		A[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)Malloc(m &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
	}
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; A;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数的目的是创建一个由n个指针组成的数据，每个指针都指向包含m个int的数组。然后创建A时错误地将&lt;code&gt;sizeof(int *)&lt;/code&gt;写成了&lt;code&gt;sizeof(int)&lt;/code&gt;，代码实际上创建的是一个int数组。&lt;/p&gt;
&lt;h3 id=&#34;引用指针而不是它所指向的对象&#34;&gt;引用指针，而不是它所指向的对象&lt;/h3&gt;
&lt;p&gt;下面的函数，其目的是删除一个有&lt;code&gt;size&lt;/code&gt;项的二叉堆里的第一项，然后对剩下的*size-1项重新建堆：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;binheapDelete&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;binheap, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;packet &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; binheap[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;];
	binheap[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; binheap[&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;];
	&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;;
	heapify(binheap, &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;(packet);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数错误地将&lt;code&gt;(*size)--&lt;/code&gt;写作了&lt;code&gt;*size--&lt;/code&gt;导致代码实际上减少的是指针自己的值，而不是它所指向整数的值。程序运行后很有可能发生的是，当程序在执行过程后很久才出现一个错误的结果。&lt;/p&gt;
&lt;h3 id=&#34;误解指针的运算&#34;&gt;误解指针的运算&lt;/h3&gt;
&lt;p&gt;指针的算数操作是以它们指向对象的大小为单位来进行的，这种大小单位不一定是字节。&lt;/p&gt;
&lt;h3 id=&#34;引用不存在的变量&#34;&gt;引用不存在的变量&lt;/h3&gt;
&lt;p&gt;有时候不理解栈的规则的程序员可能会引用不合法的本地变量，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;stackref&lt;/span&gt;()
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; val;
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;val;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数返回一个指针，指向栈中的一个局部变量，然后弹出它的栈帧，尽管&amp;amp;val仍然指向一个合法地址，但它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，内存将重用它们的栈帧。再后来，如果程序分配某个值给*p，那么其可能在修改另一个函数的栈帧中的一个条目，带来潜在的灾难性后果。&lt;/p&gt;
&lt;h3 id=&#34;引用空闲堆块中的数据&#34;&gt;引用空闲堆块中的数据&lt;/h3&gt;
&lt;p&gt;一个相似的错误是引用已经被释放了的堆块中的数据。&lt;/p&gt;
&lt;h3 id=&#34;引起内存泄漏&#34;&gt;引起内存泄漏&lt;/h3&gt;
&lt;p&gt;忘记释放已经分配的块，而在堆里创建了垃圾。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp指向类成员的指针</title>
        <link>https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</link>
        <pubDate>Tue, 28 Dec 2021 21:53:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/ -&lt;h2 id=&#34;指向类的普通成员的指针非静态&#34;&gt;指向类的普通成员的指针（非静态）&lt;/h2&gt;
&lt;h3 id=&#34;指向类成员函数的指针&#34;&gt;指向类成员函数的指针&lt;/h3&gt;
&lt;p&gt;指向类成员函数的指针不仅要匹配函数的&lt;strong&gt;参数类型和个数&lt;/strong&gt;，以及&lt;strong&gt;返回值类型&lt;/strong&gt;，还要匹配该&lt;strong&gt;函数指针所属的类类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原因是非静态的成员函数必须绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：与普通函数作为区分，指向类的成员函数的指针只需要在指针前加上类类型即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;返回值&lt;/span&gt; (&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类名&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针类型名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;赋值&lt;/strong&gt;：只需使用类的成员函数地址赋值即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针类型名&lt;/span&gt; &lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类名&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;成员函数名&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调用&lt;/strong&gt;：针对调用的对象是对象还是指针，分别用&lt;code&gt;.*&lt;/code&gt;和&lt;code&gt;-&amp;gt;*&lt;/code&gt;进行调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类对象&lt;/span&gt;.&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类对象&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指向类数据成员的指针&#34;&gt;指向类数据成员的指针&lt;/h3&gt;
&lt;p&gt;同理指向类成员函数的指针，只要判断以下两点是否一致即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员的类型&lt;/li&gt;
&lt;li&gt;所属的类类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指向类的静态成员的指针&#34;&gt;指向类的静态成员的指针&lt;/h2&gt;
&lt;p&gt;类的静态成员不依赖于具体对象，所有实例化的对象都共享同一个静态成员，即静态成员没有this指针的概念。&lt;/p&gt;
&lt;p&gt;所以，指向类的静态成员的指针就是&lt;strong&gt;普通的指针&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要使用&lt;code&gt;(&amp;amp;类名::成员名)&lt;/code&gt;获取指向成员的指针，首先这个成员必须是对外可见的，即&lt;code&gt;public&lt;/code&gt;的。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>AVL树及与红黑树、B/B&#43;树的对比</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Thu, 23 Dec 2021 15:30:08 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/ -&lt;p&gt;&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/&#34;&gt;红黑树&lt;/a&gt;和&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb+%E6%A0%91/&#34;&gt;B/B+树&lt;/a&gt;详见这两篇博客。&lt;/p&gt;
&lt;h2 id=&#34;avl树&#34;&gt;AVL树&lt;/h2&gt;
&lt;p&gt;AVL树为平衡二叉树，是以其发明者的名字命名的。任一结点对应的两棵子树的最大高度差为1。查找、插入和删除在平均和最坏的情况下的时间复杂度都为$O(\log n)$。&lt;/p&gt;
&lt;p&gt;增加和删除元素操作可能需要借由一次或多次树旋转，以实现树的重新平衡。&lt;/p&gt;
&lt;p&gt;与红黑树相比，AVL树是严格的平衡二叉树。&lt;/p&gt;
&lt;p&gt;局限性：由于维护这种高度平衡所付出的代价比从中获得的效率收益还大。故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。&lt;/p&gt;
&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;一种二叉查找树，确保没有一条路径会比其他路径长出两倍。是一种弱平衡树。在插入和删除的操作中的旋转次数相对于AVL树来说较少。&lt;/p&gt;
&lt;h2 id=&#34;bb树&#34;&gt;B/B+树&lt;/h2&gt;
&lt;p&gt;B/B+树是为了磁盘或其他存储设备设计的平衡多路查找树，与红黑树相比，在相同结点的情况下，一颗B/B+树的高度远远小于红黑树。B树的操作效率主要取决于访问磁盘的次数，关键字数相同的情况下，B树高度越小，磁盘I/O所花的时间越少。&lt;/p&gt;
&lt;p&gt;B+树是应文件系统所需而产生的一种B树的变形树，非叶子结点只保存索引，不保存实际的数据，数据都保存在叶子结点中。相当于是文件系统的查找。&lt;/p&gt;
&lt;p&gt;另外B+树支持顺序查找而B树不支持，数据库中经常需要遍历一定范围内的数据，因此采用B+树比采用B树的效率更高。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp内存对齐</title>
        <link>https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
        <pubDate>Wed, 22 Dec 2021 16:10:44 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/ -&lt;h2 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h2&gt;
&lt;p&gt;看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//32位系统
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; y;
}s;

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(s);  &lt;span style=&#34;color:#888&#34;&gt;// 输出8
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。&lt;/p&gt;
&lt;h2 id=&#34;进行内存对齐的原因&#34;&gt;进行内存对齐的原因&lt;/h2&gt;
&lt;p&gt;尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为&lt;strong&gt;内存存取粒度&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。&lt;/p&gt;
&lt;h2 id=&#34;默认内存对齐&#34;&gt;默认内存对齐&lt;/h2&gt;
&lt;p&gt;int类型放在地址能被4整除的位置，short类型放在地址能被2整除的位置，char能放在任何位置。&lt;/p&gt;
&lt;p&gt;结构体的对齐满足以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体变量的首地址能够被其&lt;strong&gt;最宽基本类型成员的大小&lt;/strong&gt;所整除。&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是&lt;strong&gt;成员大小的整数倍&lt;/strong&gt;，如有需要编译器会在成员之间填充字节。&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体&lt;strong&gt;最宽基本类型成员大小的整数倍&lt;/strong&gt;，如有需要编译器会在最末一个成员后填充字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pragma-pack命令&#34;&gt;#pragma pack()命令&lt;/h2&gt;
&lt;p&gt;改命令强制规定了成员的对齐方式，括号内为&lt;strong&gt;对齐的字节数&lt;/strong&gt;。若括号内的内容为空，则为默认对齐。&lt;/p&gt;
&lt;p&gt;改变默认对齐方式能够更加充分利用存储空间，但降低了计算机的读写速率，是一种以空间换事件的方法。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>测试机器大小端的方法</title>
        <link>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/</link>
        <pubDate>Wed, 22 Dec 2021 15:49:36 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/ -&lt;ul&gt;
&lt;li&gt;小端法：低位字节存放在低地址，高位字节存放在高地址&lt;/li&gt;
&lt;li&gt;大端法：低位字节存放在高地址，高位字节存放在低地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断电脑大小端模式的方法：&lt;/p&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言中的char和int：&lt;/p&gt;
&lt;p&gt;在C语言中并没有char类型的常量，其实是用int类型表示char。举个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; ch &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#888&#34;&gt;//分别输出ch的字符和对应的ascii码。即打印出的是字符或整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%c, %d&amp;#34;&lt;/span&gt;, ch, ch);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果为：a, 97&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将int 48存起来，然后取得其地址，再将这个地址转为char* 这时候，如果是小端存储，那么char*指针就指向48；48对应的ASCII码为字符‘0’；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge1&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;48&lt;/span&gt;;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;i;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
    c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)p);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;方法二&#34;&gt;方法二&lt;/h2&gt;
&lt;p&gt;定义变量int i=1；将 i 的地址拿到，强转成char*型，这时候就取到了 i 的低地址，这时候如果是1就是小端存储，如果是0就是大端存储。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge2&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;i);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (c)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;方法三&#34;&gt;方法三&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;联合体union是一种特殊数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共同体，但任何时候只能有一个成员带有值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义联合体，一个成员是多字节，一个是单字节，给多字节的成员赋一个最低一个字节不为0，其他字节为0 的值，再用第二个成员来判断，如果第二个字节不为0，就是小端，若为0，就是大端。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge3&lt;/span&gt;() {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;union&lt;/span&gt;
    {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c;
    } un;
    un.i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (un.c &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp容器库和相关操作总结</title>
        <link>https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
        <pubDate>Thu, 16 Dec 2021 15:34:43 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/ -&lt;h1 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h1&gt;
&lt;h2 id=&#34;vector&#34;&gt;vector&lt;/h2&gt;
&lt;p&gt;member functions：&lt;/p&gt;
&lt;p&gt;constructor、destructor、operator=、assign、get_allocator&lt;/p&gt;
&lt;h3 id=&#34;element-access&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iterators&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin/cbegin&lt;/li&gt;
&lt;li&gt;end/cend&lt;/li&gt;
&lt;li&gt;rbegin/c rbegin&lt;/li&gt;
&lt;li&gt;rend/c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;li&gt;reserve&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;shrink_to_fit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;emplace：相较于insert，不需要产生一个临时变量。&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;push_back&lt;/li&gt;
&lt;li&gt;resize&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;non-member functions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;operator==&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deque&#34;&gt;deque&lt;/h2&gt;
&lt;p&gt;双端队列&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;list&lt;/h2&gt;
&lt;p&gt;双向链表&lt;/p&gt;
&lt;h2 id=&#34;forward_list&#34;&gt;forward_list&lt;/h2&gt;
&lt;p&gt;单向链表&lt;/p&gt;
&lt;h2 id=&#34;array&#34;&gt;array&lt;/h2&gt;
&lt;p&gt;array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。&lt;/p&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;h3 id=&#34;iterators-1&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin/cbegin&lt;/li&gt;
&lt;li&gt;end/cend&lt;/li&gt;
&lt;li&gt;rbegin/c rbegin&lt;/li&gt;
&lt;li&gt;rend/c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-1&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;length&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;li&gt;reserve&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;shrink_to_fit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;element-access-1&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-1&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;+=&lt;/li&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;li&gt;push_back&lt;/li&gt;
&lt;li&gt;assign&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;pop_back&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;关联容器&#34;&gt;关联容器&lt;/h1&gt;
&lt;h2 id=&#34;set&#34;&gt;set&lt;/h2&gt;
&lt;h3 id=&#34;iterators-2&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin / cbegin&lt;/li&gt;
&lt;li&gt;end / cend&lt;/li&gt;
&lt;li&gt;rbegin / c rbegin&lt;/li&gt;
&lt;li&gt;rend / c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-2&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-2&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;emplace_hint&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lookup&#34;&gt;Lookup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;contains&lt;/li&gt;
&lt;li&gt;equal_range&lt;/li&gt;
&lt;li&gt;lower_bound&lt;/li&gt;
&lt;li&gt;upper_bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;
&lt;h3 id=&#34;element-accress&#34;&gt;Element accress&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator &lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iterators-3&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin / cbegin&lt;/li&gt;
&lt;li&gt;end / cend&lt;/li&gt;
&lt;li&gt;rbegin / c rbegin&lt;/li&gt;
&lt;li&gt;rend / c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-3&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-3&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;insert_or_assign&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;emplace_hint&lt;/li&gt;
&lt;li&gt;try_emplace&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lookup-1&#34;&gt;Lookup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;contains&lt;/li&gt;
&lt;li&gt;equal_range&lt;/li&gt;
&lt;li&gt;lower_bound&lt;/li&gt;
&lt;li&gt;upper_bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;multimap&#34;&gt;multimap&lt;/h2&gt;
&lt;p&gt;允许多个多个元素具有相同的关键词。主要应用有：例如词典中一个单词可以有多个意思。&lt;/p&gt;
&lt;h2 id=&#34;multiset&#34;&gt;multiset&lt;/h2&gt;
&lt;h2 id=&#34;unordered_map&#34;&gt;unordered_map&lt;/h2&gt;
&lt;p&gt;无序容器不使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器非常有用。某些应用中维护元素序的代价非常高昂，此时无序容器也很有用。&lt;/p&gt;
&lt;h2 id=&#34;unordered_set&#34;&gt;unordered_set&lt;/h2&gt;
&lt;h2 id=&#34;unordered_multimap&#34;&gt;unordered_multimap&lt;/h2&gt;
&lt;h2 id=&#34;unordered_multimet&#34;&gt;unordered_multimet&lt;/h2&gt;
&lt;h1 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h1&gt;
&lt;h2 id=&#34;priority_queue&#34;&gt;priority_queue&lt;/h2&gt;
&lt;h3 id=&#34;element-access-2&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-4&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-4&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stack&#34;&gt;stack&lt;/h2&gt;
&lt;p&gt;与priority_queue相同。&lt;/p&gt;
&lt;h2 id=&#34;queue&#34;&gt;queue&lt;/h2&gt;
&lt;h3 id=&#34;element-access-3&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-5&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-5&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;list-1&#34;&gt;list&lt;/h2&gt;
- https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C程序字节对齐方式</title>
        <link>https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</link>
        <pubDate>Tue, 14 Dec 2021 16:38:12 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/ -&lt;h2 id=&#34;默认字节对齐&#34;&gt;默认字节对齐&lt;/h2&gt;
&lt;p&gt;int类型放在地址能被4整除的位置，short类型放在地址能被2整除的位置，char能放在任何位置。&lt;/p&gt;
&lt;p&gt;结构体的对其满足以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体变量的首地址能够被其最宽基本类型成员的大小所整除。&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间填充字节。&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员后填充字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pragma-pack命令&#34;&gt;#pragma pack()命令&lt;/h2&gt;
&lt;p&gt;改命令强制规定了成员的对齐方式，括号内为对齐的字节数。若括号内的内容为空，则为默认对齐。&lt;/p&gt;
&lt;p&gt;改变默认对齐方式能够更加充分利用存储空间，但降低了计算机的读写速率，是一种以空间换事件的方法。&lt;/p&gt;
- https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp：7.链接</title>
        <link>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</link>
        <pubDate>Sat, 11 Dec 2021 21:38:11 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/ -&lt;p&gt;链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载到内存并执行。&lt;/p&gt;
&lt;p&gt;链接可以执行于编译时、加载时、运行时。&lt;/p&gt;
&lt;p&gt;链接使得分离编译成为可能。可以将巨大的源文件分解为更小的模块，可以独立地修改和编译这些模块。当我们改变其中的一个模块时，只需简单地将其重新编译并链接，无需重新编译其他文件。&lt;/p&gt;
&lt;p&gt;理解链接器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助构造大型程序&lt;/li&gt;
&lt;li&gt;避免一些危险的编程错误。例如错误地定义多个全局变量的程序将通过链接器，不产生任何警告。&lt;/li&gt;
&lt;li&gt;理解语言的作用域规则。如：全局和局部变量的区别；static属性的变量和函数的意义。&lt;/li&gt;
&lt;li&gt;帮助理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色。&lt;/li&gt;
&lt;li&gt;帮助我们利用共享库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器驱动程序&#34;&gt;编译器驱动程序&lt;/h2&gt;
&lt;p&gt;编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。例如我们经常使用的gcc驱动程序。&lt;/p&gt;
&lt;p&gt;main.c$\rightarrow$main.i$\rightarrow$main.s$\rightarrow$main.o$\rightarrow$prog&lt;/p&gt;
&lt;p&gt;源程序$\rightarrow$中间文件$\rightarrow$汇编语言文件$\rightarrow$&lt;strong&gt;可重定位目标文件&lt;/strong&gt;$\rightarrow$&lt;strong&gt;可执行目标文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次使用了：预处理器、编译器、汇编器 、链接器&lt;/p&gt;
&lt;p&gt;shell执行可执行文件时调用操作系统中的加载器函数，将prog中的代码和数据复制到内存中，然后将控制转移到这个程序的开头。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;静态链接&#34;&gt;静态链接&lt;/h2&gt;
&lt;p&gt;可重定位目标文件由不同的代码和数据节组成，每一节都是一个连续的字节序列。&lt;/p&gt;
&lt;p&gt;静态链接器以一组&lt;strong&gt;可重定位目标文件和命令行参数&lt;/strong&gt;作为输入，生成一个&lt;strong&gt;完全链接的、可以加载和运行的可执行目标文件&lt;/strong&gt;作为输出。&lt;/p&gt;
&lt;p&gt;为了构造可执行文件，链接器必须完成连个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符号解析&lt;/strong&gt;：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。将每个符号引用正好和一个符号定义关联起来。（每个符号对应于一个函数、一个全局变量或一个静态变量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定位&lt;/strong&gt;。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使它们指向这个内存位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目标文件&#34;&gt;目标文件&lt;/h2&gt;
&lt;p&gt;共有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重定位目标文件：二进制代码和数据，可在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。&lt;/li&gt;
&lt;li&gt;可执行目标文件：二进制代码和数据，其形式可以直接被复制到内存中并执行。&lt;/li&gt;
&lt;li&gt;共享目标文件：特殊类型的可重定位目标文件，可以在加载或运行时被&lt;strong&gt;动态地加载进内存并链接&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标文件是按照特定目标文件格式来组织的，各个系统的目标文件格式都不相同。&lt;/p&gt;
&lt;h2 id=&#34;可重定位目标文件&#34;&gt;可重定位目标文件&lt;/h2&gt;
&lt;p&gt;一个典型的ELF可重定位目标文件：&lt;/p&gt;
&lt;p&gt;首先是16B的ELF头，描述了生成该文件的系统的字的大小和字节顺序。&lt;/p&gt;
&lt;p&gt;然后是节：一个典型的ELF可重定位目标文件包含以下几个节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.text&lt;/code&gt;：已编译程序的机器代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rodata&lt;/code&gt;：只读数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：已初始化的全局和静态C变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.symtab&lt;/code&gt;：一个符号表，存放在程序中定义和引用的函数和全局变量的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.text&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.debug&lt;/code&gt;：调试符号表，以-g选项调用编译器驱动程序时才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.line&lt;/code&gt;：原始C程序的行号和&lt;code&gt;.text&lt;/code&gt;节中的机器指令之间的映射，以-g选项调用编译器驱动程序时才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.strtab&lt;/code&gt;：一个字符串表，其中内容包括&lt;code&gt;.symtab&lt;/code&gt;和&lt;code&gt;.debug&lt;/code&gt;节中的符号表，以及节头部中的节名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;符号和符号表&#34;&gt;符号和符号表&lt;/h2&gt;
&lt;p&gt;每个可重定位目标模块都有一个符号表&lt;code&gt;.symtab&lt;/code&gt;，它包含m定义和引用的符号的信息。在链接器的上下文，有三种不同符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由模块m定义并能被其他模块引用的全局符号：对应非静态的C函数和全局变量。&lt;/li&gt;
&lt;li&gt;由其他模块定义并被m引用的全局符号，称为外部符号：对应其他模块中定义的非静态的C函数和全局变量&lt;/li&gt;
&lt;li&gt;只被模块m定义和引用的局部符号：对应于带static属性的C函数和全局变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本地非静态程序变量的符号在运行时在&lt;strong&gt;栈中&lt;/strong&gt;被管理，不在符号表.symtab中。&lt;/p&gt;
&lt;p&gt;C中源文件扮演模块的角色，static属性就像C++使用的public和private一样。&lt;/p&gt;
&lt;p&gt;尽可能用static属性来保护变量和函数。&lt;/p&gt;
&lt;p&gt;符号表由汇编器构造，使用编译器输出到汇编语言&lt;code&gt;.s&lt;/code&gt;文件中的符号。&lt;code&gt;.symtab&lt;/code&gt;节中包含ELF符号表。以下为符号表中每个符号条目的格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; name;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;type&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,
		 &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;binding&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; reserved;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;short&lt;/span&gt; section;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; value;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; size;
} Elf64_Symbol;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符号的地址。对于可重定位目标文件来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时的地址。size是目标的大小。type通常代表数据或函数。符号表还可以包含各个节的条目。binging字段表示符号是本地还是全局。&lt;/p&gt;
&lt;p&gt;每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到节头部表的索引。&lt;/p&gt;
&lt;p&gt;以下是hello_world.c文件的符号表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
   printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;);
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Symbol table &#39;.symtab&#39; contains 70 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000318     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000338     0 SECTION LOCAL  DEFAULT    2 
     3: 0000000000000358     0 SECTION LOCAL  DEFAULT    3 
     4: 000000000000037c     0 SECTION LOCAL  DEFAULT    4 
     5: 00000000000003a0     0 SECTION LOCAL  DEFAULT    5 
     6: 00000000000003c8     0 SECTION LOCAL  DEFAULT    6 
     7: 0000000000000470     0 SECTION LOCAL  DEFAULT    7 
     8: 00000000000004f4     0 SECTION LOCAL  DEFAULT    8 
     9: 0000000000000508     0 SECTION LOCAL  DEFAULT    9 
    10: 0000000000000528     0 SECTION LOCAL  DEFAULT   10 
    11: 00000000000005e8     0 SECTION LOCAL  DEFAULT   11 
    12: 0000000000001000     0 SECTION LOCAL  DEFAULT   12 
    13: 0000000000001020     0 SECTION LOCAL  DEFAULT   13 
    14: 0000000000001040     0 SECTION LOCAL  DEFAULT   14 
    15: 0000000000001050     0 SECTION LOCAL  DEFAULT   15 
    16: 0000000000001060     0 SECTION LOCAL  DEFAULT   16 
    17: 00000000000011e8     0 SECTION LOCAL  DEFAULT   17 
    18: 0000000000002000     0 SECTION LOCAL  DEFAULT   18 
    19: 0000000000002014     0 SECTION LOCAL  DEFAULT   19 
    20: 0000000000002058     0 SECTION LOCAL  DEFAULT   20 
    21: 0000000000003db8     0 SECTION LOCAL  DEFAULT   21 
    22: 0000000000003dc0     0 SECTION LOCAL  DEFAULT   22 
    23: 0000000000003dc8     0 SECTION LOCAL  DEFAULT   23 
    24: 0000000000003fb8     0 SECTION LOCAL  DEFAULT   24 
    25: 0000000000004000     0 SECTION LOCAL  DEFAULT   25 
    26: 0000000000004010     0 SECTION LOCAL  DEFAULT   26 
    27: 0000000000000000     0 SECTION LOCAL  DEFAULT   27 
    28: 0000000000000000     0 SECTION LOCAL  DEFAULT   28 
    29: 0000000000000000     0 SECTION LOCAL  DEFAULT   29 
    30: 0000000000000000     0 SECTION LOCAL  DEFAULT   30 
    31: 0000000000000000     0 SECTION LOCAL  DEFAULT   31 
    32: 0000000000000000     0 SECTION LOCAL  DEFAULT   32 
    33: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    34: 0000000000001090     0 FUNC    LOCAL  DEFAULT   16 deregister_tm_clones
    35: 00000000000010c0     0 FUNC    LOCAL  DEFAULT   16 register_tm_clones
    36: 0000000000001100     0 FUNC    LOCAL  DEFAULT   16 __do_global_dtors_aux
    37: 0000000000004010     1 OBJECT  LOCAL  DEFAULT   26 completed.8061
    38: 0000000000003dc0     0 OBJECT  LOCAL  DEFAULT   22 __do_global_dtors_aux_fin
    39: 0000000000001140     0 FUNC    LOCAL  DEFAULT   16 frame_dummy
    40: 0000000000003db8     0 OBJECT  LOCAL  DEFAULT   21 __frame_dummy_init_array_
    41: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello_world.c
    42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    43: 000000000000215c     0 OBJECT  LOCAL  DEFAULT   20 __FRAME_END__
    44: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
    45: 0000000000003dc0     0 NOTYPE  LOCAL  DEFAULT   21 __init_array_end
    46: 0000000000003dc8     0 OBJECT  LOCAL  DEFAULT   23 _DYNAMIC
    47: 0000000000003db8     0 NOTYPE  LOCAL  DEFAULT   21 __init_array_start
    48: 0000000000002014     0 NOTYPE  LOCAL  DEFAULT   19 __GNU_EH_FRAME_HDR
    49: 0000000000003fb8     0 OBJECT  LOCAL  DEFAULT   24 _GLOBAL_OFFSET_TABLE_
    50: 0000000000001000     0 FUNC    LOCAL  DEFAULT   12 _init
    51: 00000000000011e0     5 FUNC    GLOBAL DEFAULT   16 __libc_csu_fini
    52: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
    53: 0000000000004000     0 NOTYPE  WEAK   DEFAULT   25 data_start
    54: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    55: 00000000000011e8     0 FUNC    GLOBAL HIDDEN    17 _fini
    56: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.2.5
    57: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    58: 0000000000004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    59: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    60: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    61: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    62: 0000000000001170   101 FUNC    GLOBAL DEFAULT   16 __libc_csu_init
    63: 0000000000004018     0 NOTYPE  GLOBAL DEFAULT   26 _end
    64: 0000000000001060    47 FUNC    GLOBAL DEFAULT   16 _start
    65: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    66: 0000000000001149    32 FUNC    GLOBAL DEFAULT   16 main
    67: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    68: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    69: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;符号解析&#34;&gt;符号解析&lt;/h2&gt;
&lt;p&gt;链接器解析符号引用的方法是将&lt;strong&gt;每个引用&lt;/strong&gt;与它输入的可重定位目标文件的符号表中的一个确定的&lt;strong&gt;符号定义&lt;/strong&gt;关联起来。&lt;/p&gt;
&lt;p&gt;对于引用和定义在相同模块中的局部符号（即对应static变量）的引用，符号解析非常简洁明了。编译器只允许每个局部符号有一个定义。&lt;/p&gt;
&lt;p&gt;对于全局符号的引用较为复杂，当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表，交给链接器处理。如果链接器在其他任何模块中都找不到这个被引用的符号，就输出一条错误信息并终止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器通过重整的编码方式来区分重载的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;链接器解析多重定义的全局符号&#34;&gt;链接器解析多重定义的全局符号&lt;/h3&gt;
&lt;p&gt;编译器向汇编器输出每个全局符号，或是强或是弱的，而汇编器把这些信息隐含地编码在可重定位目标文件的符号表里。&lt;strong&gt;函数和已初始化的全局变量&lt;/strong&gt;是强符号，&lt;strong&gt;未初始化的全局变量&lt;/strong&gt;是弱符号。&lt;/p&gt;
&lt;p&gt;Linux使用以下规则处理多重定义的符号名：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许由多个同名强符号&lt;/li&gt;
&lt;li&gt;如果一个强符号和多个弱符号同名，选择强符号&lt;/li&gt;
&lt;li&gt;如果有多个弱符号同名，从这些弱符号中任意选一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与静态库链接&#34;&gt;与静态库链接&lt;/h3&gt;
&lt;p&gt;所有编译器都有一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，它可以用作链接器的输入。链接器构造一个输出的可执行文件时，只复制静态库里被应用程序引用的目标模块。&lt;/p&gt;
&lt;p&gt;Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小，存档文件名由后缀&lt;code&gt;.a&lt;/code&gt;标识。&lt;/p&gt;
&lt;h3 id=&#34;链接器如何使用静态库来解析引用&#34;&gt;链接器如何使用静态库来解析引用&lt;/h3&gt;
&lt;p&gt;链接器从左到右按照在命令行上出现的顺序来扫描可重定位目标文件和存档文件。（编译器驱动程序自动将&lt;code&gt;.c&lt;/code&gt;文件翻译为&lt;code&gt;.o&lt;/code&gt;文件。在扫描中，链接器维护一个可重定位目标文件的集合E，一个未解析的符号集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U、D均为空。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果时目标文件则将其添加到E中，修改U和D来反映f中的符号引用和定义&lt;/li&gt;
&lt;li&gt;如果f是存档文件，链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m定义了一个符号来解析U中的一个引用，那么就把m加到E中，并修改U和D来反映m中的符号定义和引用。对存档文件依次重复这个过程直到U和D不发生变化。&lt;/li&gt;
&lt;li&gt;如果链接器完成对命令行输入文件的扫描后，U是非空的，则链接器输出错误并终止。否则，合并然后重定位E中的文件，构建可执行文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重定位&#34;&gt;重定位&lt;/h2&gt;
&lt;p&gt;链接器完成符号解析这一步后，就把代码中的每个符号引用和一个符号定义关联起来了，此时链接器就知道它的输入目标模块中的代码和数据节的确切大小。然后就可以开始重定位步骤了，该步骤将&lt;strong&gt;合并输入模块&lt;/strong&gt;，并为每个符号分配&lt;strong&gt;运行时地址&lt;/strong&gt;。共分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重定位节和符号定义&lt;/li&gt;
&lt;li&gt;重定位节中的符号引用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重定位条目&#34;&gt;重定位条目&lt;/h3&gt;
&lt;h3 id=&#34;重定位符号引用&#34;&gt;重定位符号引用&lt;/h3&gt;
&lt;h2 id=&#34;可执行目标文件&#34;&gt;可执行目标文件&lt;/h2&gt;
&lt;p&gt;转化后的&lt;strong&gt;二进制&lt;/strong&gt;的可执行目标文件包含加载程序到内存并运行它所需的所有信息。&lt;/p&gt;
&lt;p&gt;可执行目标文件格式类似于可重定位目标文件，ELF头描述文件的总体格式，还包括程序的入口点，即程序要运行时执行的第一条指令的地址。&lt;code&gt;.init&lt;/code&gt;节定义了一个小函数&lt;code&gt;_init&lt;/code&gt;，程序初始化代码会调用它。&lt;/p&gt;
&lt;p&gt;可执行文件是完全链接的（已经被重定位），所以它不需要rel节。&lt;/p&gt;
&lt;p&gt;ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系&lt;/p&gt;
&lt;h2 id=&#34;加载可执行目标文件&#34;&gt;加载可执行目标文件&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;shell认为prog是一个可执行目标文件，通过调用驻留在存储器中的&lt;strong&gt;加载器&lt;/strong&gt;的系统代码来运行它。加载器将可执行目标文件中的代码和数据从磁盘复制到内存，然后通过跳转到程序的入口点运行该程序。这整个过程叫做加载。&lt;/p&gt;
&lt;p&gt;每个Linux程序都有一个运行时内存映像。在Linux x86-64中，代码段总是从地址0x400000开始，后面是数据段。运行时堆在数据段之后，通过调用&lt;code&gt;malloc&lt;/code&gt;库向上增长。&lt;strong&gt;堆&lt;/strong&gt;后面的区域是为&lt;strong&gt;共享模块&lt;/strong&gt;保留的。用户&lt;strong&gt;栈&lt;/strong&gt;总是从最大合法地址($2^{48}-1$)开始，向较小内存地址增长。栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202112242026815.png&#34; alt=&#34;image-20211224202617709&#34;&gt;&lt;/p&gt;
&lt;p&gt;加载与之后章节的进程、虚拟内存和内存映射有关。之后章节还会介绍。&lt;/p&gt;
&lt;h2 id=&#34;动态链接共享库&#34;&gt;动态链接共享库&lt;/h2&gt;
&lt;p&gt;静态库有一个缺点，需要定期维护和更新，如果应用程序需要一个新版本，必须以某种方式了解到该库的变化情况，然后显式地将其程序与更新了的库重新连接。&lt;/p&gt;
&lt;p&gt;另一个问题是几乎每个C程序都使用标准I/O函数。运行时这些代码会被复制到每个运行进程的文本中，在一个上百个进程的系统上，这是对内存资源的极大浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享库&lt;/strong&gt;用来解决静态库的缺陷，共享库是一个目标模块，在&lt;strong&gt;运行或加载时&lt;/strong&gt;，可以加载到任意内存地址，并与一个在内存中的程序链接起来。这个过程称为&lt;strong&gt;动态链接&lt;/strong&gt;，由叫做动态链接器的程序执行。Linux中用&lt;code&gt;.so&lt;/code&gt;后缀的文件来表示共享库，Windows中使用&lt;code&gt;.dll&lt;/code&gt;表示。&lt;/p&gt;
&lt;p&gt;任何给定文件系统中，对于一个库文件只有一个&lt;code&gt;.so&lt;/code&gt;文件。所有引用该库的可执行目标文件共享这个&lt;code&gt;.so&lt;/code&gt;文件中的数据和代码，不需要都复制和嵌入到引用它们的可执行文件中。&lt;/p&gt;
&lt;p&gt;在内存中，一个共享库的&lt;code&gt;.text&lt;/code&gt;节的一个副本可以被不同的正在运行的进程共享。第9章虚拟内存的内容中将更加详细地描述。&lt;/p&gt;
&lt;h2 id=&#34;位置无关代码&#34;&gt;位置无关代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可以加载而无需重定位&lt;/strong&gt;的代码称为位置无关代码（Position Independent Code, PIC）。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。&lt;/p&gt;
&lt;h3 id=&#34;pic数据引用&#34;&gt;PIC数据引用&lt;/h3&gt;
&lt;h3 id=&#34;pic函数调用&#34;&gt;PIC函数调用&lt;/h3&gt;
&lt;h2 id=&#34;库打桩机制&#34;&gt;库打桩机制&lt;/h2&gt;
&lt;p&gt;库打桩允许我们截获对共享库函数的调用，取而代之执行自己的代码。使用该机制可以追踪对某个特殊库函数的调用次数，验证和追踪其输入输出值，或将其替换为一个完全不同的实现。&lt;/p&gt;
&lt;p&gt;给定一个需要打桩的目标函数，创建一个包装函数，其原型与目标函数完全相同，使用某种特殊打桩机制，就可以欺骗系统调用包装函数而不是目标函数。&lt;/p&gt;
&lt;p&gt;打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。&lt;/p&gt;
&lt;h3 id=&#34;编译时打桩&#34;&gt;编译时打桩&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//int.c
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; malloc(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt;);
    free(p);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//malloc.h
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#define malloc(size) mymalloc(size)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define free(ptr) myfree(ptr)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mymalloc&lt;/span&gt;(size_t size);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;myfree&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//mymalloc.c
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//#define COMPILETIME
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#ifdef COMPILETIME
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mymalloc&lt;/span&gt;(size_t size) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; malloc(size);
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;malloc(%d)=%p&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;)size, ptr);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr;
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;myfree&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr) {
    free(ptr);
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;free(%p)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, ptr);
}
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ gcc -DCOMPILETIME -c mymalloc.c
$ gcc -I. -o intc int.c mymalloc.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行程序&lt;code&gt;intc&lt;/code&gt;得到结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ ./intc
malloc&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;32&lt;span style=&#34;color:#333&#34;&gt;)=&lt;/span&gt;0x561e0ca432a0
free&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;0x561e0ca432a0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;链接时打桩&#34;&gt;链接时打桩&lt;/h3&gt;
&lt;p&gt;Linux静态链接器支持用&lt;code&gt;--wrap f&lt;/code&gt;标志进行链接时打桩。&lt;/p&gt;
&lt;h3 id=&#34;运行时打桩&#34;&gt;运行时打桩&lt;/h3&gt;
&lt;p&gt;编译时打桩需要访问源程序，链接时打桩需要访问程序的可重定位目标文件。有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个机制基于动态链接器的LD_PRELOAD环境变量。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——TopK问题总结</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
        <pubDate>Sat, 11 Dec 2021 10:18:53 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/ -&lt;p&gt;从具有n个数的数组中，找出最大的k数。&lt;/p&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;p&gt;将整个数组排序，取出前k大个数。&lt;/p&gt;
&lt;p&gt;时间复杂度：$O(n\log_2 n)$&lt;/p&gt;
&lt;p&gt;优化方法：只排序最大的k个数&lt;/p&gt;
&lt;h2 id=&#34;局部排序&#34;&gt;局部排序&lt;/h2&gt;
&lt;p&gt;进行k次冒泡排序，得到最大的k个数&lt;/p&gt;
&lt;p&gt;时间复杂度：$O(n\cdot k)$&lt;/p&gt;
&lt;p&gt;优化方法：只找出最大的k个数，不对它们进行排序&lt;/p&gt;
&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;
&lt;p&gt;先用前k个元素生成一个小根堆，接着从第k+1个元素开始扫描，与堆顶元素进行比较，若被扫描元素大于堆顶，则将其替换，然后调整堆。&lt;/p&gt;
&lt;p&gt;时间复杂度：$O(n\log_2 k)$&lt;/p&gt;
&lt;h2 id=&#34;随机选择&#34;&gt;随机选择&lt;/h2&gt;
&lt;p&gt;减治法，使用快速排序中的partition找到第k大元素，递归时当前半部分小于k时就求后半部分第k-i大元素，当前半部分大于k时就求前半部分第k大元素。&lt;/p&gt;
&lt;p&gt;时间复杂度为$O(n)$&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278&#34;&gt;拜托，面试别再问我TopK了！！！&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95topk%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——基础查找算法实现</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 11 Dec 2021 09:49:24 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/ -&lt;h2 id=&#34;二分查找&#34;&gt;二分查找&lt;/h2&gt;
&lt;p&gt;只能在有序数组中进行二分查找。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;binarySearch&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {\
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt; high) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; high) &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[mid] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; k)
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;true&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; {
			binarySearch(nums, k, low, mid &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);
            binarySearch(nums, k, mid &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, high);
        }
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;二叉查找树&#34;&gt;二叉查找树&lt;/h2&gt;
&lt;p&gt;查找、插入都非常简单。&lt;/p&gt;
&lt;h2 id=&#34;平衡查找树&#34;&gt;平衡查找树&lt;/h2&gt;
&lt;p&gt;2-3树和红黑树，详见&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/&#34;&gt;算法——红黑树&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;散列表&#34;&gt;散列表&lt;/h2&gt;
&lt;h3 id=&#34;散列函数的构造方法&#34;&gt;散列函数的构造方法&lt;/h3&gt;
&lt;p&gt;构造散列函数时的注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;散列函数的定义域要包含&lt;strong&gt;全部的关键字&lt;/strong&gt;，而值域范围则依赖于散列表大小或地址范围。&lt;/li&gt;
&lt;li&gt;散列函数计算出的地址应该能&lt;strong&gt;等概率、均匀地&lt;/strong&gt;分布在整个地址空间中&lt;/li&gt;
&lt;li&gt;散列函数应&lt;strong&gt;尽量简单&lt;/strong&gt;，能在&lt;strong&gt;较短时间内计算出&lt;/strong&gt;任一关键字对应的散列地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;直接定址法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接取关键字的某个线性函数值为散列地址，散列函数为：
$$
H(key)=key或H(key)=a\times key +b
$$
这种方法较为简单且不会产生冲突，适合关键字分布基本连续的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除留余数法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种最简单、最常用的方法。假定散列表表厂为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址：
$$
\text{H(key)=key%p}
$$
该方法的关键是选好p。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字分析法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平方取中法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取关键字的平方值的中间几位作为散列地址。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。&lt;/p&gt;
&lt;h3 id=&#34;处理冲突的方法&#34;&gt;处理冲突的方法&lt;/h3&gt;
&lt;p&gt;发生冲突时的处理方法，即为产生冲突的关键字寻找&lt;strong&gt;下一个空的Hash地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开放定址法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开放定址法指的是&lt;strong&gt;可存放新表项的空闲地址&lt;/strong&gt;既向它的&lt;strong&gt;同义&lt;/strong&gt;表项开放，又向它的&lt;strong&gt;非同义&lt;/strong&gt;词表项开放。数学递推公式为：
$$
H_i=(H(key)+d_i)%m
$$
$H(key)$为散列函数；i=0,1,2,&amp;hellip;,k；$m$表示散列表表长；$d_i$为增量序列。&lt;/p&gt;
&lt;p&gt;取定某一增量序列后，对应处理方法就确定了，通常有以下四种取法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测法&lt;/strong&gt;：$d_i=0,1,2,&amp;hellip;,m-1$。冲突发生时，顺序查看表中&lt;strong&gt;下一个单元&lt;/strong&gt;，直到找出一个空闲地址或查遍全表。这种方法可能会造成大量元素在&lt;strong&gt;相邻散列地址上的聚集&lt;/strong&gt;，大大降低了查找效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平方探测法&lt;/strong&gt;：$d_i=0^2,1^2,-1^2,2^2,-2^2,&amp;hellip;,k^2,-k^2$。其中$k\leq m/2$，散列表m的长度m必须是一个可以表示成4k+3的素数。平方探测法可以&lt;strong&gt;避免堆积&lt;/strong&gt;，但是不能探测到散列表上的所有单元。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再散列法&lt;/strong&gt;：$d_i=Hash_2(key)$。需要使用&lt;strong&gt;两个散列函数&lt;/strong&gt;。利用第二个散列函数计算该关键字的地址增量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伪随机序列法&lt;/strong&gt;：$d_i=伪随机序列$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;拉链法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有的同义词存储在&lt;strong&gt;一个线性链表&lt;/strong&gt;中，这个线性链表由其散列地址唯一标识。这种方法适用于&lt;strong&gt;经常进行插入和删除&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;h3 id=&#34;性能分析&#34;&gt;性能分析&lt;/h3&gt;
&lt;p&gt;查找的时间为$O(1)$.&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 