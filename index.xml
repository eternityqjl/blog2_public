<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sun, 17 Jul 2022 13:32:48 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>动态库和静态库实操</title>
        <link>https://eternityqjl.top/posts/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%AE%9E%E6%93%8D/</link>
        <pubDate>Sun, 17 Jul 2022 13:32:48 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%AE%9E%E6%93%8D/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%AE%9E%E6%93%8D/ -&lt;p&gt;之前在学习csapp的 &lt;a href=&#34;https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/&#34;&gt;链接&lt;/a&gt; 章节时学习了静态库和动态库的相关内容，但并没有在实际的开发中实践过。最近在公司开始接触项目后遇到一些编译时链接动态库相关内容，不太熟悉，所以在这里总结一下。&lt;/p&gt;
&lt;h2 id=&#34;静态库的制作和使用&#34;&gt;静态库的制作和使用&lt;/h2&gt;
&lt;p&gt;文件结构如下图所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;.
├── include
│   └── calculate.h
├── lib
│   └── libcalculate.a
├── main
├── main.c
└── src
    ├── add.c
    ├── add.o
    ├── multiple.c
    └── multiple.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中各个文件的内容如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;calculate.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;multiple&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;calculate.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b)
{
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;multiple.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;calculate.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;multiple&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b)
{
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;calculate.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;2 + 3 = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, add(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;));
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;2 * 3 = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, multiple(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;));
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;编译生成二进制o文件&#34;&gt;编译生成二进制&lt;code&gt;.o&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;.o&lt;/code&gt;文件是库的原型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#007020&#34;&gt;cd&lt;/span&gt; src
gcc *.c -c -I ../include/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-I&lt;/code&gt;指定了头文件的搜索路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-c&lt;/code&gt;只编译，不链接&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;打包o文件&#34;&gt;打包&lt;code&gt;.o&lt;/code&gt;文件&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ar rcs libcalculate.a *.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后将得到的静态库移动到&lt;code&gt;./lib&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;静态库的使用&#34;&gt;静态库的使用&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;main.c&lt;/code&gt;中使用这个编译好的静态库。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#007020&#34;&gt;cd&lt;/span&gt; ../
gcc main.c -I ./include/ -L ./lib -l caculate -o main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gcc中使用到的参数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-I&lt;/code&gt; : 指定头文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-L&lt;/code&gt; : 指定库文件位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; : 指定库的名称，库的名称结构为&lt;code&gt;lib库名称.a&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态库的制作和使用&#34;&gt;动态库的制作和使用&lt;/h2&gt;
&lt;h3 id=&#34;生成o文件&#34;&gt;生成&lt;code&gt;.o&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;在src目录下制作&lt;code&gt;.o&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;gcc *.c -c -fpic -I ../include/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-fpic&lt;/code&gt;参数代表用来生成与位置无关的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;打包o文件-1&#34;&gt;打包&lt;code&gt;.o&lt;/code&gt;文件&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;gcc -shared -o libmycalculate.so *.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-shared&lt;/code&gt;代表生成动态库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态库的使用&#34;&gt;动态库的使用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;gcc -I ./include/ -L ./lib/ -l mycaculate main.c -o main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时我们需要配置动态库使得操作系统在运行可执行文件的时候可以找到它。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ld.so.conf.d/*.conf&lt;/code&gt;的配置文件中添加该动态库的路径，保存后使用&lt;code&gt;ldconfig&lt;/code&gt;命令使配置生效。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/YQXLLWY/article/details/119812531&#34;&gt;C语言静态库和动态库实操&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E5%AE%9E%E6%93%8D/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Socket通信总结</title>
        <link>https://eternityqjl.top/posts/socket%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/</link>
        <pubDate>Thu, 14 Jul 2022 21:56:32 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/socket%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/socket%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/ -&lt;h2 id=&#34;客户端建立连接&#34;&gt;客户端建立连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;socket()&lt;/code&gt;系统调用创建一个套接字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;connect()&lt;/code&gt;系统调用将套接字连接到特定地址的服务器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始发送和接收数据。一般使用&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;系统调用来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务器建立连接&#34;&gt;服务器建立连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;socket()&lt;/code&gt;系统调用创建一个套接字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;bing()&lt;/code&gt;系统调用将套接字绑定到一个IP上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;listen()&lt;/code&gt;系统调用监听连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;accept()&lt;/code&gt;系统调用接受一个连接请求。这个调用一般会被阻塞，直到一个客户端与服务器建立连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始发送和接收数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;套接字类型&#34;&gt;套接字类型&lt;/h2&gt;
&lt;h3 id=&#34;stream-sockets&#34;&gt;stream sockets&lt;/h3&gt;
&lt;p&gt;连续的字节流，使用TCP (Transmission Control Protocol) 协议，不可靠，面向流。&lt;/p&gt;
&lt;h3 id=&#34;datagram-sockets&#34;&gt;datagram sockets&lt;/h3&gt;
&lt;p&gt;使用UDP (Unix Datagram Protocol) 协议，可靠的，面向消息。&lt;/p&gt;
&lt;h2 id=&#34;domain&#34;&gt;domain&lt;/h2&gt;
&lt;h3 id=&#34;unix-domain&#34;&gt;Unix domain&lt;/h3&gt;
&lt;h3 id=&#34;internet-domain&#34;&gt;Internet domain&lt;/h3&gt;
- https://eternityqjl.top/posts/socket%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>FreeRTOS操作系统总结</title>
        <link>https://eternityqjl.top/posts/freertos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</link>
        <pubDate>Mon, 11 Jul 2022 21:39:22 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/freertos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/freertos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/ -&lt;p&gt;本文来总结一些FreeRTOS的基本概念和API的使用，部分内容参考自：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.arterytek.com/download/AN0025_FreeRTOS_on_AT32_MCU_ZH_V1.0.0.pdf&#34;&gt;AN0025 应用笔记FreeRTOS on AT32 MCU - 雅特力&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;freertos中断优先级管理&#34;&gt;FreeRTOS中断优先级管理&lt;/h2&gt;
&lt;h3 id=&#34;at32stm32中断配置&#34;&gt;AT32/STM32中断配置&lt;/h3&gt;
&lt;p&gt;一般配置NVIC_PriorityGroup_4，只使用中断优先级寄存器的高四位，一共可以表示2^4=16级中断优先级，NVIC_PriorityGroup_4只有16级抢占优先级，没有子优先级。&lt;/p&gt;
&lt;h3 id=&#34;freertos中断配置&#34;&gt;FreeRTOS中断配置&lt;/h3&gt;
&lt;p&gt;一般配置用户可以在抢占优先级为3-15的中断里面调用FreeRTOS的API函数。&lt;/p&gt;
&lt;h3 id=&#34;中断优先级和任务优先级&#34;&gt;中断优先级和任务优先级&lt;/h3&gt;
&lt;p&gt;二者没有关系，中断的优先级永远高于任何任务的优先级。&lt;/p&gt;
&lt;h3 id=&#34;临界段保护&#34;&gt;临界段保护&lt;/h3&gt;
&lt;p&gt;临界段代码也成为临界区，指哪些必须完整运行不能被打断的代码。例如一些外设的初始化，需要遵循严格的时序要求。FreeRTOS采用的是在进入临界区代码后关闭中断，退出临界区的时候打开中断。FreeRTOS系统很多程序段都加了临界区保护，在写应用程序的时候也有很多地方需要用到临界区保护。&lt;/p&gt;
&lt;p&gt;与临界段代码保护有关的函数有以下4个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;taskENTER_CRITICAL()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入临界区，关中断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;taskEXIT_CRITICAL()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;退出临界区，开中断&lt;/p&gt;
&lt;p&gt;&lt;code&gt;taskENTER_CRITICAL_FROM_ISR()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入临界区，关中断（ISR中使用）&lt;/p&gt;
&lt;h2 id=&#34;任务管理&#34;&gt;任务管理&lt;/h2&gt;
&lt;h3 id=&#34;裸机与带rtos的区别&#34;&gt;裸机与带RTOS的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;裸机系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个大循环顺序执行，每一部分的操作都不是实时性的。为了解决这个问题，引入了中断，紧急事件可以放到中断中执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RTOS运行流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调度器使用调度算法来决定当前要执行的任务，从而实现多任务系统。这里所说的多任务系统同一时刻只能有一个任务可以运行，只能通过调度器决策，看起来像所有任务同时运行一样。&lt;/p&gt;
&lt;h3 id=&#34;freertos任务状态&#34;&gt;FreeRTOS任务状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运行态 - Running&lt;/li&gt;
&lt;li&gt;就绪态 - Ready&lt;/li&gt;
&lt;li&gt;阻塞态 - Blocked&lt;/li&gt;
&lt;li&gt;挂起态 - Suspended&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202203081633973.png&#34; alt=&#34;FreeRTOS任务状态转换关系&#34;&gt;&lt;/p&gt;
&lt;p&gt;阻塞态和挂起态的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞指的是进程由于发生某事件（例如I/O请求、申请缓冲区失败）暂时无法继续执行，引起进程调度，把CPU让给其他就绪进程。挂起是由于系统和用户的需要引入的操作，进程被挂起意味着该进程处于静止状态，如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度。&lt;/li&gt;
&lt;li&gt;二者的共同点是进程都暂停执行，并且都释放了CPU，即两个过程都涉及上下文切换&lt;/li&gt;
&lt;li&gt;不同点是：
&lt;ul&gt;
&lt;li&gt;对系统资源占用不同&lt;/li&gt;
&lt;li&gt;发生时机和恢复时机不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;freertos空闲任务&#34;&gt;FreeRTOS空闲任务&lt;/h3&gt;
&lt;p&gt;空闲任务是系统任务，是必须要执行的，一个RTOS每时每刻都要有一个任务执行，这个空闲任务还可以做一些其他工作，例如进入低功耗等。&lt;/p&gt;
&lt;h2 id=&#34;任务调度&#34;&gt;任务调度&lt;/h2&gt;
&lt;p&gt;FreeRTOS共有三种任务调度方式：合作式、抢占式、时间片式。&lt;/p&gt;
&lt;h3 id=&#34;合作式调度&#34;&gt;合作式调度&lt;/h3&gt;
&lt;p&gt;主要用于资源很紧张的设备，现在已经很少使用。不作详细介绍。&lt;/p&gt;
&lt;h3 id=&#34;抢占式调度&#34;&gt;抢占式调度&lt;/h3&gt;
&lt;p&gt;调度器：使用相关的调度算法决定当前需要执行的任务。&lt;/p&gt;
&lt;p&gt;所有调度器有一个共同的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度器可以区分就绪态任务和挂起任务&lt;/li&gt;
&lt;li&gt;调度器可以选择就绪态中的一个任务，然后激活他。&lt;/li&gt;
&lt;li&gt;不同调度器的最大区别就是如何分配就绪态任务的完成时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抢占式调度就是调度器算法的一种。实际应用中，不同的任务需要不同的响应时间。&lt;/p&gt;
&lt;h3 id=&#34;时间片调度&#34;&gt;时间片调度&lt;/h3&gt;
&lt;p&gt;最常用的时间片调度算法就是Round-robin调度算法。&lt;/p&gt;
&lt;h2 id=&#34;消息队列&#34;&gt;消息队列&lt;/h2&gt;
&lt;h3 id=&#34;消息队列基本概念&#34;&gt;消息队列基本概念&lt;/h3&gt;
&lt;p&gt;通过RTOS内核提供的服务，任务或中断服务子程序可以将一个消息放入到队列；同样，一个或多个任务可以通过RTOS内核服务从队列中得到消息。&lt;/p&gt;
&lt;p&gt;在裸机编程中，相比于消息队列，使用全局数组主要有如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用消息队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意在操作系统中实现中断服务程序与裸机是不同的，主要有以下几点要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果FreeRTOS工程中的中断函数没有调用FreeRTOS的消息队列API函数，那么就与裸机编程是一样的。&lt;/li&gt;
&lt;li&gt;如果调用了FreeRTOS的消息队列API函数，退出时要检测是否有高优先级任务就绪，如果有则需要在退出中断后进行任务切换。&lt;/li&gt;
&lt;li&gt;在使用AT32芯片时将中断优先级分组设置为组4，即NVIC_PriorityGroup_4&lt;/li&gt;
&lt;li&gt;要在FreeRTOS多任务开启前就设置好优先级分组，一旦设置好就不可修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息队列相关api&#34;&gt;消息队列相关API&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xQueueCreate()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建一个消息队列，返回该队列的句柄。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xQueueSend()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;向指定消息队列发送一个消息，返回值为发送消息成功与否的标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xQueueSendFromISR()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在中断处理函数中，发送消息的函数，返回值为发送消息成功与否标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xQueueReceive()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从指定消息队列内接受消息，返回值为接受消息成功与否标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xQueueReceiveFromISR()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在中断处理函数中从指定消息队列内接受消息。&lt;/p&gt;
&lt;h2 id=&#34;信号量&#34;&gt;信号量&lt;/h2&gt;
&lt;h3 id=&#34;freertos信号量的概念&#34;&gt;FreeRTOS信号量的概念&lt;/h3&gt;
&lt;p&gt;给共享资源建立一个标志，该标志表示该共享资源被占用的情况。&lt;/p&gt;
&lt;p&gt;实际中使用信号量主要来实现两个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个任务之间或中断函数和任务之间的同步功能，就是共享资源为1的时候&lt;/li&gt;
&lt;li&gt;多个共享资源的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二值信号量&#34;&gt;二值信号量&lt;/h3&gt;
&lt;p&gt;常用于互斥访问或同步。&lt;/p&gt;
&lt;p&gt;信号量API函数也允许设置一个阻塞时间，阻塞时间指的是当任务获取信号量的时候由于信号量无效而进入阻塞状态的最大时间节拍数。&lt;/p&gt;
&lt;h4 id=&#34;二值信号量api&#34;&gt;二值信号量API&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreCreateBinary()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建一个二值信号量，返回值为创建的二值信号量的句柄SemaphoreHandle_t&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreCreateBinaryStatic()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;静态创建一个二值信号量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vSemaphoreDelete()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除一个信号量，无返回值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreGive()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;释放一个信号量，返回值为释放成功与否标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreFromISR()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;内释放一个信号量（中断级）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreTake()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个信号量，返回值为获取成功与否标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreTakeFromISR()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个信号量（中断级）&lt;/p&gt;
&lt;h4 id=&#34;二值信号量例程&#34;&gt;二值信号量例程&lt;/h4&gt;
&lt;h3 id=&#34;计数型信号量&#34;&gt;计数型信号量&lt;/h3&gt;
&lt;p&gt;又称为数值信号量，是可以大于1的信号量。信号量的本质就是队列，只是不用关注队列中存放了什么消息，只需关注队列是否满即可。计数型信号量的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件计数：每次事件发生前就在事件处理函数中释放信号量（增加信号量的计数值），其他任务事件会获取信号值，获取一次就在任务事件处理函数中对信号量减1操作。该场合下创建的计数信号量的初始值为0。&lt;/li&gt;
&lt;li&gt;资源管理：该场景下，信号量代表当前资源的可用数量。任务事件获取一次资源后信号量的值就减1操作，任务事件释放一次资源后信号量加1操作。该场合中信号量的初始值为资源的总数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;计数型信号量api&#34;&gt;计数型信号量API&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreCreateCounting()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建一个计数型信号量，返回创建的计数型信号量的句柄。函数的两个参数为该信号量允许的最大值和信号量的初始值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vSemaphoreDelete()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreGive()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreTake()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uxSemaphoreGetCount()&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;计数型信号量例程&#34;&gt;计数型信号量例程&lt;/h4&gt;
&lt;p&gt;测试一下&lt;/p&gt;
&lt;h3 id=&#34;互斥信号量&#34;&gt;互斥信号量&lt;/h3&gt;
&lt;h4 id=&#34;优先级翻转&#34;&gt;优先级翻转&lt;/h4&gt;
&lt;p&gt;使用二值信号量的时候很有可能碰到优先级翻转的问题，这在可剥夺型内核中很常见。但实时系统中不允许出现这样的情况，这回打乱系统的预期执行顺序，导致低优先级的任务先运行，违背了实时性的初衷。&lt;/p&gt;
&lt;h4 id=&#34;互斥信号量介绍&#34;&gt;互斥信号量介绍&lt;/h4&gt;
&lt;p&gt;为了资源互斥访问而设计。&lt;/p&gt;
&lt;p&gt;互斥信号量采取了措施尽量&lt;strong&gt;回避优先级翻转&lt;/strong&gt;的问题。当一个高优先级任务想要获取互斥信号量但该信号量被某低优先级的任务所持有，此时高优先级任务会进入阻塞态，在进入阻塞态之前此高优先级的任务会将持有互斥信号量的低优先级的任务的优先级提高到和高优先级任务相同。&lt;/p&gt;
&lt;p&gt;这样持有互斥信号量的低优先级任务就不会被其他中间等级优先级的任务所抢占CPU的使用权，尽可能地缩短了高优先级任务的响应时间。&lt;/p&gt;
&lt;h4 id=&#34;互斥信号量api&#34;&gt;互斥信号量API&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreCreateMutex()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建一个互斥信号量，返回创建的互斥信号量的句柄。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vSemaphoreDelete()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreGive()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreTake()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uxSemaphoreGetCount()&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;互斥信号量例程&#34;&gt;互斥信号量例程&lt;/h4&gt;
&lt;h3 id=&#34;递归互斥信号量&#34;&gt;递归互斥信号量&lt;/h3&gt;
&lt;p&gt;是一个特殊的互斥信号量，已经获取了互斥信号量的任务就不能再次获取这个互斥信号量了，而递归互斥信号量则不同，在同一个任务中，此任务可以多次获得互斥递归信号量。一旦一个任务获得了递归互斥信号量，那么其他任务便不能获得此信号量，只能本身再次获取此递归互斥信号量。&lt;/p&gt;
&lt;h4 id=&#34;互斥递归信号量api&#34;&gt;互斥递归信号量API&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreCreateRecursiveMutex()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreCreateRecursiveMutexStatic()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vSemaphoreDelete()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreGiveRecursive()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xSemaphoreTakeRecursive()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件标志组&#34;&gt;事件标志组&lt;/h2&gt;
&lt;p&gt;事件标志组与消息队列、信号量一样，都是FreeRTOS内核提供的一种内核服务，在任务绒布中应用非常广泛。&lt;/p&gt;
&lt;h3 id=&#34;eventgroup概念&#34;&gt;EventGroup概念&lt;/h3&gt;
&lt;p&gt;事件标志组是FreeRTOS内核提供的一种服务，是实现多任务的有效机制之一。Event Group实质上是内核管理的一个变量，任务通过设置这个变量的不同BIT位，达到同步的效果。&lt;/p&gt;
&lt;p&gt;使用全局变量相比于事件标志组主要有以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Event Group可以让RTOS内核有效地管理任务，而全局变量无法做到，任务的超时等机制需要用户自己实现&lt;/li&gt;
&lt;li&gt;使用了全局变量就要防止多任务的访问冲突，而Event Group就不需要担心该问题&lt;/li&gt;
&lt;li&gt;使用Event Group可以解决中断服务程序和任务之间的同步问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;eventgroup-api&#34;&gt;EventGroup API&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xEventGroupCreate()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回创建的事件标志组的句柄&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xEventGroupSetBits()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个事件标志组对应的BIT位，返回事件标志组的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xEventGroupWaitBits()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等待事件标志组的对应BIT位，返回事件标志组的值&lt;/p&gt;
&lt;h2 id=&#34;软件定时器组&#34;&gt;软件定时器组&lt;/h2&gt;
&lt;h3 id=&#34;freertos软件定时器概念&#34;&gt;FreeRTOS软件定时器概念&lt;/h3&gt;
&lt;p&gt;内核提供的一种服务。FreeRTOS的软件定时器组的时基是基于&lt;strong&gt;系统时钟节拍&lt;/strong&gt;实现的，它的实现不需要使用任何硬件定时器，而且可以创建多个。&lt;/p&gt;
&lt;p&gt;在硬件定时器中，我们是在定时器中断中实现需要的功能，而使用软件定时器时，我们是在创建软件定时器时指定软件定时器的回调函数，在回调函数中实现相应的功能。&lt;/p&gt;
&lt;p&gt;FreeRTOS的软件定时器支持单次模式和周期性模式。&lt;/p&gt;
&lt;p&gt;定时事件到后会调用定时器的回调函数，用户可以在回调函数中加入需要执行的工程代码。&lt;/p&gt;
&lt;p&gt;FreeRTOS为软件定时器专门创建了一个任务，称其为软件定时器的守护进程（Daemon Task）。该任务在系统是能了软件定时器组的功能后自动创建。&lt;/p&gt;
&lt;p&gt;用户应用程序和内核管理软件定时器程序之间通过&lt;strong&gt;消息队列&lt;/strong&gt;实现通信功能。&lt;/p&gt;
&lt;h3 id=&#34;软件定时器组api&#34;&gt;软件定时器组API&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xTimerCreate()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xTimerStart()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xTimerStop()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pcTimerGetName()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pvTimerGetTimerID()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vTimerSetTimerID()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;freertos低功耗模式&#34;&gt;FreeRTOS低功耗模式&lt;/h2&gt;
&lt;p&gt;FreeRTOS提供了一种Tickless机制来管理低功耗。&lt;/p&gt;
&lt;h3 id=&#34;tickless机制&#34;&gt;Tickless机制&lt;/h3&gt;
&lt;p&gt;tickless可理解为无滴答时钟，即滴答时钟节拍停止运行的情况。&lt;/p&gt;
&lt;p&gt;FreeRTOS中，当用户任务都被挂起或阻塞时，最低优先级的空闲任务会得到执行，我们就可以把睡眠模式放到空闲任务中。进入空闲模式后，首先要计算而可执行低功耗的最大时间，即求出下一个要执行的高优先级任务的剩余事件。然后把低功耗的唤醒时间设置为这个求出的时间，到时间系统会从低功耗模式被唤醒，继续执行多任务。&lt;/p&gt;
&lt;p&gt;实现tickless模式最麻烦的是低功耗可执行时间的获取，这个问题FreeRTOS已经做好了。&lt;/p&gt;
&lt;p&gt;用户只用在FreeRTOSConfig.h配置文件中配置宏定义configUSE_TICKLESS_IDLE为1即可。另外如果将该参数配置为2，那么用户可以自定义tickless低功耗模式的实现。当该宏定义为1且系统运行满足以下条件时，系统内核会自动调用低功耗宏定义函数portSUPPRESS_TICKS_AND_SLEEP()：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前空闲任务正在运行，所有其他任务处于挂起或阻塞状态&lt;/li&gt;
&lt;li&gt;根据用户配置configEXPECTED_IDLE_TIME_BEFORE_SLEEP的大小，只有当系统可运行于低功耗模式的时钟节拍数大于等于这个参数时，系统才可以进入到低功耗模式。用户可以重新定义该宏。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;freertos内存管理方式&#34;&gt;FreeRTOS内存管理方式&lt;/h2&gt;
&lt;p&gt;FreeRTOS内核提供了5中内存管理机制，我们可以根据应用具体需求选择合适的内存管理方式，源程序路径为：FreeRTOS/portable/MemMang&lt;/p&gt;
&lt;h3 id=&#34;方式一&#34;&gt;方式一&lt;/h3&gt;
&lt;p&gt;只能分配内存，不能释放内存。FreeRTOS的内存管理策略还会使用字节对齐。&lt;/p&gt;
&lt;h3 id=&#34;方式二&#34;&gt;方式二&lt;/h3&gt;
&lt;p&gt;使用最佳匹配算法，允许释放之前已分配的内存，但不会把相邻的内存块合并为一个大的内存块。&lt;/p&gt;
&lt;h3 id=&#34;方式三&#34;&gt;方式三&lt;/h3&gt;
&lt;p&gt;简单地封装了标准库的malloc()和free()函数，采用的封装策略是操作内存前挂起调度器，完成后再恢复调度器，封装后的malloc()和free()函数具备线程保护机制。&lt;/p&gt;
&lt;h3 id=&#34;方式四&#34;&gt;方式四&lt;/h3&gt;
&lt;p&gt;与第二种策略比较类型，增加了一个合并算法，将相邻的空闲内存块合并成一个大块。&lt;/p&gt;
&lt;h3 id=&#34;方式五&#34;&gt;方式五&lt;/h3&gt;
&lt;p&gt;允许内存堆跨越多个连续的内存区，除此之外其他操作都和第四种内存管理方式相似。&lt;/p&gt;
&lt;h2 id=&#34;freertos流缓存&#34;&gt;FreeRTOS流缓存&lt;/h2&gt;
&lt;h2 id=&#34;freertos消息缓存&#34;&gt;FreeRTOS消息缓存&lt;/h2&gt;
&lt;h2 id=&#34;freertos任务通知&#34;&gt;FreeRTOS任务通知&lt;/h2&gt;
&lt;h2 id=&#34;freertos编码风格&#34;&gt;FreeRTOS编码风格&lt;/h2&gt;
&lt;p&gt;FreeRTOS的核心源代码遵从MISRA编码标准指南。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uint32_t类型的变量使用前缀ul，表示unsigned long&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;uint32_t&lt;/span&gt; ulNotifiedValue;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;uint16_t类型的变量使用前缀us，表示unsigned short&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;uint16_t&lt;/span&gt; usStackDepth;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;uint8_t类型使用前缀uc，表示unsigned char&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; ucNotifyState;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;非stdint类型的变量使用前缀x，比如基本的Type_t和TickType_t类型；非stdint类型的无符号变量使用前缀ux，比如UbaseType_t&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;BaseType_t xReturn;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;size_t类型的变量使用前缀x；枚举类型变量使用前缀e&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;size_t xBlockSize;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;enum&lt;/span&gt; {
	eAbortSleep &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;,
	eStandardSleep,
	eNoTasksWaitingTimeout
} eSleepModeStatus;
eSleepModeStatus eReturn &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; eStandardSleep;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上eReturn变量的定义，e开头表示这个变量的类型是enum。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针类型的变量在类型基础上附加前缀p，比如指向uint32_t的指针变量的前缀为pul&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;uint32_t&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pulTopOfStack, ulTemp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;char类型变量仅被允许保存ASCII字符，前缀为c；&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; cStatus;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int8_t&lt;/span&gt; cRxLock;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数命名风格&#34;&gt;函数命名风格&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在文件作用域范围的函数前缀位prv&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;prvDeleteTCB&lt;/span&gt;(TCB_t &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pxTCB)
{
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以理解为就是static函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API函数的前缀为它们的返回类型，当返回类型为空时，前缀为v&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;vTaskDelete&lt;/span&gt;(TaskHandle_t xTaskToDelete)
{
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;API函数提供给其他模块调用，可以理解为全局函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;BaseType_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;xTaskResumeAll&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;xTaskResumeAll(void)&lt;/code&gt;函数，函数前面的x代表返回值的类型，这里是BaseType_t类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API函数名字起始部分为该函数所在的文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;QueueHandle_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;xQueueGenericCreate&lt;/span&gt;()
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;xQueueGenericCreate()&lt;/code&gt;函数定义在Queue.c中，x表示函数的返回值是QueueHandle_t类型。&lt;/p&gt;
&lt;h3 id=&#34;宏命名风格&#34;&gt;宏命名风格&lt;/h3&gt;
&lt;p&gt;宏的名字起始部分为该宏定义所在的文件名的一部分。比如configUSE_PREEMPTION定义在FreeRTOSConfig.h文件中。除了前缀，宏剩下的字母全部为大写，两个单词间用下划线&lt;code&gt;_&lt;/code&gt;隔开。&lt;/p&gt;
&lt;p&gt;在FreeRTOS/Source/inclue/queue.h中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* For internal use only. */&lt;/span&gt;
 &lt;span style=&#34;color:#579&#34;&gt;#define queueSEND_TO_BACK       ( ( BaseType_t ) 0 )
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define queueSEND_TO_FRONT      ( ( BaseType_t ) 1 )
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define  queueOVERWRITE         ( ( BaseType_t ) 2 )
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/freertos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Linux常用工具使用总结</title>
        <link>https://eternityqjl.top/posts/linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
        <pubDate>Tue, 05 Jul 2022 00:25:07 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/ -&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;h3 id=&#34;chmod&#34;&gt;chmod&lt;/h3&gt;
&lt;p&gt;修改文件夹或文件的权限。&lt;/p&gt;
&lt;p&gt;权限共分为三类：文件所有者（user）、组用户（group）、其他（others）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chmod &lt;span style=&#34;color:#963&#34;&gt;u&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;rwx,g&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;rx,o&lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt;r myfile
chmod &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;754&lt;/span&gt; myfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面两个命令是等价的，可以用字符或者八进制数两种模式来表示。&lt;/p&gt;
&lt;p&gt;权限数字为以下每个数字项目的和：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4：read&lt;/li&gt;
&lt;li&gt;2：write&lt;/li&gt;
&lt;li&gt;1：execute&lt;/li&gt;
&lt;li&gt;0：no permission&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;man&#34;&gt;man&lt;/h3&gt;
&lt;p&gt;查看某个命令的手册。&lt;/p&gt;
&lt;p&gt;查看时翻屏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向后翻一屏：space(空格键)&lt;/li&gt;
&lt;li&gt;向前翻一屏：b&lt;/li&gt;
&lt;li&gt;向后翻一行：Enter(回车键)&lt;/li&gt;
&lt;li&gt;向前翻一行：k&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看时查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/关键词  向后查找  n：下一个&lt;/li&gt;
&lt;li&gt;?关键词  向前查找  N：前一个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按&lt;code&gt;ESC+u&lt;/code&gt;取消搜索&lt;/p&gt;
&lt;h2 id=&#34;tmux&#34;&gt;tmux&lt;/h2&gt;
&lt;p&gt;部分内容参考自&lt;a href=&#34;https://www.ruanyifeng.com/blog/2019/10/tmux.html&#34;&gt;Tmux 使用教程-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;启动与退出&#34;&gt;启动与退出&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进入Tmux窗口。&lt;/p&gt;
&lt;p&gt;按&lt;code&gt;Ctrl+d&lt;/code&gt;或者输入&lt;code&gt;exit&lt;/code&gt;命令就可退出Tmux。&lt;/p&gt;
&lt;h3 id=&#34;前缀键ctrlx&#34;&gt;前缀键&lt;code&gt;Ctrl+x&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;通过前缀键唤出其他快捷键。&lt;/p&gt;
&lt;h3 id=&#34;会话管理&#34;&gt;会话管理&lt;/h3&gt;
&lt;p&gt;新建会话：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux new -s &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分离会话：&lt;/p&gt;
&lt;p&gt;在Tmux窗口按下&lt;code&gt;Ctrl+x d&lt;/code&gt;或者输入&lt;code&gt;tmux detach&lt;/code&gt;命令就会将当前会话与窗口分离。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux detach
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看所有会话：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux ls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接入会话（重新从默认中断接入已存在的某个会话）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux attach -t &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;杀死会话：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux kill-session -t &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切换会话：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux switch -t &amp;lt;session-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重命名会话：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux rename-session -t &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;0&lt;/span&gt; &amp;lt;new-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;窗格操作&#34;&gt;窗格操作&lt;/h3&gt;
&lt;p&gt;将窗口划分为多个窗格，每个窗格运行不同命令。&lt;/p&gt;
&lt;p&gt;划分窗格：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# 划分上下两个窗格&lt;/span&gt;
$ tmux split-window
&lt;span style=&#34;color:#888&#34;&gt;# 划分左右两个窗格&lt;/span&gt;
$ tmux split-window -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;移动光标：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# 光标切换到上方窗格&lt;/span&gt;
$ tmux &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;select&lt;/span&gt;-pane -U
&lt;span style=&#34;color:#888&#34;&gt;# 光标切换到下方窗格&lt;/span&gt;
$ tmux &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;select&lt;/span&gt;-pane -D
&lt;span style=&#34;color:#888&#34;&gt;# 光标切换到左边窗格&lt;/span&gt;
$ tmux &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;select&lt;/span&gt;-pane -L
&lt;span style=&#34;color:#888&#34;&gt;# 光标切换到右边窗格&lt;/span&gt;
$ tmux &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;select&lt;/span&gt;-pane -R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;交换窗格位置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# 当前窗格上移&lt;/span&gt;
$ tmux swap-pane -U
&lt;span style=&#34;color:#888&#34;&gt;# 当前窗格下移&lt;/span&gt;
$ tmux swap-pane -D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;窗格相关快捷键：&lt;/p&gt;
&lt;p&gt;（注意：将&lt;code&gt;Ctrl+b&lt;/code&gt;更改为自己设置的&lt;code&gt;Ctrl+x&lt;/code&gt;即可）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Ctrl+b %：划分左右两个窗格。
Ctrl+b &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;：划分上下两个窗格。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b &amp;lt;arrow key&amp;gt;：光标切换到其他窗格。&amp;lt;arrow key&amp;gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b ;：光标切换到上一个窗格。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b o：光标切换到下一个窗格。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b {：当前窗格与上一个窗格交换位置。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b }：当前窗格与下一个窗格交换位置。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b x：关闭当前窗格。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b !：将当前窗格拆分为一个独立窗口。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b Ctrl+&amp;lt;arrow key&amp;gt;：按箭头方向调整窗格大小。
&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;Ctrl+b q：显示窗格编号。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;窗口管理&#34;&gt;窗口管理&lt;/h3&gt;
&lt;p&gt;除了将一个窗口划分为多个窗格，Tmux还允许新建多个窗口。&lt;/p&gt;
&lt;p&gt;新建窗口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux new-window -n &amp;lt;window-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切换窗口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tmux &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;select&lt;/span&gt;-window -t &amp;lt;window-name/window-number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一些窗口快捷键：&lt;/p&gt;
&lt;p&gt;（注意：将&lt;code&gt;Ctrl+b&lt;/code&gt;更改为自己设置的&lt;code&gt;Ctrl+x&lt;/code&gt;即可）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。
Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。
Ctrl+b n：切换到下一个窗口。
Ctrl+b &amp;lt;number&amp;gt;：切换到指定编号的窗口，其中的&amp;lt;number&amp;gt;是状态栏上的窗口编号。
Ctrl+b w：从列表中选择窗口。
Ctrl+b ,：窗口重命名。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;# 重新加载当前的Tmux配置&lt;/span&gt;
$ tmux source-file ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;vim&#34;&gt;Vim&lt;/h2&gt;
&lt;p&gt;多模态命令行编辑器，避免了使用鼠标和上下左右按键。&lt;/p&gt;
&lt;h3 id=&#34;编辑模式&#34;&gt;编辑模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正常模式&lt;/li&gt;
&lt;li&gt;插入模式&lt;/li&gt;
&lt;li&gt;替换模式&lt;/li&gt;
&lt;li&gt;可视化模式&lt;/li&gt;
&lt;li&gt;命令模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim启动时默认为正常模式。可以按下&lt;code&gt;ESC&lt;/code&gt;从任何其他模式返回正常模式。在正常模式，键入&lt;code&gt;i&lt;/code&gt;进入插入模式，&lt;code&gt;r&lt;/code&gt;进入替换模式，&lt;code&gt;v&lt;/code&gt;进入可视（行）模式，&lt;code&gt;Ctrl-v&lt;/code&gt;进入可视（块）模式，&lt;code&gt;:&lt;/code&gt;进入命令模式。&lt;/p&gt;
&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;插入文本&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;键入&lt;code&gt;i&lt;/code&gt;进入插入模式进行编辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令行&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;正常模式下键入&lt;code&gt;:&lt;/code&gt;进入命令行模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt;退出（关闭窗口）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt;保存（写）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt;保存然后退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e {文件名}&lt;/code&gt;打开要编辑的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:ls&lt;/code&gt;显示打开的缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help {标题}&lt;/code&gt;打开帮助文档
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help :w&lt;/code&gt;打开&lt;code&gt;:w&lt;/code&gt;命令的帮助文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vim的接口其实是一种编程语言&#34;&gt;Vim的接口其实是一种编程语言&lt;/h3&gt;
&lt;p&gt;Vim界面本身是一个程序语言。键入操作（以及其助记名）本身是命令，这些命令可以组合使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移动&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本移动：&lt;code&gt;hjkl&lt;/code&gt;（左，下，上，右）&lt;/li&gt;
&lt;li&gt;词：&lt;code&gt;w&lt;/code&gt;（下一个词）， &lt;code&gt;b&lt;/code&gt; （词初）， &lt;code&gt;e&lt;/code&gt; （词尾）&lt;/li&gt;
&lt;li&gt;行： &lt;code&gt;0&lt;/code&gt; （行初）， &lt;code&gt;^&lt;/code&gt; （第一个非空格字符）， &lt;code&gt;$&lt;/code&gt; （行尾）&lt;/li&gt;
&lt;li&gt;屏幕： &lt;code&gt;H&lt;/code&gt; （屏幕首行）， &lt;code&gt;M&lt;/code&gt; （屏幕中间）， &lt;code&gt;L&lt;/code&gt; （屏幕底部）&lt;/li&gt;
&lt;li&gt;翻页： &lt;code&gt;Ctrl-u&lt;/code&gt; （上翻）， &lt;code&gt;Ctrl-d&lt;/code&gt; （下翻）&lt;/li&gt;
&lt;li&gt;文件： &lt;code&gt;gg&lt;/code&gt; （文件头）， &lt;code&gt;G&lt;/code&gt; （文件尾）&lt;/li&gt;
&lt;li&gt;行数： &lt;code&gt;:{行数}&amp;lt;CR&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;{行数}G&lt;/code&gt; ({行数}为行数)&lt;/li&gt;
&lt;li&gt;查找： &lt;code&gt;f{字符}&lt;/code&gt;， &lt;code&gt;t{字符}&lt;/code&gt;， &lt;code&gt;F{字符}&lt;/code&gt;， &lt;code&gt;T{字符}&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;查找/到 向前/向后 在本行的{字符}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;搜索: &lt;code&gt;/{正则表达式}&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; 用于导航匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;可视化模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可视化：&lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可视化行：&lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可视化块：&lt;code&gt;Ctrl+v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用命令行来选中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;采用编辑命令和移动命令的组合完成所有功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;进入插入模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt; / &lt;code&gt;o&lt;/code&gt; 在之上/之下插入行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d{移动命令}&lt;/code&gt; 删除 {移动命令}
&lt;ul&gt;
&lt;li&gt;例如， &lt;code&gt;dw&lt;/code&gt; 删除词, &lt;code&gt;d$&lt;/code&gt; 删除到行尾, &lt;code&gt;d0&lt;/code&gt; 删除到行头。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c{移动命令}&lt;/code&gt; 改变 {移动命令}
&lt;ul&gt;
&lt;li&gt;例如， &lt;code&gt;cw&lt;/code&gt; 改变词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 删除字符（等同于 &lt;code&gt;dl&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 替换字符（等同于 &lt;code&gt;xi&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;可视化模式 + 操作
&lt;ul&gt;
&lt;li&gt;选中文字, &lt;code&gt;d&lt;/code&gt; 删除 或者 &lt;code&gt;c&lt;/code&gt; 改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 撤销, &lt;code&gt;&amp;lt;C-r&amp;gt;&lt;/code&gt; 重做&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; 复制 / “yank” （其他一些命令比如 &lt;code&gt;d&lt;/code&gt; 也会复制）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 粘贴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;计数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;3w&lt;/code&gt;向前移动三个词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5j&lt;/code&gt;向下移动5行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;7dw&lt;/code&gt;删除7个词&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修饰语&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用修饰语改变名词的意思。修饰语有：&lt;code&gt;i&lt;/code&gt;表示在内部和&lt;code&gt;a&lt;/code&gt;表示周围。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ci(&lt;/code&gt;改变当前括号内的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ci[&lt;/code&gt;改变当前方括号内的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;da&#39;&lt;/code&gt;删除一个单引号字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gdb&#34;&gt;gdb&lt;/h2&gt;
&lt;p&gt;测试一下具体的功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C标准库总结</title>
        <link>https://eternityqjl.top/posts/c%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/</link>
        <pubDate>Tue, 28 Jun 2022 21:59:47 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/c%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/c%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/ -&lt;p&gt;C标准库又称ISO C库，是用于完成输入/输出处理、字符串处理、内存管理、数学计算和许多其他操作系统服务等任务的宏、类型和函数的集合。不同的内容分布在不同的头文件中。&lt;/p&gt;
&lt;h2 id=&#34;asserth&#34;&gt;assert.h&lt;/h2&gt;
&lt;p&gt;定义了一个可以作为标准调试工具的宏函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;assert&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; expression);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果参数&lt;code&gt;expression&lt;/code&gt;所代表的表达式的结果为0，则一条消息会被写入标准error输出，&lt;code&gt;abort&lt;/code&gt;函数会被调用，终止程序的执行。&lt;/p&gt;
&lt;h2 id=&#34;ctypeh&#34;&gt;ctype.h&lt;/h2&gt;
&lt;p&gt;这个头文件定义了一组用来对单独字母进行比较和大小写转换的函数。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;isalpha&lt;/code&gt;和&lt;code&gt;tolower&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;floath&#34;&gt;float.h&lt;/h2&gt;
&lt;p&gt;此头文件描述了特定系统和编译器使用的浮点类型的字符。&lt;/p&gt;
&lt;h2 id=&#34;inttypesh&#34;&gt;inttypes.h&lt;/h2&gt;
&lt;h2 id=&#34;mathh&#34;&gt;math.h&lt;/h2&gt;
&lt;p&gt;定义了一组用于进行常规数学计算的函数。&lt;/p&gt;
&lt;h2 id=&#34;setjmph&#34;&gt;setjmp.h&lt;/h2&gt;
&lt;p&gt;定义了宏&lt;code&gt;setjmp()&lt;/code&gt;、函数&lt;code&gt;longjmp()&lt;/code&gt;和变量类型&lt;code&gt;jmp_buf&lt;/code&gt;，该变量类型会绕过正常的函数调用和返回规则。&lt;/p&gt;
&lt;h2 id=&#34;signalh&#34;&gt;signal.h&lt;/h2&gt;
&lt;h2 id=&#34;stdboolh&#34;&gt;stdbool.h&lt;/h2&gt;
&lt;h2 id=&#34;stdioh&#34;&gt;stdio.h&lt;/h2&gt;
&lt;p&gt;用来进行输入输出操作。&lt;/p&gt;
&lt;h2 id=&#34;stdlibh&#34;&gt;stdlib.h&lt;/h2&gt;
&lt;p&gt;这个头文件定义了几个通用目的的函数，包括动态内存管理，随机数生成，环境进程相关（例如abort等），整数算数，搜索，排序，字符串转换。&lt;/p&gt;
&lt;h2 id=&#34;stringh&#34;&gt;string.h&lt;/h2&gt;
&lt;p&gt;这个头文件定义了几个函数，用来操作C中的字符串和数组。&lt;/p&gt;
&lt;h2 id=&#34;timeh&#34;&gt;time.h&lt;/h2&gt;
&lt;p&gt;这个头文件定义了一些用于获取和操作日期和时间信息的函数。&lt;/p&gt;
&lt;h2 id=&#34;ucharh&#34;&gt;uchar.h&lt;/h2&gt;
&lt;h2 id=&#34;posix&#34;&gt;POSIX&lt;/h2&gt;
&lt;p&gt;POSIX是Portable Operating System Interface的缩写，X表示Unix，它是ISO C的延伸，定义了一个可移植的操作系统所应该具备的各种条件，范围不只有系统函数库。为了OS之间的可移植性，POSIX规定了一些标准的接口，这些接口就是POSIX库。&lt;/p&gt;
&lt;p&gt;GNU C（常简称为glibc），既包含C标准库，也包含POSIX库。glibc是Linux下的C标准库的实现。&lt;/p&gt;
- https://eternityqjl.top/posts/c%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp 6 存储器层次结构</title>
        <link>https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link>
        <pubDate>Sat, 05 Mar 2022 21:18:38 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ -&lt;p&gt;基本的存储技术：SRAM存储器、DRAM存储器、ROM存储器以及旋转和固态的硬盘。&lt;/p&gt;
&lt;h2 id=&#34;存储技术&#34;&gt;存储技术&lt;/h2&gt;
&lt;h3 id=&#34;随机访问存储器&#34;&gt;随机访问存储器&lt;/h3&gt;
&lt;p&gt;RAM分为动态DRAM和静态SRAM两类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的DRAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增强的DRAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非易失性存储器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又称只读存储器ROM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问主存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据流通过总线在处理器和DRAM之间来来回回。这一系列步骤又称为总线事务。&lt;/p&gt;
&lt;p&gt;系统总线、内存总线。&lt;/p&gt;
&lt;h3 id=&#34;磁盘存储&#34;&gt;磁盘存储&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;磁盘构造&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁道、扇区、柱面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;磁盘容量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读、写数据。对扇区的访问时间主要由三个部分组成：寻道时间、旋转时间、传送时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑磁盘块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护逻辑块号和物理磁盘扇区之间的映射关系。一个（盘面，磁道，扇区）三元组唯一地标识了对应的物理扇区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接I/O设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I/O设备，例如显卡、鼠标、键盘、磁盘和网路适配器等，通过I/O总线与连接到CPU和主存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问磁盘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA技术，设备可以自己执行读或写总线事务而不需要CPU干涉。DMA传送完成，I/O设备通过给CPU发送一个中断信号来通知CPU。&lt;/p&gt;
&lt;h3 id=&#34;固态硬盘&#34;&gt;固态硬盘&lt;/h3&gt;
&lt;p&gt;SSD由一个或多个闪存芯片和闪存翻译层组成。&lt;/p&gt;
&lt;h2 id=&#34;局部性&#34;&gt;局部性&lt;/h2&gt;
&lt;p&gt;时间局部性：被引用过一次的内存位置可能在不远的将来再被多次引用。&lt;/p&gt;
&lt;p&gt;空间局部性：一个内存位置被引用了一次，那么程序可能在不远的将来引用附近的一个内存位置&lt;/p&gt;
&lt;h2 id=&#34;存储器层次结构&#34;&gt;存储器层次结构&lt;/h2&gt;
&lt;p&gt;L0：寄存器&lt;/p&gt;
&lt;p&gt;L1、2、3：高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L4：主存（DRAM）&lt;/p&gt;
&lt;p&gt;L5：本地二级存储（本地磁盘）&lt;/p&gt;
&lt;p&gt;L6：远程二级存储（分布式文件系统、Web服务器）&lt;/p&gt;
&lt;p&gt;对于缓存的管理：&lt;/p&gt;
&lt;p&gt;每一层存储设备都是较低一层的缓存。在一个有虚拟内存的系统中，DRAM主存作为存储在磁盘上的数据块的缓存，由操作系统软件和CPU上的地址翻译硬件共同管理。&lt;/p&gt;
&lt;h2 id=&#34;高速缓存存储器&#34;&gt;高速缓存存储器&lt;/h2&gt;
&lt;p&gt;L1高速缓存：访问速度几乎和寄存器一样快，大约4个时钟周期。&lt;/p&gt;
&lt;p&gt;L2高速缓存：大约10个时钟周期。&lt;/p&gt;
&lt;p&gt;L3高速缓存：大约50个时钟周期。&lt;/p&gt;
&lt;h3 id=&#34;通用的高速缓冲存储器组织结构&#34;&gt;通用的高速缓冲存储器组织结构&lt;/h3&gt;
&lt;p&gt;一般来说，通用的高速缓存结构可以用元组（S，E，B，m）来描述。S为高速缓存的组数，E为每组的行数，B为每个高速缓存块的字节数，m为存储器（地址）的位数。&lt;/p&gt;
&lt;h3 id=&#34;直接映射高速缓存&#34;&gt;直接映射高速缓存&lt;/h3&gt;
&lt;p&gt;每个组只有一行（E=1）。&lt;/p&gt;
&lt;p&gt;高速缓存确定一个请求是否命中，然后抽取被请求的字的过程，分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组选择&lt;/li&gt;
&lt;li&gt;行匹配&lt;/li&gt;
&lt;li&gt;字选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组相联高速缓存&#34;&gt;组相联高速缓存&lt;/h3&gt;
&lt;p&gt;每个组都保存有多于一个的高速缓存行。&lt;/p&gt;
&lt;h3 id=&#34;全相联高速缓存&#34;&gt;全相联高速缓存&lt;/h3&gt;
&lt;p&gt;由一个包含所有高速缓存行的组组成的。&lt;/p&gt;
&lt;h3 id=&#34;有关写的问题&#34;&gt;有关写的问题&lt;/h3&gt;
&lt;p&gt;直写、写回；写分配，非写分配。&lt;/p&gt;
&lt;p&gt;一般建议采用使用写回——写分配的高速缓存的模型。因为存储器层次结构中较低层次的缓存更可能使用写回而不是直写。&lt;/p&gt;
&lt;h2 id=&#34;编写高速缓存友好的代码&#34;&gt;编写高速缓存友好的代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;让最常见的情况运行得块。要把注意力集中在核心函数里的循环上，忽略其他部分。&lt;/li&gt;
&lt;li&gt;尽量减小每个循环内部的缓存不命中的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;高速缓存对存储器性能的影响&#34;&gt;高速缓存对存储器性能的影响&lt;/h2&gt;
&lt;h3 id=&#34;存储器山&#34;&gt;存储器山&lt;/h3&gt;
&lt;h3 id=&#34;重新排列循环以提高空间局部性&#34;&gt;重新排列循环以提高空间局部性&lt;/h3&gt;
- https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp11新特性总结</title>
        <link>https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 25 Feb 2022 20:47:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/ -&lt;p&gt;部分内容参考自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/103258069&#34;&gt;知乎 - jameswhale - C++11新特性总结（相比C++98）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;指针空值0-null-nullptr&#34;&gt;指针空值（0, NULL, nullptr）&lt;/h2&gt;
&lt;h2 id=&#34;nullptr与nullptr_t&#34;&gt;nullptr与nullptr_t&lt;/h2&gt;
&lt;h2 id=&#34;default&#34;&gt;=default&lt;/h2&gt;
&lt;p&gt;在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未显示定义的成员函数，包括构造函数、拷贝构造函数、拷贝赋值函数（operator =）、移动构造函数、移动拷贝函数、析构函数。一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。例如，声明了带参数的构造函数版本，则必须声明不带参数的版本以完成无参的变量初始化，而这会导致对应的类不再是POD的（非POD类型，意味着编译器失去了优化这样简单的数据类型的可能），通过=default 可以使其重新成为POD类型，见如下几个例子。&lt;/p&gt;
&lt;h2 id=&#34;delete&#34;&gt;=delete&lt;/h2&gt;
&lt;p&gt;在以前，程序员若希望限制一些默认函数的生成，例如，单件类的实现需要阻止其生成拷贝构造函数和拷贝赋值函数，可以将拷贝构造函数和拷贝赋值函数声明为private成员，并且不提供函数实现，C++11 标准给出了非常简洁的方法，即在函数的定义或者声明加上”= delete“。&lt;/p&gt;
&lt;h2 id=&#34;左值右值&#34;&gt;左值、右值&lt;/h2&gt;
&lt;p&gt;右值又称亡值、纯右值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++11新增了与右值引用相关的表达式。&lt;/li&gt;
&lt;li&gt;一般来说，左值引用不能接受一个右值，不过常量的左值引用能接受一个右值，比如函数指针的引用传递，const T&amp;amp;，可以减少临时对象的拷贝。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;列表初始化&#34;&gt;列表初始化&lt;/h2&gt;
&lt;p&gt;C++11新增了列表初始化方式，方便了代码编写。声明一个以initializer_list&lt;!-- raw HTML omitted --&gt; 模板类为参数的构造函数，自定义的类可以使用列表初始化方式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b[]{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;};
vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; c{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;};
map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; d &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.0f&lt;/span&gt;}, {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;3.2f&lt;/span&gt;}};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;扩展了using的使用&#34;&gt;扩展了using的使用&lt;/h2&gt;
&lt;p&gt;using不只是用来声明命名空间了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; uint &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; MapString &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;T, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&amp;gt;&lt;/span&gt;;
MapString&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; numberedString;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;auto&#34;&gt;auto&lt;/h2&gt;
&lt;p&gt;auto作为新的类型指示符，用于自动推导，特别是命名空间、模板等导致类型很长的时候，非常方便。对于指针类型，声明为auto* 或者auto 是一样的，对于&lt;strong&gt;引用类型&lt;/strong&gt;，必须使用&lt;strong&gt;auto &amp;amp;&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;decltype&#34;&gt;decltype&lt;/h2&gt;
&lt;p&gt;以一个普通的表达式为参数返回该&lt;strong&gt;表达式的类型&lt;/strong&gt;，在编译期进行。&lt;/p&gt;
&lt;h2 id=&#34;基于范围的for循环&#34;&gt;基于范围的for循环&lt;/h2&gt;
&lt;p&gt;对于知道范围的数组和stl容器，C++11提供了for迭代访问能力，结合auto，可简化代码。需要满足两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代的对象实现++和==操作；&lt;/li&gt;
&lt;li&gt;知道范围&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程编程&#34;&gt;多线程编程&lt;/h2&gt;
&lt;p&gt;C++11之前，在C/C++中程序中使用线程，主要使用POSIX线程（pthread），POSIX线程是POSIX标准中关于线程的部分，程序员可以通过pthread线程的api完成线程的创建、数据的共享、同步等功能。C++11引入了多线程的支持，使得C/C++语言在进行线程编程时，不必依赖第三方库和标准。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;atomic&amp;gt;		&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;thread&amp;gt;		&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;iostream&amp;gt;		&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;		
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;		
		
atomic_llong total{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;};		
		
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; ){		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100000000LL&lt;/span&gt;;&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i){		
        total &lt;span style=&#34;color:#333&#34;&gt;+=&lt;/span&gt; i;		
    }		
}		
		
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;(){		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;thread&lt;/span&gt; t1(func, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;thread&lt;/span&gt; t2(func ,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);		
    t1.join();		
    t2.join();		
    cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; total &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;		
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;智能指针&#34;&gt;智能指针&lt;/h2&gt;
&lt;p&gt;C++11共有以下几种智能指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unique_ptr：拥有内存的所有权，没有拷贝构造函数，只有移动构造函数，不能多个unique_ptr对象共享一段内存，可以自定义delete函数，从而支持delete[]&lt;/li&gt;
&lt;li&gt;shared_ptr：通过计数方式，多个shared_ptr可以共享一段内存，计数为0时，所管理的内存会被删除，可以自定义delete函数，从而支持delete[]&lt;/li&gt;
&lt;li&gt;weak_ptr：观察shared_ptr管理的内存对象，只观察但不拥有。成员函数lock返回shared_ptr对象，若对应内存已经删除，则shared_ptr对象==nullptr，weak_ptr对象可以拷贝构造，拷贝构造出来的对象和原对象观察的是同一段内存。成员函数reset可以解除对内存的观察，注意，是解除观察，并不会删除对应内存对象。weak_ptr可以避免因为shared_ptr的循环引用引起的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h2&gt;
&lt;h2 id=&#34;pragma-once-或-_pragmaonce&#34;&gt;#Pragma once 或 _Pragma(&amp;ldquo;once&amp;rdquo;)&lt;/h2&gt;
&lt;p&gt;用来保证头文件只会被include一次。_Pragma是一个操作符，可以用在宏定义中，比预处理指令灵活。&lt;/p&gt;
&lt;h2 id=&#34;变长参数的宏定义&#34;&gt;变长参数的宏定义&lt;/h2&gt;
&lt;p&gt;变长参数的宏定义指的是在宏定义中参数列表的最后一个参数为省略号，预定义宏&lt;code&gt;__VA_ARGS__&lt;/code&gt;可以在宏定义的实现部分替换省略号代表队的字符串。&lt;/p&gt;
&lt;h2 id=&#34;cc混用头文件&#34;&gt;C/C++混用头文件&lt;/h2&gt;
&lt;p&gt;可以让如下头文件被#include到C文件中，也可以被#include到C++文件中，extern &amp;ldquo;C&amp;quot;可以抑制C++对函数名、变量名等符号进行重整，因此编译出的C目标文件和C++目标文件中的变量名和函数名都一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt; {
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;    
    
&lt;span style=&#34;color:#579&#34;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;常量表达式&#34;&gt;常量表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编译时常量：constexpr&lt;/li&gt;
&lt;li&gt;运行时常量：const&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp中的RAII机制</title>
        <link>https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 25 Feb 2022 19:17:30 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/ -&lt;h2 id=&#34;什么是raii&#34;&gt;什么是RAII&lt;/h2&gt;
&lt;p&gt;RAII即Resource Acquisition Is Initialization（资源获取就是初始化），是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。&lt;/p&gt;
&lt;h2 id=&#34;为什么要使用raii&#34;&gt;为什么要使用RAII&lt;/h2&gt;
&lt;p&gt;RAII是用来管理资源、避免资源泄露的方法。&lt;strong&gt;系统资源&lt;/strong&gt;有：网络套接字、互斥锁、文件句柄和内存等，是有限的。使用系统资源时要遵守：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请资源&lt;/li&gt;
&lt;li&gt;使用资源&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两部不可或缺，使用完成要要进行释放，否则会造成资源泄漏。&lt;/p&gt;
&lt;h2 id=&#34;如何使用raii&#34;&gt;如何使用RAII&lt;/h2&gt;
&lt;p&gt;当我们在一个函数内部使用&lt;strong&gt;局部变量&lt;/strong&gt;，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是&lt;strong&gt;类对象&lt;/strong&gt;时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。&lt;/p&gt;
&lt;p&gt;由于系统资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装，对资源的操作都封装在类的内部，在析构函数中进行释放资源。这样当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。&lt;/p&gt;
&lt;p&gt;使用RAII机制的代码举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std; 

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;ArrayOperation&lt;/span&gt; 
{
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; 
    ArrayOperation() 
    {
        m_Array &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;]; 
    }

    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;InitArray&lt;/span&gt;() 
    { 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i)
            &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;(m_Array &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; i) &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
    }

    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;ShowArray&lt;/span&gt;() 
    { 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i) 
            cout&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;m_Array[i]&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl; 
    }

    &lt;span style=&#34;color:#333&#34;&gt;~&lt;/span&gt;ArrayOperation() 
    {
        cout&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;~ArrayOperation is called&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl; 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (m_Array &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;) {
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] m_Array;
            m_Array &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
        }
    }

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; m_Array;
};

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationA&lt;/span&gt;(); 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationB&lt;/span&gt;(); 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{
    ArrayOperation arrayOp;
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下为该例子不使用RAII机制的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std; 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationA&lt;/span&gt;(); 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationB&lt;/span&gt;(); 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;]; 

    &lt;span style=&#34;color:#888&#34;&gt;// Here, you can use the array 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;OperationA()) 
    { 
        &lt;span style=&#34;color:#888&#34;&gt;// If the operation A failed, we should delete the memory 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; [] testArray; 
        testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; 
    } 

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;OperationB()) 
    {
        &lt;span style=&#34;color:#888&#34;&gt;// If the operation A failed, we should delete the memory 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; [] testArray; 
        testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; 
    }

    &lt;span style=&#34;color:#888&#34;&gt;// All the operation succeed, delete the memory 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; [] testArray; 
    testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; 
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationA&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color:#888&#34;&gt;// Do some operation, if the operate succeed, then return true, else return false 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt; ; 
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationB&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color:#888&#34;&gt;// Do some operation, if the operate succeed, then return true, else return false 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;true&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp继承和多态</title>
        <link>https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link>
        <pubDate>Fri, 18 Feb 2022 19:47:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/ -&lt;p&gt;继承：类与类之间可以&lt;strong&gt;共用代码，实现代码重用&lt;/strong&gt;。（基类和派生类）&lt;/p&gt;
&lt;p&gt;多态：面向对象过程中，基类与派生类存在&lt;strong&gt;相同的方法&lt;/strong&gt;，但有&lt;strong&gt;不同的方法体&lt;/strong&gt;，调用是根据对象有选择地调用合适的方法。&lt;/p&gt;
&lt;p&gt;多态的几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须是公有继承&lt;/li&gt;
&lt;li&gt;必须通过基类的指针或引用指向派生类对象来访问呢派生类方法&lt;/li&gt;
&lt;li&gt;基类的方法必须是虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态的实现要求必须是共有继承&lt;/li&gt;
&lt;li&gt;继承关系中，父类更通用，子类更具体。父类具有一般的特征和行为，子类除了具有父类的特征和行为，还有自己特殊的行为和特征。&lt;/li&gt;
&lt;li&gt;继承关系中，并不要求基类方法一定是虚函数。多态要求基类方法必须是虚函数。&lt;/li&gt;
&lt;li&gt;多态：子类重写父类的方法，使得子类具有不同的实现。且运行时，根据实际创建的对象动态决定使用哪个方法。&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp 8 异常控制流</title>
        <link>https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
        <pubDate>Tue, 11 Jan 2022 15:33:44 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/ -&lt;p&gt;系统要对系统状态的变化作出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。&lt;/p&gt;
&lt;p&gt;现代系统通过使用&lt;strong&gt;控制流发生突变&lt;/strong&gt;来对这些情况作出反应，一般把这些突变称为&lt;strong&gt;异常控制流ECF&lt;/strong&gt;。ECF发生在&lt;strong&gt;计算机系统的各个层次&lt;/strong&gt;。例如，在&lt;strong&gt;硬件层&lt;/strong&gt;，硬件检测到的事件会触发控制突然转移到异常处理程序。在&lt;strong&gt;操作系统层&lt;/strong&gt;，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。&lt;/p&gt;
&lt;p&gt;理解ECP有很多用处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助理解重要的&lt;strong&gt;系统概念&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;理解应用程序如何&lt;strong&gt;与操作系统交互&lt;/strong&gt;。应用程序通过使用称为陷阱或系统调用的ECF形式，向操作系统请求服务。例如，向磁盘写数据、从网络读取数据、创建一个新进程，都是通过应用程序调用系统调用实现的。&lt;/li&gt;
&lt;li&gt;帮助理解&lt;strong&gt;并发&lt;/strong&gt;。ECF是计算机系统中实现并发的基本机制。&lt;/li&gt;
&lt;li&gt;帮助理解&lt;strong&gt;软件异常&lt;/strong&gt;如何工作。例如C++使用try、catch以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;p&gt;异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。&lt;/p&gt;
&lt;p&gt;异常就是控制流中的突变，用来响应处理器状态中的某些变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件&lt;/strong&gt;（event）：状态的变化。事件可能和当前指令的执行直接相关，比如发生虚拟内存缺页、算术溢出等。&lt;/p&gt;
&lt;p&gt;处理器检测到有事件发生时，就通过异常表的跳转表，进行一个间接过程调用，到一个异常处理程序进行处理。处理完后，根据引起异常的事件类型，会发生以下三种情况的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理程序将控制返回给当前指令&lt;/li&gt;
&lt;li&gt;处理程序将控制返回给下一条指令&lt;/li&gt;
&lt;li&gt;处理程序终止被中断的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;
&lt;p&gt;系统中可能为每种类型的异常都分配一个唯一的非负整数的&lt;strong&gt;异常号&lt;/strong&gt;。其中一些号码由&lt;strong&gt;处理器设计者&lt;/strong&gt;提供，另一些由&lt;strong&gt;操作系统内核的设计者&lt;/strong&gt;分配。前者的例子包括：缺页、内存访问违规、被零除及算术运算溢出。后者的例子包括：系统调用和来自外部I/O设备的信号。&lt;/p&gt;
&lt;p&gt;系统启动时，操作系统分配和初始化一张称为异常表的跳转表。使得表目k包含异常k的处理程序的地址。&lt;/p&gt;
&lt;p&gt;运行时（系统执行某个程序）处理器检测到发生了一个事件，并确定了响应的异常号k。随后处理器触发异常，执行间接调用过程，通过异常表的表目k，转到相应的处理程序。&lt;/p&gt;
&lt;p&gt;异常号是&lt;strong&gt;到异常表中的索引&lt;/strong&gt;，异常表的起始地址放在叫做异常表基址寄存器的特殊CPU寄存器中。&lt;/p&gt;
&lt;p&gt;异常与过程调用的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回地址不同：过程调用时，跳转到处理程序之前，处理器将返回地址压入栈中。而根据异常的类型，返回地址要么是当前指令，要么是下一条指令。&lt;/li&gt;
&lt;li&gt;异常处理中处理器也把一些额外的处理器状态压入栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。&lt;/li&gt;
&lt;li&gt;如果控制从用户程序转移到内核，所有这些项目都被压入内核栈中，而不是压到用户栈中。&lt;/li&gt;
&lt;li&gt;异常处理程序运行在内核模式下，这意味着其对所有系统资源都有完全的访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦硬件触发了异常，剩下的工作就由&lt;strong&gt;异常处理程序&lt;/strong&gt;在软件中完成。处理完事件后，通过执行一条特殊的从中断返回指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中。如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将控制返回给被中断的程序。&lt;/p&gt;
&lt;h3 id=&#34;异常的类别&#34;&gt;异常的类别&lt;/h3&gt;
&lt;p&gt;异常分为中断、陷阱、故障、终止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中断是&lt;strong&gt;异步&lt;/strong&gt;发生的，是来自处理器&lt;strong&gt;外部的I/O设备的信号&lt;/strong&gt;的结果。硬件中断&lt;strong&gt;不是由任何一条专门的指令&lt;/strong&gt;造成的，因此它是异步的。硬件中观的异常处理程序常称为中断处理程序。&lt;/p&gt;
&lt;p&gt;当前只能怪执行完后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，就将控制返回给下一条指令。结果是程序继续运行，就好像没有发生过中断一样。&lt;/p&gt;
&lt;p&gt;剩下的异常类型是&lt;strong&gt;同步&lt;/strong&gt;发生的，是执行当前指令的结果，把这类指令称为&lt;strong&gt;故障指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱和系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在&lt;strong&gt;用户程序和内核之间&lt;/strong&gt;提供一个像过程一样的接口，称为系统调用。&lt;/p&gt;
&lt;p&gt;用户经常要向内核请求服务，比如读一个文件（read）、创建一个新进程（fork）、加载一个新程序（execve），或终止当前程序（exit）。为了允许对这些内核服务的受控访问，处理器提供了一条特殊的&lt;code&gt;syscall n&lt;/code&gt;的指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个程序解析参数，并调用适当的内核程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;故障是由错误引起的，他可能&lt;strong&gt;被故障处理程序修正&lt;/strong&gt;。故障发生时，处理器将控制转移给故障处理程序。如果故障处理程序能够修正这个错误，他就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，该例程会终止引起故障的应用程序。&lt;/p&gt;
&lt;p&gt;一个经典的故障示例是缺页异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，例如DRAM或SRAM位被损坏时发生的奇偶错误。&lt;/p&gt;
&lt;h3 id=&#34;linuxx86-64中的异常&#34;&gt;Linux/x86-64中的异常&lt;/h3&gt;
&lt;p&gt;x86-64有256种不同类型的异常，0~31号对应的由Intel架构师定义的异常，对任何x86-64系统都是一样的。32~255号对应的是操作系统定义的中断和陷阱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux/x86-64故障和终止&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除法错误（异常0）：Unix不会试图从除法错误中恢复，而是选择终止程序。&lt;/li&gt;
&lt;li&gt;一般保护故障（异常13）：通常因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这些故障。&lt;/li&gt;
&lt;li&gt;缺页（异常14）：会重新执行产生故障的指令的一个示例。&lt;/li&gt;
&lt;li&gt;机器检查（异常18）：在导致故障的指令执行中检测到致命的硬件错误时发生的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux/x86-64系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux提供几百种系统调用，以下为一些常见的系统调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201071509742.png&#34; alt=&#34;Linux常见系统调用&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个系统调用都有唯一的整数号，对应于一个到内核中跳转表的偏移量。&lt;/p&gt;
&lt;p&gt;C程序用syscall函数可以直接调用任何系统调用。而实际中没必要这样做，对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用函数。&lt;/p&gt;
&lt;p&gt;处理器ISA规范通常会区分异步中断和同步异常，但并不提供表述这些非常相似的概念的概括性的术语。为了避免混乱，我们使用异常作为通用术语，只要在必要时才区分异步异常（中断）和同步异常（陷阱、故障和终止）。&lt;/p&gt;
&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;p&gt;进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。&lt;/p&gt;
&lt;p&gt;进程提供给应用程序的关键抽象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个独立的逻辑控制流：提供我们的程序&lt;strong&gt;独占地使用处理器&lt;/strong&gt;的假象&lt;/li&gt;
&lt;li&gt;一个私有的地址空间：提供我们的程序&lt;strong&gt;独占地使用内存系统&lt;/strong&gt;的假象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;逻辑控制流&#34;&gt;逻辑控制流&lt;/h3&gt;
&lt;p&gt;进程为每个程序提供了一种假象，好像程序在独占地使用处理器。&lt;/p&gt;
&lt;p&gt;进程轮流使用处理器。每个进程执行它的流的一部分，然后被抢占，然后轮到其他进程。&lt;/p&gt;
&lt;h3 id=&#34;并发流&#34;&gt;并发流&lt;/h3&gt;
&lt;p&gt;一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发地运行。&lt;/p&gt;
&lt;p&gt;多个流并发地执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。&lt;/p&gt;
&lt;h3 id=&#34;私有地址空间&#34;&gt;私有地址空间&lt;/h3&gt;
&lt;p&gt;进程为每个程序提供它自己的私有地址空间。和这个空间中某个地址相关联的哪个内存字节是不能被其他进程读和写的。&lt;/p&gt;
&lt;p&gt;尽管每个私有地址空间相关联的内存一般是不同的，但每个这样的空间都有相同的通用结构。&lt;/p&gt;
&lt;h3 id=&#34;用户模式和内核模式&#34;&gt;用户模式和内核模式&lt;/h3&gt;
&lt;p&gt;处理器提供了一种限制一个应用可以执行的指令以及它可以访问的地址空间范围。&lt;/p&gt;
&lt;p&gt;处理器通常用某个控制寄存器中的一个模式位来提供这种功能，该寄存器描述了当前享有的特权。设置了模式位后，进程就运行在内核模式中。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。&lt;/p&gt;
&lt;p&gt;未设置模式位时，进程运行在用户模式。用户模式中的进程不允许执行特权指令，例如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。&lt;/p&gt;
&lt;h3 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h3&gt;
&lt;p&gt;操作系统内核使用一种称为上下文切换的较高层形式的异常流控制来实现多任务切换。&lt;/p&gt;
&lt;p&gt;内核为每个进程维持一个上下文。上下文就是内核重启一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，如页表、进程表和文件表。&lt;/p&gt;
&lt;p&gt;进程执行的某些时刻，内核可以抢占当前当前进程，并重新开始一个先前被抢占的进程，这种决策称为&lt;strong&gt;调度&lt;/strong&gt;。由内核中的调度器的代码处理的。&lt;/p&gt;
&lt;p&gt;上下文切换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存当前进程的上下文&lt;/li&gt;
&lt;li&gt;恢复某个先前被抢占的进程被保存的上下文&lt;/li&gt;
&lt;li&gt;将控制传递给这个新的恢复进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断可以引发上下文切换。例如从磁盘取完数据之后的中断。&lt;/p&gt;
&lt;h2 id=&#34;系统调用错误处理&#34;&gt;系统调用错误处理&lt;/h2&gt;
&lt;p&gt;当Unix系统级函数遇到错误时，通常会返回-1，并设置全局整数变量errno来表示出现什么错误。&lt;/p&gt;
&lt;p&gt;fork函数检查错误的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fork()) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
	fprintf(stderr, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;fork error: %s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, strerror(errno));
	exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;strerror函数返回一个文本串，描述了和某个errno值相关联的错误。通过定义以下函数，来简化代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;unix_error&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;msg) &lt;span style=&#34;color:#888&#34;&gt;/* Unix-style error */&lt;/span&gt;
{
    fprintf(stderr, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s: %s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, msg, strerror(errno));
    exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时对fork的调用缩减到2行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fork()) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;)
	unix_error(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;fork error&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用csapp.h定义的处理包装函数可以进一步简化代码。&lt;/p&gt;
&lt;h2 id=&#34;进程控制&#34;&gt;进程控制&lt;/h2&gt;
&lt;p&gt;描述Unix提供的大量从C程序中操作进程的系统调用函数。&lt;/p&gt;
&lt;h3 id=&#34;获取进程id&#34;&gt;获取进程ID&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;pid_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;getpid&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;创建和终止进程&#34;&gt;创建和终止进程&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; status);
pid_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;fork&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;exit函数以status退出状态来终止进程。&lt;/p&gt;
&lt;p&gt;父进程通过调用fork函数创建一个新的运行的子进程。&lt;/p&gt;
&lt;h3 id=&#34;回收子进程&#34;&gt;回收子进程&lt;/h3&gt;
&lt;p&gt;当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。进程被保持在一种已终止的状态，直到被它的父进程回收。当父进程回收已经终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被会回收的进程称为僵死进程。&lt;/p&gt;
&lt;h3 id=&#34;让进程休眠&#34;&gt;让进程休眠&lt;/h3&gt;
&lt;p&gt;sleep函数将一个进程挂起一段指定的时间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;include &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;unistd.h&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sleep(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; secs);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。&lt;/p&gt;
&lt;p&gt;还有一个有用的函数pause，该函数让调用函数休眠，直到该进程收到一个信号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;pause&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;加载并运行程序&#34;&gt;加载并运行程序&lt;/h3&gt;
&lt;p&gt;execve函数在当前进程的上下文中加载并运行一个新程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;execve&lt;/span&gt;(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;filename, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;argv[],
			&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数加载并运行&lt;strong&gt;可执行目标文件filename&lt;/strong&gt;，且带&lt;strong&gt;参数列表argv&lt;/strong&gt;和&lt;strong&gt;环境变量列表envp&lt;/strong&gt;。只有出现错误时才返回到调用程序。execve调用一次并从不返回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201092346534.png&#34; alt=&#34;execve函数参数列表和环境变量列表&#34;&gt;&lt;/p&gt;
&lt;p&gt;在execve加载了filename后，调用&lt;a href=&#34;https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/#%e5%8a%a0%e8%bd%bd%e5%8f%af%e6%89%a7%e8%a1%8c%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6&#34;&gt;7.9 加载可执行目标文件&lt;/a&gt;中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数main，该函数有以下形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;argv[], &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;envp[]);
&lt;span style=&#34;color:#888&#34;&gt;//或者等价的
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;envp);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;main开始执行时，用户栈的组织结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201092354435.png&#34; alt=&#34;新程序开始时的用户栈&#34;&gt;&lt;/p&gt;
&lt;p&gt;从栈底（高地址）到栈顶（低地址）的方向依次有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以null结尾的指针数组，其中每个指针都指向栈中的一个&lt;strong&gt;环境变量字符串&lt;/strong&gt;。全局变量environ指向这些指针中的第一个envp[0]&lt;/li&gt;
&lt;li&gt;以null结尾的argv[]数组，其中每个元素都指向栈中的一个&lt;strong&gt;参数字符串&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;栈顶是系统启动函数libc_start_main的栈帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;main函数的三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;argc：给出argv[]数组中非空指针的数量&lt;/li&gt;
&lt;li&gt;argv：指向argv[]数组中的第一个条目&lt;/li&gt;
&lt;li&gt;envp：指向envp[]数组中的第一个条目&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;利用fork和execve运行程序&#34;&gt;利用fork和execve运行程序&lt;/h3&gt;
&lt;p&gt;Unix shell这样的程序大量使用了fork和execve函数。shell是一个交互型的应用程序，他代表用户运行其他程序。最早的shell是sh程序，shell执行一系列的&lt;strong&gt;读/求值&lt;/strong&gt;步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* $begin shellmain */&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;csapp.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define MAXARGS   128
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;/* Function prototypes */&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;eval&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;cmdline);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;parseline&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;buf, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;builtin_command&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv); 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; cmdline[MAXLINE]; &lt;span style=&#34;color:#888&#34;&gt;/* Command line */&lt;/span&gt;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;) {
	&lt;span style=&#34;color:#888&#34;&gt;/* Read */&lt;/span&gt;
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;gt; &amp;#34;&lt;/span&gt;);                   
	Fgets(cmdline, MAXLINE, stdin); 
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (feof(stdin))
	    exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);

	&lt;span style=&#34;color:#888&#34;&gt;/* Evaluate */&lt;/span&gt;
	eval(cmdline);
    } 
}
&lt;span style=&#34;color:#888&#34;&gt;/* $end shellmain */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上为一个简单的shell的main例程。shell打印一个命令行提示符，等待用户在stdin上输入命令，然后对这个命令行求值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* $begin eval */&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;/* eval - Evaluate a command line */&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;eval&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;cmdline) 
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;argv[MAXARGS]; &lt;span style=&#34;color:#888&#34;&gt;/* Argument list execve() */&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[MAXLINE];   &lt;span style=&#34;color:#888&#34;&gt;/* Holds modified command line */&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; bg;              &lt;span style=&#34;color:#888&#34;&gt;/* Should the job run in bg or fg? */&lt;/span&gt;
    pid_t pid;           &lt;span style=&#34;color:#888&#34;&gt;/* Process id */&lt;/span&gt;
    
    strcpy(buf, cmdline);
    bg &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; parseline(buf, argv); 
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;)  
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;   &lt;span style=&#34;color:#888&#34;&gt;/* Ignore empty lines */&lt;/span&gt;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;builtin_command(argv)) { 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Fork()) &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {   &lt;span style=&#34;color:#888&#34;&gt;/* Child runs user job */&lt;/span&gt;
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (execve(argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], argv, environ) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
                printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s: Command not found.&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
                exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
            }
        }

	&lt;span style=&#34;color:#888&#34;&gt;/* Parent waits for foreground job to terminate */&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;bg) {
	    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; status;
	    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (waitpid(pid, &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;status, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;)
		unix_error(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;waitfg: waitpid error&amp;#34;&lt;/span&gt;);
	}
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
	    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d %s&amp;#34;&lt;/span&gt;, pid, cmdline);
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;
}

&lt;span style=&#34;color:#888&#34;&gt;/* If first arg is a builtin command, run it and return true */&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;builtin_command&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv) 
{
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;strcmp(argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;quit&amp;#34;&lt;/span&gt;)) &lt;span style=&#34;color:#888&#34;&gt;/* quit command */&lt;/span&gt;
	exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);  
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;strcmp(argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt;))    &lt;span style=&#34;color:#888&#34;&gt;/* Ignore singleton &amp;amp; */&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;                     &lt;span style=&#34;color:#888&#34;&gt;/* Not a builtin command */&lt;/span&gt;
}
&lt;span style=&#34;color:#888&#34;&gt;/* $end eval */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上为对命令行求值的代码。首要任务是调用parseline函数，该函数解析了以空格分隔的命令行参数，并构造最终会传递给execve的argv向量。第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。&lt;/p&gt;
&lt;p&gt;如果最后一个参数是&amp;amp;，那么parseline返回1，表示在后台执行该程序。否则返回0，表示在前台执行该程序。&lt;/p&gt;
&lt;p&gt;解析了命令行后，eval函数调用builtin_command函数，该函数检查第一个命令行参数是否是一个内置的shell命令。如果是，就立即解释这个命令，并返回1，否则返回0。简单的shell只有一个内置命令——quit命令，该命令会终止shell。&lt;/p&gt;
&lt;p&gt;如果builtin_command返回0，那么shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止。当作业终止时，shell开始下一轮迭代。&lt;/p&gt;
&lt;h2 id=&#34;信号&#34;&gt;信号&lt;/h2&gt;
&lt;p&gt;前面的异常控制流的学习中，我们已经看到了硬件和软件如何合作以提供基本的低层异常机制，以及操作系统如何利用异常来支持进程上下文切换的异常控制流形式。本节中将研究&lt;strong&gt;更高层的软件形式的异常&lt;/strong&gt;，称为Linux信号，其允许进程和内核中断其他进程。&lt;/p&gt;
&lt;p&gt;一个信号就是一条小消息，他通知进程系统中发生了一个某种类型的事件。&lt;/p&gt;
&lt;p&gt;每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下是对用户进程不可见的。信号提供了一种机制，通知用户进程发生了这些异常。例如如果一个进程试图除以0，那么内核就发送给它一个SIGFPE信号。&lt;/p&gt;
&lt;h3 id=&#34;信号术语&#34;&gt;信号术语&lt;/h3&gt;
&lt;p&gt;传送一个信号到目的进程是由两个不同步骤组成的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送信号。内核通过更新目的进程上下文的&lt;strong&gt;某个状态&lt;/strong&gt;，发送（传递）一个信号给目的进程。发送信号可能有以下原因：
&lt;ul&gt;
&lt;li&gt;内核检测到一个系统事件，例如除零错误&lt;/li&gt;
&lt;li&gt;一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给自己&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接受了信号。进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个发出而没有被接收的信号叫作待处理信号。&lt;/p&gt;
&lt;p&gt;任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都会被直接丢弃。一个进程可以有选择地阻塞接收某种信号。&lt;/p&gt;
&lt;h3 id=&#34;发送信号&#34;&gt;发送信号&lt;/h3&gt;
&lt;p&gt;Unix基于进程组提供了大量向进程发送信号的机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个进程都只属于一个进程组，进程组由一个正整数进程组ID来标识。getpgrp函数返回当前进程的进程组ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;pid_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;getpgrp&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个进程与其子进程属于同一个进程组，一个进程也可以通过使用set-pgid函数来改变自己或其他进程的进程组。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;setpgid&lt;/span&gt;(pid_t pid, pid_t pgid);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将进程pid的进程组改为pgid。如果pid为0就是用当前进程的PID。如果pgid是0就用pid指定的进程的PID作为进程组ID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用/bin/kill程序发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/bin/kill可以向另外的进程发送任意信号。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; /bin/kill -9 &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;15213&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发送信号9(SIGKILL)给进程15213.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从键盘发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unix shell使用&lt;strong&gt;作业&lt;/strong&gt;这个抽象概念来表示为&lt;strong&gt;对一条命令行求值而创建的进程&lt;/strong&gt;。在任何时刻至多只有&lt;strong&gt;一个前台作业和0个或多个后台作业&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ls | sort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会创建一个由两个进程组成的前台作业，这两个进程通过Unix管道连接起来：一个进程运行ls程序，另一个进程运行sort程序。shell为每个作业创建一个独立的进程组。进程组ID通常取自作业中父进程中的一个。&lt;/p&gt;
&lt;p&gt;在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下是终止前台作业。类似地，输入Ctrl+Z会发送一个SIGTSTP信号到前台中的每个进程。默认情况下是停止（挂起）前台作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用kill函数发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程通过调用kill函数发送信号给其他进程（包括自己）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;kill&lt;/span&gt;(pid_t pid, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sig);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，kill发送信号sig给进程组|pid|中的每个进程。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* $begin kill */&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;csapp.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{
    pid_t pid;

    &lt;span style=&#34;color:#888&#34;&gt;/* Child sleeps until SIGKILL signal received, then dies */&lt;/span&gt;   
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Fork()) &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {   
	Pause();  &lt;span style=&#34;color:#888&#34;&gt;/* Wait for a signal to arrive */&lt;/span&gt;  
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;control should never reach here!&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
	exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#888&#34;&gt;/* Parent sends a SIGKILL signal to a child */&lt;/span&gt;
    Kill(pid, SIGKILL);
    exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
}
&lt;span style=&#34;color:#888&#34;&gt;/* $end kill */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该示例中，父进程用kill函数发送SIGKILL信号给它的子进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用allarm函数发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程可以通过调用alarm函数向它自己发送SIGALARM信号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;alarm&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; secs);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;alarm函数安排内核在secs秒后发送一个SIGALARM信号给调用进程。如果secs是零，那么不会调度安排新的闹钟。&lt;/p&gt;
&lt;p&gt;任何情况下，对alarm的调用都将取消任何待处理的（pending）闹钟，并返回任何待处理的闹钟在被发送前还剩下的秒数。如果没有任何待处理的闹钟就返回零。&lt;/p&gt;
&lt;h3 id=&#34;接收信号&#34;&gt;接收信号&lt;/h3&gt;
&lt;p&gt;当内核把进程p从内核模式切换到用户模式（从系统调用返回或完成了一次上下文切换）时，它会检查进程p的未被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到p的逻辑控制流中的下一条指令。如果集合是非空，那么内核选择集合中的某个信号k，并强制p接收信号k。收到这个信号会触发进程采取某种行为。一旦进程完成这种行为，控制就传递回p的逻辑控制流中的下一条指令。每个信号都有一个预定义的默认行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程终止&lt;/li&gt;
&lt;li&gt;进程终止并转储内存&lt;/li&gt;
&lt;li&gt;进程停止（挂起）直到被SIGCONT信号重启&lt;/li&gt;
&lt;li&gt;进程忽略该信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程可以通过使用signal函数修改和信号相关联的默认行为。例外是SIGSTOP和SIGKILL，他们的默认行为不能更改。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;sighandler_t) (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
sighandler_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;signal&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若成功则返回指向前次处理程序的指针，若出错则为SIG_ERR。&lt;/p&gt;
&lt;h3 id=&#34;阻塞和解除阻塞信号&#34;&gt;阻塞和解除阻塞信号&lt;/h3&gt;
&lt;p&gt;Linux提供了阻塞信号的隐式和显式的机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。&lt;/li&gt;
&lt;li&gt;显式阻塞机制：应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编写信号处理程序&#34;&gt;编写信号处理程序&lt;/h3&gt;
&lt;p&gt;信号处理是Linux系统编程最棘手的一个问题。处理程序有几个属性使其很难推理分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理程序与主程序并发运行，共享同样的全局变量，可能与主程序和其他处理程序互相干扰&lt;/li&gt;
&lt;li&gt;如何以及何时接收信号的规则常常有违直觉&lt;/li&gt;
&lt;li&gt;不同系统有不同的信号处理语义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是信号处理程序的一些基本规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全的信号处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确的信号处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可移植的信号处理&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;同步流以避免讨厌的并发错误&#34;&gt;同步流以避免讨厌的并发错误&lt;/h3&gt;
&lt;p&gt;以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。&lt;/p&gt;
&lt;h3 id=&#34;显式地等待信号&#34;&gt;显式地等待信号&lt;/h3&gt;
&lt;p&gt;有时候主程序需要显式地等待某个信号处理程序运行。例如当Linux shell创建一个前台作业时，在接受下一条用户命令前，它必须等待作业终止，被SIGCHLD处理程序回收。&lt;/p&gt;
&lt;h2 id=&#34;非本地跳转&#34;&gt;非本地跳转&lt;/h2&gt;
&lt;p&gt;C语言提供了一种用户级异常控制流形式，称为非本地跳转，它将控制从一个函数转移到另一个当前正在执行的函数，不需要经过正常的调用-返回序列。非本地跳转通过setjmp和longjmp函数来提供。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;setjmp.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;setjmp&lt;/span&gt;(jmp_buf env);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sigsetjmp&lt;/span&gt;(sigjmp_buf env, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; savesigs);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;setjmp函数在env缓冲区保存&lt;strong&gt;当前调用环境&lt;/strong&gt;，以供后面的longjmp使用，并返回0.调用环境包括程序计数器、栈指针和通用目的寄存器。&lt;/p&gt;
&lt;h2 id=&#34;操作进程的工具&#34;&gt;操作进程的工具&lt;/h2&gt;
&lt;p&gt;Linux系统提供的大量的监控和操作进程的有用工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PS：列出当前系统中的进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TOP：打印出关于当前进程资源使用的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PMAP：显示进程的内存映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc：一个虚拟文件系统，以ASCII文本格式输出大量&lt;strong&gt;内核数据结构的内容&lt;/strong&gt;，用户程序可以读取这些内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 