<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sat, 05 Mar 2022 21:18:38 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Csapp 6 存储器层次结构</title>
        <link>https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link>
        <pubDate>Sat, 05 Mar 2022 21:18:38 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ -&lt;p&gt;基本的存储技术：SRAM存储器、DRAM存储器、ROM存储器以及旋转和固态的硬盘。&lt;/p&gt;
&lt;h2 id=&#34;存储技术&#34;&gt;存储技术&lt;/h2&gt;
&lt;h3 id=&#34;随机访问存储器&#34;&gt;随机访问存储器&lt;/h3&gt;
&lt;p&gt;RAM分为动态DRAM和静态SRAM两类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的DRAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增强的DRAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非易失性存储器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又称只读存储器ROM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问主存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据流通过总线在处理器和DRAM之间来来回回。这一系列步骤又称为总线事务。&lt;/p&gt;
&lt;p&gt;系统总线、内存总线。&lt;/p&gt;
&lt;h3 id=&#34;磁盘存储&#34;&gt;磁盘存储&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;磁盘构造&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁道、扇区、柱面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;磁盘容量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读、写数据。对扇区的访问时间主要由三个部分组成：寻道时间、旋转时间、传送时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑磁盘块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护逻辑块号和物理磁盘扇区之间的映射关系。一个（盘面，磁道，扇区）三元组唯一地标识了对应的物理扇区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接I/O设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I/O设备，例如显卡、鼠标、键盘、磁盘和网路适配器等，通过I/O总线与连接到CPU和主存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问磁盘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA技术，设备可以自己执行读或写总线事务而不需要CPU干涉。DMA传送完成，I/O设备通过给CPU发送一个中断信号来通知CPU。&lt;/p&gt;
&lt;h3 id=&#34;固态硬盘&#34;&gt;固态硬盘&lt;/h3&gt;
&lt;p&gt;SSD由一个或多个闪存芯片和闪存翻译层组成。&lt;/p&gt;
&lt;h2 id=&#34;局部性&#34;&gt;局部性&lt;/h2&gt;
&lt;p&gt;时间局部性：被引用过一次的内存位置可能在不远的将来再被多次引用。&lt;/p&gt;
&lt;p&gt;空间局部性：一个内存位置被引用了一次，那么程序可能在不远的将来引用附近的一个内存位置&lt;/p&gt;
&lt;h2 id=&#34;存储器层次结构&#34;&gt;存储器层次结构&lt;/h2&gt;
&lt;p&gt;L0：寄存器&lt;/p&gt;
&lt;p&gt;L1、2、3：高速缓存（SRAM）&lt;/p&gt;
&lt;p&gt;L4：主存（DRAM）&lt;/p&gt;
&lt;p&gt;L5：本地二级存储（本地磁盘）&lt;/p&gt;
&lt;p&gt;L6：远程二级存储（分布式文件系统、Web服务器）&lt;/p&gt;
&lt;p&gt;对于缓存的管理：&lt;/p&gt;
&lt;p&gt;每一层存储设备都是较低一层的缓存。在一个有虚拟内存的系统中，DRAM主存作为存储在磁盘上的数据块的缓存，由操作系统软件和CPU上的地址翻译硬件共同管理。&lt;/p&gt;
&lt;h2 id=&#34;高速缓存存储器&#34;&gt;高速缓存存储器&lt;/h2&gt;
&lt;p&gt;L1高速缓存：访问速度几乎和寄存器一样快，大约4个时钟周期。&lt;/p&gt;
&lt;p&gt;L2高速缓存：大约10个时钟周期。&lt;/p&gt;
&lt;p&gt;L3高速缓存：大约50个时钟周期。&lt;/p&gt;
&lt;h3 id=&#34;通用的高速缓冲存储器组织结构&#34;&gt;通用的高速缓冲存储器组织结构&lt;/h3&gt;
&lt;p&gt;一般来说，通用的高速缓存结构可以用元组（S，E，B，m）来描述。S为高速缓存的组数，E为每组的行数，B为每个高速缓存块的字节数，m为存储器（地址）的位数。&lt;/p&gt;
&lt;h3 id=&#34;直接映射高速缓存&#34;&gt;直接映射高速缓存&lt;/h3&gt;
&lt;p&gt;每个组只有一行（E=1）。&lt;/p&gt;
&lt;p&gt;高速缓存确定一个请求是否命中，然后抽取被请求的字的过程，分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组选择&lt;/li&gt;
&lt;li&gt;行匹配&lt;/li&gt;
&lt;li&gt;字选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组相联高速缓存&#34;&gt;组相联高速缓存&lt;/h3&gt;
&lt;p&gt;每个组都保存有多于一个的高速缓存行。&lt;/p&gt;
&lt;h3 id=&#34;全相联高速缓存&#34;&gt;全相联高速缓存&lt;/h3&gt;
&lt;p&gt;由一个包含所有高速缓存行的组组成的。&lt;/p&gt;
&lt;h3 id=&#34;有关写的问题&#34;&gt;有关写的问题&lt;/h3&gt;
&lt;p&gt;直写、写回；写分配，非写分配。&lt;/p&gt;
&lt;p&gt;一般建议采用使用写回——写分配的高速缓存的模型。因为存储器层次结构中较低层次的缓存更可能使用写回而不是直写。&lt;/p&gt;
&lt;h2 id=&#34;编写高速缓存友好的代码&#34;&gt;编写高速缓存友好的代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;让最常见的情况运行得块。要把注意力集中在核心函数里的循环上，忽略其他部分。&lt;/li&gt;
&lt;li&gt;尽量减小每个循环内部的缓存不命中的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;高速缓存对存储器性能的影响&#34;&gt;高速缓存对存储器性能的影响&lt;/h2&gt;
&lt;h3 id=&#34;存储器山&#34;&gt;存储器山&lt;/h3&gt;
&lt;h3 id=&#34;重新排列循环以提高空间局部性&#34;&gt;重新排列循环以提高空间局部性&lt;/h3&gt;
- https://eternityqjl.top/posts/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp11新特性总结</title>
        <link>https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 25 Feb 2022 20:47:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/ -&lt;p&gt;部分内容参考自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/103258069&#34;&gt;知乎 - jameswhale - C++11新特性总结（相比C++98）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;指针空值0-null-nullptr&#34;&gt;指针空值（0, NULL, nullptr）&lt;/h2&gt;
&lt;h2 id=&#34;nullptr与nullptr_t&#34;&gt;nullptr与nullptr_t&lt;/h2&gt;
&lt;h2 id=&#34;default&#34;&gt;=default&lt;/h2&gt;
&lt;p&gt;在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未显示定义的成员函数，包括构造函数、拷贝构造函数、拷贝赋值函数（operator =）、移动构造函数、移动拷贝函数、析构函数。一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。例如，声明了带参数的构造函数版本，则必须声明不带参数的版本以完成无参的变量初始化，而这会导致对应的类不再是POD的（非POD类型，意味着编译器失去了优化这样简单的数据类型的可能），通过=default 可以使其重新成为POD类型，见如下几个例子。&lt;/p&gt;
&lt;h2 id=&#34;delete&#34;&gt;=delete&lt;/h2&gt;
&lt;p&gt;在以前，程序员若希望限制一些默认函数的生成，例如，单件类的实现需要阻止其生成拷贝构造函数和拷贝赋值函数，可以将拷贝构造函数和拷贝赋值函数声明为private成员，并且不提供函数实现，C++11 标准给出了非常简洁的方法，即在函数的定义或者声明加上”= delete“。&lt;/p&gt;
&lt;h2 id=&#34;左值右值&#34;&gt;左值、右值&lt;/h2&gt;
&lt;p&gt;右值又称亡值、纯右值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++11新增了与右值引用相关的表达式。&lt;/li&gt;
&lt;li&gt;一般来说，左值引用不能接受一个右值，不过常量的左值引用能接受一个右值，比如函数指针的引用传递，const T&amp;amp;，可以减少临时对象的拷贝。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;列表初始化&#34;&gt;列表初始化&lt;/h2&gt;
&lt;p&gt;C++11新增了列表初始化方式，方便了代码编写。声明一个以initializer_list&lt;!-- raw HTML omitted --&gt; 模板类为参数的构造函数，自定义的类可以使用列表初始化方式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b[]{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;};
vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; c{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;};
map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; d &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;1.0f&lt;/span&gt;}, {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;3.2f&lt;/span&gt;}};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;};
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;扩展了using的使用&#34;&gt;扩展了using的使用&lt;/h2&gt;
&lt;p&gt;using不只是用来声明命名空间了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; uint &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; MapString &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;T, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&amp;gt;&lt;/span&gt;;
MapString&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; numberedString;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;auto&#34;&gt;auto&lt;/h2&gt;
&lt;p&gt;auto作为新的类型指示符，用于自动推导，特别是命名空间、模板等导致类型很长的时候，非常方便。对于指针类型，声明为auto* 或者auto 是一样的，对于&lt;strong&gt;引用类型&lt;/strong&gt;，必须使用&lt;strong&gt;auto &amp;amp;&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;decltype&#34;&gt;decltype&lt;/h2&gt;
&lt;p&gt;以一个普通的表达式为参数返回该&lt;strong&gt;表达式的类型&lt;/strong&gt;，在编译期进行。&lt;/p&gt;
&lt;h2 id=&#34;基于范围的for循环&#34;&gt;基于范围的for循环&lt;/h2&gt;
&lt;p&gt;对于知道范围的数组和stl容器，C++11提供了for迭代访问能力，结合auto，可简化代码。需要满足两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代的对象实现++和==操作；&lt;/li&gt;
&lt;li&gt;知道范围&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程编程&#34;&gt;多线程编程&lt;/h2&gt;
&lt;p&gt;C++11之前，在C/C++中程序中使用线程，主要使用POSIX线程（pthread），POSIX线程是POSIX标准中关于线程的部分，程序员可以通过pthread线程的api完成线程的创建、数据的共享、同步等功能。C++11引入了多线程的支持，使得C/C++语言在进行线程编程时，不必依赖第三方库和标准。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;atomic&amp;gt;		&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;thread&amp;gt;		&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;iostream&amp;gt;		&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;		
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;		
		
atomic_llong total{&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;};		
		
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; ){		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100000000LL&lt;/span&gt;;&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i){		
        total &lt;span style=&#34;color:#333&#34;&gt;+=&lt;/span&gt; i;		
    }		
}		
		
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;(){		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;thread&lt;/span&gt; t1(func, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;thread&lt;/span&gt; t2(func ,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);		
    t1.join();		
    t2.join();		
    cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; total &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;		
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;		
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;智能指针&#34;&gt;智能指针&lt;/h2&gt;
&lt;p&gt;C++11共有以下几种智能指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unique_ptr：拥有内存的所有权，没有拷贝构造函数，只有移动构造函数，不能多个unique_ptr对象共享一段内存，可以自定义delete函数，从而支持delete[]&lt;/li&gt;
&lt;li&gt;shared_ptr：通过计数方式，多个shared_ptr可以共享一段内存，计数为0时，所管理的内存会被删除，可以自定义delete函数，从而支持delete[]&lt;/li&gt;
&lt;li&gt;weak_ptr：观察shared_ptr管理的内存对象，只观察但不拥有。成员函数lock返回shared_ptr对象，若对应内存已经删除，则shared_ptr对象==nullptr，weak_ptr对象可以拷贝构造，拷贝构造出来的对象和原对象观察的是同一段内存。成员函数reset可以解除对内存的观察，注意，是解除观察，并不会删除对应内存对象。weak_ptr可以避免因为shared_ptr的循环引用引起的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h2&gt;
&lt;h2 id=&#34;pragma-once-或-_pragmaonce&#34;&gt;#Pragma once 或 _Pragma(&amp;ldquo;once&amp;rdquo;)&lt;/h2&gt;
&lt;p&gt;用来保证头文件只会被include一次。_Pragma是一个操作符，可以用在宏定义中，比预处理指令灵活。&lt;/p&gt;
&lt;h2 id=&#34;变长参数的宏定义&#34;&gt;变长参数的宏定义&lt;/h2&gt;
&lt;p&gt;变长参数的宏定义指的是在宏定义中参数列表的最后一个参数为省略号，预定义宏&lt;code&gt;__VA_ARGS__&lt;/code&gt;可以在宏定义的实现部分替换省略号代表队的字符串。&lt;/p&gt;
&lt;h2 id=&#34;cc混用头文件&#34;&gt;C/C++混用头文件&lt;/h2&gt;
&lt;p&gt;可以让如下头文件被#include到C文件中，也可以被#include到C++文件中，extern &amp;ldquo;C&amp;quot;可以抑制C++对函数名、变量名等符号进行重整，因此编译出的C目标文件和C++目标文件中的变量名和函数名都一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt; {
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;    
    
&lt;span style=&#34;color:#579&#34;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;常量表达式&#34;&gt;常量表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编译时常量：constexpr&lt;/li&gt;
&lt;li&gt;运行时常量：const&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp中的RAII机制</title>
        <link>https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 25 Feb 2022 19:17:30 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/ -&lt;h2 id=&#34;什么是raii&#34;&gt;什么是RAII&lt;/h2&gt;
&lt;p&gt;RAII即Resource Acquisition Is Initialization（资源获取就是初始化），是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。&lt;/p&gt;
&lt;h2 id=&#34;为什么要使用raii&#34;&gt;为什么要使用RAII&lt;/h2&gt;
&lt;p&gt;RAII是用来管理资源、避免资源泄露的方法。&lt;strong&gt;系统资源&lt;/strong&gt;有：网络套接字、互斥锁、文件句柄和内存等，是有限的。使用系统资源时要遵守：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请资源&lt;/li&gt;
&lt;li&gt;使用资源&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两部不可或缺，使用完成要要进行释放，否则会造成资源泄漏。&lt;/p&gt;
&lt;h2 id=&#34;如何使用raii&#34;&gt;如何使用RAII&lt;/h2&gt;
&lt;p&gt;当我们在一个函数内部使用&lt;strong&gt;局部变量&lt;/strong&gt;，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是&lt;strong&gt;类对象&lt;/strong&gt;时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。&lt;/p&gt;
&lt;p&gt;由于系统资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装，对资源的操作都封装在类的内部，在析构函数中进行释放资源。这样当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。&lt;/p&gt;
&lt;p&gt;使用RAII机制的代码举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std; 

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;ArrayOperation&lt;/span&gt; 
{
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; 
    ArrayOperation() 
    {
        m_Array &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;]; 
    }

    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;InitArray&lt;/span&gt;() 
    { 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i)
            &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;(m_Array &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; i) &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
    }

    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;ShowArray&lt;/span&gt;() 
    { 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;i) 
            cout&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;m_Array[i]&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl; 
    }

    &lt;span style=&#34;color:#333&#34;&gt;~&lt;/span&gt;ArrayOperation() 
    {
        cout&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;~ArrayOperation is called&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl; 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (m_Array &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;) {
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] m_Array;
            m_Array &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
        }
    }

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; m_Array;
};

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationA&lt;/span&gt;(); 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationB&lt;/span&gt;(); 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{
    ArrayOperation arrayOp;
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下为该例子不使用RAII机制的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std; 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationA&lt;/span&gt;(); 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationB&lt;/span&gt;(); 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; [&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;]; 

    &lt;span style=&#34;color:#888&#34;&gt;// Here, you can use the array 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;OperationA()) 
    { 
        &lt;span style=&#34;color:#888&#34;&gt;// If the operation A failed, we should delete the memory 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; [] testArray; 
        testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; 
    } 

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;OperationB()) 
    {
        &lt;span style=&#34;color:#888&#34;&gt;// If the operation A failed, we should delete the memory 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; [] testArray; 
        testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; 
    }

    &lt;span style=&#34;color:#888&#34;&gt;// All the operation succeed, delete the memory 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; [] testArray; 
    testArray &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt; ; 
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; 
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationA&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color:#888&#34;&gt;// Do some operation, if the operate succeed, then return true, else return false 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt; ; 
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;OperationB&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color:#888&#34;&gt;// Do some operation, if the operate succeed, then return true, else return false 
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;true&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/cpp%E4%B8%AD%E7%9A%84raii%E6%9C%BA%E5%88%B6/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp继承和多态</title>
        <link>https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link>
        <pubDate>Fri, 18 Feb 2022 19:47:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/ -&lt;p&gt;继承：类与类之间可以&lt;strong&gt;共用代码，实现代码重用&lt;/strong&gt;。（基类和派生类）&lt;/p&gt;
&lt;p&gt;多态：面向对象过程中，基类与派生类存在&lt;strong&gt;相同的方法&lt;/strong&gt;，但有&lt;strong&gt;不同的方法体&lt;/strong&gt;，调用是根据对象有选择地调用合适的方法。&lt;/p&gt;
&lt;p&gt;多态的几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须是公有继承&lt;/li&gt;
&lt;li&gt;必须通过基类的指针或引用指向派生类对象来访问呢派生类方法&lt;/li&gt;
&lt;li&gt;基类的方法必须是虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态的实现要求必须是共有继承&lt;/li&gt;
&lt;li&gt;继承关系中，父类更通用，子类更具体。父类具有一般的特征和行为，子类除了具有父类的特征和行为，还有自己特殊的行为和特征。&lt;/li&gt;
&lt;li&gt;继承关系中，并不要求基类方法一定是虚函数。多态要求基类方法必须是虚函数。&lt;/li&gt;
&lt;li&gt;多态：子类重写父类的方法，使得子类具有不同的实现。且运行时，根据实际创建的对象动态决定使用哪个方法。&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/cpp%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp 8 异常控制流</title>
        <link>https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
        <pubDate>Tue, 11 Jan 2022 15:33:44 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/ -&lt;p&gt;系统要对系统状态的变化作出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。&lt;/p&gt;
&lt;p&gt;现代系统通过使用&lt;strong&gt;控制流发生突变&lt;/strong&gt;来对这些情况作出反应，一般把这些突变称为&lt;strong&gt;异常控制流ECF&lt;/strong&gt;。ECF发生在&lt;strong&gt;计算机系统的各个层次&lt;/strong&gt;。例如，在&lt;strong&gt;硬件层&lt;/strong&gt;，硬件检测到的事件会触发控制突然转移到异常处理程序。在&lt;strong&gt;操作系统层&lt;/strong&gt;，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。&lt;/p&gt;
&lt;p&gt;理解ECP有很多用处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助理解重要的&lt;strong&gt;系统概念&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;理解应用程序如何&lt;strong&gt;与操作系统交互&lt;/strong&gt;。应用程序通过使用称为陷阱或系统调用的ECF形式，向操作系统请求服务。例如，向磁盘写数据、从网络读取数据、创建一个新进程，都是通过应用程序调用系统调用实现的。&lt;/li&gt;
&lt;li&gt;帮助理解&lt;strong&gt;并发&lt;/strong&gt;。ECF是计算机系统中实现并发的基本机制。&lt;/li&gt;
&lt;li&gt;帮助理解&lt;strong&gt;软件异常&lt;/strong&gt;如何工作。例如C++使用try、catch以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;p&gt;异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。&lt;/p&gt;
&lt;p&gt;异常就是控制流中的突变，用来响应处理器状态中的某些变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件&lt;/strong&gt;（event）：状态的变化。事件可能和当前指令的执行直接相关，比如发生虚拟内存缺页、算术溢出等。&lt;/p&gt;
&lt;p&gt;处理器检测到有事件发生时，就通过异常表的跳转表，进行一个间接过程调用，到一个异常处理程序进行处理。处理完后，根据引起异常的事件类型，会发生以下三种情况的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理程序将控制返回给当前指令&lt;/li&gt;
&lt;li&gt;处理程序将控制返回给下一条指令&lt;/li&gt;
&lt;li&gt;处理程序终止被中断的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;
&lt;p&gt;系统中可能为每种类型的异常都分配一个唯一的非负整数的&lt;strong&gt;异常号&lt;/strong&gt;。其中一些号码由&lt;strong&gt;处理器设计者&lt;/strong&gt;提供，另一些由&lt;strong&gt;操作系统内核的设计者&lt;/strong&gt;分配。前者的例子包括：缺页、内存访问违规、被零除及算术运算溢出。后者的例子包括：系统调用和来自外部I/O设备的信号。&lt;/p&gt;
&lt;p&gt;系统启动时，操作系统分配和初始化一张称为异常表的跳转表。使得表目k包含异常k的处理程序的地址。&lt;/p&gt;
&lt;p&gt;运行时（系统执行某个程序）处理器检测到发生了一个事件，并确定了响应的异常号k。随后处理器触发异常，执行间接调用过程，通过异常表的表目k，转到相应的处理程序。&lt;/p&gt;
&lt;p&gt;异常号是&lt;strong&gt;到异常表中的索引&lt;/strong&gt;，异常表的起始地址放在叫做异常表基址寄存器的特殊CPU寄存器中。&lt;/p&gt;
&lt;p&gt;异常与过程调用的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回地址不同：过程调用时，跳转到处理程序之前，处理器将返回地址压入栈中。而根据异常的类型，返回地址要么是当前指令，要么是下一条指令。&lt;/li&gt;
&lt;li&gt;异常处理中处理器也把一些额外的处理器状态压入栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。&lt;/li&gt;
&lt;li&gt;如果控制从用户程序转移到内核，所有这些项目都被压入内核栈中，而不是压到用户栈中。&lt;/li&gt;
&lt;li&gt;异常处理程序运行在内核模式下，这意味着其对所有系统资源都有完全的访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦硬件触发了异常，剩下的工作就由&lt;strong&gt;异常处理程序&lt;/strong&gt;在软件中完成。处理完事件后，通过执行一条特殊的从中断返回指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中。如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将控制返回给被中断的程序。&lt;/p&gt;
&lt;h3 id=&#34;异常的类别&#34;&gt;异常的类别&lt;/h3&gt;
&lt;p&gt;异常分为中断、陷阱、故障、终止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中断是&lt;strong&gt;异步&lt;/strong&gt;发生的，是来自处理器&lt;strong&gt;外部的I/O设备的信号&lt;/strong&gt;的结果。硬件中断&lt;strong&gt;不是由任何一条专门的指令&lt;/strong&gt;造成的，因此它是异步的。硬件中观的异常处理程序常称为中断处理程序。&lt;/p&gt;
&lt;p&gt;当前只能怪执行完后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，就将控制返回给下一条指令。结果是程序继续运行，就好像没有发生过中断一样。&lt;/p&gt;
&lt;p&gt;剩下的异常类型是&lt;strong&gt;同步&lt;/strong&gt;发生的，是执行当前指令的结果，把这类指令称为&lt;strong&gt;故障指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱和系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在&lt;strong&gt;用户程序和内核之间&lt;/strong&gt;提供一个像过程一样的接口，称为系统调用。&lt;/p&gt;
&lt;p&gt;用户经常要向内核请求服务，比如读一个文件（read）、创建一个新进程（fork）、加载一个新程序（execve），或终止当前程序（exit）。为了允许对这些内核服务的受控访问，处理器提供了一条特殊的&lt;code&gt;syscall n&lt;/code&gt;的指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个程序解析参数，并调用适当的内核程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;故障是由错误引起的，他可能&lt;strong&gt;被故障处理程序修正&lt;/strong&gt;。故障发生时，处理器将控制转移给故障处理程序。如果故障处理程序能够修正这个错误，他就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，该例程会终止引起故障的应用程序。&lt;/p&gt;
&lt;p&gt;一个经典的故障示例是缺页异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，例如DRAM或SRAM位被损坏时发生的奇偶错误。&lt;/p&gt;
&lt;h3 id=&#34;linuxx86-64中的异常&#34;&gt;Linux/x86-64中的异常&lt;/h3&gt;
&lt;p&gt;x86-64有256种不同类型的异常，0~31号对应的由Intel架构师定义的异常，对任何x86-64系统都是一样的。32~255号对应的是操作系统定义的中断和陷阱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux/x86-64故障和终止&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除法错误（异常0）：Unix不会试图从除法错误中恢复，而是选择终止程序。&lt;/li&gt;
&lt;li&gt;一般保护故障（异常13）：通常因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这些故障。&lt;/li&gt;
&lt;li&gt;缺页（异常14）：会重新执行产生故障的指令的一个示例。&lt;/li&gt;
&lt;li&gt;机器检查（异常18）：在导致故障的指令执行中检测到致命的硬件错误时发生的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux/x86-64系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux提供几百种系统调用，以下为一些常见的系统调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201071509742.png&#34; alt=&#34;Linux常见系统调用&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个系统调用都有唯一的整数号，对应于一个到内核中跳转表的偏移量。&lt;/p&gt;
&lt;p&gt;C程序用syscall函数可以直接调用任何系统调用。而实际中没必要这样做，对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用函数。&lt;/p&gt;
&lt;p&gt;处理器ISA规范通常会区分异步中断和同步异常，但并不提供表述这些非常相似的概念的概括性的术语。为了避免混乱，我们使用异常作为通用术语，只要在必要时才区分异步异常（中断）和同步异常（陷阱、故障和终止）。&lt;/p&gt;
&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;p&gt;进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。&lt;/p&gt;
&lt;p&gt;进程提供给应用程序的关键抽象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个独立的逻辑控制流：提供我们的程序&lt;strong&gt;独占地使用处理器&lt;/strong&gt;的假象&lt;/li&gt;
&lt;li&gt;一个私有的地址空间：提供我们的程序&lt;strong&gt;独占地使用内存系统&lt;/strong&gt;的假象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;逻辑控制流&#34;&gt;逻辑控制流&lt;/h3&gt;
&lt;p&gt;进程为每个程序提供了一种假象，好像程序在独占地使用处理器。&lt;/p&gt;
&lt;p&gt;进程轮流使用处理器。每个进程执行它的流的一部分，然后被抢占，然后轮到其他进程。&lt;/p&gt;
&lt;h3 id=&#34;并发流&#34;&gt;并发流&lt;/h3&gt;
&lt;p&gt;一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发地运行。&lt;/p&gt;
&lt;p&gt;多个流并发地执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。&lt;/p&gt;
&lt;h3 id=&#34;私有地址空间&#34;&gt;私有地址空间&lt;/h3&gt;
&lt;p&gt;进程为每个程序提供它自己的私有地址空间。和这个空间中某个地址相关联的哪个内存字节是不能被其他进程读和写的。&lt;/p&gt;
&lt;p&gt;尽管每个私有地址空间相关联的内存一般是不同的，但每个这样的空间都有相同的通用结构。&lt;/p&gt;
&lt;h3 id=&#34;用户模式和内核模式&#34;&gt;用户模式和内核模式&lt;/h3&gt;
&lt;p&gt;处理器提供了一种限制一个应用可以执行的指令以及它可以访问的地址空间范围。&lt;/p&gt;
&lt;p&gt;处理器通常用某个控制寄存器中的一个模式位来提供这种功能，该寄存器描述了当前享有的特权。设置了模式位后，进程就运行在内核模式中。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。&lt;/p&gt;
&lt;p&gt;未设置模式位时，进程运行在用户模式。用户模式中的进程不允许执行特权指令，例如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。&lt;/p&gt;
&lt;h3 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h3&gt;
&lt;p&gt;操作系统内核使用一种称为上下文切换的较高层形式的异常流控制来实现多任务切换。&lt;/p&gt;
&lt;p&gt;内核为每个进程维持一个上下文。上下文就是内核重启一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，如页表、进程表和文件表。&lt;/p&gt;
&lt;p&gt;进程执行的某些时刻，内核可以抢占当前当前进程，并重新开始一个先前被抢占的进程，这种决策称为&lt;strong&gt;调度&lt;/strong&gt;。由内核中的调度器的代码处理的。&lt;/p&gt;
&lt;p&gt;上下文切换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存当前进程的上下文&lt;/li&gt;
&lt;li&gt;恢复某个先前被抢占的进程被保存的上下文&lt;/li&gt;
&lt;li&gt;将控制传递给这个新的恢复进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断可以引发上下文切换。例如从磁盘取完数据之后的中断。&lt;/p&gt;
&lt;h2 id=&#34;系统调用错误处理&#34;&gt;系统调用错误处理&lt;/h2&gt;
&lt;p&gt;当Unix系统级函数遇到错误时，通常会返回-1，并设置全局整数变量errno来表示出现什么错误。&lt;/p&gt;
&lt;p&gt;fork函数检查错误的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fork()) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
	fprintf(stderr, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;fork error: %s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, strerror(errno));
	exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;strerror函数返回一个文本串，描述了和某个errno值相关联的错误。通过定义以下函数，来简化代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;unix_error&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;msg) &lt;span style=&#34;color:#888&#34;&gt;/* Unix-style error */&lt;/span&gt;
{
    fprintf(stderr, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s: %s&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, msg, strerror(errno));
    exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时对fork的调用缩减到2行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; fork()) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;)
	unix_error(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;fork error&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用csapp.h定义的处理包装函数可以进一步简化代码。&lt;/p&gt;
&lt;h2 id=&#34;进程控制&#34;&gt;进程控制&lt;/h2&gt;
&lt;p&gt;描述Unix提供的大量从C程序中操作进程的系统调用函数。&lt;/p&gt;
&lt;h3 id=&#34;获取进程id&#34;&gt;获取进程ID&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;pid_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;getpid&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;创建和终止进程&#34;&gt;创建和终止进程&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; status);
pid_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;fork&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;exit函数以status退出状态来终止进程。&lt;/p&gt;
&lt;p&gt;父进程通过调用fork函数创建一个新的运行的子进程。&lt;/p&gt;
&lt;h3 id=&#34;回收子进程&#34;&gt;回收子进程&lt;/h3&gt;
&lt;p&gt;当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。进程被保持在一种已终止的状态，直到被它的父进程回收。当父进程回收已经终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被会回收的进程称为僵死进程。&lt;/p&gt;
&lt;h3 id=&#34;让进程休眠&#34;&gt;让进程休眠&lt;/h3&gt;
&lt;p&gt;sleep函数将一个进程挂起一段指定的时间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;include &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;unistd.h&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sleep(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; secs);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。&lt;/p&gt;
&lt;p&gt;还有一个有用的函数pause，该函数让调用函数休眠，直到该进程收到一个信号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;pause&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;加载并运行程序&#34;&gt;加载并运行程序&lt;/h3&gt;
&lt;p&gt;execve函数在当前进程的上下文中加载并运行一个新程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;execve&lt;/span&gt;(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;filename, &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;argv[],
			&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数加载并运行&lt;strong&gt;可执行目标文件filename&lt;/strong&gt;，且带&lt;strong&gt;参数列表argv&lt;/strong&gt;和&lt;strong&gt;环境变量列表envp&lt;/strong&gt;。只有出现错误时才返回到调用程序。execve调用一次并从不返回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201092346534.png&#34; alt=&#34;execve函数参数列表和环境变量列表&#34;&gt;&lt;/p&gt;
&lt;p&gt;在execve加载了filename后，调用&lt;a href=&#34;https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/#%e5%8a%a0%e8%bd%bd%e5%8f%af%e6%89%a7%e8%a1%8c%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6&#34;&gt;7.9 加载可执行目标文件&lt;/a&gt;中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数main，该函数有以下形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;argv[], &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;envp[]);
&lt;span style=&#34;color:#888&#34;&gt;//或者等价的
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;envp);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;main开始执行时，用户栈的组织结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201092354435.png&#34; alt=&#34;新程序开始时的用户栈&#34;&gt;&lt;/p&gt;
&lt;p&gt;从栈底（高地址）到栈顶（低地址）的方向依次有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以null结尾的指针数组，其中每个指针都指向栈中的一个&lt;strong&gt;环境变量字符串&lt;/strong&gt;。全局变量environ指向这些指针中的第一个envp[0]&lt;/li&gt;
&lt;li&gt;以null结尾的argv[]数组，其中每个元素都指向栈中的一个&lt;strong&gt;参数字符串&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;栈顶是系统启动函数libc_start_main的栈帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;main函数的三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;argc：给出argv[]数组中非空指针的数量&lt;/li&gt;
&lt;li&gt;argv：指向argv[]数组中的第一个条目&lt;/li&gt;
&lt;li&gt;envp：指向envp[]数组中的第一个条目&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;利用fork和execve运行程序&#34;&gt;利用fork和execve运行程序&lt;/h3&gt;
&lt;p&gt;Unix shell这样的程序大量使用了fork和execve函数。shell是一个交互型的应用程序，他代表用户运行其他程序。最早的shell是sh程序，shell执行一系列的&lt;strong&gt;读/求值&lt;/strong&gt;步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* $begin shellmain */&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;csapp.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define MAXARGS   128
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;/* Function prototypes */&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;eval&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;cmdline);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;parseline&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;buf, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;builtin_command&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv); 

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; cmdline[MAXLINE]; &lt;span style=&#34;color:#888&#34;&gt;/* Command line */&lt;/span&gt;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;) {
	&lt;span style=&#34;color:#888&#34;&gt;/* Read */&lt;/span&gt;
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;gt; &amp;#34;&lt;/span&gt;);                   
	Fgets(cmdline, MAXLINE, stdin); 
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (feof(stdin))
	    exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);

	&lt;span style=&#34;color:#888&#34;&gt;/* Evaluate */&lt;/span&gt;
	eval(cmdline);
    } 
}
&lt;span style=&#34;color:#888&#34;&gt;/* $end shellmain */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上为一个简单的shell的main例程。shell打印一个命令行提示符，等待用户在stdin上输入命令，然后对这个命令行求值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* $begin eval */&lt;/span&gt;
&lt;span style=&#34;color:#888&#34;&gt;/* eval - Evaluate a command line */&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;eval&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;cmdline) 
{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;argv[MAXARGS]; &lt;span style=&#34;color:#888&#34;&gt;/* Argument list execve() */&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[MAXLINE];   &lt;span style=&#34;color:#888&#34;&gt;/* Holds modified command line */&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; bg;              &lt;span style=&#34;color:#888&#34;&gt;/* Should the job run in bg or fg? */&lt;/span&gt;
    pid_t pid;           &lt;span style=&#34;color:#888&#34;&gt;/* Process id */&lt;/span&gt;
    
    strcpy(buf, cmdline);
    bg &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; parseline(buf, argv); 
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;)  
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;   &lt;span style=&#34;color:#888&#34;&gt;/* Ignore empty lines */&lt;/span&gt;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;builtin_command(argv)) { 
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Fork()) &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {   &lt;span style=&#34;color:#888&#34;&gt;/* Child runs user job */&lt;/span&gt;
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (execve(argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], argv, environ) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
                printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%s: Command not found.&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
                exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
            }
        }

	&lt;span style=&#34;color:#888&#34;&gt;/* Parent waits for foreground job to terminate */&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;bg) {
	    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; status;
	    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (waitpid(pid, &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;status, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;)
		unix_error(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;waitfg: waitpid error&amp;#34;&lt;/span&gt;);
	}
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
	    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d %s&amp;#34;&lt;/span&gt;, pid, cmdline);
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;
}

&lt;span style=&#34;color:#888&#34;&gt;/* If first arg is a builtin command, run it and return true */&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;builtin_command&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;argv) 
{
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;strcmp(argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;quit&amp;#34;&lt;/span&gt;)) &lt;span style=&#34;color:#888&#34;&gt;/* quit command */&lt;/span&gt;
	exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);  
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;strcmp(argv[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt;))    &lt;span style=&#34;color:#888&#34;&gt;/* Ignore singleton &amp;amp; */&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;                     &lt;span style=&#34;color:#888&#34;&gt;/* Not a builtin command */&lt;/span&gt;
}
&lt;span style=&#34;color:#888&#34;&gt;/* $end eval */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上为对命令行求值的代码。首要任务是调用parseline函数，该函数解析了以空格分隔的命令行参数，并构造最终会传递给execve的argv向量。第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。&lt;/p&gt;
&lt;p&gt;如果最后一个参数是&amp;amp;，那么parseline返回1，表示在后台执行该程序。否则返回0，表示在前台执行该程序。&lt;/p&gt;
&lt;p&gt;解析了命令行后，eval函数调用builtin_command函数，该函数检查第一个命令行参数是否是一个内置的shell命令。如果是，就立即解释这个命令，并返回1，否则返回0。简单的shell只有一个内置命令——quit命令，该命令会终止shell。&lt;/p&gt;
&lt;p&gt;如果builtin_command返回0，那么shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止。当作业终止时，shell开始下一轮迭代。&lt;/p&gt;
&lt;h2 id=&#34;信号&#34;&gt;信号&lt;/h2&gt;
&lt;p&gt;前面的异常控制流的学习中，我们已经看到了硬件和软件如何合作以提供基本的低层异常机制，以及操作系统如何利用异常来支持进程上下文切换的异常控制流形式。本节中将研究&lt;strong&gt;更高层的软件形式的异常&lt;/strong&gt;，称为Linux信号，其允许进程和内核中断其他进程。&lt;/p&gt;
&lt;p&gt;一个信号就是一条小消息，他通知进程系统中发生了一个某种类型的事件。&lt;/p&gt;
&lt;p&gt;每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下是对用户进程不可见的。信号提供了一种机制，通知用户进程发生了这些异常。例如如果一个进程试图除以0，那么内核就发送给它一个SIGFPE信号。&lt;/p&gt;
&lt;h3 id=&#34;信号术语&#34;&gt;信号术语&lt;/h3&gt;
&lt;p&gt;传送一个信号到目的进程是由两个不同步骤组成的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送信号。内核通过更新目的进程上下文的&lt;strong&gt;某个状态&lt;/strong&gt;，发送（传递）一个信号给目的进程。发送信号可能有以下原因：
&lt;ul&gt;
&lt;li&gt;内核检测到一个系统事件，例如除零错误&lt;/li&gt;
&lt;li&gt;一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给自己&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接受了信号。进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个发出而没有被接收的信号叫作待处理信号。&lt;/p&gt;
&lt;p&gt;任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都会被直接丢弃。一个进程可以有选择地阻塞接收某种信号。&lt;/p&gt;
&lt;h3 id=&#34;发送信号&#34;&gt;发送信号&lt;/h3&gt;
&lt;p&gt;Unix基于进程组提供了大量向进程发送信号的机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个进程都只属于一个进程组，进程组由一个正整数进程组ID来标识。getpgrp函数返回当前进程的进程组ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;pid_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;getpgrp&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个进程与其子进程属于同一个进程组，一个进程也可以通过使用set-pgid函数来改变自己或其他进程的进程组。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;setpgid&lt;/span&gt;(pid_t pid, pid_t pgid);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将进程pid的进程组改为pgid。如果pid为0就是用当前进程的PID。如果pgid是0就用pid指定的进程的PID作为进程组ID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用/bin/kill程序发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/bin/kill可以向另外的进程发送任意信号。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; /bin/kill -9 &lt;span style=&#34;color:#60e;font-weight:bold&#34;&gt;15213&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发送信号9(SIGKILL)给进程15213.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从键盘发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unix shell使用&lt;strong&gt;作业&lt;/strong&gt;这个抽象概念来表示为&lt;strong&gt;对一条命令行求值而创建的进程&lt;/strong&gt;。在任何时刻至多只有&lt;strong&gt;一个前台作业和0个或多个后台作业&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ls | sort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会创建一个由两个进程组成的前台作业，这两个进程通过Unix管道连接起来：一个进程运行ls程序，另一个进程运行sort程序。shell为每个作业创建一个独立的进程组。进程组ID通常取自作业中父进程中的一个。&lt;/p&gt;
&lt;p&gt;在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下是终止前台作业。类似地，输入Ctrl+Z会发送一个SIGTSTP信号到前台中的每个进程。默认情况下是停止（挂起）前台作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用kill函数发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程通过调用kill函数发送信号给其他进程（包括自己）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;kill&lt;/span&gt;(pid_t pid, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sig);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，kill发送信号sig给进程组|pid|中的每个进程。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;/* $begin kill */&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;#34;csapp.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{
    pid_t pid;

    &lt;span style=&#34;color:#888&#34;&gt;/* Child sleeps until SIGKILL signal received, then dies */&lt;/span&gt;   
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; ((pid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; Fork()) &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {   
	Pause();  &lt;span style=&#34;color:#888&#34;&gt;/* Wait for a signal to arrive */&lt;/span&gt;  
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;control should never reach here!&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
	exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#888&#34;&gt;/* Parent sends a SIGKILL signal to a child */&lt;/span&gt;
    Kill(pid, SIGKILL);
    exit(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
}
&lt;span style=&#34;color:#888&#34;&gt;/* $end kill */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该示例中，父进程用kill函数发送SIGKILL信号给它的子进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用allarm函数发送信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程可以通过调用alarm函数向它自己发送SIGALARM信号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;alarm&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; secs);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;alarm函数安排内核在secs秒后发送一个SIGALARM信号给调用进程。如果secs是零，那么不会调度安排新的闹钟。&lt;/p&gt;
&lt;p&gt;任何情况下，对alarm的调用都将取消任何待处理的（pending）闹钟，并返回任何待处理的闹钟在被发送前还剩下的秒数。如果没有任何待处理的闹钟就返回零。&lt;/p&gt;
&lt;h3 id=&#34;接收信号&#34;&gt;接收信号&lt;/h3&gt;
&lt;p&gt;当内核把进程p从内核模式切换到用户模式（从系统调用返回或完成了一次上下文切换）时，它会检查进程p的未被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到p的逻辑控制流中的下一条指令。如果集合是非空，那么内核选择集合中的某个信号k，并强制p接收信号k。收到这个信号会触发进程采取某种行为。一旦进程完成这种行为，控制就传递回p的逻辑控制流中的下一条指令。每个信号都有一个预定义的默认行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程终止&lt;/li&gt;
&lt;li&gt;进程终止并转储内存&lt;/li&gt;
&lt;li&gt;进程停止（挂起）直到被SIGCONT信号重启&lt;/li&gt;
&lt;li&gt;进程忽略该信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程可以通过使用signal函数修改和信号相关联的默认行为。例外是SIGSTOP和SIGKILL，他们的默认行为不能更改。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;sighandler_t) (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);
sighandler_t &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;signal&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若成功则返回指向前次处理程序的指针，若出错则为SIG_ERR。&lt;/p&gt;
&lt;h3 id=&#34;阻塞和解除阻塞信号&#34;&gt;阻塞和解除阻塞信号&lt;/h3&gt;
&lt;p&gt;Linux提供了阻塞信号的隐式和显式的机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。&lt;/li&gt;
&lt;li&gt;显式阻塞机制：应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编写信号处理程序&#34;&gt;编写信号处理程序&lt;/h3&gt;
&lt;p&gt;信号处理是Linux系统编程最棘手的一个问题。处理程序有几个属性使其很难推理分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理程序与主程序并发运行，共享同样的全局变量，可能与主程序和其他处理程序互相干扰&lt;/li&gt;
&lt;li&gt;如何以及何时接收信号的规则常常有违直觉&lt;/li&gt;
&lt;li&gt;不同系统有不同的信号处理语义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是信号处理程序的一些基本规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全的信号处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确的信号处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可移植的信号处理&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;同步流以避免讨厌的并发错误&#34;&gt;同步流以避免讨厌的并发错误&lt;/h3&gt;
&lt;p&gt;以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。&lt;/p&gt;
&lt;h3 id=&#34;显式地等待信号&#34;&gt;显式地等待信号&lt;/h3&gt;
&lt;p&gt;有时候主程序需要显式地等待某个信号处理程序运行。例如当Linux shell创建一个前台作业时，在接受下一条用户命令前，它必须等待作业终止，被SIGCHLD处理程序回收。&lt;/p&gt;
&lt;h2 id=&#34;非本地跳转&#34;&gt;非本地跳转&lt;/h2&gt;
&lt;p&gt;C语言提供了一种用户级异常控制流形式，称为非本地跳转，它将控制从一个函数转移到另一个当前正在执行的函数，不需要经过正常的调用-返回序列。非本地跳转通过setjmp和longjmp函数来提供。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;setjmp.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;setjmp&lt;/span&gt;(jmp_buf env);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sigsetjmp&lt;/span&gt;(sigjmp_buf env, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; savesigs);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;setjmp函数在env缓冲区保存&lt;strong&gt;当前调用环境&lt;/strong&gt;，以供后面的longjmp使用，并返回0.调用环境包括程序计数器、栈指针和通用目的寄存器。&lt;/p&gt;
&lt;h2 id=&#34;操作进程的工具&#34;&gt;操作进程的工具&lt;/h2&gt;
&lt;p&gt;Linux系统提供的大量的监控和操作进程的有用工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PS：列出当前系统中的进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TOP：打印出关于当前进程资源使用的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PMAP：显示进程的内存映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc：一个虚拟文件系统，以ASCII文本格式输出大量&lt;strong&gt;内核数据结构的内容&lt;/strong&gt;，用户程序可以读取这些内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://eternityqjl.top/posts/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>八股文——操作系统相关</title>
        <link>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Sat, 08 Jan 2022 22:13:05 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/ -&lt;h2 id=&#34;进程和线程的区别&#34;&gt;进程和线程的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程是资源（CPU、内存等）分配的基本单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程是进程的一个实体，是CPU调度和分配的基本单位（程序执行的最小单位）。线程自身不拥有系统资源，但可与同属一个进程的其他线程共享进程所拥有的全部资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程崩溃就等于整个进程崩溃，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程同步通信方法&#34;&gt;进程同步（通信）方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;管道：一个进程链接数据流到另一个进程，就是把一个进程的输出直接传递给另一个进程的输入。
&lt;ul&gt;
&lt;li&gt;无名管道适用于父子进程间的通信&lt;/li&gt;
&lt;li&gt;管道是基于字节流的&lt;/li&gt;
&lt;li&gt;半双工，数据同一时间只能从一个方向传输&lt;/li&gt;
&lt;li&gt;自带同步机制，在保证数据安全前提下，按照特定顺序访问临界资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号：处理异步事件的方式，用于接收通知进程有某种事情发生，也可发送信号给进程本身。&lt;/li&gt;
&lt;li&gt;信号量
&lt;ul&gt;
&lt;li&gt;处理进程间同步和互斥的通信机制，类似于资源计数器，保证任意时刻只有一个进程访问代码的临界区。临界期指执行数据更新的代码需要独占式地执行&lt;/li&gt;
&lt;li&gt;P操作&lt;/li&gt;
&lt;li&gt;V操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息队列：消息的链表，提供了一个进程向另一个进程发送数据块的方法，每个数据块可被认为是有一个类型，接收者接受的数据块可以有不同的类型。
&lt;ul&gt;
&lt;li&gt;生命周期随内核存在，需要显式调用或删除&lt;/li&gt;
&lt;li&gt;可以双向通信，且克服了管道只能承载无格式字节流的缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享内存：同一物理内存被映射到两个进程的地址空间，两个进程都可以访问这段空间，从而实现进程间通信
&lt;ul&gt;
&lt;li&gt;最快的IPC形式，内存映射到两个进程的地址空间，进程数据传递不再涉及内核&lt;/li&gt;
&lt;li&gt;共享内存的生命周期随进程存在，需要显式地删除&lt;/li&gt;
&lt;li&gt;没有互斥与同步机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;socket：套接字，应用层与传输层之间的一个抽象，socket是一种”打开——读写——关闭“模式的实现，作为服务器和客户端之间维护的”文件“，可以向文件写入内容供对方读取或读取对方的内容，通信结束时关闭文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程间通信方法&#34;&gt;线程间通信方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;读写锁&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;硬中断和软中断的区别&#34;&gt;硬中断和软中断的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;软中断是执行中断指令产生的，硬中断是由外设引发的&lt;/li&gt;
&lt;li&gt;硬中断的中断号是由中断控制器提供的，软中断的中断号是由指令直接指出，无需使用中断控制器。&lt;/li&gt;
&lt;li&gt;硬中断是可屏蔽的，软中断不可屏蔽。&lt;/li&gt;
&lt;li&gt;硬中断处理程序要确保它能快速完成任务，这样程序执行时才不会等待较长时间，称为上半部。&lt;/li&gt;
&lt;li&gt;软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;h3 id=&#34;死锁发生的四个必要条件&#34;&gt;死锁发生的四个必要条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥条件：进程要求对所分配的资源进行排他性控制，在一段时间内某资源仅为一进程所占用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无法剥夺条件：进程已获得的资源在未使用完之前，无法剥夺，只能在使用完后由自己释放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环路等待条件：发生死锁时，必然存在一个进程——资源的环形链路&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;预防死锁&#34;&gt;预防死锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;资源一次性分配：破坏请求条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要有一个资源得不到分配，不给这个进程分配其他的资源：破坏请求保持条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可剥夺资源：当进程获得了部分资源但得不到其他资源，则释放已占用资源：破坏不可剥夺条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源有序分配法：进程按规定顺序请求资源，释放则相反：破坏环路等待条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;互斥锁和自旋锁的选择&#34;&gt;互斥锁和自旋锁的选择&lt;/h2&gt;
&lt;p&gt;利用加锁来实现互斥和同步的一般模型为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加锁$\rightarrow$临界区：访问公共变量$\rightarrow$解锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当判断lock已被加锁，则有两种处理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用系统函数将当前线程阻塞（互斥）&lt;/li&gt;
&lt;li&gt;使其一直处于循环判断的状态（自旋）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阻塞当前线程可以让出CPU资源去执行别的线程，通过减少CPU浪费来提高效率；但切换线程需要进行上下文切换，耗费时间较长。对于线程占用锁时间短的情况，自旋锁会更加高效。&lt;/p&gt;
&lt;h2 id=&#34;信号量和互斥量&#34;&gt;信号量和互斥量&lt;/h2&gt;
&lt;p&gt;互斥量只能用于一个资源的互斥访问，而信号量可以实现多个同类资源的多线程互斥和同步。&lt;/p&gt;
&lt;p&gt;互斥量在任意时刻只允许一个线程访问某个共享资源，而信号量则允许固定数量的线程访问某个共享资源池，即互斥量是信号量n为1的特殊情况。&lt;/p&gt;
&lt;h2 id=&#34;软中断tasklet和工作队列&#34;&gt;软中断、tasklet和工作队列&lt;/h2&gt;
&lt;p&gt;这三者都属于中断的下半部，区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软中断可以并发运行在多个CPU上，因此必须设计为可重入函数，也需要使用自旋锁来保护其数据结构&lt;/li&gt;
&lt;li&gt;同一类型的tasklet只能运行在一个CPU上，只能串行执行；不同类型tasklet可以并行在多个CPU上&lt;/li&gt;
&lt;li&gt;软中断是静态分配的，内核编译完后不能改变；tasklet可以运行时改变&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux内核的组成部分&#34;&gt;Linux内核的组成部分&lt;/h2&gt;
&lt;p&gt;进程调度、内存管理、虚拟文件系统、网络接口&lt;/p&gt;
&lt;h2 id=&#34;内核态和用户态的区别&#34;&gt;内核态和用户态的区别&lt;/h2&gt;
&lt;p&gt;操作系统的两种运行级别，以限制不同程序的访问权限。内核态可以访问所有数据，包括外围设备；用户态只能受限地访问内存，不允许访问外围设备。&lt;/p&gt;
&lt;p&gt;三种方式由用户态切换到内核态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用，如库函数malloc，调用brk()或mmap()指令&lt;/li&gt;
&lt;li&gt;异常&lt;/li&gt;
&lt;li&gt;外设中断&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;硬链接和软链接&#34;&gt;硬链接和软链接&lt;/h2&gt;
&lt;h3 id=&#34;硬链接&#34;&gt;硬链接&lt;/h3&gt;
&lt;p&gt;Linux下的文件是通过索引节点（i-node）来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配i-node。每添加一个硬链接，文件的链接数就加1，只有当该文件的所有链接都被删除后，文件才会从硬盘中被完全移除。&lt;/p&gt;
&lt;p&gt;不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可以在不同文件系统的文件间建立链接&lt;/li&gt;
&lt;li&gt;只有超级用户才能为目录创建硬链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;软链接&#34;&gt;软链接&lt;/h3&gt;
&lt;p&gt;又称符号链接，包含的是原文件的i-node记录。没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。删除软链接不影响被指向的文件，但若源文件被删除，则软链接将会失效。&lt;/p&gt;
&lt;p&gt;不足：&lt;/p&gt;
&lt;p&gt;因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。&lt;/p&gt;
&lt;p&gt;实际场景下，一般使用软链接。&lt;/p&gt;
&lt;h2 id=&#34;文件权限与归属&#34;&gt;文件权限与归属&lt;/h2&gt;
&lt;p&gt;每个文件都有归属的所有者和所有组，并规定了文件的所有者、所有组以及其他人对文件所拥有的读、写、执行等权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读：read，r，4来表示；&lt;/li&gt;
&lt;li&gt;写：write，w，2来表示；&lt;/li&gt;
&lt;li&gt;执行：execute，x，1来表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-rwx-rw-r--  1  root  root&lt;/code&gt;：第一个&lt;code&gt;-&lt;/code&gt;表示文件类型，&lt;code&gt;rwx-rw-r--&lt;/code&gt;表示访问权限，最后两个表示属主和属组。&lt;/p&gt;
&lt;p&gt;文件类型：普通文件&lt;code&gt;-&lt;/code&gt;、目录文件&lt;code&gt;d&lt;/code&gt;、链接文件&lt;code&gt;l&lt;/code&gt;、管道文件&lt;code&gt;p&lt;/code&gt;、块设备文件&lt;code&gt;b&lt;/code&gt;、字符设备文件&lt;code&gt;c&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通文件包括：纯文本文件、服务配置信息、日志信息以及shell脚本&lt;/li&gt;
&lt;li&gt;块设备文件：块设备以块为单位存储数据，如磁盘设备。数据可被随机访问，传送任何数据块所需时间较少而且大致相同。&lt;/li&gt;
&lt;li&gt;字符设备文件：字符设备是指IO过程中以字符为单位进行传输的设备，数据不可随机访问，或可随机访问但所需时间很大程度上依赖于数据在设备内位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件的特殊权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SUID：对二进制程序进行设置的特殊权限，能够让二进制程序的执行者临时拥有属主的权限&lt;/li&gt;
&lt;li&gt;SGID：对二进制程序进行设置时，能够让执行者临时获取到文件所有组的权限；对目录进行设置时，让目录内新创建的文件自动继承该目录的原有用户组&lt;/li&gt;
&lt;li&gt;确保用户只能删除自己的文件，而不能删除其他用户的文件；对目录设置SBIT粘滞位权限后，该目录中的文件只能被其所有者执行删除操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rwxrw-rwx：767&lt;/p&gt;
&lt;h2 id=&#34;fork和vfork的区别&#34;&gt;fork和vfork的区别&lt;/h2&gt;
&lt;p&gt;fork和vfork都是在已有的进程中创建一个新的进程，但所创建的子进程是有区别的：&lt;/p&gt;
&lt;p&gt;fork父子进程的执行次序不确定，且子进程拷贝父进程的数据段和代码段。&lt;/p&gt;
&lt;p&gt;vfork确保子进程先运行，在调用exec或exit之后，父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。&lt;/p&gt;
&lt;h2 id=&#34;gcc语法&#34;&gt;gcc语法&lt;/h2&gt;
&lt;p&gt;预处理 -E；编译 -S；汇编 -c；&lt;/p&gt;
&lt;p&gt;生成目标 -o&lt;/p&gt;
&lt;p&gt;嵌入调试信息 -g&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/789780?channel=-1&amp;amp;source_id=profile_follow_post_nctrack&#34;&gt;八股文之操作系统 高频知识点整理&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>八股文——Cpp相关</title>
        <link>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Thu, 06 Jan 2022 15:13:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/ -&lt;h2 id=&#34;newdelete和mallocfree的区别&#34;&gt;new/delete和malloc/free的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;malloc/free是C/C++的库函数，需要stdlib.h；new/delete是C++的关键字；&lt;/li&gt;
&lt;li&gt;都可用于申请动态内存和释放内存，new/delete在对象创建的时候自动执行&lt;strong&gt;构造函数&lt;/strong&gt;，对象消亡前自动执行&lt;strong&gt;析构函数&lt;/strong&gt;，底层实现其实也是malloc/free&lt;/li&gt;
&lt;li&gt;new无需指定内存块的大小，编译器会根据类型信息自行计算；malloc需要显式地支持所需内存的大小&lt;/li&gt;
&lt;li&gt;new返回&lt;strong&gt;指定类型&lt;/strong&gt;的指针，无需进行类型转换；malloc默认返回类型为&lt;strong&gt;void*&lt;/strong&gt;，必须强行转换为实际类型的指针&lt;/li&gt;
&lt;li&gt;new内存分配失败时会抛出bad_alloc异常；malloc失败时返回NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;malloc的底层实现&#34;&gt;malloc的底层实现&lt;/h2&gt;
&lt;p&gt;Linux下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开辟空间小于128K时，通过&lt;strong&gt;brk()函数&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;将数据段.data的最高地址指针**_edata&lt;strong&gt;向高地址移动，即&lt;/strong&gt;增加堆**的有效区域来申请内存空间&lt;/li&gt;
&lt;li&gt;brk分配的内存需要等到高地址内存释放以后才能释放，这也是内存碎片产生的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开辟空间大于128K时，通过&lt;strong&gt;mmap()函数&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;利用mmap系统调用，在堆和栈之间&lt;strong&gt;文件映射区域&lt;/strong&gt;申请一块虚拟内存&lt;/li&gt;
&lt;li&gt;128K限制可由M_MMAP_THRESHOLD选项进行修改&lt;/li&gt;
&lt;li&gt;mmap分配的内存可以单独释放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以上只涉及虚拟内存的分配，直到进程第一次访问其地址时，才会通过缺页中断机制分配到物理页中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指针和引用的异同点如何相互转换&#34;&gt;指针和引用的异同点；如何相互转换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用是别名，指针是地址&lt;/li&gt;
&lt;li&gt;指针变量在符号表上对应的地址值为&lt;strong&gt;指针变量的地址&lt;/strong&gt;；而引用在符号边上的地址值为&lt;strong&gt;引用对象的地址&lt;/strong&gt;；指针可以改变指向的对象，而引用不行；二者都可以改变指向对象的值。&lt;/li&gt;
&lt;li&gt;硬件通过地址访问内存位置，因此引用可以理解为一个常量指针，只能绑定到初始化它的对象上&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;structunion的异同&#34;&gt;struct、union的异同&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;struct中每个变量一次存储；union中，每个变量都是从偏移地址零开始存储，同一时刻只有一个成员存储于该地址&lt;/li&gt;
&lt;li&gt;struct内存大小遵循&lt;strong&gt;结构对齐&lt;/strong&gt;原则（详见&lt;a href=&#34;https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/&#34;&gt;Cpp内存对齐&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;union内存大小为其最大成员的整数倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;extern-c的作用&#34;&gt;extern C的作用&lt;/h2&gt;
&lt;p&gt;主要是为了能正确实现C++代码调用C语言代码。&lt;/p&gt;
&lt;p&gt;C++支持&lt;strong&gt;函数重载&lt;/strong&gt;，即不同名字空间namespace的两个函数原型声明可以完全相同，或者两个函数同名但参数列表不同；g++编译器会对此进行&lt;strong&gt;name mangling&lt;/strong&gt;，生成全局唯一的符号名称，使链接器可以准确识别。&lt;/p&gt;
&lt;p&gt;C语言不支持函数重载，即不允许同名符号，所以不需要这些工作，因此在C++代码中加入extern C，是为了&lt;strong&gt;链接规范&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;memcpy函数注意的问题&#34;&gt;memcpy()函数注意的问题&lt;/h2&gt;
&lt;p&gt;函数原型声明&lt;code&gt;void *memcpy(void *dest, void *src, unsigned int count);  &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;memcpy函数用于把资源内存（src所指向的内存区域）中连续的count个字节数据拷贝到目标内存（dest所指向的内存区域）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据长度count的单位是字节，1byte = 8bit&lt;/li&gt;
&lt;li&gt;数据类型为char，则数据长度就等于元素的个数；其他数据类型则要注意数据长度的值&lt;/li&gt;
&lt;li&gt;n * sizeof(type_name)的写法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;memmove()&lt;/code&gt;函数与&lt;code&gt;memcpy()&lt;/code&gt;函数的功能相同，区别是前者处理空间重叠问题，后者不处理。&lt;/p&gt;
&lt;h2 id=&#34;memset函数&#34;&gt;memset()函数&lt;/h2&gt;
&lt;p&gt;函数原型声明&lt;code&gt;void *memset(void *buffer,int c,int count);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化所指定的内存空间。memset把buffer指向的内存区域的前count个字节设置成某个字符的ASCII值，一般用于给数组、字符串等赋值。&lt;/p&gt;
&lt;h2 id=&#34;strcatstrncatstrcmpstrcpy函数&#34;&gt;strcat、strncat、strcmp、strcpy函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;char* strcpy(char *dest, const char *src);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;strcpy拷贝函数，不会判断拷贝大小，也没有任何安全检查，不会检查目的地址内存是否够用；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char* strncpy(char *dest, const char *src);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;strncpy拷贝函数，会计算复制字符串的大小，但没有检查目标的边界；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int strcmp(const char *str1, const char *str2); &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比较两个字符串。str1指向的字符串大于str2指向的字符串时，返回正数，小于时返回负数，等于是返回0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char* strcat(char *dest, const char *src);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;连接两个字符串，把src连接到dest后面，返回dest地址。&lt;/p&gt;
&lt;h2 id=&#34;机器大小端问题&#34;&gt;机器大小端问题&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&#34;https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/&#34;&gt;测试机器大小端的方法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;static的用法定义和用途&#34;&gt;static的用法（定义和用途）&lt;/h2&gt;
&lt;p&gt;static修饰局部变量：使其变为&lt;strong&gt;静态存储方式&lt;/strong&gt;（静态数据区），函数执行完成之后不会被释放，而是继续保存在内存中；&lt;/p&gt;
&lt;p&gt;static修饰全局变量：使其只在本文件内部有效，其他文件不可链接或引用该变量；&lt;/p&gt;
&lt;p&gt;static修饰函数：静态函数，即函数只在本文件内部有效，对其他文件不可见；避免同名干扰，同时保护。&lt;/p&gt;
&lt;h2 id=&#34;const的用法定义和用途&#34;&gt;const的用法（定义和用途）&lt;/h2&gt;
&lt;p&gt;const起到&lt;strong&gt;强制保护&lt;/strong&gt;的修饰作用，可以预防意外改动，提高程序的健壮性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const修饰常量：定义时就初始化，以后不能更改；&lt;/li&gt;
&lt;li&gt;const修饰形参：func(const int a); 该形参在函数里不能改变；&lt;/li&gt;
&lt;li&gt;const修饰类成员函数：const类成员函数不能改变成员变量的数值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;const常量和define的区别&#34;&gt;const常量和#define的区别&lt;/h2&gt;
&lt;p&gt;主要区别在于：编译阶段、安全性、内存占用等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const定义的常量有类型名字，存放在内存的静态区，在编译时确定其值；&lt;/li&gt;
&lt;li&gt;#define定义的常量是没有类型的一个&lt;strong&gt;立即数&lt;/strong&gt;，编译器会在预处理阶段将程序中所有使用到该常量的地方进行&lt;strong&gt;拷贝替换&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;由于#define的拷贝有很多分，故宏定义占用的内存要高得多&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;volatile的用法&#34;&gt;volatile的用法&lt;/h2&gt;
&lt;p&gt;编译器不会对volatile变量有关的运算进行编译优化：每次使用该变量必须从内存地址中读取，而不是保存在寄存器中的备份。&lt;/p&gt;
&lt;p&gt;用到volatile的几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行设备的硬件寄存器（如状态寄存器）&lt;/li&gt;
&lt;li&gt;终端服务子程序会访问到的非自动变量&lt;/li&gt;
&lt;li&gt;多线程应用中被几个任务共享的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常量指针指针常量常量引用&#34;&gt;常量指针、指针常量、常量引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常量指针：指针本身是一个常量，指向的内存地址不能改变，但指向地址的内容可以改变&lt;/li&gt;
&lt;li&gt;指针常量：指针指向地址的内容是常量，指针本身可以改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详见后面对于&lt;code&gt;char * const&lt;/code&gt;和&lt;code&gt;const char*&lt;/code&gt;的说明。&lt;/p&gt;
&lt;h2 id=&#34;变量的作用域全局变量和局部变量&#34;&gt;变量的作用域（全局变量和局部变量）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局变量：在所有函数体外部定义，程序所在部分都可以使用，不受作用域的影响（生命周期一直到程序的结束）&lt;/li&gt;
&lt;li&gt;局部变量：局限于作用域内，默认为auto关键字修饰，即进入作用域时自动生成，离开作用域时自动消失&lt;/li&gt;
&lt;li&gt;局部变量可以和全局变量重名，在局部变量作用域范围内，全局变量失效，采用的是局部变量的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sizeof和strlen&#34;&gt;sizeof和strlen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sizeof是一个操作符或关键字，不是一个函数，而strlen是一个函数&lt;/li&gt;
&lt;li&gt;sizeof返回一个对象或类型占用的内存字节数，不会对其中的数据或指针作运算&lt;/li&gt;
&lt;li&gt;strlen返回一个字符串的长度，不包括/0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sizeofstruct和内存对齐&#34;&gt;sizeof(struct)和内存对齐&lt;/h2&gt;
&lt;p&gt;内存对齐的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移植原因：某些硬件平台只能在某些特定地址处取特定类型的数据；&lt;/li&gt;
&lt;li&gt;性能原因：数据结构应尽可能在自然边界上对齐，未对齐内存需要做两次内存访问，对齐仅需要一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情对齐原则见&lt;a href=&#34;https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/&#34;&gt;Cpp内存对齐&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;char--const-const-char-&#34;&gt;char * const, const char *&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const char *ptr&lt;/code&gt;是指向字符常量的指针，ptr是一个char*类型的常量，所指向的内容不能修改&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char* const ptr&lt;/code&gt;是指向字符的指针常数，即const指针，不能修改ptr指针，但能修改该指针指向的内容。&lt;/p&gt;
&lt;h2 id=&#34;inline函数&#34;&gt;inline函数&lt;/h2&gt;
&lt;p&gt;被频繁调用的函数会导致栈空间或栈内存的大量消耗，因此引入inline修饰函数，即内联函数；内联函数将在程序的每个调用点上内联式地展开。内联以代码膨胀为代价，省去了函数调用的开销，从而提高了函数的执行效率。&lt;/p&gt;
&lt;h2 id=&#34;inline函数和define的区别&#34;&gt;inline函数和#define的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宏调用不执行类型检查，甚至连正常参数也不检查，但函数调用要检查&lt;/li&gt;
&lt;li&gt;宏使用的是文本替代，可能导致无法预料的后果。&lt;/li&gt;
&lt;li&gt;宏中的编译错误很难发现，其引用的是扩展的代码，而不是程序员键入的&lt;/li&gt;
&lt;li&gt;许多结构体使用宏或使用不同语法来表达很难理解，内联函数使用与普通函数相同的语言，可以随意内联或不内联。&lt;/li&gt;
&lt;li&gt;内联代码的调试信息通常比扩展的宏代码更加有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存四区变量存储区域堆栈&#34;&gt;内存四区，变量存储区域（堆/栈）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代码区：.text&lt;/li&gt;
&lt;li&gt;全局初始化区/静态数据区：.data，明确被初始化的全局变量、静态变量和常量数据，整个生命周期内都可能需要访问&lt;/li&gt;
&lt;li&gt;未初始化数据区：.bss，全局未初始化变量&lt;/li&gt;
&lt;li&gt;栈区stack：由编译器自动分配释放，存放函数的参数值、局部参数的值等。每当一个函数被调用，该函数的返回地址和调用信息，如某些寄存器内容，会被存储到栈区，这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，即C实现函数递归调用的方法&lt;/li&gt;
&lt;li&gt;堆区heap：用于动态内存分配&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数组名和指针的区别&#34;&gt;数组名和指针的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数组名对应的是指向数据首元素地址的指针，但该指针所指的地址不能被改写&lt;/li&gt;
&lt;li&gt;指针是变量指针，所指向的地址可以更改&lt;/li&gt;
&lt;li&gt;对数组名取地址，得到的是数组首元素的地址；对指针取地址，得到的是指针变量所在地址&lt;/li&gt;
&lt;li&gt;对数组名使用sizeof，得到的是数组元素个数与数组元素类型字节数的成绩；而对指针使用sizeof得到的是指针类型的字节数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;strcpy和memcpy的区别&#34;&gt;strcpy和memcpy的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;复制的内容不同：strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等&lt;/li&gt;
&lt;li&gt;复制的方法不同：strcpy不需要指定长度，遇到被复制字符的串结束符\0才结束，所以容易溢出。memcpy则根据其第三个参数决定复制的长度&lt;/li&gt;
&lt;li&gt;用途不同：通常子啊复制字符串时使用strcpy，而需要复制其他类型数据时则一般用memcpy&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;野指针&#34;&gt;野指针&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;野指针是指向内存未知区域或访问首先区域的指针，结果未知&lt;/li&gt;
&lt;li&gt;产生原因
&lt;ul&gt;
&lt;li&gt;指针定义时未被初始化，默认值随机&lt;/li&gt;
&lt;li&gt;指向的内存区域被释放时，指针没有置空&lt;/li&gt;
&lt;li&gt;指针操作超越变量作用域，如函数返回指向栈内存的指针或引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全局变量和静态变量的区别&#34;&gt;全局变量和静态变量的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储方式上没有区别，都是静态存储方式&lt;/li&gt;
&lt;li&gt;非静态全局变量作用域为震哥哥源程序；当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件都是有效的，而静态全局则限制了其作用域，只在该变量的源文件内有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;左值和右值&#34;&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;左值可以用于赋值语句的左侧，右值不能。&lt;/p&gt;
&lt;p&gt;左值与右值的根本区别在于是否允许取地址运算符&amp;amp;获得对应的内存地址。&lt;/p&gt;
&lt;h2 id=&#34;explicit作用&#34;&gt;explicit作用&lt;/h2&gt;
&lt;p&gt;用于修饰构造函数，使得其不能用于隐式转换和赋值初始化。被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎，因为它们禁止编译器执行非预期的类型转换，除非有一个好的理由允许构造函数被用于隐式类型转换，否则会将其声明为explicit。&lt;/p&gt;
&lt;h2 id=&#34;i和i的区别&#34;&gt;++i和i++的区别&lt;/h2&gt;
&lt;p&gt;一般都用&lt;code&gt;++i&lt;/code&gt;，因为其速度较快。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;++i&lt;/code&gt;相当于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; i;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而&lt;code&gt;i++&lt;/code&gt;相当于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; j;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于i++还必须拷贝值给j，所以速度较慢.&lt;/p&gt;
&lt;h2 id=&#34;继承和多态&#34;&gt;继承和多态&lt;/h2&gt;
&lt;p&gt;继承：类与类之间可以&lt;strong&gt;共用代码，实现代码重用&lt;/strong&gt;。（基类和派生类）&lt;/p&gt;
&lt;p&gt;多态：面向对象过程中，基类与派生类存在&lt;strong&gt;相同的方法&lt;/strong&gt;，但有&lt;strong&gt;不同的方法体&lt;/strong&gt;，调用是根据对象有选择地调用合适的方法。&lt;/p&gt;
&lt;p&gt;多态的几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须是公有继承&lt;/li&gt;
&lt;li&gt;必须通过基类的指针或引用指向派生类对象来访问呢派生类方法&lt;/li&gt;
&lt;li&gt;基类的方法必须是虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态的实现要求必须是共有继承&lt;/li&gt;
&lt;li&gt;继承关系中，父类更通用，子类更具体。父类具有一般的特征和行为，子类除了具有父类的特征和行为，还有自己特殊的行为和特征。&lt;/li&gt;
&lt;li&gt;继承关系中，并不要求基类方法一定是虚函数。多态要求基类方法必须是虚函数。&lt;/li&gt;
&lt;li&gt;多态：子类重写父类的方法，使得子类具有不同的实现。且运行时，根据实际创建的对象动态决定使用哪个方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;部分参考自&lt;a href=&#34;https://www.nowcoder.com/discuss/789739?channel=-1&amp;amp;source_id=profile_follow_post_nctrack&#34;&gt;八股文之C/C++ 高频知识点汇总&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp：9.虚拟内存</title>
        <link>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
        <pubDate>Tue, 04 Jan 2022 14:59:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ -&lt;h2 id=&#34;物理和虚拟寻址&#34;&gt;物理和虚拟寻址&lt;/h2&gt;
&lt;p&gt;物理地址PA、虚拟地址VA、内存管理单元MMU（利用存放在主存中的查询表来动态地翻译虚拟地址，该表的内容由操作系统管理）。&lt;/p&gt;
&lt;h2 id=&#34;地址空间&#34;&gt;地址空间&lt;/h2&gt;
&lt;p&gt;非负整数地址的有序集合。&lt;/p&gt;
&lt;p&gt;目前x86使用39位物理地址空间、49位虚拟地址空间。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为缓存的工具&#34;&gt;虚拟内存作为缓存的工具&lt;/h2&gt;
&lt;p&gt;VM系统通过将虚拟内存分割为大小为$P=2^p$字节的虚拟页来处理，同样地，物理内存也被分割为大小为P的物理页（页帧）。&lt;/p&gt;
&lt;p&gt;任意时刻，虚拟页面的集合都分为三个不相交的子集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未分配的&lt;/li&gt;
&lt;li&gt;缓存的&lt;/li&gt;
&lt;li&gt;未缓存的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dram缓存的组织结构&#34;&gt;DRAM缓存的组织结构&lt;/h3&gt;
&lt;p&gt;使用术语&lt;code&gt;SRAM缓存&lt;/code&gt;来表示位于CPU和主存之间的L1、L2和L3高速缓存；用术语&lt;code&gt;DRAM缓存&lt;/code&gt;表示虚拟内存系统的缓存，它在主存中缓存虚拟页。&lt;/p&gt;
&lt;p&gt;在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。DRAM比SRAM慢大约10倍，磁盘比DRAM慢大约100000倍。DRAM缓存的不命中（缺页）比SRAM缓存的不命中要昂贵的多。&lt;/p&gt;
&lt;p&gt;与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。&lt;/p&gt;
&lt;h3 id=&#34;页表&#34;&gt;页表&lt;/h3&gt;
&lt;p&gt;虚拟内存系统必须有方法判断&lt;strong&gt;一个虚拟页是否缓存在DRAM中&lt;/strong&gt;的某个地方。如果是，系统还必须确定这个虚拟页存&lt;strong&gt;放在哪个物理页中&lt;/strong&gt;。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。&lt;/p&gt;
&lt;p&gt;页表就是一个页表条目（PET）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE由一个有效位和一个n位地址字段组成的。有效位表明该虚拟页当前是否被缓存在DRAM中。&lt;/p&gt;
&lt;h3 id=&#34;页命中&#34;&gt;页命中&lt;/h3&gt;
&lt;p&gt;页面缓存在DRAM缓存中。&lt;/p&gt;
&lt;h3 id=&#34;缺页&#34;&gt;缺页&lt;/h3&gt;
&lt;p&gt;DRAM缓存不命中称为缺页。&lt;/p&gt;
&lt;p&gt;在磁盘和内存之间传送页的活动叫作交换或页面调度。只有当不命中发生时，才换入页面，这种策略称为&lt;strong&gt;按需页面调度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所有现代系统都采用按需页面调度的方式。&lt;/p&gt;
&lt;h3 id=&#34;局部性&#34;&gt;局部性&lt;/h3&gt;
&lt;p&gt;局部性原理保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合称为工作集或常驻集。&lt;/p&gt;
&lt;p&gt;只要程序具有良好的时间局部性，虚拟内存系统就能工作得相当好。如果工作集的大小超出了物理内存的大小，程序将产生一种不幸的&lt;strong&gt;抖动&lt;/strong&gt;状态，这时页面将不断地换进换出。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为内存管理的工具&#34;&gt;虚拟内存作为内存管理的工具&lt;/h2&gt;
&lt;p&gt;虚拟内存大大简化了内存管理，并提供了一种自然的保护内存的方法。&lt;/p&gt;
&lt;p&gt;操作系统实际上为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。&lt;/p&gt;
&lt;p&gt;多个虚拟页面可以映射到同一个共享的物理页面上。&lt;/p&gt;
&lt;p&gt;VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。&lt;/p&gt;
&lt;h3 id=&#34;简化链接&#34;&gt;简化链接&lt;/h3&gt;
&lt;p&gt;独立的地址空间允许每个进程的内存映射使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。&lt;/p&gt;
&lt;p&gt;一个给定的Linux系统上的每个进程都使用类似的内存格式。对于64位地址空间，代码段总是从虚拟地址0x400000开始。数据段跟在代码段后，中间有一段符合要求的对齐空白。栈占用用户地址空间最高的部分，并向下生长。&lt;/p&gt;
&lt;p&gt;这样的一致性简化了链接器的设计和实现。允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。&lt;/p&gt;
&lt;h3 id=&#34;简化加载&#34;&gt;简化加载&lt;/h3&gt;
&lt;p&gt;虚拟内存使得很容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。在每个页被初次引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。&lt;/p&gt;
&lt;p&gt;将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。详见后面小节。&lt;/p&gt;
&lt;h3 id=&#34;简化共享&#34;&gt;简化共享&lt;/h3&gt;
&lt;p&gt;一般情况下，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程进行共享的。但在另一些情况下，需要进程来共享数据和代码。例如，每个进程必须调用相同的操作系统内核代码，操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本。&lt;/p&gt;
&lt;h3 id=&#34;简化内存分配&#34;&gt;简化内存分配&lt;/h3&gt;
&lt;p&gt;虚拟内存为用户进程提供了一个简单的分配额外内存的机制。当一个运行在用户进程的程序要求额外的堆空间时（调用malloc），操作系统分配一个适当数字大小的连续的虚拟内存页面，并将其映射到物理内存中任意位置的k个任意的物理页面。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为内存管理的工具-1&#34;&gt;虚拟内存作为内存管理的工具&lt;/h2&gt;
&lt;p&gt;提供独立的地址空间使得区分不同进程的私有内存变得容易。但时地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每个CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE上添加一些&lt;strong&gt;额外的许可位&lt;/strong&gt;开控制对一个虚拟页面内容的访问十分简单。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201041455041.png&#34; alt=&#34;虚拟内存提供的页面级内存保护&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个PTE添加了三个许可位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SUP位：进程是否必须运行在内核（超级用户）模式下才能访问该页&lt;/li&gt;
&lt;li&gt;READ位和WRITE位控制对页面的读和写访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。&lt;/p&gt;
&lt;h2 id=&#34;地址翻译&#34;&gt;地址翻译&lt;/h2&gt;
&lt;p&gt;页面命中时CPU&lt;strong&gt;硬件&lt;/strong&gt;执行的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器生成一个虚拟地址，将其传送给MMU&lt;/li&gt;
&lt;li&gt;MMU生成PTE（Page Table Entry）地址，并从高速缓存/主存请求得到它&lt;/li&gt;
&lt;li&gt;高速缓存/主存向MMU返回PTE&lt;/li&gt;
&lt;li&gt;MMU构造物理地址，并把它传送给高速缓存/主存&lt;/li&gt;
&lt;li&gt;高速缓存/主存返回所请求的数据字给处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;页面命中完全由硬件来处理，与之不同的是，处理缺页要求&lt;strong&gt;硬件和操作系统内核&lt;/strong&gt;协作完成。步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1-3步：与页面命中时的前三步相同&lt;/li&gt;
&lt;li&gt;PTE中的有效位为0，所以MMU触发了一次异常，传递CPU中的控制到&lt;strong&gt;操作系统内核中的缺页异常处理程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;缺页处理程序确定出物理内存中的牺牲页，如果该页面已经被修改，则把它换出到磁盘。&lt;/li&gt;
&lt;li&gt;缺页处理程序页面调入新的页面，并更新内存中的PTE。&lt;/li&gt;
&lt;li&gt;缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。虚拟页面现在缓存在物理内存中，所以就会命中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结合高速缓存和虚拟内存&#34;&gt;结合高速缓存和虚拟内存&lt;/h3&gt;
&lt;p&gt;在任何既使用高速缓存SRAM又使用虚拟内存的系统中，一般使用物理内存来访问高速缓存。&lt;/p&gt;
&lt;p&gt;使用物理内存，多个进程同时在高速缓存中由存储块和共享来自相同虚拟页面的块非常简单。并且高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。&lt;/p&gt;
&lt;h3 id=&#34;利用tlb加速地址翻译&#34;&gt;利用TLB加速地址翻译&lt;/h3&gt;
&lt;h3 id=&#34;多级页表&#34;&gt;多级页表&lt;/h3&gt;
&lt;p&gt;用来压缩页表的常用方法是使用层次结构的页表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201032140608.png&#34; alt=&#34;两级页表结构&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;案例研究linux虚拟内存系统&#34;&gt;案例研究：Linux虚拟内存系统&lt;/h2&gt;
&lt;p&gt;Linux为&lt;strong&gt;每个进程&lt;/strong&gt;维护了一个单独的虚拟地址空间。内核虚拟内存位于&lt;strong&gt;用户栈之上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图中为一个Linux进程的虚拟内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011847831.png&#34; alt=&#34;一个Linux进程的虚拟内存&#34;&gt;&lt;/p&gt;
&lt;p&gt;内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。内核虚拟内存的其他区域包含每个进程都不相同的数据，比如，页表、内核在进程的上下文执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。&lt;/p&gt;
&lt;h3 id=&#34;linux虚拟内存区域&#34;&gt;Linux虚拟内存区域&lt;/h3&gt;
&lt;p&gt;Linux将虚拟内存组织成一些区域（又称段）的集合。一个区域就是已存在的虚拟内存的连续片。代码段、数据段、堆、共享库以及用户栈都是不同的区域。每个虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域很重要，因为其允许虚拟地址空间有间隙。&lt;/p&gt;
&lt;p&gt;下图强调了记录&lt;strong&gt;一个进程中虚拟内存区域的内核数据结构&lt;/strong&gt;。内核为系统中的每个进程维护一个单独的&lt;strong&gt;任务结构&lt;code&gt;task_struct&lt;/code&gt;&lt;/strong&gt;。任务结构中的元素包含或指向内核&lt;strong&gt;运行该进程所需要的所有信息&lt;/strong&gt;（如PID、指向用户栈的指针、可执行目标文件的名字以及程序计数器）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011858154.png&#34; alt=&#34;Linux一个进程中虚拟内存区域的内核数据结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;任务结构中的一个条目指向&lt;code&gt;mm_struct&lt;/code&gt;，它描述了虚拟内存的当前状态。我们想了解的是pgd和mmap两个字段。pgd指向第一级页表的基址，mmap指向一个&lt;code&gt;vm_area_struct&lt;/code&gt;的链表，其中每个&lt;code&gt;vm_area_structs&lt;/code&gt;都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就把pgd存放在CR3控制寄存器中。&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;具体区域&lt;/strong&gt;的区域结构包含以下字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vm_start&lt;/code&gt;：指向该区域的起始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_end&lt;/code&gt;：指向该区域的结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_port&lt;/code&gt;：描述这个区域内包含的所有页的读写许可权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_flags&lt;/code&gt;：描述这个区域内的页面是与其他进程共享的还是这个进程私有的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_next&lt;/code&gt;：指向链表中下一个区域的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux缺页异常处理&#34;&gt;Linux缺页异常处理&lt;/h3&gt;
&lt;p&gt;假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序执行以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断&lt;strong&gt;虚拟地址A&lt;/strong&gt;是否合法？即A是否在某个区域结构定义的区域内。为了找到答案，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的&lt;code&gt;vm_start&lt;/code&gt;和&lt;code&gt;vm_end&lt;/code&gt;作比较。如果该指令不合法，则触发一个段错误，从而终止该进程。由于一个进程可以创建任意数量的新虚拟内存，因此顺序搜索链表的开销可能很大，Linux在链表中构建一棵树，并在这棵树上查找。&lt;/li&gt;
&lt;li&gt;试图进行的&lt;strong&gt;内存访问&lt;/strong&gt;是否合法？即进程是否有读、写或执行这个区域内页面的权限。如果试图进行的访问是不合法的，缺页处理程序就会触发一个保护异常，从而终止这个进程。&lt;/li&gt;
&lt;li&gt;此时内核知道这个缺页是由于&lt;strong&gt;对合法的虚拟内存进行合法的操作&lt;/strong&gt;造成的。这样进行处理：选择一个&lt;strong&gt;牺牲页面&lt;/strong&gt;，如果该页面被修改过，则将其交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送A到MMU。此时MMU就能正常翻译A，不会再产生缺页中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011920465.png&#34; alt=&#34;Linux缺页处理&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存映射&#34;&gt;内存映射&lt;/h2&gt;
&lt;p&gt;内存映射：Linux通过一个&lt;strong&gt;虚拟内存区域&lt;/strong&gt;与一个&lt;strong&gt;磁盘上的对象&lt;/strong&gt;关联起来，以初始化这个虚拟内存区域的内容。虚拟内存区域可以映射到两种类型的对象中的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux文件系统中的普通文件&lt;/li&gt;
&lt;li&gt;匿名文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的&lt;strong&gt;交换文件swap file&lt;/strong&gt;之间换来换去。交换文件也叫做交换空间或交换区域。&lt;/p&gt;
&lt;h3 id=&#34;共享对象&#34;&gt;共享对象&lt;/h3&gt;
&lt;p&gt;许多程序要访问只读运行时库代码的相同副本，例如每个C程序都需要来自标准C库的诸如printf这样的函数。如果每个进程都在物理内存中保存这些常用代码的副本，就是极端的浪费。&lt;/p&gt;
&lt;p&gt;内存映射为我们提供了一种清晰的机制，用来控制多个进程如何共享对象。&lt;/p&gt;
&lt;p&gt;一个对象可以被映射到虚拟内存的一个区域，要么作为&lt;strong&gt;共享对象&lt;/strong&gt;，要么作为&lt;strong&gt;私有对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么该进程对这个地址区域的任何写操作，对于那些同样将该共享对象映射到自己的虚拟内存的进程也是可见的。这些变化会反映在磁盘的原始对象上。另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域的任何写操作都不会反映在磁盘的对象中。&lt;/p&gt;
&lt;p&gt;私有对象使用一种称为&lt;strong&gt;写时复制&lt;/strong&gt;的技术被映射到虚拟内存中。私有对象开始生命周期的方式基本与共享对象相同，在物理内存中只保存&lt;strong&gt;私有对象的一份副本&lt;/strong&gt;。两个进程将一个私有对象映射到它们的虚拟内存的不同区域，但共享这个对象的同一物理副本。对于每个映射私有对象的进程，响应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。只要有一个进程试图写私有区域内的某个页面，这个&lt;strong&gt;写操作&lt;/strong&gt;就会触发一个&lt;strong&gt;保护故障&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;故障处理程序注意到保护异常是由于进程试图&lt;strong&gt;写私有的写时复制区域中的一个页面&lt;/strong&gt;而引起的，它就会在物理内存中创建这个页面的一个&lt;strong&gt;新副本&lt;/strong&gt;，更新页表条目指向这个新副本，然后恢复这个页面的可写权限。由此写操作就可以正常执行了。&lt;/p&gt;
&lt;p&gt;通过这种延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。&lt;/p&gt;
&lt;h3 id=&#34;fork函数&#34;&gt;fork函数&lt;/h3&gt;
&lt;p&gt;fork函数创建一个带有自己独立虚拟地址空间的新进程。&lt;/p&gt;
&lt;p&gt;当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的&lt;code&gt;mm_struct&lt;/code&gt;、区域结构和页表的原样&lt;strong&gt;副本&lt;/strong&gt;。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的&lt;strong&gt;写时复制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当fork函数在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的一个后来进行写操作时，写时复制就会创建新页面，因此为每个进程保持了私有地址空间的概念。&lt;/p&gt;
&lt;h3 id=&#34;execve函数&#34;&gt;execve函数&lt;/h3&gt;
&lt;p&gt;虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。&lt;/p&gt;
&lt;p&gt;假设在当前进程中的程序执行了如下的execve调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;execve(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;a.out&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载该程序需要以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除已存在的用户区域。&lt;/li&gt;
&lt;li&gt;映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。.bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。&lt;/li&gt;
&lt;li&gt;映射共享区域。如果a.out程序与共享对象或目标链接（比如标准C库libc.so），那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。&lt;/li&gt;
&lt;li&gt;设置程序计数器PC。设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了加载器如何映射用户地址空间区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201022200703.png&#34; alt=&#34;加载器映射用户地址空间区域&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用mmap函数的用户级内存映射&#34;&gt;使用mmap函数的用户级内存映射&lt;/h3&gt;
&lt;p&gt;Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mmap&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;start, size_t length, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; prot, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; flags, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; fd, off_t offset);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;mmap函数要求内核创建一个新的虚拟内存区域，最好从地址start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片映射到这个新的区域。连续对象片大小为length字节，从距文件开始处偏移量为offset字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL。&lt;/p&gt;
&lt;p&gt;参数prot包含描述新映射的虚拟内存区域的访问权限位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PROT_EXEC&lt;/li&gt;
&lt;li&gt;PROT_READ&lt;/li&gt;
&lt;li&gt;PROT_WRITE&lt;/li&gt;
&lt;li&gt;PROT_NONE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数flag由描述被映射对象类型的位组成。&lt;/p&gt;
&lt;p&gt;munmap函数删除虚拟内存的区域：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;munmap&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;start, size_t length);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;删除从虚拟地址start开始的，由接下来length字节组成的区域。&lt;/p&gt;
&lt;h2 id=&#34;动态内存分配&#34;&gt;动态内存分配&lt;/h2&gt;
&lt;p&gt;动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，指向堆的顶部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201121330003.png&#34; alt=&#34;虚拟内存的堆区域&#34;&gt;&lt;/p&gt;
&lt;p&gt;分配器将堆视为一组不同大小的块的集合，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。&lt;/p&gt;
&lt;p&gt;分配器有两种基本风格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显式&lt;/strong&gt;分配器：要求应用显式地释放任何已有的块。C标准库提供称为malloc程序包的显式分配器，C程序通过调用malloc分配内存，通过调用free释放一个块。C++通过new和delete分配和释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式&lt;/strong&gt;分配器：又称为垃圾收集器。自动释放未使用的已分配的块的过程称为垃圾收集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来主要讨论显式分配器的设计与实现。&lt;/p&gt;
&lt;h3 id=&#34;malloc和free函数&#34;&gt;malloc和free函数&lt;/h3&gt;
&lt;p&gt;C标准库提供成为malloc的显示分配器，程序通过调用malloc函数来从堆中分配块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;malloc&lt;/span&gt;(size_t size);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;malloc函数返回一个指针，指向大小至少为size字节的额内存块。&lt;/p&gt;
&lt;p&gt;如果malloc遇到问题（例如程序要求的内存块比可用的虚拟内存还要大），那么它就返回NULL，并设置errno。&lt;/p&gt;
&lt;p&gt;动态分配器还可以使用sbrk函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sbrk&lt;/span&gt;(intptr_t incr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sbrk函数通过将内核的brk指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1，并将errno设置为ENOMEM。如果incr为零，那么sbrk就返回brk的当前值。&lt;/p&gt;
&lt;p&gt;程序通过调用free函数来释放已分配的堆块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;free&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用动态内存分配的原因&#34;&gt;使用动态内存分配的原因&lt;/h3&gt;
&lt;p&gt;经常直到程序实际运行时，才知道某些数据结构的大小。&lt;/p&gt;
&lt;h3 id=&#34;分配器的要求和目标&#34;&gt;分配器的要求和目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;处理任意请求序列&lt;/li&gt;
&lt;li&gt;立即响应请求&lt;/li&gt;
&lt;li&gt;只使用堆&lt;/li&gt;
&lt;li&gt;对齐块&lt;/li&gt;
&lt;li&gt;不修改已分配的块&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;碎片&#34;&gt;碎片&lt;/h3&gt;
&lt;p&gt;造成堆利用率很低的主要原因是一种称为碎片的现象，当虽然有未使用的内存但不能用来满足分配请求时，就会发发生这种现象。由以下两种碎片：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部碎片：已分配块的大小和它们的有效荷载大小之差的和。内部碎片的数量取决于以前请求的模式和分配器的实现方式。比如分配器可能增加块大小以满足对齐约束条件。&lt;/li&gt;
&lt;li&gt;外部碎片：当空闲内存合计起来足够满足一个分配请求，但没有一个单独的空闲块足够大可以来处理这个请求。如果不向内核请求额外的虚拟内存就无法满足这个请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块。&lt;/p&gt;
&lt;h3 id=&#34;实现问题&#34;&gt;实现问题&lt;/h3&gt;
&lt;p&gt;要实现一个在吞吐率和利用率之间把握好平衡的分配器，要考虑以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲块组织&lt;/li&gt;
&lt;li&gt;放置&lt;/li&gt;
&lt;li&gt;分割&lt;/li&gt;
&lt;li&gt;合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;隐式空闲链表&#34;&gt;隐式空闲链表&lt;/h3&gt;
&lt;p&gt;分配器需要一些数据结构，允许它来区分块边界，以及区别已分配和空闲块。大多数分配器将这些信息&lt;strong&gt;嵌入块本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个块由一个字（4B）的头部、有效荷载以及可能的一些额外的填充组成。头部编码了这个块的大小以及这个块是已分配的还是空闲的。&lt;/p&gt;
&lt;h3 id=&#34;放置已分配的块&#34;&gt;放置已分配的块&lt;/h3&gt;
&lt;p&gt;应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求快的空闲块。这种搜索方式是由放置策略确定的。常见的策略有首次适配、下一次适配和最佳适配。&lt;/p&gt;
&lt;h3 id=&#34;分隔空闲块&#34;&gt;分隔空闲块&lt;/h3&gt;
&lt;p&gt;分配器找到一个匹配的块后，就必须作出一个决策，就是分配这个空闲块中多少空间。一个选择是分配整个空闲块，但这种方式可能造成内部碎片。&lt;/p&gt;
&lt;p&gt;如果匹配不太好，分配器通常会选择将这个空闲块分割为两部分，第一部分变成分配块，剩下的变成一个新的空闲块。&lt;/p&gt;
&lt;h3 id=&#34;获取额外的堆内存&#34;&gt;获取额外的堆内存&lt;/h3&gt;
&lt;p&gt;如果不能请求到合适的空闲块，一个解决方法是合并那些在物理内存中相邻的空闲块来创建一个更大的块。如果还是不能生成一个足够大的块，那么分配器会调用&lt;strong&gt;sbrk函数&lt;/strong&gt;，向&lt;strong&gt;内核&lt;/strong&gt;请求额外的堆内存。&lt;/p&gt;
&lt;h3 id=&#34;合并空闲块&#34;&gt;合并空闲块&lt;/h3&gt;
&lt;p&gt;任何分配器都必须合并相邻的空闲块，这个过程称为合并。分配器可以选择立即合并，就是在每次一个块被释放时，就合并所有相邻块。或者也可以选择推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有的空闲块。&lt;/p&gt;
&lt;p&gt;立即合并对于某些请求模式而言，会产生一种形式的抖动，块会反复地合并，然后马上分割。&lt;/p&gt;
&lt;h3 id=&#34;带边界标记的合并&#34;&gt;带边界标记的合并&lt;/h3&gt;
&lt;p&gt;边界标记技术允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾处添加一个脚部（footer，边界标记），其中脚部就是头部的一个副本。如果每个块包含一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。&lt;/p&gt;
&lt;h3 id=&#34;显式空闲链表&#34;&gt;显式空闲链表&lt;/h3&gt;
&lt;h3 id=&#34;分离的空闲链表&#34;&gt;分离的空闲链表&lt;/h3&gt;
&lt;h2 id=&#34;垃圾收集&#34;&gt;垃圾收集&lt;/h2&gt;
&lt;p&gt;未能释放已分配的块是一种常见的编程错误。&lt;/p&gt;
&lt;p&gt;垃圾收集器是一种动态内存分配器，它自动释放不再需要的已分配块。这些块被称为垃圾。在一个支持垃圾收集的系统中，应用显式地分配块，但从不显式地释放它们。&lt;/p&gt;
&lt;p&gt;这里讨论McCarthy独创的标记、清除算法，这个算法可以建立在已存在的malloc包的基础之上，为C/C++提供垃圾收集。&lt;/p&gt;
&lt;h2 id=&#34;c语言常见的与内存有关的错误&#34;&gt;C语言常见的与内存有关的错误&lt;/h2&gt;
&lt;h3 id=&#34;间接引用坏指针&#34;&gt;间接引用坏指针&lt;/h3&gt;
&lt;p&gt;常见的是经典的scanf错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;scanf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;val);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用scanf从stdin读取一个整数到一个变量。很容易错误地传递val的内容而不是它的地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;scanf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, val);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;scanf将把val的内容解释为一个地址，并试图将一个字写到这个位置。在最糟糕的情况下，val的内容对应于虚拟内存的合法读/写区域，于是我们就覆盖了这块内存，这在相当长一段时间后会造成灾难性后果。&lt;/p&gt;
&lt;h3 id=&#34;读未初始化的内存&#34;&gt;读未初始化的内存&lt;/h3&gt;
&lt;p&gt;虽然bss内存位置总是被加载器初始化为零，但对于堆内存并不是这样。一个常见的错误就是假设堆内存被初始化为零。我们在使用堆内存的变量是要先将其初始化。&lt;/p&gt;
&lt;h3 id=&#34;允许栈缓冲区溢出&#34;&gt;允许栈缓冲区溢出&lt;/h3&gt;
&lt;p&gt;如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;bufferflow&lt;/span&gt;() {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;64&lt;/span&gt;];
	gets(buf);
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数就有缓冲区溢出错误，因为gets函数复制一个任意长度的串到缓冲区。为了纠正这个错误，必须使用fgets函数，该函数限制了输入串的大小。&lt;/p&gt;
&lt;h3 id=&#34;假设指针和它们指向的对象是相同大小的&#34;&gt;假设指针和它们指向的对象是相同大小的&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;makeArray1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; m) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;A &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;)Malloc(n &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
		A[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)Malloc(m &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
	}
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; A;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数的目的是创建一个由n个指针组成的数据，每个指针都指向包含m个int的数组。然后创建A时错误地将&lt;code&gt;sizeof(int *)&lt;/code&gt;写成了&lt;code&gt;sizeof(int)&lt;/code&gt;，代码实际上创建的是一个int数组。&lt;/p&gt;
&lt;h3 id=&#34;引用指针而不是它所指向的对象&#34;&gt;引用指针，而不是它所指向的对象&lt;/h3&gt;
&lt;p&gt;下面的函数，其目的是删除一个有&lt;code&gt;size&lt;/code&gt;项的二叉堆里的第一项，然后对剩下的*size-1项重新建堆：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;binheapDelete&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;binheap, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;packet &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; binheap[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;];
	binheap[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; binheap[&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;];
	&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;;
	heapify(binheap, &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;(packet);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数错误地将&lt;code&gt;(*size)--&lt;/code&gt;写作了&lt;code&gt;*size--&lt;/code&gt;导致代码实际上减少的是指针自己的值，而不是它所指向整数的值。程序运行后很有可能发生的是，当程序在执行过程后很久才出现一个错误的结果。&lt;/p&gt;
&lt;h3 id=&#34;误解指针的运算&#34;&gt;误解指针的运算&lt;/h3&gt;
&lt;p&gt;指针的算数操作是以它们指向对象的大小为单位来进行的，这种大小单位不一定是字节。&lt;/p&gt;
&lt;h3 id=&#34;引用不存在的变量&#34;&gt;引用不存在的变量&lt;/h3&gt;
&lt;p&gt;有时候不理解栈的规则的程序员可能会引用不合法的本地变量，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;stackref&lt;/span&gt;()
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; val;
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;val;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数返回一个指针，指向栈中的一个局部变量，然后弹出它的栈帧，尽管&amp;amp;val仍然指向一个合法地址，但它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，内存将重用它们的栈帧。再后来，如果程序分配某个值给*p，那么其可能在修改另一个函数的栈帧中的一个条目，带来潜在的灾难性后果。&lt;/p&gt;
&lt;h3 id=&#34;引用空闲堆块中的数据&#34;&gt;引用空闲堆块中的数据&lt;/h3&gt;
&lt;p&gt;一个相似的错误是引用已经被释放了的堆块中的数据。&lt;/p&gt;
&lt;h3 id=&#34;引起内存泄漏&#34;&gt;引起内存泄漏&lt;/h3&gt;
&lt;p&gt;忘记释放已经分配的块，而在堆里创建了垃圾。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp指向类成员的指针</title>
        <link>https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</link>
        <pubDate>Tue, 28 Dec 2021 21:53:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/ -&lt;h2 id=&#34;指向类的普通成员的指针非静态&#34;&gt;指向类的普通成员的指针（非静态）&lt;/h2&gt;
&lt;h3 id=&#34;指向类成员函数的指针&#34;&gt;指向类成员函数的指针&lt;/h3&gt;
&lt;p&gt;指向类成员函数的指针不仅要匹配函数的&lt;strong&gt;参数类型和个数&lt;/strong&gt;，以及&lt;strong&gt;返回值类型&lt;/strong&gt;，还要匹配该&lt;strong&gt;函数指针所属的类类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原因是非静态的成员函数必须绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：与普通函数作为区分，指向类的成员函数的指针只需要在指针前加上类类型即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;返回值&lt;/span&gt; (&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类名&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针类型名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;赋值&lt;/strong&gt;：只需使用类的成员函数地址赋值即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针类型名&lt;/span&gt; &lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类名&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;成员函数名&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调用&lt;/strong&gt;：针对调用的对象是对象还是指针，分别用&lt;code&gt;.*&lt;/code&gt;和&lt;code&gt;-&amp;gt;*&lt;/code&gt;进行调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类对象&lt;/span&gt;.&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类对象&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指向类数据成员的指针&#34;&gt;指向类数据成员的指针&lt;/h3&gt;
&lt;p&gt;同理指向类成员函数的指针，只要判断以下两点是否一致即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员的类型&lt;/li&gt;
&lt;li&gt;所属的类类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指向类的静态成员的指针&#34;&gt;指向类的静态成员的指针&lt;/h2&gt;
&lt;p&gt;类的静态成员不依赖于具体对象，所有实例化的对象都共享同一个静态成员，即静态成员没有this指针的概念。&lt;/p&gt;
&lt;p&gt;所以，指向类的静态成员的指针就是&lt;strong&gt;普通的指针&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要使用&lt;code&gt;(&amp;amp;类名::成员名)&lt;/code&gt;获取指向成员的指针，首先这个成员必须是对外可见的，即&lt;code&gt;public&lt;/code&gt;的。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>AVL树及与红黑树、B/B&#43;树的对比</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Thu, 23 Dec 2021 15:30:08 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/ -&lt;p&gt;&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/&#34;&gt;红黑树&lt;/a&gt;和&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb+%E6%A0%91/&#34;&gt;B/B+树&lt;/a&gt;详见这两篇博客。&lt;/p&gt;
&lt;h2 id=&#34;avl树&#34;&gt;AVL树&lt;/h2&gt;
&lt;p&gt;AVL树为平衡二叉树，是以其发明者的名字命名的。任一结点对应的两棵子树的最大高度差为1。查找、插入和删除在平均和最坏的情况下的时间复杂度都为$O(\log n)$。&lt;/p&gt;
&lt;p&gt;增加和删除元素操作可能需要借由一次或多次树旋转，以实现树的重新平衡。&lt;/p&gt;
&lt;p&gt;与红黑树相比，AVL树是严格的平衡二叉树。&lt;/p&gt;
&lt;p&gt;局限性：由于维护这种高度平衡所付出的代价比从中获得的效率收益还大。故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。&lt;/p&gt;
&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;一种二叉查找树，确保没有一条路径会比其他路径长出两倍。是一种弱平衡树。在插入和删除的操作中的旋转次数相对于AVL树来说较少。&lt;/p&gt;
&lt;h2 id=&#34;bb树&#34;&gt;B/B+树&lt;/h2&gt;
&lt;p&gt;B/B+树是为了磁盘或其他存储设备设计的平衡多路查找树，与红黑树相比，在相同结点的情况下，一颗B/B+树的高度远远小于红黑树。B树的操作效率主要取决于访问磁盘的次数，关键字数相同的情况下，B树高度越小，磁盘I/O所花的时间越少。&lt;/p&gt;
&lt;p&gt;B+树是应文件系统所需而产生的一种B树的变形树，非叶子结点只保存索引，不保存实际的数据，数据都保存在叶子结点中。相当于是文件系统的查找。&lt;/p&gt;
&lt;p&gt;另外B+树支持顺序查找而B树不支持，数据库中经常需要遍历一定范围内的数据，因此采用B+树比采用B树的效率更高。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 