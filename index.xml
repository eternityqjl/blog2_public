<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Sat, 08 Jan 2022 22:13:05 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>八股文——操作系统相关</title>
        <link>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Sat, 08 Jan 2022 22:13:05 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/ -&lt;h2 id=&#34;进程和线程的区别&#34;&gt;进程和线程的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程是资源（CPU、内存等）分配的基本单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程是进程的一个实体，是CPU调度和分配的基本单位（程序执行的最小单位）。线程自身不拥有系统资源，但可与同属一个进程的其他线程共享进程所拥有的全部资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程崩溃就等于整个进程崩溃，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程同步通信方法&#34;&gt;进程同步（通信）方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;管道：一个进程链接数据流到另一个进程，就是把一个进程的输出直接传递给另一个进程的输入。
&lt;ul&gt;
&lt;li&gt;无名管道适用于父子进程间的通信&lt;/li&gt;
&lt;li&gt;管道是基于字节流的&lt;/li&gt;
&lt;li&gt;半双工，数据同一时间只能从一个方向传输&lt;/li&gt;
&lt;li&gt;自带同步机制，在保证数据安全前提下，按照特定顺序访问临界资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号：处理异步事件的方式，用于接收通知进程有某种事情发生，也可发送信号给进程本身。&lt;/li&gt;
&lt;li&gt;信号量
&lt;ul&gt;
&lt;li&gt;处理进程间同步和互斥的通信机制，类似于资源计数器，保证任意时刻只有一个进程访问代码的临界区。临界期指执行数据更新的代码需要独占式地执行&lt;/li&gt;
&lt;li&gt;P操作&lt;/li&gt;
&lt;li&gt;V操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息队列：消息的链表，提供了一个进程向另一个进程发送数据块的方法，每个数据块可被认为是有一个类型，接收者接受的数据块可以有不同的类型。
&lt;ul&gt;
&lt;li&gt;生命周期随内核存在，需要显式调用或删除&lt;/li&gt;
&lt;li&gt;可以双向通信，且克服了管道只能承载无格式字节流的缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享内存：同一物理内存被映射到两个进程的地址空间，两个进程都可以访问这段空间，从而实现进程间通信
&lt;ul&gt;
&lt;li&gt;最快的IPC形式，内存映射到两个进程的地址空间，进程数据传递不再涉及内核&lt;/li&gt;
&lt;li&gt;共享内存的生命周期随进程存在，需要显式地删除&lt;/li&gt;
&lt;li&gt;没有互斥与同步机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;socket：套接字，应用层与传输层之间的一个抽象，socket是一种”打开——读写——关闭“模式的实现，作为服务器和客户端之间维护的”文件“，可以向文件写入内容供对方读取或读取对方的内容，通信结束时关闭文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程间通信方法&#34;&gt;线程间通信方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;读写锁&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;硬中断和软中断的区别&#34;&gt;硬中断和软中断的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;软中断是执行中断指令产生的，硬中断是由外设引发的&lt;/li&gt;
&lt;li&gt;硬中断的中断号是由中断控制器提供的，软中断的中断号是由指令直接指出，无需使用中断控制器。&lt;/li&gt;
&lt;li&gt;硬中断是可屏蔽的，软中断不可屏蔽。&lt;/li&gt;
&lt;li&gt;硬中断处理程序要确保它能快速完成任务，这样程序执行时才不会等待较长时间，称为上半部。&lt;/li&gt;
&lt;li&gt;软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;h3 id=&#34;死锁发生的四个必要条件&#34;&gt;死锁发生的四个必要条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥条件：进程要求对所分配的资源进行排他性控制，在一段时间内某资源仅为一进程所占用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无法剥夺条件：进程已获得的资源在未使用完之前，无法剥夺，只能在使用完后由自己释放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环路等待条件：发生死锁时，必然存在一个进程——资源的环形链路&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;预防死锁&#34;&gt;预防死锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;资源一次性分配：破坏请求条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要有一个资源得不到分配，不给这个进程分配其他的资源：破坏请求保持条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可剥夺资源：当进程获得了部分资源但得不到其他资源，则释放已占用资源：破坏不可剥夺条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源有序分配法：进程按规定顺序请求资源，释放则相反：破坏环路等待条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;互斥锁和自旋锁的选择&#34;&gt;互斥锁和自旋锁的选择&lt;/h2&gt;
&lt;p&gt;利用加锁来实现互斥和同步的一般模型为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加锁$\rightarrow$临界区：访问公共变量$\rightarrow$解锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当判断lock已被加锁，则有两种处理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用系统函数将当前线程阻塞（互斥）&lt;/li&gt;
&lt;li&gt;使其一直处于循环判断的状态（自旋）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阻塞当前线程可以让出CPU资源去执行别的线程，通过减少CPU浪费来提高效率；但切换线程需要进行上下文切换，耗费时间较长。对于线程占用锁时间短的情况，自旋锁会更加高效。&lt;/p&gt;
&lt;h2 id=&#34;信号量和互斥量&#34;&gt;信号量和互斥量&lt;/h2&gt;
&lt;p&gt;互斥量只能用于一个资源的互斥访问，而信号量可以实现多个同类资源的多线程互斥和同步。&lt;/p&gt;
&lt;p&gt;互斥量在任意时刻只允许一个线程访问某个共享资源，而信号量则允许固定数量的线程访问某个共享资源池，即互斥量是信号量n为1的特殊情况。&lt;/p&gt;
&lt;h2 id=&#34;软中断tasklet和工作队列&#34;&gt;软中断、tasklet和工作队列&lt;/h2&gt;
&lt;p&gt;这三者都属于中断的下半部，区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软中断可以并发运行在多个CPU上，因此必须设计为可重入函数，也需要使用自旋锁来保护其数据结构&lt;/li&gt;
&lt;li&gt;同一类型的tasklet只能运行在一个CPU上，只能串行执行；不同类型tasklet可以并行在多个CPU上&lt;/li&gt;
&lt;li&gt;软中断是静态分配的，内核编译完后不能改变；tasklet可以运行时改变&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux内核的组成部分&#34;&gt;Linux内核的组成部分&lt;/h2&gt;
&lt;p&gt;进程调度、内存管理、虚拟文件系统、网络接口&lt;/p&gt;
&lt;h2 id=&#34;内核态和用户态的区别&#34;&gt;内核态和用户态的区别&lt;/h2&gt;
&lt;p&gt;操作系统的两种运行级别，以限制不同程序的访问权限。内核态可以访问所有数据，包括外围设备；用户态只能受限地访问内存，不允许访问外围设备。&lt;/p&gt;
&lt;p&gt;三种方式由用户态切换到内核态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用，如库函数malloc，调用brk()或mmap()指令&lt;/li&gt;
&lt;li&gt;异常&lt;/li&gt;
&lt;li&gt;外设中断&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;硬链接和软链接&#34;&gt;硬链接和软链接&lt;/h2&gt;
&lt;h3 id=&#34;硬链接&#34;&gt;硬链接&lt;/h3&gt;
&lt;p&gt;Linux下的文件是通过索引节点（i-node）来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配i-node。每添加一个硬链接，文件的链接数就加1，只有当该文件的所有链接都被删除后，文件才会从硬盘中被完全移除。&lt;/p&gt;
&lt;p&gt;不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可以在不同文件系统的文件间建立链接&lt;/li&gt;
&lt;li&gt;只有超级用户才能为目录创建硬链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;软链接&#34;&gt;软链接&lt;/h3&gt;
&lt;p&gt;又称符号链接，包含的是原文件的i-node记录。没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。删除软链接不影响被指向的文件，但若源文件被删除，则软链接将会失效。&lt;/p&gt;
&lt;p&gt;不足：&lt;/p&gt;
&lt;p&gt;因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。&lt;/p&gt;
&lt;p&gt;实际场景下，一般使用软链接。&lt;/p&gt;
&lt;h2 id=&#34;文件权限与归属&#34;&gt;文件权限与归属&lt;/h2&gt;
&lt;p&gt;每个文件都有归属的所有者和所有组，并规定了文件的所有者、所有组以及其他人对文件所拥有的读、写、执行等权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读：read，r，4来表示；&lt;/li&gt;
&lt;li&gt;写：write，w，2来表示；&lt;/li&gt;
&lt;li&gt;执行：execute，x，1来表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-rwx-rw-r--  1  root  root&lt;/code&gt;：第一个&lt;code&gt;-&lt;/code&gt;表示文件类型，&lt;code&gt;rwx-rw-r--&lt;/code&gt;表示访问权限，最后两个表示属主和属组。&lt;/p&gt;
&lt;p&gt;文件类型：普通文件&lt;code&gt;-&lt;/code&gt;、目录文件&lt;code&gt;d&lt;/code&gt;、链接文件&lt;code&gt;l&lt;/code&gt;、管道文件&lt;code&gt;p&lt;/code&gt;、块设备文件&lt;code&gt;b&lt;/code&gt;、字符设备文件&lt;code&gt;c&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通文件包括：纯文本文件、服务配置信息、日志信息以及shell脚本&lt;/li&gt;
&lt;li&gt;块设备文件：块设备以块为单位存储数据，如磁盘设备。数据可被随机访问，传送任何数据块所需时间较少而且大致相同。&lt;/li&gt;
&lt;li&gt;字符设备文件：字符设备是指IO过程中以字符为单位进行传输的设备，数据不可随机访问，或可随机访问但所需时间很大程度上依赖于数据在设备内位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件的特殊权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SUID：对二进制程序进行设置的特殊权限，能够让二进制程序的执行者临时拥有属主的权限&lt;/li&gt;
&lt;li&gt;SGID：对二进制程序进行设置时，能够让执行者临时获取到文件所有组的权限；对目录进行设置时，让目录内新创建的文件自动继承该目录的原有用户组&lt;/li&gt;
&lt;li&gt;确保用户只能删除自己的文件，而不能删除其他用户的文件；对目录设置SBIT粘滞位权限后，该目录中的文件只能被其所有者执行删除操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rwxrw-rwx：767&lt;/p&gt;
&lt;h2 id=&#34;fork和vfork的区别&#34;&gt;fork和vfork的区别&lt;/h2&gt;
&lt;p&gt;fork和vfork都是在已有的进程中创建一个新的进程，但所创建的子进程是有区别的：&lt;/p&gt;
&lt;p&gt;fork父子进程的执行次序不确定，且子进程拷贝父进程的数据段和代码段。&lt;/p&gt;
&lt;p&gt;vfork确保子进程先运行，在调用exec或exit之后，父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。&lt;/p&gt;
&lt;h2 id=&#34;gcc语法&#34;&gt;gcc语法&lt;/h2&gt;
&lt;p&gt;预处理 -E；编译 -S；汇编 -c；&lt;/p&gt;
&lt;p&gt;生成目标 -o&lt;/p&gt;
&lt;p&gt;嵌入调试信息 -g&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/789780?channel=-1&amp;amp;source_id=profile_follow_post_nctrack&#34;&gt;八股文之操作系统 高频知识点整理&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>八股文——Cpp相关</title>
        <link>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Thu, 06 Jan 2022 15:13:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/ -&lt;h2 id=&#34;newdelete和mallocfree的区别&#34;&gt;new/delete和malloc/free的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;malloc/free是C/C++的库函数，需要stdlib.h；new/delete是C++的关键字；&lt;/li&gt;
&lt;li&gt;都可用于申请动态内存和释放内存，new/delete在对象创建的时候自动执行&lt;strong&gt;构造函数&lt;/strong&gt;，对象消亡前自动执行&lt;strong&gt;析构函数&lt;/strong&gt;，底层实现其实也是malloc/free&lt;/li&gt;
&lt;li&gt;new无需指定内存块的大小，编译器会根据类型信息自行计算；malloc需要显式地支持所需内存的大小&lt;/li&gt;
&lt;li&gt;new返回&lt;strong&gt;指定类型&lt;/strong&gt;的指针，无需进行类型转换；malloc默认返回类型为&lt;strong&gt;void*&lt;/strong&gt;，必须强行转换为实际类型的指针&lt;/li&gt;
&lt;li&gt;new内存分配失败时会抛出bad_alloc异常；malloc失败时返回NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;malloc的底层实现&#34;&gt;malloc的底层实现&lt;/h2&gt;
&lt;p&gt;Linux下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开辟空间小于128K时，通过&lt;strong&gt;brk()函数&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;将数据段.data的最高地址指针**_edata&lt;strong&gt;向高地址移动，即&lt;/strong&gt;增加堆**的有效区域来申请内存空间&lt;/li&gt;
&lt;li&gt;brk分配的内存需要等到高地址内存释放以后才能释放，这也是内存碎片产生的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开辟空间大于128K时，通过&lt;strong&gt;mmap()函数&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;利用mmap系统调用，在堆和栈之间&lt;strong&gt;文件映射区域&lt;/strong&gt;申请一块虚拟内存&lt;/li&gt;
&lt;li&gt;128K限制可由M_MMAP_THRESHOLD选项进行修改&lt;/li&gt;
&lt;li&gt;mmap分配的内存可以单独释放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以上只涉及虚拟内存的分配，直到进程第一次访问其地址时，才会通过缺页中断机制分配到物理页中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指针和引用的异同点如何相互转换&#34;&gt;指针和引用的异同点；如何相互转换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用是别名，指针是地址&lt;/li&gt;
&lt;li&gt;指针变量在符号表上对应的地址值为&lt;strong&gt;指针变量的地址&lt;/strong&gt;；而引用在符号边上的地址值为&lt;strong&gt;引用对象的地址&lt;/strong&gt;；指针可以改变指向的对象，而引用不行；二者都可以改变指向对象的值。&lt;/li&gt;
&lt;li&gt;硬件通过地址访问内存位置，因此引用可以理解为一个常量指针，只能绑定到初始化它的对象上&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;structunion的异同&#34;&gt;struct、union的异同&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;struct中每个变量一次存储；union中，每个变量都是从偏移地址零开始存储，同一时刻只有一个成员存储于该地址&lt;/li&gt;
&lt;li&gt;struct内存大小遵循&lt;strong&gt;结构对齐&lt;/strong&gt;原则（详见&lt;a href=&#34;https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/&#34;&gt;Cpp内存对齐&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;union内存大小为其最大成员的整数倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;extern-c的作用&#34;&gt;extern C的作用&lt;/h2&gt;
&lt;p&gt;主要是为了能正确实现C++代码调用C语言代码。&lt;/p&gt;
&lt;p&gt;C++支持&lt;strong&gt;函数重载&lt;/strong&gt;，即不同名字空间namespace的两个函数原型声明可以完全相同，或者两个函数同名但参数列表不同；g++编译器会对此进行&lt;strong&gt;name mangling&lt;/strong&gt;，生成全局唯一的符号名称，使链接器可以准确识别。&lt;/p&gt;
&lt;p&gt;C语言不支持函数重载，即不允许同名符号，所以不需要这些工作，因此在C++代码中加入extern C，是为了&lt;strong&gt;链接规范&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;memcpy函数注意的问题&#34;&gt;memcpy()函数注意的问题&lt;/h2&gt;
&lt;p&gt;函数原型声明&lt;code&gt;void *memcpy(void *dest, void *src, unsigned int count);  &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;memcpy函数用于把资源内存（src所指向的内存区域）中连续的count个字节数据拷贝到目标内存（dest所指向的内存区域）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据长度count的单位是字节，1byte = 8bit&lt;/li&gt;
&lt;li&gt;数据类型为char，则数据长度就等于元素的个数；其他数据类型则要注意数据长度的值&lt;/li&gt;
&lt;li&gt;n * sizeof(type_name)的写法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;memmove()&lt;/code&gt;函数与&lt;code&gt;memcpy()&lt;/code&gt;函数的功能相同，区别是前者处理空间重叠问题，后者不处理。&lt;/p&gt;
&lt;h2 id=&#34;memset函数&#34;&gt;memset()函数&lt;/h2&gt;
&lt;p&gt;函数原型声明&lt;code&gt;void *memset(void *buffer,int c,int count);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化所指定的内存空间。memset把buffer指向的内存区域的前count个字节设置成某个字符的ASCII值，一般用于给数组、字符串等赋值。&lt;/p&gt;
&lt;h2 id=&#34;strcatstrncatstrcmpstrcpy函数&#34;&gt;strcat、strncat、strcmp、strcpy函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;char* strcpy(char *dest, const char *src);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;strcpy拷贝函数，不会判断拷贝大小，也没有任何安全检查，不会检查目的地址内存是否够用；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char* strncpy(char *dest, const char *src);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;strncpy拷贝函数，会计算复制字符串的大小，但没有检查目标的边界；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int strcmp(const char *str1, const char *str2); &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比较两个字符串。str1指向的字符串大于str2指向的字符串时，返回正数，小于时返回负数，等于是返回0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char* strcat(char *dest, const char *src);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;连接两个字符串，把src连接到dest后面，返回dest地址。&lt;/p&gt;
&lt;h2 id=&#34;机器大小端问题&#34;&gt;机器大小端问题&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&#34;https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/&#34;&gt;测试机器大小端的方法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;static的用法定义和用途&#34;&gt;static的用法（定义和用途）&lt;/h2&gt;
&lt;p&gt;static修饰局部变量：使其变为&lt;strong&gt;静态存储方式&lt;/strong&gt;（静态数据区），函数执行完成之后不会被释放，而是继续保存在内存中；&lt;/p&gt;
&lt;p&gt;static修饰全局变量：使其只在本文件内部有效，其他文件不可链接或引用该变量；&lt;/p&gt;
&lt;p&gt;static修饰函数：静态函数，即函数只在本文件内部有效，对其他文件不可见；避免同名干扰，同时保护。&lt;/p&gt;
&lt;h2 id=&#34;const的用法定义和用途&#34;&gt;const的用法（定义和用途）&lt;/h2&gt;
&lt;p&gt;const起到&lt;strong&gt;强制保护&lt;/strong&gt;的修饰作用，可以预防意外改动，提高程序的健壮性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const修饰常量：定义时就初始化，以后不能更改；&lt;/li&gt;
&lt;li&gt;const修饰形参：func(const int a); 该形参在函数里不能改变；&lt;/li&gt;
&lt;li&gt;const修饰类成员函数：const类成员函数不能改变成员变量的数值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;const常量和define的区别&#34;&gt;const常量和#define的区别&lt;/h2&gt;
&lt;p&gt;主要区别在于：编译阶段、安全性、内存占用等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const定义的常量有类型名字，存放在内存的静态区，在编译时确定其值；&lt;/li&gt;
&lt;li&gt;#define定义的常量是没有类型的一个&lt;strong&gt;立即数&lt;/strong&gt;，编译器会在预处理阶段将程序中所有使用到该常量的地方进行&lt;strong&gt;拷贝替换&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;由于#define的拷贝有很多分，故宏定义占用的内存要高得多&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;volatile的用法&#34;&gt;volatile的用法&lt;/h2&gt;
&lt;p&gt;编译器不会对volatile变量有关的运算进行编译优化：每次使用该变量必须从内存地址中读取，而不是保存在寄存器中的备份。&lt;/p&gt;
&lt;p&gt;用到volatile的几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行设备的硬件寄存器（如状态寄存器）&lt;/li&gt;
&lt;li&gt;终端服务子程序会访问到的非自动变量&lt;/li&gt;
&lt;li&gt;多线程应用中被几个任务共享的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常量指针指针常量常量引用&#34;&gt;常量指针、指针常量、常量引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常量指针：指针本身是一个常量，指向的内存地址不能改变，但指向地址的内容可以改变&lt;/li&gt;
&lt;li&gt;指针常量：指针指向地址的内容是常量，指针本身可以改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详见后面对于&lt;code&gt;char * const&lt;/code&gt;和&lt;code&gt;const char*&lt;/code&gt;的说明。&lt;/p&gt;
&lt;h2 id=&#34;变量的作用域全局变量和局部变量&#34;&gt;变量的作用域（全局变量和局部变量）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局变量：在所有函数体外部定义，程序所在部分都可以使用，不受作用域的影响（生命周期一直到程序的结束）&lt;/li&gt;
&lt;li&gt;局部变量：局限于作用域内，默认为auto关键字修饰，即进入作用域时自动生成，离开作用域时自动消失&lt;/li&gt;
&lt;li&gt;局部变量可以和全局变量重名，在局部变量作用域范围内，全局变量失效，采用的是局部变量的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sizeof和strlen&#34;&gt;sizeof和strlen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sizeof是一个操作符或关键字，不是一个函数，而strlen是一个函数&lt;/li&gt;
&lt;li&gt;sizeof返回一个对象或类型占用的内存字节数，不会对其中的数据或指针作运算&lt;/li&gt;
&lt;li&gt;strlen返回一个字符串的长度，不包括/0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sizeofstruct和内存对齐&#34;&gt;sizeof(struct)和内存对齐&lt;/h2&gt;
&lt;p&gt;内存对齐的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移植原因：某些硬件平台只能在某些特定地址处取特定类型的数据；&lt;/li&gt;
&lt;li&gt;性能原因：数据结构应尽可能在自然边界上对齐，未对齐内存需要做两次内存访问，对齐仅需要一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情对齐原则见&lt;a href=&#34;https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/&#34;&gt;Cpp内存对齐&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;char--const-const-char-&#34;&gt;char * const, const char *&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const char *ptr&lt;/code&gt;是指向字符常量的指针，ptr是一个char*类型的常量，所指向的内容不能修改&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char* const ptr&lt;/code&gt;是指向字符的指针常数，即const指针，不能修改ptr指针，但能修改该指针指向的内容。&lt;/p&gt;
&lt;h2 id=&#34;inline函数&#34;&gt;inline函数&lt;/h2&gt;
&lt;p&gt;被频繁调用的函数会导致栈空间或栈内存的大量消耗，因此引入inline修饰函数，即内联函数；内联函数将在程序的每个调用点上内联式地展开。内联以代码膨胀为代价，省去了函数调用的开销，从而提高了函数的执行效率。&lt;/p&gt;
&lt;h2 id=&#34;inline函数和define的区别&#34;&gt;inline函数和#define的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宏调用不执行类型检查，甚至连正常参数也不检查，但函数调用要检查&lt;/li&gt;
&lt;li&gt;宏使用的是文本替代，可能导致无法预料的后果。&lt;/li&gt;
&lt;li&gt;宏中的编译错误很难发现，其引用的是扩展的代码，而不是程序员键入的&lt;/li&gt;
&lt;li&gt;许多结构体使用宏或使用不同语法来表达很难理解，内联函数使用与普通函数相同的语言，可以随意内联或不内联。&lt;/li&gt;
&lt;li&gt;内联代码的调试信息通常比扩展的宏代码更加有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存四区变量存储区域堆栈&#34;&gt;内存四区，变量存储区域（堆/栈）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代码区：.text&lt;/li&gt;
&lt;li&gt;全局初始化区/静态数据区：.data，明确被初始化的全局变量、静态变量和常量数据，整个生命周期内都可能需要访问&lt;/li&gt;
&lt;li&gt;未初始化数据区：.bss，全局未初始化变量&lt;/li&gt;
&lt;li&gt;栈区stack：由编译器自动分配释放，存放函数的参数值、局部参数的值等。每当一个函数被调用，该函数的返回地址和调用信息，如某些寄存器内容，会被存储到栈区，这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，即C实现函数递归调用的方法&lt;/li&gt;
&lt;li&gt;堆区heap：用于动态内存分配&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数组名和指针的区别&#34;&gt;数组名和指针的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数组名对应的是指向数据首元素地址的指针，但该指针所指的地址不能被改写&lt;/li&gt;
&lt;li&gt;指针是变量指针，所指向的地址可以更改&lt;/li&gt;
&lt;li&gt;对数组名取地址，得到的是数组首元素的地址；对指针取地址，得到的是指针变量所在地址&lt;/li&gt;
&lt;li&gt;对数组名使用sizeof，得到的是数组元素个数与数组元素类型字节数的成绩；而对指针使用sizeof得到的是指针类型的字节数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;strcpy和memcpy的区别&#34;&gt;strcpy和memcpy的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;复制的内容不同：strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等&lt;/li&gt;
&lt;li&gt;复制的方法不同：strcpy不需要指定长度，遇到被复制字符的串结束符\0才结束，所以容易溢出。memcpy则根据其第三个参数决定复制的长度&lt;/li&gt;
&lt;li&gt;用途不同：通常子啊复制字符串时使用strcpy，而需要复制其他类型数据时则一般用memcpy&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;野指针&#34;&gt;野指针&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;野指针是指向内存未知区域或访问首先区域的指针，结果未知&lt;/li&gt;
&lt;li&gt;产生原因
&lt;ul&gt;
&lt;li&gt;指针定义时未被初始化，默认值随机&lt;/li&gt;
&lt;li&gt;指向的内存区域被释放时，指针没有置空&lt;/li&gt;
&lt;li&gt;指针操作超越变量作用域，如函数返回指向栈内存的指针或引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全局变量和静态变量的区别&#34;&gt;全局变量和静态变量的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储方式上没有区别，都是静态存储方式&lt;/li&gt;
&lt;li&gt;非静态全局变量作用域为震哥哥源程序；当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件都是有效的，而静态全局则限制了其作用域，只在该变量的源文件内有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;左值和右值&#34;&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;左值可以用于赋值语句的左侧，右值不能。&lt;/p&gt;
&lt;p&gt;左值与右值的根本区别在于是否允许取地址运算符&amp;amp;获得对应的内存地址。&lt;/p&gt;
&lt;h2 id=&#34;explicit作用&#34;&gt;explicit作用&lt;/h2&gt;
&lt;p&gt;用于修饰构造函数，使得其不能用于隐式转换和赋值初始化。被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎，因为它们禁止编译器执行非预期的类型转换，除非有一个好的理由允许构造函数被用于隐式类型转换，否则会将其声明为explicit。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;部分参考自&lt;a href=&#34;https://www.nowcoder.com/discuss/789739?channel=-1&amp;amp;source_id=profile_follow_post_nctrack&#34;&gt;八股文之C/C++ 高频知识点汇总&lt;/a&gt;&lt;/p&gt;
- https://eternityqjl.top/posts/%E5%85%AB%E8%82%A1%E6%96%87cpp%E7%9B%B8%E5%85%B3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp：9.虚拟内存</title>
        <link>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
        <pubDate>Tue, 04 Jan 2022 14:59:16 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ -&lt;h2 id=&#34;物理和虚拟寻址&#34;&gt;物理和虚拟寻址&lt;/h2&gt;
&lt;p&gt;物理地址PA、虚拟地址VA、内存管理单元MMU（利用存放在主存中的查询表来动态地翻译虚拟地址，该表的内容由操作系统管理）。&lt;/p&gt;
&lt;h2 id=&#34;地址空间&#34;&gt;地址空间&lt;/h2&gt;
&lt;p&gt;非负整数地址的有序集合。&lt;/p&gt;
&lt;p&gt;目前x86使用39位物理地址空间、49位虚拟地址空间。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为缓存的工具&#34;&gt;虚拟内存作为缓存的工具&lt;/h2&gt;
&lt;p&gt;VM系统通过将虚拟内存分割为大小为$P=2^p$字节的虚拟页来处理，同样地，物理内存也被分割为大小为P的物理页（页帧）。&lt;/p&gt;
&lt;p&gt;任意时刻，虚拟页面的集合都分为三个不相交的子集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未分配的&lt;/li&gt;
&lt;li&gt;缓存的&lt;/li&gt;
&lt;li&gt;未缓存的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dram缓存的组织结构&#34;&gt;DRAM缓存的组织结构&lt;/h3&gt;
&lt;p&gt;使用术语&lt;code&gt;SRAM缓存&lt;/code&gt;来表示位于CPU和主存之间的L1、L2和L3高速缓存；用术语&lt;code&gt;DRAM缓存&lt;/code&gt;表示虚拟内存系统的缓存，它在主存中缓存虚拟页。&lt;/p&gt;
&lt;p&gt;在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。DRAM比SRAM慢大约10倍，磁盘比DRAM慢大约100000倍。DRAM缓存的不命中（缺页）比SRAM缓存的不命中要昂贵的多。&lt;/p&gt;
&lt;p&gt;与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。&lt;/p&gt;
&lt;h3 id=&#34;页表&#34;&gt;页表&lt;/h3&gt;
&lt;p&gt;虚拟内存系统必须有方法判断一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。&lt;/p&gt;
&lt;p&gt;页表就是一个页表条目（PET）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE由一个有效位和一个n位地址字段组成的。有效位表明该虚拟页当前是否被缓存在DRAM中。&lt;/p&gt;
&lt;h3 id=&#34;页命中&#34;&gt;页命中&lt;/h3&gt;
&lt;h3 id=&#34;缺页&#34;&gt;缺页&lt;/h3&gt;
&lt;h3 id=&#34;分配页面&#34;&gt;分配页面&lt;/h3&gt;
&lt;h2 id=&#34;虚拟内存作为内存管理的工具&#34;&gt;虚拟内存作为内存管理的工具&lt;/h2&gt;
&lt;p&gt;虚拟内存大大简化了内存管理，并提供了一种自然的保护内存的方法。&lt;/p&gt;
&lt;p&gt;操作系统实际上为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。&lt;/p&gt;
&lt;p&gt;多个虚拟页面可以映射到同一个共享的物理页面上。&lt;/p&gt;
&lt;p&gt;VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。&lt;/p&gt;
&lt;h3 id=&#34;简化链接&#34;&gt;简化链接&lt;/h3&gt;
&lt;p&gt;独立的地址空间允许每个进程的内存映射使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。&lt;/p&gt;
&lt;p&gt;一个给定的Linux系统上的每个进程都使用类似的内存格式。对于64位地址空间，代码段总是从虚拟地址0x400000开始。数据段跟在代码段后，中间有一段符号要求的对齐空白。栈占用用户地址空间最高的部分，并向下生长。&lt;/p&gt;
&lt;p&gt;这样的一致性简化了链接器的设计和实现。允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。&lt;/p&gt;
&lt;h3 id=&#34;简化加载&#34;&gt;简化加载&lt;/h3&gt;
&lt;p&gt;虚拟内存使得很容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器位代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。在每个页被初次引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。&lt;/p&gt;
&lt;p&gt;将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。详见后面小节。&lt;/p&gt;
&lt;h3 id=&#34;简化共享&#34;&gt;简化共享&lt;/h3&gt;
&lt;p&gt;一般情况下，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程进行共享的。但在另一些情况下，需要进程来共享数据和代码。例如，每个进程必须调用相同的操作系统内核代码，操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本。&lt;/p&gt;
&lt;h3 id=&#34;简化内存分配&#34;&gt;简化内存分配&lt;/h3&gt;
&lt;p&gt;虚拟内存为用户进程提供了一个简单的分配额外内存的机制。当一个运行在用户进程的程序要求额外的堆空间时（调用malloc），操作系统分配一个适当数字大小的连续的虚拟内存页面，并将其映射到物理内存中任意位置的k个任意的物理页面。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存作为内存管理的工具-1&#34;&gt;虚拟内存作为内存管理的工具&lt;/h2&gt;
&lt;p&gt;提供独立的地址空间使得区分不同进程的私有内存变得容易。但时地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每个CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE上添加一些&lt;strong&gt;额外的许可位&lt;/strong&gt;开控制对一个虚拟页面内容的访问十分简单。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201041455041.png&#34; alt=&#34;虚拟内存提供的页面级内存保护&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个PTE添加了三个许可位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SUP位：进程是否必须运行在内核（超级用户）模式下才能访问该页&lt;/li&gt;
&lt;li&gt;READ位和WRITE位控制对页面的读和写访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。&lt;/p&gt;
&lt;h2 id=&#34;地址翻译&#34;&gt;地址翻译&lt;/h2&gt;
&lt;p&gt;页面命中时CPU&lt;strong&gt;硬件&lt;/strong&gt;执行的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器生成一个虚拟地址，将其传送给MMU&lt;/li&gt;
&lt;li&gt;MMU生成PTE（Page Table Entry）地址，并从高速缓存/主存请求得到它&lt;/li&gt;
&lt;li&gt;高速缓存/主存向MMU返回PTE&lt;/li&gt;
&lt;li&gt;MMU构造物理地址，并把它传送给高速缓存/主存&lt;/li&gt;
&lt;li&gt;高速缓存/主存返回所请求的数据字给处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;页面命中完全由硬件来处理，与之不同的是，处理缺页要求&lt;strong&gt;硬件和操作系统内核&lt;/strong&gt;协作完成。步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1-3步：与页面命中时的前三步相同&lt;/li&gt;
&lt;li&gt;PTE中的有效位为0，所以MMU触发了一次异常，传递CPU中的控制到&lt;strong&gt;操作系统内核中的缺页异常处理程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;缺页处理程序确定出物理内存中的牺牲页，如果该页面已经被修改，则把它换出到磁盘。&lt;/li&gt;
&lt;li&gt;缺页处理程序页面调入新的页面，并更新内存中的PTE。&lt;/li&gt;
&lt;li&gt;缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。虚拟页面现在缓存在物理内存中，所以就会命中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结合高速缓存和虚拟内存&#34;&gt;结合高速缓存和虚拟内存&lt;/h3&gt;
&lt;p&gt;在任何既使用高速缓存SRAM又使用虚拟内存的系统中，一般使用物理内存来访问高速缓存。&lt;/p&gt;
&lt;p&gt;使用物理内存，多个进程同时在高速缓存中由存储块和共享来自相同虚拟页面的块非常简单。并且高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。&lt;/p&gt;
&lt;h3 id=&#34;利用tlb加速地址翻译&#34;&gt;利用TLB加速地址翻译&lt;/h3&gt;
&lt;h3 id=&#34;多级页表&#34;&gt;多级页表&lt;/h3&gt;
&lt;p&gt;用来压缩页表的常用方法是使用层次结构的页表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201032140608.png&#34; alt=&#34;两级页表结构&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;案例研究linux虚拟内存系统&#34;&gt;案例研究：Linux虚拟内存系统&lt;/h2&gt;
&lt;p&gt;Linux为&lt;strong&gt;每个进程&lt;/strong&gt;维护了一个单独的虚拟地址空间。内核虚拟内存位于&lt;strong&gt;用户栈之上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图中为一个Linux进程的虚拟内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011847831.png&#34; alt=&#34;一个Linux进程的虚拟内存&#34;&gt;&lt;/p&gt;
&lt;p&gt;内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。内核虚拟内存的其他区域包含每个进程都不相同的数据，比如，页表、内核在进程的上下文执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。&lt;/p&gt;
&lt;h3 id=&#34;linux虚拟内存区域&#34;&gt;Linux虚拟内存区域&lt;/h3&gt;
&lt;p&gt;Linux将虚拟内存组织成一些区域（又称段）的集合。一个区域就是已存在的虚拟内存的连续片。代码段、数据段、堆、共享库以及用户栈都是不同的区域。每个虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域很重要，因为其允许虚拟地址空间有间隙。&lt;/p&gt;
&lt;p&gt;下图强调了记录&lt;strong&gt;一个进程中虚拟内存区域的内核数据结构&lt;/strong&gt;。内核为系统中的每个进程维护一个单独的&lt;strong&gt;任务结构&lt;code&gt;task_struct&lt;/code&gt;&lt;/strong&gt;。任务结构中的元素包含或指向内核&lt;strong&gt;运行该进程所需要的所有信息&lt;/strong&gt;（如PID、指向用户栈的指针、可执行目标文件的名字以及程序计数器）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011858154.png&#34; alt=&#34;Linux一个进程中虚拟内存区域的内核数据结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;任务结构中的一个条目指向&lt;code&gt;mm_struct&lt;/code&gt;，它描述了虚拟内存的当前状态。我们想了解的是pgd和mmap两个字段。pgd指向第一级页表的基址，mmap指向一个&lt;code&gt;vm_area_structs&lt;/code&gt;的链表，其中每个&lt;code&gt;vm_area_structs&lt;/code&gt;都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就把pgd存放在CR3控制寄存器中。&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;具体区域&lt;/strong&gt;的区域结构包含以下字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vm_start&lt;/code&gt;：指向该区域的起始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_end&lt;/code&gt;：指向该区域的结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_port&lt;/code&gt;：描述这个区域内包含的所有页的读写许可权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_flags&lt;/code&gt;：描述这个区域内的页面是与其他进程共享的还是这个进程私有的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm_next&lt;/code&gt;：指向链表中下一个区域的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux缺页异常处理&#34;&gt;Linux缺页异常处理&lt;/h3&gt;
&lt;p&gt;假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序执行以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断&lt;strong&gt;虚拟地址A&lt;/strong&gt;是否合法？即A是否在某个区域结构定义的区域内。为了找到答案，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的&lt;code&gt;vm_start&lt;/code&gt;和&lt;code&gt;vm_end&lt;/code&gt;作比较。如果该指令不合法，则触发一个段错误，从而终止该进程。由于一个进程可以创建任意数量的新虚拟内存，因此顺序搜索链表的开销可能很大，Linux在链表中构建一棵树，并在这棵树上查找。&lt;/li&gt;
&lt;li&gt;试图进行的&lt;strong&gt;内存访问&lt;/strong&gt;是否合法？即进程是否有读、写或执行这个区域内页面的权限。如果试图进行的访问是不合法的，缺页处理程序就会触发一个保护异常，从而终止这个进程。&lt;/li&gt;
&lt;li&gt;此时内核知道这个缺页是由于&lt;strong&gt;对合法的虚拟内存进行合法的操作&lt;/strong&gt;造成的。这样进行处理：选择一个&lt;strong&gt;牺牲页面&lt;/strong&gt;，如果该页面被修改过，则将其交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送A到MMU。此时MMU就能正常翻译A，不会再产生缺页中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201011920465.png&#34; alt=&#34;Linux缺页处理&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存映射&#34;&gt;内存映射&lt;/h2&gt;
&lt;p&gt;内存映射：Linux通过一个&lt;strong&gt;虚拟内存区域&lt;/strong&gt;与一个&lt;strong&gt;磁盘上的对象&lt;/strong&gt;关联起来，以初始化这个虚拟内存区域的内容。虚拟内存区域可以映射到两种类型的对象中的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux文件系统中的普通文件&lt;/li&gt;
&lt;li&gt;匿名文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的**交换文件(swap file)**之间换来换去。交换文件也叫做交换空间或交换区域。&lt;/p&gt;
&lt;h3 id=&#34;共享对象&#34;&gt;共享对象&lt;/h3&gt;
&lt;p&gt;许多程序要访问只读运行时库代码的相同副本，例如每个C程序都需要来自标准C库的诸如printf这样的函数。如果每个进程都在物理内存中保存这些常用代码的副本，就是极端的浪费。&lt;/p&gt;
&lt;p&gt;内存映射为我们提供了一种清晰的机制，用来控制多个进程如何共享对象。&lt;/p&gt;
&lt;p&gt;一个对象可以被映射到虚拟内存的一个区域，要么作为&lt;strong&gt;共享对象&lt;/strong&gt;，要么作为&lt;strong&gt;私有对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么该进程对这个地址区域的任何写操作，对于那些同样将该共享对象映射到自己的虚拟内存的进程也是可见的。这些变化会反映在磁盘的原始对象上。另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域的任何写操作都不会反映在磁盘的对象中。&lt;/p&gt;
&lt;p&gt;私有对象使用一种称为&lt;strong&gt;写时复制&lt;/strong&gt;的技术被映射到虚拟内存中。私有对象来时生命周期的方式基本与共享对象相同，在物理内存中只保存私有对象的一份副本。两个进程将一个私有对象映射到它们的虚拟内存的不同区域，但共享这个对象的同一物理副本。对于每个映射私有对象的进程，响应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。&lt;/p&gt;
&lt;p&gt;通过这种延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。&lt;/p&gt;
&lt;h3 id=&#34;fork函数&#34;&gt;fork函数&lt;/h3&gt;
&lt;p&gt;fork函数创建一个带有自己独立虚拟地址空间的新进程。&lt;/p&gt;
&lt;p&gt;当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的&lt;code&gt;mm_struct&lt;/code&gt;、区域结构和页表的原样&lt;strong&gt;副本&lt;/strong&gt;。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的&lt;strong&gt;写时复制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当fork函数在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的一个后来进程写操作时，写时复制就会创建新页面，因此为每个进程保持了私有地址空间的概念。&lt;/p&gt;
&lt;h3 id=&#34;execve函数&#34;&gt;execve函数&lt;/h3&gt;
&lt;p&gt;虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。&lt;/p&gt;
&lt;p&gt;假设在当前进程中的程序执行了如下的execve调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;execve(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;a.out&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载该程序需要以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除已存在的用户区域。&lt;/li&gt;
&lt;li&gt;映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域时请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。&lt;/li&gt;
&lt;li&gt;映射共享区域。如果a.out程序与共享对象或目标链接（比如标准C库libc.so），那么这些对象都是动态连接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。&lt;/li&gt;
&lt;li&gt;设置程序计数器PC。设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了加载器如何映射用户地址空间区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202201022200703.png&#34; alt=&#34;加载器映射用户地址空间区域&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用mmap函数的用户级内存映射&#34;&gt;使用mmap函数的用户级内存映射&lt;/h3&gt;
&lt;h2 id=&#34;动态内存分配&#34;&gt;动态内存分配&lt;/h2&gt;
&lt;p&gt;动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，指向堆的顶部。&lt;/p&gt;
&lt;p&gt;分配器将堆视为一组不同大小的块的集合，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。&lt;/p&gt;
&lt;p&gt;分配器有两种基本风格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显式&lt;/strong&gt;分配器：要求应用显式地释放任何已有的块。C标准库提供称为malloc程序包的显式分配器，C程序通过调用malloc分配内存，通过调用free释放一个块。C++通过new和delete分配和释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式&lt;/strong&gt;分配器：又称为垃圾收集器。自动释放未使用的已分配的块的过程称为垃圾收集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来主要讨论显式分配器的设计与实现。&lt;/p&gt;
&lt;h3 id=&#34;malloc和free函数&#34;&gt;malloc和free函数&lt;/h3&gt;
&lt;p&gt;C标准库提供成为malloc的显示分配器，程序通过调用malloc函数来从堆中分配块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;malloc&lt;/span&gt;(size_t size);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;malloc函数返回一个指针，指向大小至少为size字节的额内存块。&lt;/p&gt;
&lt;p&gt;如果malloc遇到问题（例如程序要求的内存块比可用的虚拟内存还要大），那么它就返回NULL，并设置errno。&lt;/p&gt;
&lt;p&gt;动态分配器还可以使用sbrk函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sbrk&lt;/span&gt;(intptr_t incr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sbrk函数通过将内核的brk指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1，并将errno设置为ENOMEM。如果incr为零，那么sbrk就返回brk的当前值。&lt;/p&gt;
&lt;p&gt;程序通过调用free函数来释放已分配的堆块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;free&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用动态内存分配的原因&#34;&gt;使用动态内存分配的原因&lt;/h3&gt;
&lt;p&gt;经常直到程序实际运行时，才知道某些数据结构的大小。&lt;/p&gt;
&lt;h3 id=&#34;分配器的要求和目标&#34;&gt;分配器的要求和目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;处理任意请求序列&lt;/li&gt;
&lt;li&gt;立即响应请求&lt;/li&gt;
&lt;li&gt;只使用堆&lt;/li&gt;
&lt;li&gt;对齐块&lt;/li&gt;
&lt;li&gt;不修改已分配的块&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;碎片&#34;&gt;碎片&lt;/h3&gt;
&lt;p&gt;造成堆利用率很低的主要原因是一种称为碎片的现象，当虽然有未使用的内存但不能用来满足分配请求时，就会发发生这种现象。由以下两种碎片：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部碎片：已分配块的大小和它们的有效荷载大小之差的和。内部碎片的数量取决于以前请求的模式和分配器的实现方式。比如分配器可能增加块大小以满足对齐约束条件。&lt;/li&gt;
&lt;li&gt;外部碎片：当空闲内存合计起来足够满足一个分配请求，但没有一个单独的空闲块足够大可以来处理这个请求。如果不向内核请求额外的虚拟内存就无法满足这个请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块。&lt;/p&gt;
&lt;h3 id=&#34;实现问题&#34;&gt;实现问题&lt;/h3&gt;
&lt;p&gt;要实现一个在吞吐率和利用率之间把握好平衡的分配器，要考虑以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲块组织&lt;/li&gt;
&lt;li&gt;放置&lt;/li&gt;
&lt;li&gt;分割&lt;/li&gt;
&lt;li&gt;合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;隐式空闲链表&#34;&gt;隐式空闲链表&lt;/h3&gt;
&lt;p&gt;分配器需要一些数据结构，允许它来区分块边界，以及区别已分配和空闲块。大都数分配器将这些信息嵌入块本身。&lt;/p&gt;
&lt;p&gt;一个块由一个字（4B）的头部、有效荷载以及可能的一些额外的填充组成。头部编码了这个快的大小以及这个快是已分配的还是空闲的。&lt;/p&gt;
&lt;h3 id=&#34;放置已分配的块&#34;&gt;放置已分配的块&lt;/h3&gt;
&lt;p&gt;应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求快的空闲块。这种搜索方式是由放置策略确定的。常见的策略有首次适配、下一次适配和最佳适配。&lt;/p&gt;
&lt;h3 id=&#34;分隔空闲块&#34;&gt;分隔空闲块&lt;/h3&gt;
&lt;h3 id=&#34;获取额外的堆内存&#34;&gt;获取额外的堆内存&lt;/h3&gt;
&lt;h3 id=&#34;合并空闲块&#34;&gt;合并空闲块&lt;/h3&gt;
&lt;h3 id=&#34;带边界标记的合并&#34;&gt;带边界标记的合并&lt;/h3&gt;
&lt;h3 id=&#34;显式空闲链表&#34;&gt;显式空闲链表&lt;/h3&gt;
&lt;h3 id=&#34;分离的空闲链表&#34;&gt;分离的空闲链表&lt;/h3&gt;
&lt;h2 id=&#34;垃圾收集&#34;&gt;垃圾收集&lt;/h2&gt;
&lt;p&gt;未能释放已分配的块是一种常见的编程错误。&lt;/p&gt;
&lt;p&gt;垃圾收集器是一种动态内存分配器，它自动释放不再需要的已分配块。这些块被称为垃圾。在一个支持垃圾收集的系统中，应用显式地分配块，但从不显式地释放它们。&lt;/p&gt;
&lt;p&gt;这里讨论McCarthy独创的标记、清除算法，这个算法可以建立在已存在的malloc包的基础之上，为C/C++提供垃圾收集。&lt;/p&gt;
&lt;h2 id=&#34;c语言常见的与内存有关的错误&#34;&gt;C语言常见的与内存有关的错误&lt;/h2&gt;
&lt;h3 id=&#34;间接引用坏指针&#34;&gt;间接引用坏指针&lt;/h3&gt;
&lt;p&gt;常见的是经典的scanf错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;scanf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;val);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用scanf从stdin读取一个整数到一个变量。很容易错误地传递val的内容而不是它的地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;scanf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, val);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;scanf将把val的内容解释为一个地址，并试图将一个字写到这个位置。在最糟糕的情况下，val的内容对应于虚拟内存的合法读/写区域，于是我们就覆盖了这块内存，这在相当长一段时间后会造成灾难性后果。&lt;/p&gt;
&lt;h3 id=&#34;读未初始化的内存&#34;&gt;读未初始化的内存&lt;/h3&gt;
&lt;p&gt;虽然bss内存位置总是被加载器初始化为零，但对于堆内存并不是这样。一个常见的错误就是假设堆内存被初始化为零。我们在使用堆内存的变量是要先将其初始化。&lt;/p&gt;
&lt;h3 id=&#34;允许栈缓冲区溢出&#34;&gt;允许栈缓冲区溢出&lt;/h3&gt;
&lt;p&gt;如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;bufferflow&lt;/span&gt;() {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;64&lt;/span&gt;];
	gets(buf);
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数就有缓冲区溢出错误，因为gets函数复制一个任意长度的串到缓冲区。为了纠正这个错误，必须使用fgets函数，该函数限制了输入串的大小。&lt;/p&gt;
&lt;h3 id=&#34;假设指针和它们指向的对象是相同大小的&#34;&gt;假设指针和它们指向的对象是相同大小的&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;makeArray1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; m) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;A &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;)Malloc(n &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
		A[i] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)Malloc(m &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;));
	}
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; A;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数的目的是创建一个由n个指针组成的数据，每个指针都指向包含m个int的数组。然后创建A时错误地将&lt;code&gt;sizeof(int *)&lt;/code&gt;写成了&lt;code&gt;sizeof(int)&lt;/code&gt;，代码实际上创建的是一个int数组。&lt;/p&gt;
&lt;h3 id=&#34;引用指针而不是它所指向的对象&#34;&gt;引用指针，而不是它所指向的对象&lt;/h3&gt;
&lt;p&gt;下面的函数，其目的是删除一个有&lt;code&gt;size&lt;/code&gt;项的二叉堆里的第一项，然后对剩下的*size-1项重新建堆：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;binheapDelete&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;**&lt;/span&gt;binheap, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;packet &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; binheap[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;];
	binheap[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; binheap[&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;];
	&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;;
	heapify(binheap, &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;size, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;(packet);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数错误地将&lt;code&gt;(*size)--&lt;/code&gt;写作了&lt;code&gt;*size--&lt;/code&gt;导致代码实际上减少的是指针自己的值，而不是它所指向整数的值。程序运行后很有可能发生的是，当程序在执行过程后很久才出现一个错误的结果。&lt;/p&gt;
&lt;h3 id=&#34;误解指针的运算&#34;&gt;误解指针的运算&lt;/h3&gt;
&lt;p&gt;指针的算数操作是以它们指向对象的大小为单位来进行的，这种大小单位不一定是字节。&lt;/p&gt;
&lt;h3 id=&#34;引用不存在的变量&#34;&gt;引用不存在的变量&lt;/h3&gt;
&lt;p&gt;有时候不理解栈的规则的程序员可能会引用不合法的本地变量，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;stackref&lt;/span&gt;()
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; val;
	
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;val;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数返回一个指针，指向栈中的一个局部变量，然后弹出它的栈帧，尽管&amp;amp;val仍然指向一个合法地址，但它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，内存将重用它们的栈帧。再后来，如果程序分配某个值给*p，那么其可能在修改另一个函数的栈帧中的一个条目，带来潜在的灾难性后果。&lt;/p&gt;
&lt;h3 id=&#34;引用空闲堆块中的数据&#34;&gt;引用空闲堆块中的数据&lt;/h3&gt;
&lt;p&gt;一个相似的错误是引用已经被释放了的堆块中的数据。&lt;/p&gt;
&lt;h3 id=&#34;引起内存泄漏&#34;&gt;引起内存泄漏&lt;/h3&gt;
&lt;p&gt;忘记释放已经分配的块，而在堆里创建了垃圾。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp指向类成员的指针</title>
        <link>https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</link>
        <pubDate>Tue, 28 Dec 2021 21:53:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/ -&lt;h2 id=&#34;指向类的普通成员的指针非静态&#34;&gt;指向类的普通成员的指针（非静态）&lt;/h2&gt;
&lt;h3 id=&#34;指向类成员函数的指针&#34;&gt;指向类成员函数的指针&lt;/h3&gt;
&lt;p&gt;指向类成员函数的指针不仅要匹配函数的&lt;strong&gt;参数类型和个数&lt;/strong&gt;，以及&lt;strong&gt;返回值类型&lt;/strong&gt;，还要匹配该&lt;strong&gt;函数指针所属的类类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原因是非静态的成员函数必须绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：与普通函数作为区分，指向类的成员函数的指针只需要在指针前加上类类型即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;返回值&lt;/span&gt; (&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类名&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针类型名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;赋值&lt;/strong&gt;：只需使用类的成员函数地址赋值即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针类型名&lt;/span&gt; &lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类名&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;成员函数名&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调用&lt;/strong&gt;：针对调用的对象是对象还是指针，分别用&lt;code&gt;.*&lt;/code&gt;和&lt;code&gt;-&amp;gt;*&lt;/code&gt;进行调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类对象&lt;/span&gt;.&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;类对象&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;*&lt;/span&gt;&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;指针名&lt;/span&gt;)(&lt;span style=&#34;color:#f00;background-color:#faa&#34;&gt;参数列表&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指向类数据成员的指针&#34;&gt;指向类数据成员的指针&lt;/h3&gt;
&lt;p&gt;同理指向类成员函数的指针，只要判断以下两点是否一致即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员的类型&lt;/li&gt;
&lt;li&gt;所属的类类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指向类的静态成员的指针&#34;&gt;指向类的静态成员的指针&lt;/h2&gt;
&lt;p&gt;类的静态成员不依赖于具体对象，所有实例化的对象都共享同一个静态成员，即静态成员没有this指针的概念。&lt;/p&gt;
&lt;p&gt;所以，指向类的静态成员的指针就是&lt;strong&gt;普通的指针&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要使用&lt;code&gt;(&amp;amp;类名::成员名)&lt;/code&gt;获取指向成员的指针，首先这个成员必须是对外可见的，即&lt;code&gt;public&lt;/code&gt;的。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>AVL树及与红黑树、B/B&#43;树的对比</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Thu, 23 Dec 2021 15:30:08 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/ -&lt;p&gt;&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/&#34;&gt;红黑树&lt;/a&gt;和&lt;a href=&#34;https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95b%E6%A0%91%E5%92%8Cb+%E6%A0%91/&#34;&gt;B/B+树&lt;/a&gt;详见这两篇博客。&lt;/p&gt;
&lt;h2 id=&#34;avl树&#34;&gt;AVL树&lt;/h2&gt;
&lt;p&gt;AVL树为平衡二叉树，是以其发明者的名字命名的。任一结点对应的两棵子树的最大高度差为1。查找、插入和删除在平均和最坏的情况下的时间复杂度都为$O(\log n)$。&lt;/p&gt;
&lt;p&gt;增加和删除元素操作可能需要借由一次或多次树旋转，以实现树的重新平衡。&lt;/p&gt;
&lt;p&gt;与红黑树相比，AVL树是严格的平衡二叉树。&lt;/p&gt;
&lt;p&gt;局限性：由于维护这种高度平衡所付出的代价比从中获得的效率收益还大。故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。&lt;/p&gt;
&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;一种二叉查找树，确保没有一条路径会比其他路径长出两倍。是一种弱平衡树。在插入和删除的操作中的旋转次数相对于AVL树来说较少。&lt;/p&gt;
&lt;h2 id=&#34;bb树&#34;&gt;B/B+树&lt;/h2&gt;
&lt;p&gt;B/B+树是为了磁盘或其他存储设备设计的平衡多路查找树，与红黑树相比，在相同结点的情况下，一颗B/B+树的高度远远小于红黑树。B树的操作效率主要取决于访问磁盘的次数，关键字数相同的情况下，B树高度越小，磁盘I/O所花的时间越少。&lt;/p&gt;
&lt;p&gt;B+树是应文件系统所需而产生的一种B树的变形树，非叶子结点只保存索引，不保存实际的数据，数据都保存在叶子结点中。相当于是文件系统的查找。&lt;/p&gt;
&lt;p&gt;另外B+树支持顺序查找而B树不支持，数据库中经常需要遍历一定范围内的数据，因此采用B+树比采用B树的效率更高。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95avl%E6%A0%91%E5%8F%8A%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91_b%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp内存对齐</title>
        <link>https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
        <pubDate>Wed, 22 Dec 2021 16:10:44 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/ -&lt;h2 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h2&gt;
&lt;p&gt;看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//32位系统
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; y;
}s;

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(s);  &lt;span style=&#34;color:#888&#34;&gt;// 输出8
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。&lt;/p&gt;
&lt;h2 id=&#34;进行内存对齐的原因&#34;&gt;进行内存对齐的原因&lt;/h2&gt;
&lt;p&gt;尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为&lt;strong&gt;内存存取粒度&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。&lt;/p&gt;
&lt;h2 id=&#34;默认内存对齐&#34;&gt;默认内存对齐&lt;/h2&gt;
&lt;p&gt;int类型放在地址能被4整除的位置，short类型放在地址能被2整除的位置，char能放在任何位置。&lt;/p&gt;
&lt;p&gt;结构体的对齐满足以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体变量的首地址能够被其&lt;strong&gt;最宽基本类型成员的大小&lt;/strong&gt;所整除。&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是&lt;strong&gt;成员大小的整数倍&lt;/strong&gt;，如有需要编译器会在成员之间填充字节。&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体&lt;strong&gt;最宽基本类型成员大小的整数倍&lt;/strong&gt;，如有需要编译器会在最末一个成员后填充字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pragma-pack命令&#34;&gt;#pragma pack()命令&lt;/h2&gt;
&lt;p&gt;改命令强制规定了成员的对齐方式，括号内为&lt;strong&gt;对齐的字节数&lt;/strong&gt;。若括号内的内容为空，则为默认对齐。&lt;/p&gt;
&lt;p&gt;改变默认对齐方式能够更加充分利用存储空间，但降低了计算机的读写速率，是一种以空间换事件的方法。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>测试机器大小端的方法</title>
        <link>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/</link>
        <pubDate>Wed, 22 Dec 2021 15:49:36 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/ -&lt;ul&gt;
&lt;li&gt;小端法：低位字节存放在低地址，高位字节存放在高地址&lt;/li&gt;
&lt;li&gt;大端法：低位字节存放在高地址，高位字节存放在低地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断电脑大小端模式的方法：&lt;/p&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言中的char和int：&lt;/p&gt;
&lt;p&gt;在C语言中并没有char类型的常量，其实是用int类型表示char。举个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; ch &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#888&#34;&gt;//分别输出ch的字符和对应的ascii码。即打印出的是字符或整数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;%c, %d&amp;#34;&lt;/span&gt;, ch, ch);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果为：a, 97&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将int 48存起来，然后取得其地址，再将这个地址转为char* 这时候，如果是小端存储，那么char*指针就指向48；48对应的ASCII码为字符‘0’；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge1&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;48&lt;/span&gt;;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;i;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
    c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)p);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;方法二&#34;&gt;方法二&lt;/h2&gt;
&lt;p&gt;定义变量int i=1；将 i 的地址拿到，强转成char*型，这时候就取到了 i 的低地址，这时候如果是1就是小端存储，如果是0就是大端存储。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge2&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;i);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (c)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;方法三&#34;&gt;方法三&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;联合体union是一种特殊数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共同体，但任何时候只能有一个成员带有值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义联合体，一个成员是多字节，一个是单字节，给多字节的成员赋一个最低一个字节不为0，其他字节为0 的值，再用第二个成员来判断，如果第二个字节不为0，就是小端，若为0，就是大端。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;judge3&lt;/span&gt;() {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;union&lt;/span&gt;
    {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; c;
    } un;
    un.i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (un.c &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;)
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;小端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
        cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;大端&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/%E6%B5%8B%E8%AF%95%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp容器库和相关操作总结</title>
        <link>https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</link>
        <pubDate>Thu, 16 Dec 2021 15:34:43 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/ -&lt;h1 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h1&gt;
&lt;h2 id=&#34;vector&#34;&gt;vector&lt;/h2&gt;
&lt;p&gt;member functions：&lt;/p&gt;
&lt;p&gt;constructor、destructor、operator=、assign、get_allocator&lt;/p&gt;
&lt;h3 id=&#34;element-access&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iterators&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin/cbegin&lt;/li&gt;
&lt;li&gt;end/cend&lt;/li&gt;
&lt;li&gt;rbegin/c rbegin&lt;/li&gt;
&lt;li&gt;rend/c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;li&gt;reserve&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;shrink_to_fit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;emplace：相较于insert，不需要产生一个临时变量。&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;push_back&lt;/li&gt;
&lt;li&gt;resize&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;non-member functions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;operator==&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deque&#34;&gt;deque&lt;/h2&gt;
&lt;p&gt;双端队列&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;list&lt;/h2&gt;
&lt;p&gt;双向链表&lt;/p&gt;
&lt;h2 id=&#34;forward_list&#34;&gt;forward_list&lt;/h2&gt;
&lt;p&gt;单向链表&lt;/p&gt;
&lt;h2 id=&#34;array&#34;&gt;array&lt;/h2&gt;
&lt;p&gt;array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。&lt;/p&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;h3 id=&#34;iterators-1&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin/cbegin&lt;/li&gt;
&lt;li&gt;end/cend&lt;/li&gt;
&lt;li&gt;rbegin/c rbegin&lt;/li&gt;
&lt;li&gt;rend/c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-1&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;length&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;li&gt;reserve&lt;/li&gt;
&lt;li&gt;capacity&lt;/li&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;shrink_to_fit&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;element-access-1&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-1&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;+=&lt;/li&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;li&gt;push_back&lt;/li&gt;
&lt;li&gt;assign&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;pop_back&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;关联容器&#34;&gt;关联容器&lt;/h1&gt;
&lt;h2 id=&#34;set&#34;&gt;set&lt;/h2&gt;
&lt;h3 id=&#34;iterators-2&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin / cbegin&lt;/li&gt;
&lt;li&gt;end / cend&lt;/li&gt;
&lt;li&gt;rbegin / c rbegin&lt;/li&gt;
&lt;li&gt;rend / c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-2&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-2&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;emplace_hint&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lookup&#34;&gt;Lookup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;contains&lt;/li&gt;
&lt;li&gt;equal_range&lt;/li&gt;
&lt;li&gt;lower_bound&lt;/li&gt;
&lt;li&gt;upper_bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;
&lt;h3 id=&#34;element-accress&#34;&gt;Element accress&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;at&lt;/li&gt;
&lt;li&gt;operator &lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iterators-3&#34;&gt;Iterators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;begin / cbegin&lt;/li&gt;
&lt;li&gt;end / cend&lt;/li&gt;
&lt;li&gt;rbegin / c rbegin&lt;/li&gt;
&lt;li&gt;rend / c rend&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-3&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;max_size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-3&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;insert_or_assign&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;emplace_hint&lt;/li&gt;
&lt;li&gt;try_emplace&lt;/li&gt;
&lt;li&gt;erase&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lookup-1&#34;&gt;Lookup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;contains&lt;/li&gt;
&lt;li&gt;equal_range&lt;/li&gt;
&lt;li&gt;lower_bound&lt;/li&gt;
&lt;li&gt;upper_bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;multimap&#34;&gt;multimap&lt;/h2&gt;
&lt;p&gt;允许多个多个元素具有相同的关键词。主要应用有：例如词典中一个单词可以有多个意思。&lt;/p&gt;
&lt;h2 id=&#34;multiset&#34;&gt;multiset&lt;/h2&gt;
&lt;h2 id=&#34;unordered_map&#34;&gt;unordered_map&lt;/h2&gt;
&lt;p&gt;无序容器不使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器非常有用。某些应用中维护元素序的代价非常高昂，此时无序容器也很有用。&lt;/p&gt;
&lt;h2 id=&#34;unordered_set&#34;&gt;unordered_set&lt;/h2&gt;
&lt;h2 id=&#34;unordered_multimap&#34;&gt;unordered_multimap&lt;/h2&gt;
&lt;h2 id=&#34;unordered_multimet&#34;&gt;unordered_multimet&lt;/h2&gt;
&lt;h1 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h1&gt;
&lt;h2 id=&#34;priority_queue&#34;&gt;priority_queue&lt;/h2&gt;
&lt;h3 id=&#34;element-access-2&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-4&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-4&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stack&#34;&gt;stack&lt;/h2&gt;
&lt;p&gt;与priority_queue相同。&lt;/p&gt;
&lt;h2 id=&#34;queue&#34;&gt;queue&lt;/h2&gt;
&lt;h3 id=&#34;element-access-3&#34;&gt;Element access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;front&lt;/li&gt;
&lt;li&gt;back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;capacity-5&#34;&gt;Capacity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;empty&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modifiers-5&#34;&gt;Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;li&gt;emplace&lt;/li&gt;
&lt;li&gt;pop&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;list-1&#34;&gt;list&lt;/h2&gt;
- https://eternityqjl.top/posts/cpp%E5%AE%B9%E5%99%A8%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C程序字节对齐方式</title>
        <link>https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</link>
        <pubDate>Tue, 14 Dec 2021 16:38:12 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/ -&lt;h2 id=&#34;默认字节对齐&#34;&gt;默认字节对齐&lt;/h2&gt;
&lt;p&gt;int类型放在地址能被4整除的位置，short类型放在地址能被2整除的位置，char能放在任何位置。&lt;/p&gt;
&lt;p&gt;结构体的对其满足以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体变量的首地址能够被其最宽基本类型成员的大小所整除。&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间填充字节。&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员后填充字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pragma-pack命令&#34;&gt;#pragma pack()命令&lt;/h2&gt;
&lt;p&gt;改命令强制规定了成员的对齐方式，括号内为对齐的字节数。若括号内的内容为空，则为默认对齐。&lt;/p&gt;
&lt;p&gt;改变默认对齐方式能够更加充分利用存储空间，但降低了计算机的读写速率，是一种以空间换事件的方法。&lt;/p&gt;
- https://eternityqjl.top/posts/c%E7%A8%8B%E5%BA%8F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Csapp：7.链接</title>
        <link>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</link>
        <pubDate>Sat, 11 Dec 2021 21:38:11 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/ -&lt;p&gt;链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载到内存并执行。&lt;/p&gt;
&lt;p&gt;链接可以执行于编译时、加载时、运行时。&lt;/p&gt;
&lt;p&gt;链接使得分离编译成为可能。可以将巨大的源文件分解为更小的模块，可以独立地修改和编译这些模块。当我们改变其中的一个模块时，只需简单地将其重新编译并链接，无需重新编译其他文件。&lt;/p&gt;
&lt;p&gt;理解链接器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助构造大型程序&lt;/li&gt;
&lt;li&gt;避免一些危险的编程错误。例如错误地定义多个全局变量的程序将通过链接器，不产生任何警告。&lt;/li&gt;
&lt;li&gt;理解语言的作用域规则。如：全局和局部变量的区别；static属性的变量和函数的意义。&lt;/li&gt;
&lt;li&gt;帮助理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色。&lt;/li&gt;
&lt;li&gt;帮助我们利用共享库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器驱动程序&#34;&gt;编译器驱动程序&lt;/h2&gt;
&lt;p&gt;编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。例如我们经常使用的gcc驱动程序。&lt;/p&gt;
&lt;p&gt;main.c$\rightarrow$main.i$\rightarrow$main.s$\rightarrow$main.o$\rightarrow$prog&lt;/p&gt;
&lt;p&gt;源程序$\rightarrow$中间文件$\rightarrow$汇编语言文件$\rightarrow$&lt;strong&gt;可重定位目标文件&lt;/strong&gt;$\rightarrow$&lt;strong&gt;可执行目标文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次使用了：预处理器、编译器、汇编器 、链接器&lt;/p&gt;
&lt;p&gt;shell执行可执行文件时调用操作系统中的加载器函数，将prog中的代码和数据复制到内存中，然后将控制转移到这个程序的开头。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;静态链接&#34;&gt;静态链接&lt;/h2&gt;
&lt;p&gt;可重定位目标文件由不同的代码和数据节组成，每一节都是一个连续的字节序列。&lt;/p&gt;
&lt;p&gt;静态链接器以一组&lt;strong&gt;可重定位目标文件和命令行参数&lt;/strong&gt;作为输入，生成一个&lt;strong&gt;完全链接的、可以加载和运行的可执行目标文件&lt;/strong&gt;作为输出。&lt;/p&gt;
&lt;p&gt;为了构造可执行文件，链接器必须完成连个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符号解析&lt;/strong&gt;：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。将每个符号引用正好和一个符号定义关联起来。（每个符号对应于一个函数、一个全局变量或一个静态变量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定位&lt;/strong&gt;。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使它们指向这个内存位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目标文件&#34;&gt;目标文件&lt;/h2&gt;
&lt;p&gt;共有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重定位目标文件：二进制代码和数据，可在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。&lt;/li&gt;
&lt;li&gt;可执行目标文件：二进制代码和数据，其形式可以直接被复制到内存中并执行。&lt;/li&gt;
&lt;li&gt;共享目标文件：特殊类型的可重定位目标文件，可以在加载或运行时被&lt;strong&gt;动态地加载进内存并链接&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标文件是按照特定目标文件格式来组织的，各个系统的目标文件格式都不相同。&lt;/p&gt;
&lt;h2 id=&#34;可重定位目标文件&#34;&gt;可重定位目标文件&lt;/h2&gt;
&lt;p&gt;一个典型的ELF可重定位目标文件：&lt;/p&gt;
&lt;p&gt;首先是16B的ELF头，描述了生成该文件的系统的字的大小和字节顺序。&lt;/p&gt;
&lt;p&gt;然后是节：一个典型的ELF可重定位目标文件包含以下几个节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.text&lt;/code&gt;：已编译程序的机器代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rodata&lt;/code&gt;：只读数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：已初始化的全局和静态C变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.symtab&lt;/code&gt;：一个符号表，存放在程序中定义和引用的函数和全局变量的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.text&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.debug&lt;/code&gt;：调试符号表，以-g选项调用编译器驱动程序时才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.line&lt;/code&gt;：原始C程序的行号和&lt;code&gt;.text&lt;/code&gt;节中的机器指令之间的映射，以-g选项调用编译器驱动程序时才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.strtab&lt;/code&gt;：一个字符串表，其中内容包括&lt;code&gt;.symtab&lt;/code&gt;和&lt;code&gt;.debug&lt;/code&gt;节中的符号表，以及节头部中的节名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;符号和符号表&#34;&gt;符号和符号表&lt;/h2&gt;
&lt;p&gt;每个可重定位目标模块都有一个符号表&lt;code&gt;.symtab&lt;/code&gt;，它包含m定义和引用的符号的信息。在链接器的上下文，有三种不同符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由模块m定义并能被其他模块引用的全局符号：对应非静态的C函数和全局变量。&lt;/li&gt;
&lt;li&gt;由其他模块定义并被m引用的全局符号，称为外部符号：对应其他模块中定义的非静态的C函数和全局变量&lt;/li&gt;
&lt;li&gt;只被模块m定义和引用的局部符号：对应于带static属性的C函数和全局变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本地非静态程序变量的符号在运行时在&lt;strong&gt;栈中&lt;/strong&gt;被管理，不在符号表.symtab中。&lt;/p&gt;
&lt;p&gt;C中源文件扮演模块的角色，static属性就像C++使用的public和private一样。&lt;/p&gt;
&lt;p&gt;尽可能用static属性来保护变量和函数。&lt;/p&gt;
&lt;p&gt;符号表由汇编器构造，使用编译器输出到汇编语言&lt;code&gt;.s&lt;/code&gt;文件中的符号。&lt;code&gt;.symtab&lt;/code&gt;节中包含ELF符号表。以下为符号表中每个符号条目的格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; name;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;type&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;,
		 &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;binding&lt;/span&gt;:&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;4&lt;/span&gt;;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; reserved;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;short&lt;/span&gt; section;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; value;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;long&lt;/span&gt; size;
} Elf64_Symbol;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符号的地址。对于可重定位目标文件来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时的地址。size是目标的大小。type通常代表数据或函数。符号表还可以包含各个节的条目。binging字段表示符号是本地还是全局。&lt;/p&gt;
&lt;p&gt;每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到节头部表的索引。&lt;/p&gt;
&lt;p&gt;以下是hello_world.c文件的符号表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
   printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;);
   &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Symbol table &#39;.symtab&#39; contains 70 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000318     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000338     0 SECTION LOCAL  DEFAULT    2 
     3: 0000000000000358     0 SECTION LOCAL  DEFAULT    3 
     4: 000000000000037c     0 SECTION LOCAL  DEFAULT    4 
     5: 00000000000003a0     0 SECTION LOCAL  DEFAULT    5 
     6: 00000000000003c8     0 SECTION LOCAL  DEFAULT    6 
     7: 0000000000000470     0 SECTION LOCAL  DEFAULT    7 
     8: 00000000000004f4     0 SECTION LOCAL  DEFAULT    8 
     9: 0000000000000508     0 SECTION LOCAL  DEFAULT    9 
    10: 0000000000000528     0 SECTION LOCAL  DEFAULT   10 
    11: 00000000000005e8     0 SECTION LOCAL  DEFAULT   11 
    12: 0000000000001000     0 SECTION LOCAL  DEFAULT   12 
    13: 0000000000001020     0 SECTION LOCAL  DEFAULT   13 
    14: 0000000000001040     0 SECTION LOCAL  DEFAULT   14 
    15: 0000000000001050     0 SECTION LOCAL  DEFAULT   15 
    16: 0000000000001060     0 SECTION LOCAL  DEFAULT   16 
    17: 00000000000011e8     0 SECTION LOCAL  DEFAULT   17 
    18: 0000000000002000     0 SECTION LOCAL  DEFAULT   18 
    19: 0000000000002014     0 SECTION LOCAL  DEFAULT   19 
    20: 0000000000002058     0 SECTION LOCAL  DEFAULT   20 
    21: 0000000000003db8     0 SECTION LOCAL  DEFAULT   21 
    22: 0000000000003dc0     0 SECTION LOCAL  DEFAULT   22 
    23: 0000000000003dc8     0 SECTION LOCAL  DEFAULT   23 
    24: 0000000000003fb8     0 SECTION LOCAL  DEFAULT   24 
    25: 0000000000004000     0 SECTION LOCAL  DEFAULT   25 
    26: 0000000000004010     0 SECTION LOCAL  DEFAULT   26 
    27: 0000000000000000     0 SECTION LOCAL  DEFAULT   27 
    28: 0000000000000000     0 SECTION LOCAL  DEFAULT   28 
    29: 0000000000000000     0 SECTION LOCAL  DEFAULT   29 
    30: 0000000000000000     0 SECTION LOCAL  DEFAULT   30 
    31: 0000000000000000     0 SECTION LOCAL  DEFAULT   31 
    32: 0000000000000000     0 SECTION LOCAL  DEFAULT   32 
    33: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    34: 0000000000001090     0 FUNC    LOCAL  DEFAULT   16 deregister_tm_clones
    35: 00000000000010c0     0 FUNC    LOCAL  DEFAULT   16 register_tm_clones
    36: 0000000000001100     0 FUNC    LOCAL  DEFAULT   16 __do_global_dtors_aux
    37: 0000000000004010     1 OBJECT  LOCAL  DEFAULT   26 completed.8061
    38: 0000000000003dc0     0 OBJECT  LOCAL  DEFAULT   22 __do_global_dtors_aux_fin
    39: 0000000000001140     0 FUNC    LOCAL  DEFAULT   16 frame_dummy
    40: 0000000000003db8     0 OBJECT  LOCAL  DEFAULT   21 __frame_dummy_init_array_
    41: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello_world.c
    42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    43: 000000000000215c     0 OBJECT  LOCAL  DEFAULT   20 __FRAME_END__
    44: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
    45: 0000000000003dc0     0 NOTYPE  LOCAL  DEFAULT   21 __init_array_end
    46: 0000000000003dc8     0 OBJECT  LOCAL  DEFAULT   23 _DYNAMIC
    47: 0000000000003db8     0 NOTYPE  LOCAL  DEFAULT   21 __init_array_start
    48: 0000000000002014     0 NOTYPE  LOCAL  DEFAULT   19 __GNU_EH_FRAME_HDR
    49: 0000000000003fb8     0 OBJECT  LOCAL  DEFAULT   24 _GLOBAL_OFFSET_TABLE_
    50: 0000000000001000     0 FUNC    LOCAL  DEFAULT   12 _init
    51: 00000000000011e0     5 FUNC    GLOBAL DEFAULT   16 __libc_csu_fini
    52: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
    53: 0000000000004000     0 NOTYPE  WEAK   DEFAULT   25 data_start
    54: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    55: 00000000000011e8     0 FUNC    GLOBAL HIDDEN    17 _fini
    56: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.2.5
    57: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    58: 0000000000004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    59: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    60: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    61: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    62: 0000000000001170   101 FUNC    GLOBAL DEFAULT   16 __libc_csu_init
    63: 0000000000004018     0 NOTYPE  GLOBAL DEFAULT   26 _end
    64: 0000000000001060    47 FUNC    GLOBAL DEFAULT   16 _start
    65: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    66: 0000000000001149    32 FUNC    GLOBAL DEFAULT   16 main
    67: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    68: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    69: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;符号解析&#34;&gt;符号解析&lt;/h2&gt;
&lt;p&gt;链接器解析符号引用的方法是将&lt;strong&gt;每个引用&lt;/strong&gt;与它输入的可重定位目标文件的符号表中的一个确定的&lt;strong&gt;符号定义&lt;/strong&gt;关联起来。&lt;/p&gt;
&lt;p&gt;对于引用和定义在相同模块中的局部符号（即对应static变量）的引用，符号解析非常简洁明了。编译器只允许每个局部符号有一个定义。&lt;/p&gt;
&lt;p&gt;对于全局符号的引用较为复杂，当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表，交给链接器处理。如果链接器在其他任何模块中都找不到这个被引用的符号，就输出一条错误信息并终止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器通过重整的编码方式来区分重载的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;链接器解析多重定义的全局符号&#34;&gt;链接器解析多重定义的全局符号&lt;/h3&gt;
&lt;p&gt;编译器向汇编器输出每个全局符号，或是强或是弱的，而汇编器把这些信息隐含地编码在可重定位目标文件的符号表里。&lt;strong&gt;函数和已初始化的全局变量&lt;/strong&gt;是强符号，&lt;strong&gt;未初始化的全局变量&lt;/strong&gt;是弱符号。&lt;/p&gt;
&lt;p&gt;Linux使用以下规则处理多重定义的符号名：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许由多个同名强符号&lt;/li&gt;
&lt;li&gt;如果一个强符号和多个弱符号同名，选择强符号&lt;/li&gt;
&lt;li&gt;如果有多个弱符号同名，从这些弱符号中任意选一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与静态库链接&#34;&gt;与静态库链接&lt;/h3&gt;
&lt;p&gt;所有编译器都有一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，它可以用作链接器的输入。链接器构造一个输出的可执行文件时，只复制静态库里被应用程序引用的目标模块。&lt;/p&gt;
&lt;p&gt;Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小，存档文件名由后缀&lt;code&gt;.a&lt;/code&gt;标识。&lt;/p&gt;
&lt;h3 id=&#34;链接器如何使用静态库来解析引用&#34;&gt;链接器如何使用静态库来解析引用&lt;/h3&gt;
&lt;p&gt;链接器从左到右按照在命令行上出现的顺序来扫描可重定位目标文件和存档文件。（编译器驱动程序自动将&lt;code&gt;.c&lt;/code&gt;文件翻译为&lt;code&gt;.o&lt;/code&gt;文件。在扫描中，链接器维护一个可重定位目标文件的集合E，一个未解析的符号集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U、D均为空。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果时目标文件则将其添加到E中，修改U和D来反映f中的符号引用和定义&lt;/li&gt;
&lt;li&gt;如果f是存档文件，链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m定义了一个符号来解析U中的一个引用，那么就把m加到E中，并修改U和D来反映m中的符号定义和引用。对存档文件依次重复这个过程直到U和D不发生变化。&lt;/li&gt;
&lt;li&gt;如果链接器完成对命令行输入文件的扫描后，U是非空的，则链接器输出错误并终止。否则，合并然后重定位E中的文件，构建可执行文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重定位&#34;&gt;重定位&lt;/h2&gt;
&lt;p&gt;链接器完成符号解析这一步后，就把代码中的每个符号引用和一个符号定义关联起来了，此时链接器就知道它的输入目标模块中的代码和数据节的确切大小。然后就可以开始重定位步骤了，该步骤将&lt;strong&gt;合并输入模块&lt;/strong&gt;，并为每个符号分配&lt;strong&gt;运行时地址&lt;/strong&gt;。共分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重定位节和符号定义&lt;/li&gt;
&lt;li&gt;重定位节中的符号引用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重定位条目&#34;&gt;重定位条目&lt;/h3&gt;
&lt;h3 id=&#34;重定位符号引用&#34;&gt;重定位符号引用&lt;/h3&gt;
&lt;h2 id=&#34;可执行目标文件&#34;&gt;可执行目标文件&lt;/h2&gt;
&lt;p&gt;转化后的&lt;strong&gt;二进制&lt;/strong&gt;的可执行目标文件包含加载程序到内存并运行它所需的所有信息。&lt;/p&gt;
&lt;p&gt;可执行目标文件格式类似于可重定位目标文件，ELF头描述文件的总体格式，还包括程序的入口点，即程序要运行时执行的第一条指令的地址。&lt;code&gt;.init&lt;/code&gt;节定义了一个小函数&lt;code&gt;_init&lt;/code&gt;，程序初始化代码会调用它。&lt;/p&gt;
&lt;p&gt;可执行文件是完全链接的（已经被重定位），所以它不需要rel节。&lt;/p&gt;
&lt;p&gt;ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系&lt;/p&gt;
&lt;h2 id=&#34;加载可执行目标文件&#34;&gt;加载可执行目标文件&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;linux&amp;gt; ./prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;shell认为prog是一个可执行目标文件，通过调用驻留在存储器中的&lt;strong&gt;加载器&lt;/strong&gt;的系统代码来运行它。加载器将可执行目标文件中的代码和数据从磁盘复制到内存，然后通过跳转到程序的入口点运行该程序。这整个过程叫做加载。&lt;/p&gt;
&lt;p&gt;每个Linux程序都有一个运行时内存映像。在Linux x86-64中，代码段总是从地址0x400000开始，后面是数据段。运行时堆在数据段之后，通过调用&lt;code&gt;malloc&lt;/code&gt;库向上增长。&lt;strong&gt;堆&lt;/strong&gt;后面的区域是为&lt;strong&gt;共享模块&lt;/strong&gt;保留的。用户&lt;strong&gt;栈&lt;/strong&gt;总是从最大合法地址($2^{48}-1$)开始，向较小内存地址增长。栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202112242026815.png&#34; alt=&#34;image-20211224202617709&#34;&gt;&lt;/p&gt;
&lt;p&gt;加载与之后章节的进程、虚拟内存和内存映射有关。之后章节还会介绍。&lt;/p&gt;
&lt;h2 id=&#34;动态链接共享库&#34;&gt;动态链接共享库&lt;/h2&gt;
&lt;p&gt;静态库有一个缺点，需要定期维护和更新，如果应用程序需要一个新版本，必须以某种方式了解到该库的变化情况，然后显式地将其程序与更新了的库重新连接。&lt;/p&gt;
&lt;p&gt;另一个问题是几乎每个C程序都使用标准I/O函数。运行时这些代码会被复制到每个运行进程的文本中，在一个上百个进程的系统上，这是对内存资源的极大浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享库&lt;/strong&gt;用来解决静态库的缺陷，共享库是一个目标模块，在&lt;strong&gt;运行或加载时&lt;/strong&gt;，可以加载到任意内存地址，并与一个在内存中的程序链接起来。这个过程称为&lt;strong&gt;动态链接&lt;/strong&gt;，由叫做动态链接器的程序执行。Linux中用&lt;code&gt;.so&lt;/code&gt;后缀的文件来表示共享库，Windows中使用&lt;code&gt;.dll&lt;/code&gt;表示。&lt;/p&gt;
&lt;p&gt;任何给定文件系统中，对于一个库文件只有一个&lt;code&gt;.so&lt;/code&gt;文件。所有引用该库的可执行目标文件共享这个&lt;code&gt;.so&lt;/code&gt;文件中的数据和代码，不需要都复制和嵌入到引用它们的可执行文件中。&lt;/p&gt;
&lt;p&gt;在内存中，一个共享库的&lt;code&gt;.text&lt;/code&gt;节的一个副本可以被不同的正在运行的进程共享。第9章虚拟内存的内容中将更加详细地描述。&lt;/p&gt;
&lt;h2 id=&#34;位置无关代码&#34;&gt;位置无关代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可以加载而无需重定位&lt;/strong&gt;的代码称为位置无关代码（Position Independent Code, PIC）。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。&lt;/p&gt;
&lt;h3 id=&#34;pic数据引用&#34;&gt;PIC数据引用&lt;/h3&gt;
&lt;h3 id=&#34;pic函数调用&#34;&gt;PIC函数调用&lt;/h3&gt;
&lt;h2 id=&#34;库打桩机制&#34;&gt;库打桩机制&lt;/h2&gt;
&lt;p&gt;库打桩允许我们截获对共享库函数的调用，取而代之执行自己的代码。使用该机制可以追踪对某个特殊库函数的调用次数，验证和追踪其输入输出值，或将其替换为一个完全不同的实现。&lt;/p&gt;
&lt;p&gt;给定一个需要打桩的目标函数，创建一个包装函数，其原型与目标函数完全相同，使用某种特殊打桩机制，就可以欺骗系统调用包装函数而不是目标函数。&lt;/p&gt;
&lt;p&gt;打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。&lt;/p&gt;
&lt;h3 id=&#34;编译时打桩&#34;&gt;编译时打桩&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//int.c
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; malloc(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt;);
    free(p);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//malloc.h
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#define malloc(size) mymalloc(size)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define free(ptr) myfree(ptr)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mymalloc&lt;/span&gt;(size_t size);
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;myfree&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;//mymalloc.c
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//#define COMPILETIME
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#ifdef COMPILETIME
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mymalloc&lt;/span&gt;(size_t size) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; malloc(size);
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;malloc(%d)=%p&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;)size, ptr);

    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr;
}

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;myfree&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ptr) {
    free(ptr);
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;free(%p)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, ptr);
}
&lt;span style=&#34;color:#579&#34;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ gcc -DCOMPILETIME -c mymalloc.c
$ gcc -I. -o intc int.c mymalloc.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行程序&lt;code&gt;intc&lt;/code&gt;得到结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ ./intc
malloc&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;32&lt;span style=&#34;color:#333&#34;&gt;)=&lt;/span&gt;0x561e0ca432a0
free&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;0x561e0ca432a0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;链接时打桩&#34;&gt;链接时打桩&lt;/h3&gt;
&lt;p&gt;Linux静态链接器支持用&lt;code&gt;--wrap f&lt;/code&gt;标志进行链接时打桩。&lt;/p&gt;
&lt;h3 id=&#34;运行时打桩&#34;&gt;运行时打桩&lt;/h3&gt;
&lt;p&gt;编译时打桩需要访问源程序，链接时打桩需要访问程序的可重定位目标文件。有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个机制基于动态链接器的LD_PRELOAD环境变量。&lt;/p&gt;
- https://eternityqjl.top/posts/csapp-7-%E9%93%BE%E6%8E%A5/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 