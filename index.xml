<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Thu, 09 Dec 2021 10:55:47 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>算法——桶排序&amp;计数排序&amp;基数排序</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 09 Dec 2021 10:55:47 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/ -&lt;h2 id=&#34;桶排序bucket-sort&#34;&gt;桶排序（Bucket Sort）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将待排元素划分到不同的桶中。先扫描一遍序列，找出最大值max和最小值min，设桶的个数为k，则把区间[min, max]划分为k个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。&lt;/li&gt;
&lt;li&gt;对每个桶内的元素进行排序。一般使用快速排序。&lt;/li&gt;
&lt;li&gt;将各桶中的元素合并为一个大的有序序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当k接近于n时，桶排序的时间复杂度为O(n)，即桶越多，时间效率就越高。&lt;/p&gt;
&lt;h2 id=&#34;计数排序counting-sort&#34;&gt;计数排序（Counting Sort）&lt;/h2&gt;
&lt;p&gt;新建一个大小为maxValue-minValue+1的数组nums，然后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配。扫描一遍原始数组，以扫描到的当前值val减去1作为下标，将下标对应位置数组加1，即nums[val]++&lt;/li&gt;
&lt;li&gt;收集。顺序扫描一遍数组nums。数组的每个元素代表了按当前下标+1对应值的个数，将这些值收集起来放入新的数组就得到最终排序结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：nums=[2,1,3,1,5]，首先扫描一遍取最大值maxValue=5和最小值minValue=1，新建一个长度为5-1+1=5的数组nums：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配：得到nums=[2,1,1,0,1]，例如nums[0]表示值为0+minValue=1出现了两次。&lt;/li&gt;
&lt;li&gt;收集：得到结果，[1,1,2,3,5]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上是一种&lt;strong&gt;特殊的桶排序&lt;/strong&gt;。当桶的个数等于元素个数时就是计数排序。&lt;/p&gt;
&lt;h2 id=&#34;基数排序&#34;&gt;基数排序&lt;/h2&gt;
&lt;p&gt;基于关键字各位的大小进行排序。是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。&lt;/p&gt;
&lt;p&gt;共有&lt;strong&gt;最高位优先MSD&lt;/strong&gt;和&lt;strong&gt;最低位优先LSD&lt;/strong&gt;两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有待排序整数（注意，必须是非负整数）统一为位数相同的整数，位数较少的前面补零。一般用10进制，也可以用16进制甚至2进制。所以前提是能够找到最大值，得到最长的位数，设k进制下最长为位数为d。&lt;/li&gt;
&lt;li&gt;从最低位开始，依次进行一次稳定排序。这样从最低位一直到最高位排序完成以后，整个序列就变成了一个有序序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基数排序可以看作是多轮桶排序，每个数位上都进行一次桶排序。&lt;/p&gt;
&lt;p&gt;当使用2进制时， k=2 最小，位数 d 最大，时间复杂度 O(nd) 会变大，空间复杂度 O(n+k) 会变小。当用最大值作为基数时， k=maxV 最大， d=1 最小，此时时间复杂度 O(nd) 变小，但是空间复杂度 O(n+k) 会急剧增大，此时基数排序退化成了计数排序。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>TCP三次握手四次挥手详解</title>
        <link>https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Thu, 09 Dec 2021 09:31:30 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/ -&lt;h2 id=&#34;三次握手建立连接&#34;&gt;三次握手建立连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步：客户机的TCP向服务器的TCP发送连接请求报文段。该报文段的同步位&lt;strong&gt;SYN置为1&lt;/strong&gt;，同时选择一个初始序号&lt;strong&gt;seq=x&lt;/strong&gt;。SYN报文段&lt;strong&gt;不能携带数据&lt;/strong&gt;，但要&lt;strong&gt;消耗掉一个序号&lt;/strong&gt;。这是客户机进入&lt;strong&gt;SYN-SENT同步已发送&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;第二步：服务器的TCP收到连接请求后，如果同意建立连接，则向客户机发回确认，并为该TCP分配缓存和变量。在确认报文段中，&lt;strong&gt;SYN和ACK都置为1&lt;/strong&gt;，确认号是&lt;strong&gt;ack=x+1&lt;/strong&gt;，同时为自己选择一个初始序号&lt;strong&gt;seq=y&lt;/strong&gt;。确认报文&lt;strong&gt;不能携带数据&lt;/strong&gt;，但也要&lt;strong&gt;消耗一个序号&lt;/strong&gt;。此时服务器进入&lt;strong&gt;SYN-RCVD同步收到&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;第三步：客户机收到确认报文后，还要向服务器给出确认，并为该TCP连接&lt;strong&gt;分配缓存和变量&lt;/strong&gt;。确认报文段的&lt;strong&gt;ACK置为1&lt;/strong&gt;，确认号&lt;strong&gt;ack=y+1&lt;/strong&gt;，序号&lt;strong&gt;seq=x+1&lt;/strong&gt;.该报文段&lt;strong&gt;可以携带数据&lt;/strong&gt;，若&lt;strong&gt;不携带则不消耗序号&lt;/strong&gt;。此时TCP客户进程进入&lt;strong&gt;ESTABLISH已建立连接&lt;/strong&gt;状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四次挥手关闭连接&#34;&gt;四次挥手关闭连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步：客户端TCP发送连接释放报文段，并&lt;strong&gt;停止发送数据&lt;/strong&gt;，终止位&lt;strong&gt;FIN置为1&lt;/strong&gt;，序号&lt;strong&gt;seq=u&lt;/strong&gt;，等于之前&lt;strong&gt;已经传送的数据的最后一个字节的序号加1&lt;/strong&gt;，FIN报文段即使&lt;strong&gt;不携带数据也要消耗一个序号&lt;/strong&gt;。此时TCP客户机进入&lt;strong&gt;FIN-WAIT-1状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第二步：服务器收到连接释放报文后即发出确认，确认号&lt;strong&gt;ack=u+1&lt;/strong&gt;，序号&lt;strong&gt;seq=v&lt;/strong&gt;，等于前面&lt;strong&gt;已经传输过的数据的最后一个字节的序号加1&lt;/strong&gt;。然后服务器进入&lt;strong&gt;CLOSE-WAIT状态&lt;/strong&gt;。此时从客户机到服务器的连接就释放了，TCP连接处于&lt;strong&gt;半关闭&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;第三步：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出&lt;strong&gt;FIN=1&lt;/strong&gt;的&lt;strong&gt;连接释放报文段&lt;/strong&gt;，该报文段的序号&lt;strong&gt;seq=w&lt;/strong&gt;（在半关闭的时候可能又传输了一些数据），还需重复上次已经发送的确认号&lt;strong&gt;ack=u+1&lt;/strong&gt;.此时服务器进入&lt;strong&gt;LAST-ACK状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第四步：客户机收到连接释放报文段后，要发送确认。把确认报文中的&lt;strong&gt;确认位ACK置为1&lt;/strong&gt;，确认号&lt;strong&gt;ack=w+1&lt;/strong&gt;，序号&lt;strong&gt;seq=u+1&lt;/strong&gt;。此时连接还未释放，要等到计时器的设置时间**2MSL（最长报文寿命）**后客户机才进入CLOSED状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;粘包&#34;&gt;粘包&lt;/h2&gt;
&lt;p&gt;应用层一次recv接收了多个send。原因是TCP协议是面向字节流的，无法区分边界，需要应用层协议去解决。可以通过在应用层为数据流加上特定标志开头。还有就是关闭Nagle协议。&lt;/p&gt;
- https://eternityqjl.top/posts/%E8%AE%A1%E7%BD%91tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>现代操作系统学习日志——进程与线程</title>
        <link>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
        <pubDate>Tue, 07 Dec 2021 17:14:52 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/ -&lt;h2 id=&#34;0-操作系统概念&#34;&gt;0. 操作系统概念&lt;/h2&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;h3 id=&#34;地址空间&#34;&gt;地址空间&lt;/h3&gt;
&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;
&lt;h3 id=&#34;输入输出&#34;&gt;输入输出&lt;/h3&gt;
&lt;h3 id=&#34;保护&#34;&gt;保护&lt;/h3&gt;
&lt;h3 id=&#34;shell&#34;&gt;shell&lt;/h3&gt;
&lt;p&gt;进程是操作系统中的最核心的概念，它是对正在运行程序的一个抽象。&lt;/p&gt;
&lt;h2 id=&#34;进程-1&#34;&gt;进程&lt;/h2&gt;
&lt;p&gt;在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使得每个进程各运行几十至几百毫秒。在某一瞬间，CPU只运行一个进程，但在1秒内CPU可能运行多个进程。&lt;/p&gt;
&lt;h3 id=&#34;进程模型&#34;&gt;进程模型&lt;/h3&gt;
&lt;p&gt;计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程。一个进程就是一个正在执行程序的实例。&lt;/p&gt;
&lt;h3 id=&#34;进程的创建&#34;&gt;进程的创建&lt;/h3&gt;
&lt;h3 id=&#34;进程的终止&#34;&gt;进程的终止&lt;/h3&gt;
&lt;h3 id=&#34;进程的层次结构&#34;&gt;进程的层次结构&lt;/h3&gt;
&lt;p&gt;UNIX中进程和它的所有子进程及后裔共同组成一个&lt;strong&gt;进程组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;UNIX启动时初始化自己的方式：一个称为&lt;code&gt;init&lt;/code&gt;的特殊进程出现在启动映像中，开始运行时读入一个说明终端数量的文件，接着为每个终端创建一个新进程，这些进程等待用户登陆，如果有一个用户登录成功，该登录进程就执行一个shell准备接受命令，所接受的这些命令会启动更多进程。以此类推，在整个系统中，所有进程都是属于以init为根的一棵树。&lt;/p&gt;
&lt;p&gt;Windows中没有进程层次的概念，所有进程都是&lt;strong&gt;低位相等&lt;/strong&gt;的。&lt;/p&gt;
&lt;h3 id=&#34;进程的状态&#34;&gt;进程的状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运行态：该时刻进程实际占用CPU&lt;/li&gt;
&lt;li&gt;就绪态：可运行，但因为其他进程正在运行而暂时停止&lt;/li&gt;
&lt;li&gt;阻塞态：除非某种外部事件发生，否则进程不能运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的实现&#34;&gt;进程的实现&lt;/h3&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;p&gt;每个进程有一个地址空间和一个控制线程；但是，经常存在同一个地址空间中&lt;strong&gt;准并行运行&lt;/strong&gt;多个控制线程的情况，这些线程就像是分离的进程（除共享地址空间外）。&lt;/p&gt;
&lt;h3 id=&#34;线程的使用&#34;&gt;线程的使用&lt;/h3&gt;
&lt;p&gt;并行实体拥有&lt;strong&gt;共享同一个地址空间和所有可用数据&lt;/strong&gt;的能力，而多进程模型的地址空间不同。&lt;/p&gt;
&lt;p&gt;线程比进程更轻量级，更容易创建、也更容易撤销。&lt;/p&gt;
&lt;p&gt;另外如果存在大量计算和I/O处理，多个线程允许这些活动彼此重叠进行，加快执行速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字处理软件：
&lt;ul&gt;
&lt;li&gt;与用户交互线程&lt;/li&gt;
&lt;li&gt;格式处理线程&lt;/li&gt;
&lt;li&gt;处理磁盘备份线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;经典的线程模型&#34;&gt;经典的线程模型&lt;/h3&gt;
&lt;p&gt;在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。前一种情形下，多个线程共享共享&lt;strong&gt;同一地址空间和其他资源&lt;/strong&gt;，后一种情形中，多个进程共享物理内存、磁盘、打印机和其他资源。因此由于线程具有进程的某些性质，所以有时被称为轻量级进程。&lt;/p&gt;
&lt;p&gt;多线程用来描述在同一个进程中允许多个线程的情形，一些CPU已经有直接硬件支持多线程，允许线程切换在纳秒级完成。&lt;/p&gt;
&lt;p&gt;所有线程共享同一地址空间，意味着它们也共享同样的全局变量。各个线程可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或清除另一个线程的堆栈。&lt;strong&gt;线程之间是没有保护的&lt;/strong&gt;，因为同一个进程的多个线程是为了相互合作的。除了共享地址空间，所有线程还共享同一个打开文件、子进程、定时器及相关信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个进程中的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址空间&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;打开文件&lt;/li&gt;
&lt;li&gt;子进程&lt;/li&gt;
&lt;li&gt;定时器&lt;/li&gt;
&lt;li&gt;信号与信号处理程序&lt;/li&gt;
&lt;li&gt;账户信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;每个线程中的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆栈&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和传统进程一样，线程可以处于若干种状态的任何一个：&lt;strong&gt;运行、阻塞、就绪或终止&lt;/strong&gt;。正在运行的线程&lt;strong&gt;拥有CPU并且是活跃的&lt;/strong&gt;，被阻塞线程正在等待某个释放它的事件。&lt;/p&gt;
&lt;p&gt;认识到&lt;strong&gt;每个线程有其自己的堆栈&lt;/strong&gt;很重要。每个线程的堆栈有一个帧，供各个被调用但还没有从中返回的过程使用。在该栈帧中存放了响应过程的局部变量以及过程调用完后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，因此每个线程需要有自己的堆栈。&lt;/p&gt;
&lt;p&gt;一个常见的系统调用：&lt;strong&gt;thread_yield&lt;/strong&gt;，允许线程自动放弃CPU而让另一个线程运行。这样的调用很重要，因为不同于进程，线程库无法利用时钟中断强制线程让出CPU。所以设法使线程随着事件推移自动交出CPU，并让其他线程有机会使用，就非常重要。&lt;/p&gt;
&lt;h3 id=&#34;posix线程&#34;&gt;POSIX线程&lt;/h3&gt;
&lt;p&gt;为实现可移植的线程程序，IEEE定义了线程的标准。它定义的线程包叫做&lt;strong&gt;pthread&lt;/strong&gt;。大部分UNIX系统都支持该标准，这个标准定义了超过60个函数调用。所有pthread线程都有某些特性，每一个都含有一个标识符、一组寄存器和一个存储在结构中的属性。这些属性包括堆栈大小、调度参数以及其他线程需要的项目。&lt;/p&gt;
&lt;p&gt;以下是一些线程调用举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pthread_create：创建新线程并返回标识符，线程标识符为了让其他线程引用该线程&lt;/li&gt;
&lt;li&gt;pthread_exit：结束调用的线程&lt;/li&gt;
&lt;li&gt;pthread_join：等待一个特定线程的推出&lt;/li&gt;
&lt;li&gt;pthread_yield：释放CPU来运行另一个线程&lt;/li&gt;
&lt;li&gt;pthread_attr_init：创建并初始化一个线程的属性结构&lt;/li&gt;
&lt;li&gt;pthread_attr_destroy：删除一个线程的属性结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;在用户空间中实现线程&#34;&gt;在用户空间中实现线程&lt;/h3&gt;
&lt;p&gt;有两种主要的方法实现线程包：在用户空间中和在内核中。&lt;/p&gt;
&lt;p&gt;把整个线程包放在用户空间时，内核对线程包一无所知。从内核的角度看就相当于单线程进程。&lt;/p&gt;
&lt;p&gt;第一个优点是用户级线程包可以在不支持线程的操作系统上实现。可以用函数库实现线程。&lt;/p&gt;
&lt;p&gt;线程是在一个&lt;strong&gt;运行时系统&lt;/strong&gt;的上层运行，该运行时系统是一个管理线程的过程的集合。前面已经介绍过pthread_create、pthread_exit等过程。&lt;/p&gt;
&lt;p&gt;用户空间管理线程时，每个进程需要有其专用的&lt;strong&gt;线程表&lt;/strong&gt;，用来跟踪该进程中的线程。线程表与内核中的进程表类似，不过只记录每个线程的属性。该线程表由运行时系统管理。&lt;/p&gt;
&lt;p&gt;用户线程的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程切换要比陷入内核快一个数量级，保存线程状态的过程和调度程序都是本地过程，启动它们比进行内核调用效率高&lt;/li&gt;
&lt;li&gt;允许每个进程有自己的调度算法。同时用户级i安城具有较好的可扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;如何实现阻塞系统的问题。使用线程的一个主要目的：要允许每个线程使用阻塞调用，还要避免被阻塞的线程影响其他线程。发生缺页的故障时，在对所需的指令进行定位和读入时，相关进程就被阻塞。一个线程引起页面故障时，内核由于不知道有线程存在，通常会把整个进程阻塞直到磁盘I/O完成为止，尽管其他线程可以正常运行。&lt;/p&gt;
&lt;p&gt;另一个问题是单独的一个进程内部没有时钟中断，只能等一个线程自动放弃CPU时其他线程才能使用。&lt;/p&gt;
&lt;h3 id=&#34;在内核中实现线程&#34;&gt;在内核中实现线程&lt;/h3&gt;
&lt;p&gt;此时无需运行时系统，并且每个进程中也没有线程表。在&lt;strong&gt;内核中&lt;/strong&gt;有用来记录系统中所有线程的&lt;strong&gt;线程表&lt;/strong&gt;。当某个线程希望&lt;strong&gt;创建一个新线程或撤销一个已有线程&lt;/strong&gt;时，它进行一个&lt;strong&gt;系统调用&lt;/strong&gt;，这个系统调用通过对线程表的更新完成线程创建或撤销工作。&lt;/p&gt;
&lt;p&gt;所有能阻塞线程的调用都以&lt;strong&gt;系统调用&lt;/strong&gt;的形式实现，这与运行时系统相比，&lt;strong&gt;代价十分可观&lt;/strong&gt;。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中另一个线程（若有一个就绪线程）或运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺其CPU。&lt;/p&gt;
&lt;p&gt;内核线程不需要任何新的、非阻塞系统调用。如果某个进程中的线程引起了页面故障，内核可以方便地检查该进程是否有其他就绪的线程，如果有就将其运行。这样做的缺点是&lt;strong&gt;系统调用的代价较大&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;混合实现&#34;&gt;混合实现&lt;/h3&gt;
&lt;p&gt;多个内核级线程和用户级线程多路复用。一些内核级线程被多个用户级线程多路复用，如同进程的用户级线程一样。每个内核级线程有一个可以轮流使用的用户级线程的集合。&lt;/p&gt;
&lt;h3 id=&#34;调度程序激活机制&#34;&gt;调度程序激活机制&lt;/h3&gt;
&lt;p&gt;内核级线程在一些关键点上优于用户级线程，但速度远慢于用户级线程。人们设计了调度程序激活，来模拟内核线程的功能&lt;/p&gt;
&lt;h3 id=&#34;弹出式线程&#34;&gt;弹出式线程&lt;/h3&gt;
&lt;p&gt;用来处理到来的消息，例如服务请求。&lt;/p&gt;
&lt;h3 id=&#34;使单线程代码多线程化&#34;&gt;使单线程代码多线程化&lt;/h3&gt;
&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;
&lt;h3 id=&#34;0-基本概念&#34;&gt;0. 基本概念&lt;/h3&gt;
&lt;p&gt;消息传递小节以前介绍的内容都是&lt;strong&gt;共享存储&lt;/strong&gt;相关的内容，主要是来实现同步和互斥机制。&lt;strong&gt;消息传递&lt;/strong&gt;是第二种通信方式，使用send和receive原语进行传递，它们是系统调用，需要进入内核态。&lt;/p&gt;
&lt;p&gt;IPC（Inter Process Communication）。以下有一些进程间通信有关的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个进程如何把&lt;strong&gt;信息传递&lt;/strong&gt;给另一个（共享存储、消息传递）&lt;/li&gt;
&lt;li&gt;确保两个或更多的进程在关键活动中&lt;strong&gt;不会出现交叉（互斥）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正确的顺序（同步）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个问题对线程比较容易，因为它们共享同一个地址空间。另外两个问题同样适用于线程。&lt;/p&gt;
&lt;h3 id=&#34;竞争条件&#34;&gt;竞争条件&lt;/h3&gt;
&lt;p&gt;竞争条件是指两个或多个进程读写某些&lt;strong&gt;共享数据&lt;/strong&gt;，最后的结果取决于进程运行的&lt;strong&gt;精确时序&lt;/strong&gt;。多核增长带来的并行使得使得竞争条件越来越普遍。&lt;/p&gt;
&lt;h3 id=&#34;临界区&#34;&gt;临界区&lt;/h3&gt;
&lt;p&gt;涉及共享内存、共享文件及共享任何资源的情况都会引发与前面（竞争条件）类似的错误，我们要通过某种途径来阻止多个进程同时读写共享的数据，即我们需要的是&lt;strong&gt;互斥&lt;/strong&gt;。用一种手段确保当一个进程在使用共享变量或文件时，其他进程不能做同样的操作。&lt;/p&gt;
&lt;p&gt;我们把对共享内存进行访问的程序片段称为&lt;strong&gt;临界区&lt;/strong&gt;，通过适当安排，使两个进程不可能同时处于临界区中，就能避免竞争条件。&lt;/p&gt;
&lt;p&gt;这样的要求避免了竞争条件，但它不能保证使用共享数据的并发进程能够&lt;strong&gt;正确和高效地进行协作&lt;/strong&gt;。一个好的解决方案需要满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何两个进程不能同时处于临界区&lt;/li&gt;
&lt;li&gt;不应对CPU的速度和数量作任何假设&lt;/li&gt;
&lt;li&gt;临界区外运行的进程不得阻碍其他进程&lt;/li&gt;
&lt;li&gt;不得使进程无限期等待进入临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;忙等待的互斥&#34;&gt;忙等待的互斥&lt;/h3&gt;
&lt;p&gt;这里将会讨论&lt;strong&gt;几种互斥方案&lt;/strong&gt;。当一个进程在临界区中更新共享内存时，其他进程将不会进入其临界区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;屏蔽中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最简单的方法是每个进程刚刚进入临界区后立即屏蔽所有中断，并在离开前打开中断。&lt;/p&gt;
&lt;p&gt;这个方案并不好，把屏蔽中断的权力&lt;strong&gt;交给用户&lt;/strong&gt;是不明智的。若一个进程屏蔽中断后不再打开，系统可能终止。&lt;/p&gt;
&lt;p&gt;另一方面，对内核来说，当其在更新变量或列表的几条指令期间将中断屏蔽很方便。&lt;/p&gt;
&lt;p&gt;在多核系统中，屏蔽一个CPU中断不会阻止其他CPU干预第一个CPU所做的操作，因此我们需要更加复杂的计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即408中学习的单标志法。是一种软件实现方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;严格轮换法（自旋锁）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程连续测试一个变量直到出现某个值为止，称为&lt;strong&gt;忙等待&lt;/strong&gt;，这种方式&lt;strong&gt;浪费CPU时间&lt;/strong&gt;，通常应该避免。用于忙等待的锁，称为&lt;strong&gt;自旋锁&lt;/strong&gt;。该方案要求两个进程严格地轮流进入他们的临界区，任何一个进程都不可能在一轮中打印两个文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Peterson解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;防止两个进程进行无限等待，又设置了一个变量turn，每个变量在先设置自己的标志flag后再置turn标志。这时再同时检测另一个进程状态标志和允许进入标志，保证两个进程同时要求进入临界时只允许一个进程进入。该算法解决了饥饿现象。该算法是1和3的结合，利用flag实现临界资源的互斥访问，利用turn解决饥饿现象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TSL指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该指令需要硬件支持。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;TSL RX, LOCK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;称为&lt;strong&gt;测试并加锁&lt;/strong&gt;，将一个&lt;strong&gt;内存字lock&lt;/strong&gt;读到寄存器RX中，然后再在内存地址上存一个&lt;strong&gt;非零值&lt;/strong&gt;。读字和写字操作保证是不可分割的，该指令结束之前其他处理器均不允许访问该内存字。执行TSL指令的CPU将&lt;strong&gt;锁住内存总线&lt;/strong&gt;，以禁止其他CPU再本指令结束之前访问内存。&lt;/p&gt;
&lt;p&gt;为了使用TSL指令，要使用已给共享变量lock协调对共享内存的访问。当lock为0时任何进程都可以使用TSL指令将其设置为1，并读写共享内存。操作结束时，进程用一条普通move指令将lock的值重新设置为0.&lt;/p&gt;
&lt;h3 id=&#34;睡眠与唤醒&#34;&gt;睡眠与唤醒&lt;/h3&gt;
&lt;p&gt;Peterson和TSL或XCHG方法都正确，但有忙等待的缺点。&lt;/p&gt;
&lt;p&gt;现在来考虑几条&lt;strong&gt;进程间通信原语&lt;/strong&gt;，他们在无法进入临界区时将&lt;strong&gt;阻塞&lt;/strong&gt;，而不是忙等待。最简单的时sleep和wakeup。&lt;/p&gt;
&lt;h3 id=&#34;信号量&#34;&gt;信号量&lt;/h3&gt;
&lt;p&gt;semaphore。P操作和V操作。对于信号量的操作都是单一的、不可分割的&lt;strong&gt;原子操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用信号量问题解决生产者、消费者问题。&lt;/p&gt;
&lt;p&gt;信号量可以用来实现同步、互斥操作。详见408笔记内容。&lt;/p&gt;
&lt;h3 id=&#34;互斥量mutex锁&#34;&gt;互斥量(mutex锁)&lt;/h3&gt;
&lt;p&gt;mutex。信号量的简化版本。互斥量是一个可以处于两态之一的变量：解锁和加锁。只需要一个二进制位表示。实际上常用一个整型量，0表示解锁，其他所有制表示枷锁。&lt;/p&gt;
&lt;p&gt;互斥量使用两个过程。当一个进程或线程需要访问临界区时，调用mutex_lock，如果该互斥量当前是解锁的（临界区可用），则此调用成功，调用线程可以自由进入该区域。另外如果该互斥量已经加锁，则调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件变量与互斥量&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;管程&#34;&gt;管程&lt;/h3&gt;
&lt;p&gt;一种高级同步原语。一个管程是一个由过程、变量即数据结构组成的一个集合，共同组成一个特殊的模块或软件包。进程可以任何需要的时候调用管程中的过程，但它们不能再管程之外声明的过程中直接访问管程内的数据结构。&lt;/p&gt;
&lt;p&gt;任一时刻管程中只能有一个活跃的进程，这一特性使得管程能有效地完成互斥。&lt;/p&gt;
&lt;h3 id=&#34;消息传递&#34;&gt;消息传递&lt;/h3&gt;
&lt;p&gt;这种方法使用两条原语send和receive，它们是系统调用。&lt;/p&gt;
&lt;h2 id=&#34;调度&#34;&gt;调度&lt;/h2&gt;
&lt;p&gt;其他进程调度算法详见408相关内容。&lt;/p&gt;
&lt;h3 id=&#34;线程调度&#34;&gt;线程调度&lt;/h3&gt;
&lt;p&gt;线程调度中考虑支持的是用户级线程还是内核级线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户级线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户级线程的调度&lt;strong&gt;由运行时系统决定&lt;/strong&gt;，一般使用轮转调度和优先级调度。局限是缺乏一个时钟中断运行过长的线程，但由于线程间的合作关系，也不算是问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内核级线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户级线程的切换只需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映射，使高速缓存失效，导致了若干数量级的延迟。&lt;/p&gt;
&lt;p&gt;另一方面使用内核级线程时，一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。&lt;/p&gt;
&lt;p&gt;从进程A的一个线程切换到进程B的一个线程的代价高于运行进程A的第二个线程（必须修改内存映像，修改高速缓存的内容），内核对此是了解的，可以运用这些信息做出决定。&lt;/p&gt;
&lt;p&gt;另一个因素是用户级线程可以使用&lt;strong&gt;专为应用程序定制的线程调度程序&lt;/strong&gt;，内核线程不了解每个线程的作用，一般而言，应用定制的线程调度程序能够比内核更好地满足应用的需要。&lt;/p&gt;
&lt;h2 id=&#34;经典ipc问题&#34;&gt;经典IPC问题&lt;/h2&gt;
&lt;h3 id=&#34;哲学家就餐问题&#34;&gt;哲学家就餐问题&lt;/h3&gt;
&lt;h3 id=&#34;读者-写者问题&#34;&gt;读者-写者问题&lt;/h3&gt;
- https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——基础排序算法的实现</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Mon, 06 Dec 2021 20:37:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/ -&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;selectSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; min &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; N; j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;)
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (a[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; a[min]) min &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; j;
        swap(nums[i], nums[min]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;插入排序&#34;&gt;插入排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;insertSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i; j &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]; j&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;)
            swap(nums[j], nums[j&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;时间复杂度为$O(n^2)$，算法稳定。&lt;/p&gt;
&lt;h2 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;shellSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; h &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (h &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;) {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i; j &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; h &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; num[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;h]; j &lt;span style=&#34;color:#333&#34;&gt;-=&lt;/span&gt; h)
                swap(nums[j], nums[j&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;h]);
        }
        h &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;n在某个特定范围内时，希尔排序的时间复杂度约为$O(n^{1.3})$，最坏时间复杂度为$O(n^2)$。算法不稳定。&lt;/p&gt;
&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;从后向前两两比较相邻元素的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;BubbleSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; flag &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//flag用来判断一趟遍历是否发生交换，如果没有发生交换则说明已经有序
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; i; j &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]) {
                swap(nums[j], nums[j&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
                flag &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;true&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (flag &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;false&lt;/span&gt;)
                &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;时间复杂度：$O(n^2)$，算法稳定。&lt;/p&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;递归调用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;quickSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; high) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; pivot &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; partition(nums, low, high);
        quickSort(nums, low, pivot &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);
        quickSort(nums, pivot &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, high);
    }
}
&lt;span style=&#34;color:#888&#34;&gt;//每趟划分都把当前数组第一个元素作为轴枢，把所有小于轴枢的元素移动到左侧，大于轴枢的元素移动到右侧
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;partition&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; pivot &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums[low];	&lt;span style=&#34;color:#888&#34;&gt;//将第一个元素当作轴枢，low和high作为两个指针
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; high) {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; high &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[high] &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; pivot)	&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;high;
        nums[low] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums[high];	&lt;span style=&#34;color:#888&#34;&gt;//将比轴枢小的元素移动到左端
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; high &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[low] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt; pivot)	&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;low;
        nums[high] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums[low];	&lt;span style=&#34;color:#888&#34;&gt;//将比轴枢大的元素移动到右侧
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#888&#34;&gt;//结束时low==high
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    nums[low] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; pivot;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; low;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;时间复杂度为$O(n\log_2 n)$。算法不稳定。&lt;/p&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;p&gt;2路归并排序。分治的思想。&lt;/p&gt;
&lt;p&gt;归并排序必须要占用额外的存储空间，空间复杂度为O(N)&lt;/p&gt;
&lt;h3 id=&#34;自顶向下归并&#34;&gt;自顶向下归并&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; aux;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mergeSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt;(low &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; high) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; (low &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; high) &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
        MergeSort(nums, low, mid);
        MergeSort(nums, mid&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, high);
        Merge(A, low, mid, high);
    }
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;Merge&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; mid, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {
    &lt;span style=&#34;color:#888&#34;&gt;//nums中的两段nums[low, mid]和nums[mid + 1, high]各自有序，将这两个数组合并
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; low; m &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt; high; m&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
        aux.push_back(nums[m]);
    }
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; low &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; low; k &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt; high; k&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; mid &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; low)					nums[k] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; aux[j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;];
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (j &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; high &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; low)			nums[k] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; aux[i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;];
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (aux[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;=&lt;/span&gt; aux[i])			nums[k] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; aux[j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;];
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;								nums[k] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; aux[i&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;自底向上归并&#34;&gt;自底向上归并&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; aux;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mergeSort&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; high) {
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; sz &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; N; sz &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; sz &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; sz) {	&lt;span style=&#34;color:#888&#34;&gt;//sz为子数组的大小
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; lo &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; lo &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; sz; lo &lt;span style=&#34;color:#333&#34;&gt;+=&lt;/span&gt; sz &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; sz) {	&lt;span style=&#34;color:#888&#34;&gt;//lo为子数组的索引
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;            Merge(nums, lo, lo&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;sz&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, MIN(lo&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;sz&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;sz&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, N&lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;自底向上归并会多次遍历整个数组，根据子数组的大小进行两两归并。子数组的大小sz的初始值为1，每次加倍。最后一个子数组的大小只有在数组大小是sz的偶数倍时才会等于sz（否则其会比sz小）。&lt;/p&gt;
&lt;p&gt;归并排序是一种渐进最优的基于比较的排序算法。在最坏的情况下的比较次数为$n\log n$.&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——堆排序和优先队列</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
        <pubDate>Mon, 06 Dec 2021 14:26:53 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/ -&lt;h2 id=&#34;优先队列&#34;&gt;优先队列&lt;/h2&gt;
&lt;p&gt;优先队列如同其字面意思，是一种支持&lt;strong&gt;删除最大元素&lt;/strong&gt;和&lt;strong&gt;插入元素&lt;/strong&gt;的一种数据结构。&lt;/p&gt;
&lt;p&gt;二叉堆是一棵&lt;strong&gt;有序的完全二叉树&lt;/strong&gt;，可以很好地实现优先队列。使用二叉堆实现优先队列可以保证插入元素和删除最大元素的操作在$\log N$的时间内完成。&lt;/p&gt;
&lt;p&gt;我们通常使用数组来实现二叉堆。&lt;/p&gt;
&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;
&lt;h3 id=&#34;堆的有序化&#34;&gt;堆的有序化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;sink——自上而下的有序化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sink&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; heapSize) {	&lt;span style=&#34;color:#888&#34;&gt;//i为数组下标
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; heapSize) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;i;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (j &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])		j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;(nums[i] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j]))	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        swap(nums[i], nums[j]);
        i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; j;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;swim——自下而上的有序化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;swim&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {&lt;span style=&#34;color:#888&#34;&gt;//x为插入末尾的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    nums.push_back(x);
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (k &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[k]) {
        swap(nums[k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], nums[k]);
        k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;构建大根堆&#34;&gt;构建大根堆&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;buildMaxHeap&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {	&lt;span style=&#34;color:#888&#34;&gt;//使用sink从上向下构建大根堆
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;) {
        sink(nums, i, heapSize);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;删除堆顶元素&#34;&gt;删除堆顶元素&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;deleteK&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {	&lt;span style=&#34;color:#888&#34;&gt;//输出大根堆第k大的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    
    &lt;span style=&#34;color:#888&#34;&gt;//依次交换第0个和第heapSize - 1个元素,...,第k-1个和第heapSize - k + 1个元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#888&#34;&gt;//每次交换后使用sink重新构建使堆有序
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;) {
        swap(nums[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], nums[i]);
        heapSize&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;;
        sink(nums, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, heapSize);
    }
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; nums[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;向堆中插入元素&#34;&gt;向堆中插入元素&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;swim&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {	&lt;span style=&#34;color:#888&#34;&gt;//向大根堆堆中插入元素x，然后从下向上有序化
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    nums.push_back(x);
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (k &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; nums[k])
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        swap(nums[j], nums[k]);
        k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH18 用于大型工程的工具——命名空间</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
        <pubDate>Fri, 03 Dec 2021 11:21:29 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/ -&lt;h2 id=&#34;命名空间&#34;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;大型程序往往使用多个独立开发的库，这些库又会定义大量全局名字，如类、函数、模板。当应用程序使用到多个供应商提供的库时，不可避免会发生某些名字的冲突。多个库名字放置在全局命名空间中会引发&lt;strong&gt;命名空间污染&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;命名空间提供了防止污染的可控机制。命名空间分隔了全局命名空间，每个命名空间是一个&lt;strong&gt;作用域&lt;/strong&gt;。通过某个命名空间定义库名，可以避免全局名字固有的限制。&lt;/p&gt;
&lt;h3 id=&#34;定义命名空间&#34;&gt;定义命名空间&lt;/h3&gt;
&lt;p&gt;命名空间既可以定义在&lt;strong&gt;全局作用域&lt;/strong&gt;中，也可以定义在&lt;strong&gt;其他命名空间&lt;/strong&gt;中，但&lt;strong&gt;不能&lt;/strong&gt;定义在&lt;strong&gt;函数或类的内部&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个命名空间都是一个作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;位于该命名空间之外的代码必须明确指出所用的名字属于哪个命名空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名空间可以是不连续的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; nsp {
&lt;span style=&#34;color:#888&#34;&gt;//相关声明
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能定义了一个新命名空间，可以能为已存在的命名空间添加一些新成员。&lt;/p&gt;
&lt;p&gt;因此我们可以将几个独立的接口和实现文件组成一个命名空间。其组织方式类似于我们管理自定义类及函数的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名空间中是定义类、声明作为类接口的函数及对象的部分，放置于&lt;strong&gt;头文件&lt;/strong&gt;中，然后将这些头文件包含在使用了这些成员的文件中&lt;/li&gt;
&lt;li&gt;命名空间成员的定义部分则置于另外的&lt;strong&gt;源文件&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序中某些实体只能定义一次，如内联函数、变量等。命名空间中的定义也要满足这一要求。即接口与实现分离的机制。&lt;/p&gt;
&lt;p&gt;另外，我们&lt;strong&gt;不把#include放在命名空间内部&lt;/strong&gt;。这样做的隐含意思是把头文件中所有名字定义成该命名空间的成员，这很有可能导致错误，例如可能将std命名空间嵌套在自己的命名空间内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义命名空间成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命名空间中的名字可以直接使用名字，此时无需前缀。&lt;/p&gt;
&lt;p&gt;另外也可以将命名空间的外部定义该命名空间的成员，需要有完整的前缀。命名空间对于名字的声明必须在作用域内，同时改名字的定义需要明确指出其所属的命名空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; cpp_primer {
	std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istream&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istream&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt; in, Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt; s) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;模板特例化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板特例化必须定义在原始模板所属的命名空间中。只要我们在命名空间中声明了特例化，就能在命名空间外部定义它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;hash&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;;
}
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;std&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;hash&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
{
	....
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;全局命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局作用域中定义的名字即定义在全局命名空间中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。&lt;/p&gt;
&lt;p&gt;作用域运算符同样可以用于全局作用域成员：(因为其是隐式地，所以没有名字)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;nember_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;内联命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++ 11引入的新的嵌套命名空间，称为内联命名空间。内联命名空间中的名字可以被外层命名空间直接使用。即无需在内联命名空间的名字前添加表示该命名空间的前缀。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; FifthEd {

}
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; FifthEd {
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键字inline必须出现在命名空间第一次定义的地方，后续再打开时可以不写inline。&lt;/p&gt;
&lt;p&gt;当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常用到内联命名空间。我们可以将当前版本的所有代码都放在一个内联命名空间中，把之前版本的代码都放在一个非内联命名空间中。这样在使用时，使用当前版本的成员的代码无需加前缀，如需使用之前版本的代码，则需加上完整的外层命名空间名字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未命名的命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;未命名的命名空间拥有静态生命周期，在第一次使用前创建，直到程序结束才销毁。&lt;/p&gt;
&lt;p&gt;一个未命名的命名空间可以在某个给定文件内不连续，但不能跨越多个文件。每个文件定义自己的未命名的命名空间，多个文件的未命名的命名空间之间没有关系。&lt;/p&gt;
&lt;p&gt;如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中成员的名字一定要与全局作用域中的名字有所区别。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;未命名的命名空间取代文件中的静态声明&lt;/p&gt;
&lt;p&gt;标准C++引入命名空间前，程序要将名字声明称static使得其堆整个文件有效，这是从C语言继承而来的。而如今在C++中直接使用未命名的命名空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;使用命名空间成员&#34;&gt;使用命名空间成员&lt;/h3&gt;
&lt;p&gt;我们可以通过使用using声明以及命名空间别名或using指示等来更加便捷地使用命名空间的成员。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们应当避免使用using指示&lt;/p&gt;
&lt;p&gt;using指示一次性注入某个命名空间的所有名字，这种用法充满了风险，将命名空间中的所有成员的名字变得可见。使用多个库时，可能导致全局命名空间污染。&lt;/p&gt;
&lt;/blockquote&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH15 面向对象程序设计</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Fri, 03 Dec 2021 11:10:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/ -&lt;p&gt;面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。&lt;/p&gt;
&lt;p&gt;本章介绍剩余的&lt;strong&gt;继承和动态绑定&lt;/strong&gt;。通过这两种特性我们可以更容易地定义与其他类&lt;strong&gt;相似但不完全相同的新类&lt;/strong&gt;；另外在使用这些彼此相似的类编写函数时。我们可以在一定程度上忽略掉它们的区别。&lt;/p&gt;
&lt;h2 id=&#34;oop概述&#34;&gt;OOP：概述&lt;/h2&gt;
&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;
&lt;p&gt;通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个&lt;strong&gt;基类&lt;/strong&gt;，其他类别从基类继承而来，这些继承而来的类称为&lt;strong&gt;派生类&lt;/strong&gt;。基类负责定义所有类&lt;strong&gt;共同拥有的成员&lt;/strong&gt;，而每个派生类定义&lt;strong&gt;各自特有的成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于某些函数，基类希望它的派生类各自定义适合自己的版本，此时基类就将这些函数声明成&lt;strong&gt;虚函数&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Quote&lt;/span&gt; {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string isbn() &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;net_price&lt;/span&gt;(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;size_t n)	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类必须通过使用&lt;strong&gt;类派生列表&lt;/strong&gt;明确指出它是从哪个基类继承而来的。&lt;/p&gt;
&lt;p&gt;类派生列表的形式：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类列表前面可以有访问说明符：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Bulk_quote&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; Quote {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; net_price(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;size_t n)	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完全可以把Bulk_quote的对象当作Quote的对象来使用。&lt;/p&gt;
&lt;p&gt;派生类必须在其内部对所有重新定义的虚函数进行&lt;strong&gt;声明&lt;/strong&gt;。C++11 允许派生类&lt;strong&gt;显式地注明&lt;/strong&gt;它将使用哪个成员函数改写基类的虚函数，方法是在该函数的形参列表之后增加一个&lt;strong&gt;override关键字&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;动态绑定&#34;&gt;动态绑定&lt;/h3&gt;
&lt;p&gt;又称为运行时绑定，根据运行时传入的实参选择函数的版本。通过动态绑定，我们可以用同一段代码分别处理Quote和Bulk_quote的对象。&lt;/p&gt;
&lt;h2 id=&#34;定义基类和派生类&#34;&gt;定义基类和派生类&lt;/h2&gt;
&lt;h3 id=&#34;定义基类&#34;&gt;定义基类&lt;/h3&gt;
&lt;p&gt;继承关系中的根节点的类通常会定义一个&lt;strong&gt;虚析构函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于一些操作，派生类需要提供自己的新定义以覆盖（override）从基类继承而来的就定义。需要&lt;strong&gt;覆盖&lt;/strong&gt;的函数，&lt;strong&gt;基类&lt;/strong&gt;通常将其定义为&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。&lt;/p&gt;
&lt;p&gt;任何构造函数之外的非静态函数都可以是虚函数。virtual只能出现在&lt;strong&gt;类内部的声明语句&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问控制与继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下派生类可以继承定义在基类中的成员，但派生类的成员函数没有权限访问从基类继承而来的成员，派生类只能访问公有成员，不能访问私有成员。而有一种成员，基类希望它的&lt;strong&gt;派生类有权限访问&lt;/strong&gt;该成员，同时&lt;strong&gt;禁止其他用户访问&lt;/strong&gt;，我们使用&lt;strong&gt;受保护的（protected）访问运算符&lt;/strong&gt;说明该成员。&lt;/p&gt;
&lt;h3 id=&#34;定义派生类&#34;&gt;定义派生类&lt;/h3&gt;
&lt;p&gt;派生类必须通过使用&lt;strong&gt;类派生列表&lt;/strong&gt;明确指出从哪个（哪些）基类继承而来的。&lt;/p&gt;
&lt;p&gt;类派生列表的形式：冒号后紧跟以逗号分隔的基类列表，每个基类前面可以有三个&lt;strong&gt;访问说明符&lt;/strong&gt;中的一个：public、protected或private。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Bulk_quote&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; Quote {	&lt;span style=&#34;color:#888&#34;&gt;//Bulk_quote继承自Quote
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。&lt;/p&gt;
&lt;p&gt;如果一个派生是&lt;strong&gt;公有&lt;/strong&gt;的，则&lt;strong&gt;基类的公有成员&lt;/strong&gt;也是派生类接口的组成部分；此外还能将公有派生类型的对象&lt;strong&gt;绑定到基类的引用或指针&lt;/strong&gt;上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Quote item;		&lt;span style=&#34;color:#888&#34;&gt;//基类对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Bulk_quote bulk;	&lt;span style=&#34;color:#888&#34;&gt;//派生类对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Quote &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;item;	&lt;span style=&#34;color:#888&#34;&gt;//p指向Quote对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;bulk;		&lt;span style=&#34;color:#888&#34;&gt;//p指向bulk的Quote部分
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Quote &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; bulk;	&lt;span style=&#34;color:#888&#34;&gt;//r绑定到bulk的Quote部分
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这样做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派生类不能直接初始化从基类继承而来的成员。派生类必须使用基类的构造函数来初始化它的基类部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个类控制它自己的成员初始化过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;派生类构造函数同样是通过构造函数的初始化列表来将实参传递给基类构造函数的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类使用基类成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派生类可以使用基类的公有成员和受保护的成员。&lt;/p&gt;
&lt;p&gt;派生类的作用域嵌套在基类的作用域之内。对于派生类的一个成员来说，它使用派生类成员的方式和使用基类成员的方式没有差别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承与静态成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。对于每个静态成员来说，只存在唯一的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类的声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明中包含类名但不包含其派生列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防止继承发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候我们不希望一个类被其它类继承，C++11 提供了防止继承的方法，在类名后赶一个关键字final：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;NoDerived&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; {&lt;span style=&#34;color:#888&#34;&gt;/* */&lt;/span&gt;};	&lt;span style=&#34;color:#888&#34;&gt;//NoDerived不能作为基类
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Bad&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; NoDerived {}	&lt;span style=&#34;color:#888&#34;&gt;//错误
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;类型转换与继承&#34;&gt;类型转换与继承&lt;/h3&gt;
&lt;p&gt;通常我们把引用或指针绑定到一个对象上，则引用或指针的类型应该与对象的类型一致。但在继承关系中是一个例外，我们可以将&lt;strong&gt;基类的指针或引用&lt;/strong&gt;绑定到&lt;strong&gt;派生类的对象&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;这隐含了：使用基类的指针或引用时，我们不知道其所绑定对象的真实类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态类型和动态类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不存在&lt;/strong&gt;从基类向派生类的&lt;strong&gt;隐式类型转换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同样的，在对象之间不存在类型转换。&lt;/p&gt;
&lt;p&gt;派生类向基类的类型转换也可能由于访问受限而变得不可行。&lt;/p&gt;
&lt;h2 id=&#34;虚函数&#34;&gt;虚函数&lt;/h2&gt;
&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;对虚函数的调用可能在&lt;strong&gt;运行时&lt;/strong&gt;才被解析。&lt;/p&gt;
&lt;p&gt;动态绑定只有当我们&lt;strong&gt;通过指针或引用调用虚函数&lt;/strong&gt;时才会发生。当我们通过一个具有普通类型（非引用指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。&lt;/p&gt;
&lt;p&gt;一旦某个函数被声明成虚函数。则在所有派生类中它都是虚函数。所以派生类中的虚函数可以不加virtual关键字。&lt;/p&gt;
&lt;p&gt;派生类中的虚函数的返回类型也必须与基类函数匹配，但存在一个例外，当类的虚函数返回类型是&lt;strong&gt;类本身的指针或引用&lt;/strong&gt;时，上述规则无效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;final和override说明符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派生类如果定义了一个函数与基类中的虚函数的&lt;strong&gt;名字相同但形参列表不同&lt;/strong&gt;，这仍然是正确的，编译器将认为新定义的这个函数与基类中原有的函数是&lt;strong&gt;相互独立&lt;/strong&gt;的，此时派生类的函数没有覆盖掉基类中的版本。&lt;/p&gt;
&lt;p&gt;C++11 中可以使用override关键字来说明派生类中的虚函数，降低错误发生的可能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;B&lt;/span&gt; {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f2&lt;/span&gt;();
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f3&lt;/span&gt;();
};
sturct &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;D1&lt;/span&gt; : B {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f2&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//错误，B中没有f(int)函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f3&lt;/span&gt;() &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//错误，f3不是虚函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还能把某个函数指定为final，这是之后任何尝试覆盖该函数的操作都会引发错误。&lt;/p&gt;
&lt;p&gt;和其他函数一样，虚函数也有默认实参。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回避虚函数机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某些情况下我们希望对虚函数的调用不要进行动态绑定而是强迫其执行虚函数的某个特定版本。使用作用域运算符&lt;code&gt;-&amp;gt;&lt;/code&gt;可以实现这一目的。&lt;/p&gt;
&lt;h3 id=&#34;不能声明为虚函数的函数&#34;&gt;不能声明为虚函数的函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;内联成员函数。inline函数在编译时杯展开，而虚函数在运行时才能动态地绑定函数&lt;/li&gt;
&lt;li&gt;静态成员函数。静态成员只属于该类，没有绑定的必要，不能被继承。&lt;/li&gt;
&lt;li&gt;友元函数。C++不支持友元函数的继承。另外友元函数不属于类的成员函数，不能被继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;抽象基类&#34;&gt;抽象基类&lt;/h2&gt;
&lt;p&gt;当我们希望继承类不使用某一个虚函数时，可以将其定义为&lt;strong&gt;纯虚函数&lt;/strong&gt;，这样可以清晰明了地告诉用户当前这个函数没有实际意义。方式是：&lt;/p&gt;
&lt;p&gt;通过在函数体的位置（在声明语句的分号之前）书写&lt;code&gt;=0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;含有纯虚函数的类是抽象基类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象基类负责定义接口，而后续其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。但我们可以定义抽象基类的派生类对象，前提是这些类覆盖了纯虚函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类构造函数只初始化它的直接基类&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;访问控制与继承&#34;&gt;访问控制与继承&lt;/h2&gt;
&lt;p&gt;每个类还分别控制着其成员对于派生类来说是否&lt;strong&gt;可访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受保护的成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;protected说明符可看作是public和private中和后的产物：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和私有成员类似，受保护的成员对于类的用户来说是不可访问的&lt;/li&gt;
&lt;li&gt;和公有成员类似，受保护的成员对于派生类的成员和友元来说是可以访问的&lt;/li&gt;
&lt;li&gt;派生类的成员或友元只能通过&lt;strong&gt;派生类对象&lt;/strong&gt;来访问基类的受保护成员（private成员）。&lt;strong&gt;派生类&lt;/strong&gt;对于一个基类对象中的受保护成员没有任何访问特权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友元与继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;友元关系&lt;strong&gt;既不能传递，也不能继承&lt;/strong&gt;。基类的成员在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。&lt;/p&gt;
&lt;h2 id=&#34;继承中的类作用域&#34;&gt;继承中的类作用域&lt;/h2&gt;
&lt;p&gt;当存在继承关系时，派生类的作用域&lt;strong&gt;嵌套在其基类的作用域之内&lt;/strong&gt;。如果一个名字在派生类的作用域内无法正确解析，那么编译器将继续在&lt;strong&gt;外层的基类作用域中&lt;/strong&gt;寻找该名字的定义。&lt;/p&gt;
&lt;p&gt;正因为有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员。&lt;/p&gt;
&lt;p&gt;派生类的成员将&lt;strong&gt;隐藏同名的基类成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外可以通过作用域运算符覆盖原有的查找规则。&lt;/p&gt;
&lt;h2 id=&#34;构造函数与拷贝控制&#34;&gt;构造函数与拷贝控制&lt;/h2&gt;
&lt;p&gt;如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器将为它合成一个版本。&lt;/p&gt;
&lt;h3 id=&#34;虚析构函数&#34;&gt;虚析构函数&lt;/h3&gt;
&lt;p&gt;基类通常应该定义一个虚析构函数，这样我们就能&lt;strong&gt;动态分配&lt;/strong&gt;继承体系中的对象了。&lt;/p&gt;
&lt;p&gt;当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则可能出现指针的静态类型与被删除对象的动态类型不符的情况。所以编译器必须清楚它应该执行的是哪个类的析构函数。所以与其他函数一样，通过在基类中将析构函数定义为虚函数确保执行正确的析构函数版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Quote&lt;/span&gt; {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;~&lt;/span&gt;Quote() &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;default&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//动态绑定析构函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虚析构函数将阻止合成移动操作。&lt;/p&gt;
&lt;h3 id=&#34;合成拷贝控制与继承&#34;&gt;合成拷贝控制与继承&lt;/h3&gt;
&lt;h3 id=&#34;派生类的拷贝控制成员&#34;&gt;派生类的拷贝控制成员&lt;/h3&gt;
&lt;h3 id=&#34;继承的构造函数&#34;&gt;继承的构造函数&lt;/h3&gt;
&lt;h2 id=&#34;容器与继承&#34;&gt;容器与继承&lt;/h2&gt;
&lt;p&gt;当我们使用容器存放&lt;strong&gt;继承体系中的对象&lt;/strong&gt;时，通常必须采用&lt;strong&gt;间接存储&lt;/strong&gt;的方式，因为不允许在容器中保存不同类型的元素。&lt;/p&gt;
&lt;p&gt;当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型无法兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器中放置（智能）指针而非对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在容器中存放具有继承关系的对象时，我们实际上存放的是基类的指针（智能指针更好）。这些指针所指的对象的动态类型可能是&lt;strong&gt;基类类型也可能是派生类类型&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Quote&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; basket;
basket.push_back(make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Bulk_quote&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;0-121&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类的智能指针和基类的智能指针可以相互转换。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp程序的内存分配</title>
        <link>https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
        <pubDate>Thu, 02 Dec 2021 21:54:01 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/ -&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/202112061915469.jpg&#34; alt=&#34;cpp程序内存模型图&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;栈stack--堆heap&#34;&gt;栈stack &amp;amp; 堆heap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;栈区stack：由编译器自动分配和释放，用来存放函数的参数值、局部变量的值。按内存地址由高往低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。&lt;/li&gt;
&lt;li&gt;堆区heap：一般由程序员分配和释放，用来创建动态内存。按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;data--bss--text&#34;&gt;.data &amp;amp; .bss &amp;amp; .text&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局区.data(gvar)：程序中已经初始化的非零全局变量、静态变量，程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;.bss：存放程序中未初始化的全局变量和静态变量，以及所有被初始化为0的全局或静态变量。目标文件中这个节不占据实际空间，仅仅是一个占位符。&lt;/li&gt;
&lt;li&gt;程序代码区.text：存放已编译程序的机器代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;text和data节都在可执行文件中，.bss不在可执行目标文件中，由系统自动生成。&lt;/p&gt;
&lt;p&gt;宏定义不占用内存和编译时间。&lt;/p&gt;
&lt;h2 id=&#34;new与malloc的区别&#34;&gt;new与malloc的区别&lt;/h2&gt;
&lt;p&gt;malloc是面向&lt;strong&gt;内存&lt;/strong&gt;的，想要多大内存就分配多大。而new是面向&lt;strong&gt;对象&lt;/strong&gt;的，根据执行的对象类型来申请空间，并能够内部调用构造函数生成对象。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>typedef和define宏详解</title>
        <link>https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Wed, 01 Dec 2021 19:43:11 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/ -&lt;p&gt;typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。&lt;/p&gt;
&lt;p&gt;当const和typedef一起出现时，typedef不会是简单的字符串替换就行。&lt;/p&gt;
&lt;p&gt;typedef常用来定义一个标识符及关键字的别名，它是语言&lt;strong&gt;编译过程&lt;/strong&gt;的一部分，但它并不实际分配内存空间&lt;/p&gt;
&lt;p&gt;#define为一宏定义语句，通常用它来定义常量(包括无参量与带参量)，以及用来实现那些“表面似和善、背后一长串”的宏，它本身并不在编译过程中进行，而是在这之前(&lt;strong&gt;预处理过程&lt;/strong&gt;)就已经完成了，但也因此难以发现潜在的错误及其它代码维护问题&lt;/p&gt;
&lt;h2 id=&#34;define用法详解&#34;&gt;#define用法详解&lt;/h2&gt;
&lt;h3 id=&#34;无参宏定义&#34;&gt;无参宏定义&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define 标识符 字符串
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预处理命令。&lt;/p&gt;
&lt;h3 id=&#34;有参宏定义&#34;&gt;有参宏定义&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define 宏名(形参表) 字符串
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;宏定义中称为形参，宏调用中称为实参。带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。&lt;/p&gt;
&lt;h3 id=&#34;宏定义中的特殊操作符&#34;&gt;宏定义中的特殊操作符&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）#&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希望在字符串中包含宏参数时使用，#作为一个预处理运算符，可以把语言符号转换为字符串，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define NUM(x) printf(&amp;#34;the number is #x.\n&amp;#34;, x)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;（2）##&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##可以把两个字符串转换成单个字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define XNAME(n) x##n
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;XNAME&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//相当于int x1 = 12;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;（3）可变宏 &amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若要使用可变参数宏，可以在宏定义中将省略号指定为&lt;strong&gt;最后一个形参&lt;/strong&gt;，并且替换标识符可以在定义中用于插入 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 额外的参数。 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 替换为与省略号匹配的所有参数，包括它们之间的逗号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;// variadic_macros.cpp
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define EMPTY
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#define CHECK1(x, ...) if (!(x)) { printf(__VA_ARGS__); }
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define CHECK2(x, ...) if ((x)) { printf(__VA_ARGS__); }
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define CHECK3(...) { printf(__VA_ARGS__); }
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define MACRO(s, ...) printf(s, __VA_ARGS__)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
    CHECK1(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs1(1)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
    CHECK1(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs1(2)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);   &lt;span style=&#34;color:#888&#34;&gt;// won&amp;#39;t print
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
    CHECK2(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs2(3)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);   &lt;span style=&#34;color:#888&#34;&gt;// won&amp;#39;t print
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    CHECK2(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs2(4)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#888&#34;&gt;// always invokes printf in the macro
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    CHECK3(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs3(5)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);

    MACRO(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;hello, world&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);

    MACRO(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;error&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, EMPTY); &lt;span style=&#34;color:#888&#34;&gt;// would cause error C2059, except VC++
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;                             &lt;span style=&#34;color:#888&#34;&gt;// suppresses the trailing comma
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;here are some varargs1(1)
here are some varargs2(4)
here are some varargs3(5)
hello, world
error
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;宏定义中的多行定义&#34;&gt;宏定义中的多行定义&lt;/h3&gt;
&lt;p&gt;在每一个换行的地方加上一个&lt;code&gt;/&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;简单函数指针&#34;&gt;简单函数指针&lt;/h2&gt;
&lt;h3 id=&#34;形式1返回类型函数名参数表&#34;&gt;形式1：返回类型(*函数名)(参数表)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pFun)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;); 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;glFun&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a){ &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;} 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{ 
    pFun &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; glFun; 
    (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pFun)(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一行定义了一个指针变量pFun，它是一种指向某种函数的指针，这种函数是一个int型，返回值是char型。&lt;/p&gt;
&lt;p&gt;第二行定义了一个函数glFun()。该函数正好是一个以int为参数返回char的函数。我们要从指针的层次上理解函数——函数的函数名实际上就是一个指针，函数名指向该函数的代码在内存中的首地址。&lt;/p&gt;
&lt;p&gt;main()函数中将函数glFun的地址赋值给变量pFun。main()函数的第二句中“*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。&lt;/p&gt;
&lt;h2 id=&#34;typedef函数指针&#34;&gt;typedef函数指针&lt;/h2&gt;
&lt;h3 id=&#34;形式2typedef--返回类型新类型参数表&#34;&gt;形式2：typedef  返回类型(*新类型)(参数表)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;char&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;PTRFUN)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;); 
PTRFUN pFun; 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;glFun&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a){ &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;} 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{ 
    pFun &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; glFun; 
    (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pFun)(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;); 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;typedef的功能是&lt;strong&gt;定义新的类型&lt;/strong&gt;。第一句就是定义了一种PTRFUN的类型，并定义这种类型为&lt;strong&gt;指向某种函数的指针&lt;/strong&gt;，这种函数以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了。&lt;/p&gt;
&lt;p&gt;第二行的代码便使用这个新类型定义了变量pFun，此时就可以像使用形式1一样使用这个变量了。&lt;/p&gt;
&lt;h2 id=&#34;举例说明&#34;&gt;举例说明&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt; 
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;FP_CALC)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);&lt;span style=&#34;color:#888&#34;&gt;//定义一个函数指针类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt; 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; b;
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sub&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; b;
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mul&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; b;
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;div&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; b &lt;span style=&#34;color:#333&#34;&gt;?&lt;/span&gt; a&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;b&lt;/span&gt; : &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
}

&lt;span style=&#34;color:#888&#34;&gt;//定义一个函数，参数为op，返回一个指针,该指针类型为拥有两个int参数、
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//返回类型为int的函数指针。它的作用是根据操作符返回相应函数的地址
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;FP_CALC &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;calc_func&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; op)
{	&lt;span style=&#34;color:#888&#34;&gt;//函数名即为对应函数指针
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;switch&lt;/span&gt;( op )
	{
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; add;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; sub;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; mul;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; div;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;;
	}
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;;
}
 
&lt;span style=&#34;color:#888&#34;&gt;//s_calc_func为函数，它的参数是 op，   
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//返回值为一个拥有两个int参数、返回类型为int的函数指针  
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;s_calc_func(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; op)) (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; , &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;)
{
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;calc_func&lt;/span&gt;(op);
}
 
&lt;span style=&#34;color:#888&#34;&gt;//最终用户直接调用的函数，该函数接收两个int整数，
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//和一个算术运算符，返回两数的运算结果
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;calc&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; op)
{
	FP_CALC fp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; calc_func(op);
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;s_fp)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; s_calc_func(op);&lt;span style=&#34;color:#888&#34;&gt;//用于测试
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt; 
	assert(fp &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; s_fp);&lt;span style=&#34;color:#888&#34;&gt;// 可以断言这两个是相等的
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt; 
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt;(fp)
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; fp(a,b);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
}
 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;, b &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;;
 
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;));
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;));   
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;));   
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>基础算法总结</title>
        <link>https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
        <pubDate>Tue, 30 Nov 2021 22:16:50 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ -&lt;p&gt;希望未来一段时间能够手动实现一下这些算法。&lt;/p&gt;
&lt;h2 id=&#34;线性表&#34;&gt;线性表&lt;/h2&gt;
&lt;h3 id=&#34;顺序表&#34;&gt;顺序表&lt;/h3&gt;
&lt;h3 id=&#34;链表&#34;&gt;链表&lt;/h3&gt;
&lt;h2 id=&#34;栈和队列&#34;&gt;栈和队列&lt;/h2&gt;
&lt;p&gt;栈的顺序、链式存储&lt;/p&gt;
&lt;p&gt;队列的顺序、链式存储&lt;/p&gt;
&lt;p&gt;双端队列&lt;/p&gt;
&lt;p&gt;优先队列（堆排序）&lt;/p&gt;
&lt;h2 id=&#34;字符串&#34;&gt;字符串&lt;/h2&gt;
&lt;p&gt;KMP模式匹配&lt;/p&gt;
&lt;h2 id=&#34;树与二叉树&#34;&gt;树与二叉树&lt;/h2&gt;
&lt;h3 id=&#34;二叉树的遍历&#34;&gt;二叉树的遍历&lt;/h3&gt;
&lt;p&gt;前序、中序、后序&lt;/p&gt;
&lt;h3 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h3&gt;
&lt;h3 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h3&gt;
&lt;h3 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h3&gt;
&lt;h3 id=&#34;2-3树和红黑树&#34;&gt;2-3树和红黑树&lt;/h3&gt;
&lt;h2 id=&#34;图&#34;&gt;图&lt;/h2&gt;
&lt;h3 id=&#34;图的遍历&#34;&gt;图的遍历&lt;/h3&gt;
&lt;p&gt;广度优先搜索和深度优先搜索&lt;/p&gt;
&lt;h3 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h3&gt;
&lt;p&gt;Prim、Kruskal&lt;/p&gt;
&lt;h3 id=&#34;最短路径&#34;&gt;最短路径&lt;/h3&gt;
&lt;p&gt;Dijkstra、Floyd&lt;/p&gt;
&lt;h3 id=&#34;拓扑排序&#34;&gt;拓扑排序&lt;/h3&gt;
&lt;p&gt;活动的先后顺序&lt;/p&gt;
&lt;h3 id=&#34;关键路径&#34;&gt;关键路径&lt;/h3&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找&lt;/h2&gt;
&lt;h3 id=&#34;顺序查找&#34;&gt;顺序查找&lt;/h3&gt;
&lt;h3 id=&#34;折半查找&#34;&gt;折半查找&lt;/h3&gt;
&lt;h3 id=&#34;b树&#34;&gt;B树&lt;/h3&gt;
&lt;h3 id=&#34;散列表&#34;&gt;散列表&lt;/h3&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;h3 id=&#34;插入排序&#34;&gt;插入排序&lt;/h3&gt;
&lt;h3 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h3&gt;
&lt;h3 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h3&gt;
&lt;h3 id=&#34;快速排序&#34;&gt;快速排序&lt;/h3&gt;
&lt;h3 id=&#34;选择排序&#34;&gt;选择排序&lt;/h3&gt;
&lt;h3 id=&#34;堆排序优先队列&#34;&gt;堆排序（优先队列）&lt;/h3&gt;
&lt;p&gt;删除最大元素、插入元素&lt;/p&gt;
&lt;p&gt;构造大根堆、小根堆&lt;/p&gt;
&lt;h3 id=&#34;归并排序&#34;&gt;归并排序&lt;/h3&gt;
&lt;h3 id=&#34;基数排序&#34;&gt;基数排序&lt;/h3&gt;
- https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 