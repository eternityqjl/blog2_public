<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jialong&#39;s Blog</title>
    <link>https://eternityqjl.top/</link>
    <description>Recent content on Jialong&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019-2021 By Jialong</copyright>
    <lastBuildDate>Mon, 06 Dec 2021 14:26:53 +0800</lastBuildDate>
    
        <atom:link href="https://eternityqjl.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>算法——堆排序和优先队列</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
        <pubDate>Mon, 06 Dec 2021 14:26:53 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/ -&lt;h2 id=&#34;优先队列&#34;&gt;优先队列&lt;/h2&gt;
&lt;p&gt;优先队列如同其字面意思，是一种支持&lt;strong&gt;删除最大元素&lt;/strong&gt;和&lt;strong&gt;插入元素&lt;/strong&gt;的一种数据结构。&lt;/p&gt;
&lt;p&gt;二叉堆是一棵&lt;strong&gt;有序的完全二叉树&lt;/strong&gt;，可以很好地实现优先队列。使用二叉堆实现优先队列可以保证插入元素和删除最大元素的操作在$\log N$的时间内完成。&lt;/p&gt;
&lt;p&gt;我们通常使用数组来实现二叉堆。&lt;/p&gt;
&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;
&lt;h3 id=&#34;堆的有序化&#34;&gt;堆的有序化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;sink——自上而下的有序化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sink&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; heapSize) {	&lt;span style=&#34;color:#888&#34;&gt;//i为数组下标
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;i &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; heapSize) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;i;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (j &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j&lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;])		j&lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;(nums[i] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[j]))	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        swap(nums[i], nums[j]);
        i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; j;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;swim——自下而上的有序化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;swim&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {&lt;span style=&#34;color:#888&#34;&gt;//x为插入末尾的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    nums.push_back(x);
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (k &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; nums[k]) {
        swap(nums[k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;], nums[k]);
        k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;构建大根堆&#34;&gt;构建大根堆&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;buildMaxHeap&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {	&lt;span style=&#34;color:#888&#34;&gt;//使用sink从上向下构建大根堆
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;) {
        sink(nums, i, heapSize);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;删除堆顶元素&#34;&gt;删除堆顶元素&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;deleteK&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {	&lt;span style=&#34;color:#888&#34;&gt;//输出大根堆第k大的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; heapSize &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size();
    
    &lt;span style=&#34;color:#888&#34;&gt;//依次交换第0个和第heapSize - 1个元素,...,第k-1个和第heapSize - k + 1个元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#888&#34;&gt;//每次交换后使用sink重新构建使堆有序
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;) {
        swap(nums[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;], nums[i]);
        heapSize&lt;span style=&#34;color:#333&#34;&gt;--&lt;/span&gt;;
        sink(nums, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, heapSize);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;向堆中插入元素&#34;&gt;向堆中插入元素&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;swim&lt;/span&gt;(vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {	&lt;span style=&#34;color:#888&#34;&gt;//向大根堆堆中插入元素x，然后从下向上有序化
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    nums.push_back(x);
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (k &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[j] &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; nums[k])
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        swap(nums[j], nums[k]);
        k &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; k&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH18 用于大型工程的工具——命名空间</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
        <pubDate>Fri, 03 Dec 2021 11:21:29 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/ -&lt;h2 id=&#34;命名空间&#34;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;大型程序往往使用多个独立开发的库，这些库又会定义大量全局名字，如类、函数、模板。当应用程序使用到多个供应商提供的库时，不可避免会发生某些名字的冲突。多个库名字放置在全局命名空间中会引发&lt;strong&gt;命名空间污染&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;命名空间提供了防止污染的可控机制。命名空间分隔了全局命名空间，每个命名空间是一个&lt;strong&gt;作用域&lt;/strong&gt;。通过某个命名空间定义库名，可以避免全局名字固有的限制。&lt;/p&gt;
&lt;h3 id=&#34;定义命名空间&#34;&gt;定义命名空间&lt;/h3&gt;
&lt;p&gt;命名空间既可以定义在&lt;strong&gt;全局作用域&lt;/strong&gt;中，也可以定义在&lt;strong&gt;其他命名空间&lt;/strong&gt;中，但&lt;strong&gt;不能&lt;/strong&gt;定义在&lt;strong&gt;函数或类的内部&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个命名空间都是一个作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;位于该命名空间之外的代码必须明确指出所用的名字属于哪个命名空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名空间可以是不连续的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; nsp {
&lt;span style=&#34;color:#888&#34;&gt;//相关声明
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能定义了一个新命名空间，可以能为已存在的命名空间添加一些新成员。&lt;/p&gt;
&lt;p&gt;因此我们可以将几个独立的接口和实现文件组成一个命名空间。其组织方式类似于我们管理自定义类及函数的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名空间中是定义类、声明作为类接口的函数及对象的部分，放置于&lt;strong&gt;头文件&lt;/strong&gt;中，然后将这些头文件包含在使用了这些成员的文件中&lt;/li&gt;
&lt;li&gt;命名空间成员的定义部分则置于另外的&lt;strong&gt;源文件&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序中某些实体只能定义一次，如内联函数、变量等。命名空间中的定义也要满足这一要求。即接口与实现分离的机制。&lt;/p&gt;
&lt;p&gt;另外，我们&lt;strong&gt;不把#include放在命名空间内部&lt;/strong&gt;。这样做的隐含意思是把头文件中所有名字定义成该命名空间的成员，这很有可能导致错误，例如可能将std命名空间嵌套在自己的命名空间内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义命名空间成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命名空间中的名字可以直接使用名字，此时无需前缀。&lt;/p&gt;
&lt;p&gt;另外也可以将命名空间的外部定义该命名空间的成员，需要有完整的前缀。命名空间对于名字的声明必须在作用域内，同时改名字的定义需要明确指出其所属的命名空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; cpp_primer {
	std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istream&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;istream&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt; in, Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt; s) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;模板特例化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板特例化必须定义在原始模板所属的命名空间中。只要我们在命名空间中声明了特例化，就能在命名空间外部定义它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;hash&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;;
}
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;std&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;hash&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Sales_data&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
{
	....
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;全局命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局作用域中定义的名字即定义在全局命名空间中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。&lt;/p&gt;
&lt;p&gt;作用域运算符同样可以用于全局作用域成员：(因为其是隐式地，所以没有名字)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;nember_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;内联命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++ 11引入的新的嵌套命名空间，称为内联命名空间。内联命名空间中的名字可以被外层命名空间直接使用。即无需在内联命名空间的名字前添加表示该命名空间的前缀。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; FifthEd {

}
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; FifthEd {
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键字inline必须出现在命名空间第一次定义的地方，后续再打开时可以不写inline。&lt;/p&gt;
&lt;p&gt;当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常用到内联命名空间。我们可以将当前版本的所有代码都放在一个内联命名空间中，把之前版本的代码都放在一个非内联命名空间中。这样在使用时，使用当前版本的成员的代码无需加前缀，如需使用之前版本的代码，则需加上完整的外层命名空间名字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未命名的命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;namespace&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;未命名的命名空间拥有静态生命周期，在第一次使用前创建，直到程序结束才销毁。&lt;/p&gt;
&lt;p&gt;一个未命名的命名空间可以在某个给定文件内不连续，但不能跨越多个文件。每个文件定义自己的未命名的命名空间，多个文件的未命名的命名空间之间没有关系。&lt;/p&gt;
&lt;p&gt;如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中成员的名字一定要与全局作用域中的名字有所区别。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;未命名的命名空间取代文件中的静态声明&lt;/p&gt;
&lt;p&gt;标准C++引入命名空间前，程序要将名字声明称static使得其堆整个文件有效，这是从C语言继承而来的。而如今在C++中直接使用未命名的命名空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;使用命名空间成员&#34;&gt;使用命名空间成员&lt;/h3&gt;
&lt;p&gt;我们可以通过使用using声明以及命名空间别名或using指示等来更加便捷地使用命名空间的成员。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们应当避免使用using指示&lt;/p&gt;
&lt;p&gt;using指示一次性注入某个命名空间的所有名字，这种用法充满了风险，将命名空间中的所有成员的名字变得可见。使用多个库时，可能导致全局命名空间污染。&lt;/p&gt;
&lt;/blockquote&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH15 面向对象程序设计</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Fri, 03 Dec 2021 11:10:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/ -&lt;p&gt;面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。&lt;/p&gt;
&lt;p&gt;本章介绍剩余的&lt;strong&gt;继承和动态绑定&lt;/strong&gt;。通过这两种特性我们可以更容易地定义与其他类&lt;strong&gt;相似但不完全相同的新类&lt;/strong&gt;；另外在使用这些彼此相似的类编写函数时。我们可以在一定程度上忽略掉它们的区别。&lt;/p&gt;
&lt;h2 id=&#34;oop概述&#34;&gt;OOP：概述&lt;/h2&gt;
&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;
&lt;p&gt;通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个&lt;strong&gt;基类&lt;/strong&gt;，其他类别从基类继承而来，这些继承而来的类称为&lt;strong&gt;派生类&lt;/strong&gt;。基类负责定义所有类&lt;strong&gt;共同拥有的成员&lt;/strong&gt;，而每个派生类定义&lt;strong&gt;各自特有的成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于某些函数，基类希望它的派生类各自定义适合自己的版本，此时基类就将这些函数声明成&lt;strong&gt;虚函数&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Quote&lt;/span&gt; {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;string isbn() &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;net_price&lt;/span&gt;(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;size_t n)	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类必须通过使用&lt;strong&gt;类派生列表&lt;/strong&gt;明确指出它是从哪个基类继承而来的。&lt;/p&gt;
&lt;p&gt;类派生列表的形式：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类列表前面可以有访问说明符：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Bulk_quote&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; Quote {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;double&lt;/span&gt; net_price(std&lt;span style=&#34;color:#333&#34;&gt;::&lt;/span&gt;size_t n)	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完全可以把Bulk_quote的对象当作Quote的对象来使用。&lt;/p&gt;
&lt;p&gt;派生类必须在其内部对所有重新定义的虚函数进行&lt;strong&gt;声明&lt;/strong&gt;。C++11 允许派生类&lt;strong&gt;显式地注明&lt;/strong&gt;它将使用哪个成员函数改写基类的虚函数，方法是在该函数的形参列表之后增加一个&lt;strong&gt;override关键字&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;动态绑定&#34;&gt;动态绑定&lt;/h3&gt;
&lt;p&gt;又称为运行时绑定，根据运行时传入的实参选择函数的版本。通过动态绑定，我们可以用同一段代码分别处理Quote和Bulk_quote的对象。&lt;/p&gt;
&lt;h2 id=&#34;定义基类和派生类&#34;&gt;定义基类和派生类&lt;/h2&gt;
&lt;h3 id=&#34;定义基类&#34;&gt;定义基类&lt;/h3&gt;
&lt;p&gt;继承关系中的根节点的类通常会定义一个&lt;strong&gt;虚析构函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于一些操作，派生类需要提供自己的新定义以覆盖（override）从基类继承而来的就定义。需要&lt;strong&gt;覆盖&lt;/strong&gt;的函数，&lt;strong&gt;基类&lt;/strong&gt;通常将其定义为&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。&lt;/p&gt;
&lt;p&gt;任何构造函数之外的非静态函数都可以是虚函数。virtual只能出现在&lt;strong&gt;类内部的声明语句&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问控制与继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下派生类可以继承定义在基类中的成员，但派生类的成员函数没有权限访问从基类继承而来的成员，派生类只能访问公有成员，不能访问私有成员。而有一种成员，基类希望它的&lt;strong&gt;派生类有权限访问&lt;/strong&gt;该成员，同时&lt;strong&gt;禁止其他用户访问&lt;/strong&gt;，我们使用&lt;strong&gt;受保护的（protected）访问运算符&lt;/strong&gt;说明该成员。&lt;/p&gt;
&lt;h3 id=&#34;定义派生类&#34;&gt;定义派生类&lt;/h3&gt;
&lt;p&gt;派生类必须通过使用&lt;strong&gt;类派生列表&lt;/strong&gt;明确指出从哪个（哪些）基类继承而来的。&lt;/p&gt;
&lt;p&gt;类派生列表的形式：冒号后紧跟以逗号分隔的基类列表，每个基类前面可以有三个&lt;strong&gt;访问说明符&lt;/strong&gt;中的一个：public、protected或private。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Bulk_quote&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; Quote {	&lt;span style=&#34;color:#888&#34;&gt;//Bulk_quote继承自Quote
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。&lt;/p&gt;
&lt;p&gt;如果一个派生是&lt;strong&gt;公有&lt;/strong&gt;的，则&lt;strong&gt;基类的公有成员&lt;/strong&gt;也是派生类接口的组成部分；此外还能将公有派生类型的对象&lt;strong&gt;绑定到基类的引用或指针&lt;/strong&gt;上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Quote item;		&lt;span style=&#34;color:#888&#34;&gt;//基类对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Bulk_quote bulk;	&lt;span style=&#34;color:#888&#34;&gt;//派生类对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Quote &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;item;	&lt;span style=&#34;color:#888&#34;&gt;//p指向Quote对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;p &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;bulk;		&lt;span style=&#34;color:#888&#34;&gt;//p指向bulk的Quote部分
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;Quote &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&lt;/span&gt;r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; bulk;	&lt;span style=&#34;color:#888&#34;&gt;//r绑定到bulk的Quote部分
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这样做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派生类不能直接初始化从基类继承而来的成员。派生类必须使用基类的构造函数来初始化它的基类部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个类控制它自己的成员初始化过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;派生类构造函数同样是通过构造函数的初始化列表来将实参传递给基类构造函数的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类使用基类成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派生类可以使用基类的公有成员和受保护的成员。&lt;/p&gt;
&lt;p&gt;派生类的作用域嵌套在基类的作用域之内。对于派生类的一个成员来说，它使用派生类成员的方式和使用基类成员的方式没有差别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承与静态成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。对于每个静态成员来说，只存在唯一的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类的声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明中包含类名但不包含其派生列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防止继承发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候我们不希望一个类被其它类继承，C++11 提供了防止继承的方法，在类名后赶一个关键字final：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;NoDerived&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; {&lt;span style=&#34;color:#888&#34;&gt;/* */&lt;/span&gt;};	&lt;span style=&#34;color:#888&#34;&gt;//NoDerived不能作为基类
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Bad&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt; NoDerived {}	&lt;span style=&#34;color:#888&#34;&gt;//错误
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;类型转换与继承&#34;&gt;类型转换与继承&lt;/h3&gt;
&lt;p&gt;通常我们把引用或指针绑定到一个对象上，则引用或指针的类型应该与对象的类型一致。但在继承关系中是一个例外，我们可以将&lt;strong&gt;基类的指针或引用&lt;/strong&gt;绑定到&lt;strong&gt;派生类的对象&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;这隐含了：使用基类的指针或引用时，我们不知道其所绑定对象的真实类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态类型和动态类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不存在&lt;/strong&gt;从基类向派生类的&lt;strong&gt;隐式类型转换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同样的，在对象之间不存在类型转换。&lt;/p&gt;
&lt;p&gt;派生类向基类的类型转换也可能由于访问受限而变得不可行。&lt;/p&gt;
&lt;h2 id=&#34;虚函数&#34;&gt;虚函数&lt;/h2&gt;
&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;对虚函数的调用可能在&lt;strong&gt;运行时&lt;/strong&gt;才被解析。&lt;/p&gt;
&lt;p&gt;动态绑定只有当我们&lt;strong&gt;通过指针或引用调用虚函数&lt;/strong&gt;时才会发生。当我们通过一个具有普通类型（非引用指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。&lt;/p&gt;
&lt;p&gt;一旦某个函数被声明成虚函数。则在所有派生类中它都是虚函数。所以派生类中的虚函数可以不加virtual关键字。&lt;/p&gt;
&lt;p&gt;派生类中的虚函数的返回类型也必须与基类函数匹配，但存在一个例外，当类的虚函数返回类型是&lt;strong&gt;类本身的指针或引用&lt;/strong&gt;时，上述规则无效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;final和override说明符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派生类如果定义了一个函数与基类中的虚函数的&lt;strong&gt;名字相同但形参列表不同&lt;/strong&gt;，这仍然是正确的，编译器将认为新定义的这个函数与基类中原有的函数是&lt;strong&gt;相互独立&lt;/strong&gt;的，此时派生类的函数没有覆盖掉基类中的版本。&lt;/p&gt;
&lt;p&gt;C++11 中可以使用override关键字来说明派生类中的虚函数，降低错误发生的可能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;B&lt;/span&gt; {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt;;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f2&lt;/span&gt;();
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f3&lt;/span&gt;();
};
sturct &lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;D1&lt;/span&gt; : B {
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f1&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f2&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//错误，B中没有f(int)函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;f3&lt;/span&gt;() &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;override&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//错误，f3不是虚函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外还能把某个函数指定为final，这是之后任何尝试覆盖该函数的操作都会引发错误。&lt;/p&gt;
&lt;p&gt;和其他函数一样，虚函数也有默认实参。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回避虚函数机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某些情况下我们希望对虚函数的调用不要进行动态绑定而是强迫其执行虚函数的某个特定版本。使用作用域运算符&lt;code&gt;-&amp;gt;&lt;/code&gt;可以实现这一目的。&lt;/p&gt;
&lt;h3 id=&#34;不能声明为虚函数的函数&#34;&gt;不能声明为虚函数的函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;内联成员函数。inline函数在编译时杯展开，而虚函数在运行时才能动态地绑定函数&lt;/li&gt;
&lt;li&gt;静态成员函数。静态成员只属于该类，没有绑定的必要，不能被继承。&lt;/li&gt;
&lt;li&gt;友元函数。C++不支持友元函数的继承。另外友元函数不属于类的成员函数，不能被继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;抽象基类&#34;&gt;抽象基类&lt;/h2&gt;
&lt;p&gt;当我们希望继承类不使用某一个虚函数时，可以将其定义为&lt;strong&gt;纯虚函数&lt;/strong&gt;，这样可以清晰明了地告诉用户当前这个函数没有实际意义。方式是：&lt;/p&gt;
&lt;p&gt;通过在函数体的位置（在声明语句的分号之前）书写&lt;code&gt;=0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;含有纯虚函数的类是抽象基类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象基类负责定义接口，而后续其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。但我们可以定义抽象基类的派生类对象，前提是这些类覆盖了纯虚函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生类构造函数只初始化它的直接基类&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;访问控制与继承&#34;&gt;访问控制与继承&lt;/h2&gt;
&lt;p&gt;每个类还分别控制着其成员对于派生类来说是否&lt;strong&gt;可访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受保护的成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;protected说明符可看作是public和private中和后的产物：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和私有成员类似，受保护的成员对于类的用户来说是不可访问的&lt;/li&gt;
&lt;li&gt;和公有成员类似，受保护的成员对于派生类的成员和友元来说是可以访问的&lt;/li&gt;
&lt;li&gt;派生类的成员或友元只能通过&lt;strong&gt;派生类对象&lt;/strong&gt;来访问基类的受保护成员（private成员）。&lt;strong&gt;派生类&lt;/strong&gt;对于一个基类对象中的受保护成员没有任何访问特权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友元与继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;友元关系&lt;strong&gt;既不能传递，也不能继承&lt;/strong&gt;。基类的成员在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。&lt;/p&gt;
&lt;h2 id=&#34;继承中的类作用域&#34;&gt;继承中的类作用域&lt;/h2&gt;
&lt;p&gt;当存在继承关系时，派生类的作用域&lt;strong&gt;嵌套在其基类的作用域之内&lt;/strong&gt;。如果一个名字在派生类的作用域内无法正确解析，那么编译器将继续在&lt;strong&gt;外层的基类作用域中&lt;/strong&gt;寻找该名字的定义。&lt;/p&gt;
&lt;p&gt;正因为有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员。&lt;/p&gt;
&lt;p&gt;派生类的成员将&lt;strong&gt;隐藏同名的基类成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外可以通过作用域运算符覆盖原有的查找规则。&lt;/p&gt;
&lt;h2 id=&#34;构造函数与拷贝控制&#34;&gt;构造函数与拷贝控制&lt;/h2&gt;
&lt;p&gt;如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器将为它合成一个版本。&lt;/p&gt;
&lt;h3 id=&#34;虚析构函数&#34;&gt;虚析构函数&lt;/h3&gt;
&lt;p&gt;基类通常应该定义一个虚析构函数，这样我们就能&lt;strong&gt;动态分配&lt;/strong&gt;继承体系中的对象了。&lt;/p&gt;
&lt;p&gt;当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则可能出现指针的静态类型与被删除对象的动态类型不符的情况。所以编译器必须清楚它应该执行的是哪个类的析构函数。所以与其他函数一样，通过在基类中将析构函数定义为虚函数确保执行正确的析构函数版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Quote&lt;/span&gt; {
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;~&lt;/span&gt;Quote() &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;default&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//动态绑定析构函数
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虚析构函数将阻止合成移动操作。&lt;/p&gt;
&lt;h3 id=&#34;合成拷贝控制与继承&#34;&gt;合成拷贝控制与继承&lt;/h3&gt;
&lt;h3 id=&#34;派生类的拷贝控制成员&#34;&gt;派生类的拷贝控制成员&lt;/h3&gt;
&lt;h3 id=&#34;继承的构造函数&#34;&gt;继承的构造函数&lt;/h3&gt;
&lt;h2 id=&#34;容器与继承&#34;&gt;容器与继承&lt;/h2&gt;
&lt;p&gt;当我们使用容器存放&lt;strong&gt;继承体系中的对象&lt;/strong&gt;时，通常必须采用&lt;strong&gt;间接存储&lt;/strong&gt;的方式，因为不允许在容器中保存不同类型的元素。&lt;/p&gt;
&lt;p&gt;当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型无法兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器中放置（智能）指针而非对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在容器中存放具有继承关系的对象时，我们实际上存放的是基类的指针（智能指针更好）。这些指针所指的对象的动态类型可能是&lt;strong&gt;基类类型也可能是派生类类型&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Quote&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; basket;
basket.push_back(make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Bulk_quote&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;0-121&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;50&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;派生类的智能指针和基类的智能指针可以相互转换。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>Cpp程序的内存分配</title>
        <link>https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
        <pubDate>Thu, 02 Dec 2021 21:54:01 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/ -&lt;ul&gt;
&lt;li&gt;栈区stack：由编译器自动分配和释放，用来存放函数的参数值、局部变量的值&lt;/li&gt;
&lt;li&gt;堆区heap：一般由程序员分配和释放，用来创建动态内存&lt;/li&gt;
&lt;li&gt;全局区static：全局变量、静态变量，程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;文字常量区：常量字符串存放在此&lt;/li&gt;
&lt;li&gt;程序代码区：存放函数体的二进制代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宏定义不占用内存和编译时间。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>typedef和define宏详解</title>
        <link>https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Wed, 01 Dec 2021 19:43:11 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/ -&lt;p&gt;typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。&lt;/p&gt;
&lt;p&gt;当const和typedef一起出现时，typedef不会是简单的字符串替换就行。&lt;/p&gt;
&lt;p&gt;typedef常用来定义一个标识符及关键字的别名，它是语言&lt;strong&gt;编译过程&lt;/strong&gt;的一部分，但它并不实际分配内存空间&lt;/p&gt;
&lt;p&gt;#define为一宏定义语句，通常用它来定义常量(包括无参量与带参量)，以及用来实现那些“表面似和善、背后一长串”的宏，它本身并不在编译过程中进行，而是在这之前(&lt;strong&gt;预处理过程&lt;/strong&gt;)就已经完成了，但也因此难以发现潜在的错误及其它代码维护问题&lt;/p&gt;
&lt;h2 id=&#34;define用法详解&#34;&gt;#define用法详解&lt;/h2&gt;
&lt;h3 id=&#34;无参宏定义&#34;&gt;无参宏定义&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define 标识符 字符串
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预处理命令。&lt;/p&gt;
&lt;h3 id=&#34;有参宏定义&#34;&gt;有参宏定义&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define 宏名(形参表) 字符串
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;宏定义中称为形参，宏调用中称为实参。带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。&lt;/p&gt;
&lt;h3 id=&#34;宏定义中的特殊操作符&#34;&gt;宏定义中的特殊操作符&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）#&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希望在字符串中包含宏参数时使用，#作为一个预处理运算符，可以把语言符号转换为字符串，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define NUM(x) printf(&amp;#34;the number is #x.\n&amp;#34;, x)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;（2）##&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##可以把两个字符串转换成单个字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#define XNAME(n) x##n
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;XNAME&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;12&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//相当于int x1 = 12;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;（3）可变宏 &amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若要使用可变参数宏，可以在宏定义中将省略号指定为&lt;strong&gt;最后一个形参&lt;/strong&gt;，并且替换标识符可以在定义中用于插入 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 额外的参数。 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 替换为与省略号匹配的所有参数，包括它们之间的逗号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#888&#34;&gt;// variadic_macros.cpp
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define EMPTY
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#579&#34;&gt;#define CHECK1(x, ...) if (!(x)) { printf(__VA_ARGS__); }
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define CHECK2(x, ...) if ((x)) { printf(__VA_ARGS__); }
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define CHECK3(...) { printf(__VA_ARGS__); }
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#define MACRO(s, ...) printf(s, __VA_ARGS__)
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() {
    CHECK1(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs1(1)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);
    CHECK1(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs1(2)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);   &lt;span style=&#34;color:#888&#34;&gt;// won&amp;#39;t print
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;
    CHECK2(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs2(3)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);   &lt;span style=&#34;color:#888&#34;&gt;// won&amp;#39;t print
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    CHECK2(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs2(4)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#888&#34;&gt;// always invokes printf in the macro
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;    CHECK3(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;here %s %s %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;are&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;some&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;varargs3(5)&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);

    MACRO(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;hello, world&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;);

    MACRO(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;error&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, EMPTY); &lt;span style=&#34;color:#888&#34;&gt;// would cause error C2059, except VC++
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;                             &lt;span style=&#34;color:#888&#34;&gt;// suppresses the trailing comma
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;here are some varargs1(1)
here are some varargs2(4)
here are some varargs3(5)
hello, world
error
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;宏定义中的多行定义&#34;&gt;宏定义中的多行定义&lt;/h3&gt;
&lt;p&gt;在每一个换行的地方加上一个&lt;code&gt;/&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;简单函数指针&#34;&gt;简单函数指针&lt;/h2&gt;
&lt;h3 id=&#34;形式1返回类型函数名参数表&#34;&gt;形式1：返回类型(*函数名)(参数表)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pFun)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;); 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;glFun&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a){ &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;} 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{ 
    pFun &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; glFun; 
    (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pFun)(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一行定义了一个指针变量pFun，它是一种指向某种函数的指针，这种函数是一个int型，返回值是char型。&lt;/p&gt;
&lt;p&gt;第二行定义了一个函数glFun()。该函数正好是一个以int为参数返回char的函数。我们要从指针的层次上理解函数——函数的函数名实际上就是一个指针，函数名指向该函数的代码在内存中的首地址。&lt;/p&gt;
&lt;p&gt;main()函数中将函数glFun的地址赋值给变量pFun。main()函数的第二句中“*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。&lt;/p&gt;
&lt;h2 id=&#34;typedef函数指针&#34;&gt;typedef函数指针&lt;/h2&gt;
&lt;h3 id=&#34;形式2typedef--返回类型新类型参数表&#34;&gt;形式2：typedef  返回类型(*新类型)(参数表)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;char&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;PTRFUN)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;); 
PTRFUN pFun; 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;glFun&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a){ &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt;;} 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;() 
{ 
    pFun &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; glFun; 
    (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pFun)(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;); 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;typedef的功能是&lt;strong&gt;定义新的类型&lt;/strong&gt;。第一句就是定义了一种PTRFUN的类型，并定义这种类型为&lt;strong&gt;指向某种函数的指针&lt;/strong&gt;，这种函数以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了。&lt;/p&gt;
&lt;p&gt;第二行的代码便使用这个新类型定义了变量pFun，此时就可以像使用形式1一样使用这个变量了。&lt;/p&gt;
&lt;h2 id=&#34;举例说明&#34;&gt;举例说明&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#579&#34;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#579&#34;&gt;&lt;/span&gt; 
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;FP_CALC)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;);&lt;span style=&#34;color:#888&#34;&gt;//定义一个函数指针类型
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt; 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; b;
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;sub&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt; b;
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;mul&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt; b;
}
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;div&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; b &lt;span style=&#34;color:#333&#34;&gt;?&lt;/span&gt; a&lt;span style=&#34;color:#333&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#970;font-weight:bold&#34;&gt;b&lt;/span&gt; : &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
}

&lt;span style=&#34;color:#888&#34;&gt;//定义一个函数，参数为op，返回一个指针,该指针类型为拥有两个int参数、
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//返回类型为int的函数指针。它的作用是根据操作符返回相应函数的地址
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;FP_CALC &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;calc_func&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; op)
{	&lt;span style=&#34;color:#888&#34;&gt;//函数名即为对应函数指针
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;switch&lt;/span&gt;( op )
	{
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; add;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; sub;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; mul;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; div;
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;;
	}
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;NULL&lt;/span&gt;;
}
 
&lt;span style=&#34;color:#888&#34;&gt;//s_calc_func为函数，它的参数是 op，   
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//返回值为一个拥有两个int参数、返回类型为int的函数指针  
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;s_calc_func(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; op)) (&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; , &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;)
{
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;calc_func&lt;/span&gt;(op);
}
 
&lt;span style=&#34;color:#888&#34;&gt;//最终用户直接调用的函数，该函数接收两个int整数，
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;//和一个算术运算符，返回两数的运算结果
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;calc&lt;/span&gt;(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; b, &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;char&lt;/span&gt; op)
{
	FP_CALC fp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; calc_func(op);
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;s_fp)(&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; s_calc_func(op);&lt;span style=&#34;color:#888&#34;&gt;//用于测试
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt; 
	assert(fp &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; s_fp);&lt;span style=&#34;color:#888&#34;&gt;// 可以断言这两个是相等的
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt; 
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt;(fp)
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; fp(a,b);
	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
}
 
&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;main&lt;/span&gt;()
{
	&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;100&lt;/span&gt;, b &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;20&lt;/span&gt;;
 
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;));
	printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;));   
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;));   
    printf(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;calc(%d, %d, %c) = %d&lt;/span&gt;&lt;span style=&#34;color:#666;background-color:#fff0f0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;&lt;/span&gt;, a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, calc(a, b, &lt;span style=&#34;color:#04d;background-color:#fff0f0&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://eternityqjl.top/posts/cpp_typedef%E5%92%8Cdefine%E5%AE%8F%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>基础算法总结</title>
        <link>https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
        <pubDate>Tue, 30 Nov 2021 22:16:50 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ -&lt;p&gt;希望未来一段时间能够手动实现一下这些算法。&lt;/p&gt;
&lt;h2 id=&#34;线性表&#34;&gt;线性表&lt;/h2&gt;
&lt;h3 id=&#34;顺序表&#34;&gt;顺序表&lt;/h3&gt;
&lt;h3 id=&#34;链表&#34;&gt;链表&lt;/h3&gt;
&lt;h2 id=&#34;栈和队列&#34;&gt;栈和队列&lt;/h2&gt;
&lt;p&gt;栈的顺序、链式存储&lt;/p&gt;
&lt;p&gt;队列的顺序、链式存储&lt;/p&gt;
&lt;p&gt;双端队列&lt;/p&gt;
&lt;p&gt;优先队列（堆排序）&lt;/p&gt;
&lt;h2 id=&#34;字符串&#34;&gt;字符串&lt;/h2&gt;
&lt;p&gt;KMP模式匹配&lt;/p&gt;
&lt;h2 id=&#34;树与二叉树&#34;&gt;树与二叉树&lt;/h2&gt;
&lt;h3 id=&#34;二叉树的遍历&#34;&gt;二叉树的遍历&lt;/h3&gt;
&lt;p&gt;前序、中序、后序&lt;/p&gt;
&lt;h3 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h3&gt;
&lt;h3 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h3&gt;
&lt;h3 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h3&gt;
&lt;h3 id=&#34;2-3树和红黑树&#34;&gt;2-3树和红黑树&lt;/h3&gt;
&lt;h2 id=&#34;图&#34;&gt;图&lt;/h2&gt;
&lt;h3 id=&#34;图的遍历&#34;&gt;图的遍历&lt;/h3&gt;
&lt;p&gt;广度优先搜索和深度优先搜索&lt;/p&gt;
&lt;h3 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h3&gt;
&lt;p&gt;Prim、Kruskal&lt;/p&gt;
&lt;h3 id=&#34;最短路径&#34;&gt;最短路径&lt;/h3&gt;
&lt;p&gt;Dijkstra、Floyd&lt;/p&gt;
&lt;h3 id=&#34;拓扑排序&#34;&gt;拓扑排序&lt;/h3&gt;
&lt;p&gt;活动的先后顺序&lt;/p&gt;
&lt;h3 id=&#34;关键路径&#34;&gt;关键路径&lt;/h3&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找&lt;/h2&gt;
&lt;h3 id=&#34;顺序查找&#34;&gt;顺序查找&lt;/h3&gt;
&lt;h3 id=&#34;折半查找&#34;&gt;折半查找&lt;/h3&gt;
&lt;h3 id=&#34;b树&#34;&gt;B树&lt;/h3&gt;
&lt;h3 id=&#34;散列表&#34;&gt;散列表&lt;/h3&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;h3 id=&#34;插入排序&#34;&gt;插入排序&lt;/h3&gt;
&lt;h3 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h3&gt;
&lt;h3 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h3&gt;
&lt;h3 id=&#34;快速排序&#34;&gt;快速排序&lt;/h3&gt;
&lt;h3 id=&#34;选择排序&#34;&gt;选择排序&lt;/h3&gt;
&lt;h3 id=&#34;堆排序优先队列&#34;&gt;堆排序（优先队列）&lt;/h3&gt;
&lt;p&gt;删除最大元素、插入元素&lt;/p&gt;
&lt;p&gt;构造大根堆、小根堆&lt;/p&gt;
&lt;h3 id=&#34;归并排序&#34;&gt;归并排序&lt;/h3&gt;
&lt;h3 id=&#34;基数排序&#34;&gt;基数排序&lt;/h3&gt;
- https://eternityqjl.top/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>算法——红黑树</title>
        <link>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
        <pubDate>Sat, 27 Nov 2021 21:03:17 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/ -&lt;p&gt;本节是为了介绍一种二分查找树，无论如何构造，它的运行时间都是对数级别的。在一棵含有N个结点的树中，树的高为$\lg N$。&lt;/p&gt;
&lt;h2 id=&#34;2-3查找树&#34;&gt;2-3查找树&lt;/h2&gt;
&lt;p&gt;允许一个结点保存多个键。一颗2-3查找树由2-结点和3-结点组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2-结点：含有一个键（及其对应键值）和两条链接&lt;/li&gt;
&lt;li&gt;3-结点：含有两个键（及其对应键值）和三条链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样地，将指向一颗空树的链接称为空链接。&lt;/p&gt;
&lt;h3 id=&#34;查找&#34;&gt;查找&lt;/h3&gt;
&lt;p&gt;与二叉查找树基本相同，只是可能多了中间结点，从上向下一次递归查找。&lt;/p&gt;
&lt;h3 id=&#34;插入新键&#34;&gt;插入新键&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;向2-结点插入新键&lt;/li&gt;
&lt;li&gt;向一棵只含有3-结点的树中插入新键&lt;/li&gt;
&lt;li&gt;向一个父结点为2-结点的3-结点中插入新键&lt;/li&gt;
&lt;li&gt;向一个父结点为3-结点的3-结点中插入新键&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局性质&#34;&gt;全局性质&lt;/h3&gt;
&lt;p&gt;任意空链接到根结点的路径长度都是相等的。&lt;/p&gt;
&lt;p&gt;一棵含有N个结点的2-3树高度在$\lfloor \log_3N\rfloor$（树中全是3-结点）和$\lfloor \lg N\rfloor$（树中全是2-结点）之间。&lt;/p&gt;
&lt;h2 id=&#34;红黑二叉查找树&#34;&gt;红黑二叉查找树&lt;/h2&gt;
&lt;p&gt;用标准二叉查找树和一些额外的信息来表示2-3树。将树中的链接分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红链接：将两个2-结点连接起来构成一个3-结点&lt;/li&gt;
&lt;li&gt;黑链接：2-3树中的普通链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相当于将3-结点表示为一条左斜的红色链接。这种方法的优点是我们无需修改就可以直接使用标准二叉查找树的&lt;code&gt;get()&lt;/code&gt;方法。对于任意的2-3树，只需对结点进行转换，就可以立即派生出一棵对应的二叉查找树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种等价的定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红链接均为左链接&lt;/li&gt;
&lt;li&gt;没有任何一个结点同时和两条红链接相连&lt;/li&gt;
&lt;li&gt;该树是完美黑色平衡的，即任意空链接到根结点路径上的黑链接数量相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;插入操作的方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;左旋转、右旋转、颜色转换&lt;/p&gt;
&lt;h2 id=&#34;红黑树的实现&#34;&gt;红黑树的实现&lt;/h2&gt;
&lt;p&gt;红黑树的插入算法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; RED &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; BLACK &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;Node&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    Key key&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    Value val&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    Node left&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; right&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; color&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    Node&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Key key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Value val&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; color&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; N&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; color&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;isRed&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node x&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;	&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

Node &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;rotateLeft&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    Node x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; 1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

Bode &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;rotateRight&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    Node x &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    x&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; 1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;flipColors&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; BLACK&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; BLACK&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#b06;font-weight:bold&#34;&gt;RedBlackBST&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Key &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;extends&lt;/span&gt; Comparable&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;Key&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;,&lt;/span&gt; Value&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; Node root&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Key key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Value val&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
        root &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; put&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;root&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        root&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; BLACK&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;private&lt;/span&gt; Node &lt;span style=&#34;color:#06b;font-weight:bold&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;Node h&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Key key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; Value val&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h &lt;span style=&#34;color:#333&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; Node&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; RED&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; cmp &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;compareTo&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;key&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; 		&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;cmp &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt; 0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;	h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; put&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;cmp &lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; 0&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt;	h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; put&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; key&lt;span style=&#34;color:#333&#34;&gt;,&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;else&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; val&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
        
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;!&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;))&lt;/span&gt;		h &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; rotateLeft&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;))&lt;/span&gt;	h &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; rotateRight&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isRed&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;))&lt;/span&gt;		flipColors&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        
        h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; 1 &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;+&lt;/span&gt; size&lt;span style=&#34;color:#333&#34;&gt;(&lt;/span&gt;h&lt;span style=&#34;color:#333&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#00c&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;return&lt;/span&gt; h&lt;span style=&#34;color:#333&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;   
&lt;span style=&#34;color:#333&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一条if语句：将任意含有红色右链接的3-结点（或临时4-结点）向左旋转；&lt;/p&gt;
&lt;p&gt;第二条if语句：将临时的4-结点中两条连续红链接中的上层链接向右旋转；&lt;/p&gt;
&lt;p&gt;第三条if语句：进行颜色转换，并将红链接在树中向上传递。&lt;/p&gt;
&lt;h2 id=&#34;红黑树的删除操作&#34;&gt;红黑树的删除操作&lt;/h2&gt;
&lt;h3 id=&#34;自顶向下的2-3-4树&#34;&gt;自顶向下的2-3-4树&lt;/h3&gt;
&lt;h2 id=&#34;红黑树的性质&#34;&gt;红黑树的性质&lt;/h2&gt;
&lt;p&gt;所有基于红黑树的符号表（键值对）实现都能保证操作的运行时间为&lt;strong&gt;对数级别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一棵大小为N的红黑树的高度不会超过$2\lg N$。&lt;/p&gt;
&lt;p&gt;一颗大小为N的红黑树中，根结点到任意结点的平均路径为$\lg N$。&lt;/p&gt;
&lt;p&gt;红黑树的实现中最复杂的代码仅限于插入和删除方法，其他的二叉查找树中的查找最大最小键不做任何变动即可继续使用。&lt;/p&gt;
- https://eternityqjl.top/posts/%E7%AE%97%E6%B3%95%E7%BA%A2%E9%BB%91%E6%A0%91/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH12 动态内存</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
        <pubDate>Thu, 18 Nov 2021 09:20:28 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/ -&lt;p&gt;C++支持动态分配对象，动态分配的对象的生存期与它们在哪里创建无关，只有当显示地被释放时，这些对象才会销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态内存&lt;/strong&gt;用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。&lt;strong&gt;栈内存&lt;/strong&gt;用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。&lt;/p&gt;
&lt;p&gt;除了静态内存和栈内存，每个程序还拥有一个&lt;strong&gt;内存池&lt;/strong&gt;，这部分内存被称为&lt;strong&gt;堆&lt;/strong&gt;，程序用堆来存储&lt;strong&gt;动态分配&lt;/strong&gt;的对象，即那些在程序运行时分配的对象。动态对象的&lt;strong&gt;生存期由程序来控制&lt;/strong&gt;，即动态对象不再使用时，我们的代码必须显示销毁它们。&lt;/p&gt;
&lt;h2 id=&#34;动态内存与智能指针&#34;&gt;动态内存与智能指针&lt;/h2&gt;
&lt;p&gt;动态内存的管理是通过&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;完成的。new为对象分配空间并返回一个指向该对象的指针，delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;p&gt;新的标准库提供了两种&lt;strong&gt;智能指针&lt;/strong&gt;类型来管理动态对象，这两种智能指针的区别在于管理底层指针的方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;允许&lt;strong&gt;多个指针指向同一个对象&lt;/strong&gt;；&lt;code&gt;unique_ptr&lt;/code&gt;独占所指向的对象。标准库还顶一个名为&lt;code&gt;weak_ptr&lt;/code&gt;的伴随类，是一种弱引用，指向&lt;code&gt;shared_ptr&lt;/code&gt;所管理的对象。&lt;/p&gt;
&lt;h3 id=&#34;shared_ptr类&#34;&gt;shared_ptr类&lt;/h3&gt;
&lt;p&gt;类似于vector，&lt;strong&gt;智能指针&lt;/strong&gt;也是模板，当我们创建一个智能指针时，必须提供额外信息——指针&lt;strong&gt;可以指向的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p1;		&lt;span style=&#34;color:#888&#34;&gt;//可以指向string
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;list&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; p2;	&lt;span style=&#34;color:#888&#34;&gt;//可以指向int的list
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认初始化的智能指针中保存着一个空指针。使用方法与普通指针类似，解引用一个智能指针返回它指向的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;make_shared函数&lt;/strong&gt;
是最安全的用来分配和使用动态内存的标准库函数。&lt;/p&gt;
&lt;p&gt;此函数在动态内存中分配一个对象并初始化它，返回指向此对象的&lt;code&gt;shared_ptr&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;); &lt;span style=&#34;color:#888&#34;&gt;//指向一个值为42的int的shared_ptr
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用make_shared时要指定创建对象的类型，方法与定义模板类相同，在函数名后跟一个尖括号，在其中给出类型，如上所示。另外，make_shared用其参数来构造给定类型的对象。例如调用&lt;code&gt;make_shared&amp;lt;string&amp;gt;&lt;/code&gt;时传递参数必须与string的某个构造函数匹配。&lt;/p&gt;
&lt;p&gt;一般使用auto来定义一个对象来保存make_shared的结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; p6 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;shared_ptr的拷贝和赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个shared_ptr都会记录&lt;strong&gt;指向相同对象&lt;/strong&gt;的其他shared_ptr的数量。&lt;/p&gt;
&lt;p&gt;每个shared_ptr都有一个关联的计数器，称其为&lt;strong&gt;引用计数&lt;/strong&gt;。无论何时拷贝一个shared_ptr，计数器都会递增。&lt;/p&gt;
&lt;p&gt;当我们给shared_ptr赋予一个新值或shared_ptr被销毁时，计数器就会递减。&lt;/p&gt;
&lt;p&gt;一旦一个shared_ptr的计数器变为0，它就会释放自己所管理的对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);
r &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; q;	&lt;span style=&#34;color:#888&#34;&gt;//给r赋值，令它指向另一个地址；递增q指向的对象的引用次数；递减r原来指向对象的引用次数；r原来指向的对象已经没有引用者，会自动释放
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;shared_ptr自动销毁所管理的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。这是通过另一个特殊成员函数——&lt;strong&gt;析构函数&lt;/strong&gt;完成的。析构函数一般用来释放对象多分配的资源。&lt;/p&gt;
&lt;p&gt;shared_ptr的析构函数会&lt;strong&gt;递减&lt;/strong&gt;它所指向对象的引用次数，引用次数变为0后shared_ptr的析构函数就会自动销毁对象并释放内存。&lt;/p&gt;
&lt;p&gt;由于最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重用，否则程序虽然会正常执行，但会浪费内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用动态内存的原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序不知道自己需要使用多少对象（容器类就是出于这种原因从而使用动态内存）&lt;/li&gt;
&lt;li&gt;程序不知道对象的准确类型&lt;/li&gt;
&lt;li&gt;程序需要在多个对象间共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直接管理内存&#34;&gt;直接管理内存&lt;/h3&gt;
&lt;p&gt;使用运算符&lt;code&gt;new&lt;/code&gt;分配内存，&lt;code&gt;delete&lt;/code&gt;释放new分配的内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用new动态分配和初始化对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在自由空间分配的&lt;strong&gt;内存是无名的&lt;/strong&gt;，因此new无法为其分配的对象命名，而是返回一个&lt;strong&gt;指向该对象的指针&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pi &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//pi指向一个动态分配的、未初始化的无名对象
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认情况下动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的。类类型对象将用默认构造函数进行初始化：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;string &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;ps &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; string;	&lt;span style=&#34;color:#888&#34;&gt;//初始化为空string
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pi &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//pi指向一个未初始化的int
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; p1 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt;(obj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以通过括号包围的初始化器判断我们想到分配的对象类型，然后使用auto。但只有括号内仅有单一初始化器时才能使用auto。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态分配的const对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pci &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1024&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个动态分配的const必须进行初始化，对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，其他类型的对象必须显式初始化。上面new返回的是一个指向const的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存耗尽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序内存耗尽后new表达式就会失败，然后抛出一个类型为&lt;code&gt;std::bad_alloc&lt;/code&gt;的异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;释放动态内存&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;delete&lt;/span&gt; p;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;delete接受一个指针，销毁其指向的对象，释放对应内存。&lt;/p&gt;
&lt;p&gt;向delete传递的指针值必须指向动态分配的内存或是一个空指针。释放一块非new分配的内存，其行为未定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态对象的生存周期直到被释放为止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了额外负担，调用者必须记得释放内存。&lt;/p&gt;
&lt;h3 id=&#34;shared_ptr和new结合使用&#34;&gt;shared_ptr和new结合使用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p2(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;));
shared_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p3 &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//错误，必须使用直接初始化
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接受指针参数的智能指针的构造函数时explicit的，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针.&lt;/p&gt;
&lt;p&gt;不要混用内置指针和智能指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他shared_ptr操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;p.reset(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1024&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用reset将一个新的指针赋予一个shared_ptr.上面的例子中p指向了一个新对象。&lt;/p&gt;
&lt;h3 id=&#34;智能指针和异常&#34;&gt;智能指针和异常&lt;/h3&gt;
&lt;p&gt;使用智能指针时，即使程序块过早结束（发生异常），智能指针也能确保在内存不再需要时将其释放。&lt;/p&gt;
&lt;p&gt;与之相对的，当发生异常时，我们直接管理的内存不会自动释放。如果使用内置指针管理内存，且在new之后再对应的delete之前发生异常，内存不会被释放。&lt;/p&gt;
&lt;h3 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h3&gt;
&lt;p&gt;一个unique_ptr&lt;strong&gt;拥有&lt;/strong&gt;它所指向的对象，某个时刻只能有&lt;strong&gt;一个unique_ptr指向一个给定对象&lt;/strong&gt;，因此其&lt;strong&gt;不支持普通的拷贝或赋值&lt;/strong&gt;操作；当unique_ptr被销毁时，它所指向的对象也被销毁。&lt;/p&gt;
&lt;p&gt;unique_ptr没有类似于make_shared的标准库函数返回一个shared_ptr；我们定义一个unique_ptr时，需要将其绑定到一个&lt;strong&gt;new返回的指针&lt;/strong&gt;上；初始化unique_ptr必须采用&lt;strong&gt;直接初始化&lt;/strong&gt;形式，即使用括号直接初始化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p2(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;42&lt;/span&gt;));	&lt;span style=&#34;color:#888&#34;&gt;//p2指向一个值为42的int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;unique_ptr的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;T, D&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; u(d)	&lt;span style=&#34;color:#888&#34;&gt;//空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;	&lt;span style=&#34;color:#888&#34;&gt;//释放u指向的对象，将u置为空
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u.release()	&lt;span style=&#34;color:#888&#34;&gt;//u放弃对指针的控制权，返回指针，并将u置为空
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u.reset()	&lt;span style=&#34;color:#888&#34;&gt;//释放u指向的对象
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;u.reset(q)	&lt;span style=&#34;color:#888&#34;&gt;//q为内置指针，另u指向这个对象
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然我们不能拷贝或赋值unique_ptr，但可以通过调用&lt;strong&gt;release或reset&lt;/strong&gt;将指针的所有权从一个unique_ptr转移给另一个unique：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p2(p1.release());&lt;span style=&#34;color:#888&#34;&gt;//release将p1置为空
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; p3(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; string(&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Trex&amp;#34;&lt;/span&gt;));
p2.reset(p3.release());	&lt;span style=&#34;color:#888&#34;&gt;//reset释放了p2原来指向的内存
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;weak_ptr&#34;&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;weak_ptr是一种&lt;strong&gt;不控制所指向对象生存期&lt;/strong&gt;的智能指针，它指向一个&lt;strong&gt;shared_ptr管理的对象&lt;/strong&gt;。将一个weak_ptr绑定到shared_ptr&lt;strong&gt;不会改变对象的引用计数&lt;/strong&gt;。一旦最后一只指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。weak_ptr的名字抓住了这种指针弱共享的特点。&lt;/p&gt;
&lt;h2 id=&#34;动态数组&#34;&gt;动态数组&lt;/h2&gt;
&lt;p&gt;可以一次为很多对象分配动态内存。C++语言和标准库提供了两种一次分配一个对象数组的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用new表达式语法&lt;/li&gt;
&lt;li&gt;标准库中allocator的类，允许我们将分配和初始化分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单，更不容易出现内存管理错误并可能有更好的性能。&lt;/p&gt;
&lt;h3 id=&#34;new和数组&#34;&gt;new和数组&lt;/h3&gt;
&lt;p&gt;为了让new分配一个对象数组，要在类型名之后跟一对&lt;strong&gt;方括号&lt;/strong&gt;，在其中要指明分配对象的数目。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;*&lt;/span&gt;pia &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;32&lt;/span&gt;];	&lt;span style=&#34;color:#888&#34;&gt;//pia指向第一个int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的例子中，new分配32个int对象并返回指向第一个int对象的指针。&lt;/p&gt;
&lt;p&gt;也可以用一个表示数组类型的&lt;strong&gt;类型别名&lt;/strong&gt;来分配一个数组，这样new表达式就不需要方括号了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;智能指针和动态数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标准库提供了一个可以管理new分配的数组的unique_ptr版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unique_ptr&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;[]&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; up(&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;10&lt;/span&gt;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了用一个unique_ptr管理动态数组，必须在一个动态类型后面跟一对方括号。&lt;/p&gt;
&lt;h3 id=&#34;allocator类&#34;&gt;allocator类&lt;/h3&gt;
&lt;p&gt;标准库allocator类定义在头文件memory中，其帮助我们将内存分配和对象构造分离开来。它提供了一种类型感知的内存分配方法。&lt;/p&gt;
&lt;h2 id=&#34;使用标准库文本查询程序&#34;&gt;使用标准库：文本查询程序&lt;/h2&gt;
&lt;p&gt;这个例子作为标准库相关内容学习的总结。&lt;/p&gt;
&lt;p&gt;现代C++程序应该尽可能使用智能指针。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Primer——CH11 关联容器</title>
        <link>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Mon, 15 Nov 2021 15:32:41 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/ -&lt;p&gt;键值对。&lt;/p&gt;
&lt;p&gt;set和map&lt;/p&gt;
&lt;h2 id=&#34;使用关联容器&#34;&gt;使用关联容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;map： 关联数组，关键字——值。&lt;/li&gt;
&lt;li&gt;set：关键字的简单集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以进行列表初始化&lt;/p&gt;
&lt;h2 id=&#34;关联容器概述&#34;&gt;关联容器概述&lt;/h2&gt;
&lt;p&gt;关联容器不支持顺序容器的位置相关的操作，例如&lt;code&gt;push_front&lt;/code&gt;，原因是关联容器中的值是按照关键字存储的，这些操作没有意义。&lt;/p&gt;
&lt;p&gt;另外无序容器还提供调整哈希性能的操作。&lt;/p&gt;
&lt;h3 id=&#34;定义关联容器&#34;&gt;定义关联容器&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; word_count;	&lt;span style=&#34;color:#888&#34;&gt;//空容器
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;set&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; exclude &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;the&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;but&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;and&amp;#34;&lt;/span&gt;};
map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; authors &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {{&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Joyce&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;James&amp;#34;&lt;/span&gt;},
                               {&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Austen&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Jane&amp;#34;&lt;/span&gt;}};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初始化一个map时必须提供关键字类型和值类型。&lt;/p&gt;
&lt;h3 id=&#34;关键字类型的要求&#34;&gt;关键字类型的要求&lt;/h3&gt;
&lt;p&gt;对于有序容器map、set、multimap、multiset，关键字类型必须定义元素比较的方法。所提供的操作必须在关键字类型上定义一个严格弱序。&lt;/p&gt;
&lt;h3 id=&#34;pair类型&#34;&gt;pair类型&lt;/h3&gt;
&lt;p&gt;定义在头文件utility中。&lt;/p&gt;
&lt;p&gt;pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;pair&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; anon;
pair&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, string&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; author{&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;James&amp;#34;&lt;/span&gt;, &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Joyce&amp;#34;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;pair的数据成员是public的，两个成员分别命名为first和second，可以用普通的成员访问符号来访问它们。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; w.first &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; w.second &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;关联容器操作&#34;&gt;关联容器操作&lt;/h2&gt;
&lt;p&gt;除了之前在顺序容器P295页列出的类型，关联容器还定义了以下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key_type&lt;/code&gt;：此容器类型的关键字类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapped_type&lt;/code&gt;：每个关键字关联的类型，只适用于map&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value_type&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;对于set而言，与&lt;code&gt;key_type&lt;/code&gt;相同&lt;/li&gt;
&lt;li&gt;对于map而言，为&lt;code&gt;pair&amp;lt;const key_type, mapped_type&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用作用域运算符来提取一个类型的成员，例如：&lt;code&gt;map&amp;lt;string, int&amp;gt;::key_value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;只有map类型才定义了&lt;code&gt;mapped_type&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;关联容器迭代器&#34;&gt;关联容器迭代器&lt;/h3&gt;
&lt;p&gt;解引用一个关联容器迭代器时，就能得到一个类型为容器的value_type的值的引用。对于&lt;strong&gt;map&lt;/strong&gt;而言，&lt;strong&gt;value_type是一个pair类型&lt;/strong&gt;，其first成员保存&lt;strong&gt;const的关键字&lt;/strong&gt;，second成员保存值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; map_it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; word_count.begin();
&lt;span style=&#34;color:#888&#34;&gt;//*map_it是指向一个pair&amp;lt;const string, size_t&amp;gt;对象的引用
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;first;	&lt;span style=&#34;color:#888&#34;&gt;//打印此元素的关键字
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;first &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;new key&amp;#34;&lt;/span&gt;;	&lt;span style=&#34;color:#888&#34;&gt;//错误，关键字是const的
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切记，一个map的value_type是一个pair，可以改变pair的值但不能改变关键字成员的值。&lt;/p&gt;
&lt;p&gt;我们通常不对关联容器使用泛型算法，&lt;strong&gt;关键字是const&lt;/strong&gt;这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是count的，map中元素是pair，其第一个成员是const的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遍历关联容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;map和set都支持begin和end操作，我们可以用这些函数获取迭代器，然后用迭代器来遍历容器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;auto&lt;/span&gt; map_it &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; word_count.cbegin();
&lt;span style=&#34;color:#080;font-weight:bold&#34;&gt;while&lt;/span&gt; (map_it &lt;span style=&#34;color:#333&#34;&gt;!=&lt;/span&gt; word_count.cend()) {
    cout &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;first &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;occurs &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; map_it&lt;span style=&#34;color:#333&#34;&gt;-&amp;gt;&lt;/span&gt;second &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;times&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#333&#34;&gt;++&lt;/span&gt;map_it;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外我们通常不对关联容器使用泛型算法，关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法要写入值。&lt;/p&gt;
&lt;h3 id=&#34;添加元素&#34;&gt;添加元素&lt;/h3&gt;
&lt;p&gt;关联容器的&lt;strong&gt;insert成员&lt;/strong&gt;向容器中添加一个元素或一个元素范围，map和set不包含重复关键字，因此插入一个已存在的元素对容器没有任何影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向map添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记住元素类型是pair。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;word_count.insert({word, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;});
word_count.insert(make_pair(word, &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;c.emplace(args)&lt;/code&gt;：对于map和set，只有当元素的关键字不在c中时才插入（或构造）元素。&lt;/p&gt;
&lt;p&gt;insert返回的值依赖于容器类型和参数，对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功，pair的first成员是一个&lt;strong&gt;迭代器&lt;/strong&gt;，指向具有给定关键字的元素；second成员是一个&lt;strong&gt;bool值&lt;/strong&gt;，指出元素时插入成功还是已经存在于容器中。&lt;/p&gt;
&lt;h3 id=&#34;删除元素&#34;&gt;删除元素&lt;/h3&gt;
&lt;p&gt;关联容器定义了三个版本的erase，与顺序容器一样，我们可以通过传递给erase一个&lt;strong&gt;迭代器&lt;/strong&gt;或一个&lt;strong&gt;迭代器对&lt;/strong&gt;来删除一个元素或一个元素范围。&lt;/p&gt;
&lt;p&gt;关联容器额外提供一个erase操作，接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量。&lt;/p&gt;
&lt;h3 id=&#34;map的下标操作&#34;&gt;map的下标操作&lt;/h3&gt;
&lt;p&gt;map和unordered_map容器提供了下标运算符和一个对应的at函数，set类型不支持下标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; word_count;
word_count[&lt;span style=&#34;background-color:#fff0f0&#34;&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;] &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;c[k]	&lt;span style=&#34;color:#888&#34;&gt;//返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;c.at(k)	&lt;span style=&#34;color:#888&#34;&gt;//访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;访问元素&#34;&gt;访问元素&lt;/h3&gt;
&lt;p&gt;对于不允许重复关键字的容器，使用find和count没什么区别，但对于重复关键字的容器，count还会做更多的工作：如果元素在容器中，能够统计有多少个元素有相同的关键字。如果不需要技术，虽好使用find。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;set&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#339;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; iset &lt;span style=&#34;color:#333&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;3&lt;/span&gt;};
iset.find(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//返回一个迭代器，指向key == 1的元素
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;iset.count(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//返回1
&lt;/span&gt;&lt;span style=&#34;color:#888&#34;&gt;&lt;/span&gt;iset.count(&lt;span style=&#34;color:#00d;font-weight:bold&#34;&gt;11&lt;/span&gt;);	&lt;span style=&#34;color:#888&#34;&gt;//返回0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;无序容器&#34;&gt;无序容器&lt;/h2&gt;
&lt;p&gt;C++11 新定义了4个无序关联容器。这些容器不是使用比较运算符来组织元素，而是使用一个&lt;strong&gt;哈希函数&lt;/strong&gt;和关键字类型的**==运算符**。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。&lt;/p&gt;
&lt;p&gt;虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到更好的效果还要进行一些性能测试和调优。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;unordered_map&lt;span style=&#34;color:#333&#34;&gt;&amp;lt;&lt;/span&gt;string, size_t&lt;span style=&#34;color:#333&#34;&gt;&amp;gt;&lt;/span&gt; word_count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;管理桶&#34;&gt;管理桶&lt;/h3&gt;
&lt;p&gt;无序容器在存储上组织为&lt;strong&gt;一组桶&lt;/strong&gt;，每个桶保存&lt;strong&gt;零个或多个元素&lt;/strong&gt;。无序容器使用一个&lt;strong&gt;哈希函数&lt;/strong&gt;将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个&lt;strong&gt;特定哈希值&lt;/strong&gt;的所有元素都保存在相同的桶中（有点像散列表处理冲突时使用的拉链法）。无需容器的性能依赖于哈希函数的质量和桶的数量。&lt;/p&gt;
&lt;h3 id=&#34;无需容器对关键字类型的要求&#34;&gt;无需容器对关键字类型的要求&lt;/h3&gt;
&lt;p&gt;默认情况下，无需容器使用关键字类型的==运算符来比较元素，它们还是用一个&lt;strong&gt;hash&amp;lt;key_type&amp;gt;类型&lt;/strong&gt;的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。&lt;/p&gt;
- https://eternityqjl.top/posts/cpp%E5%9B%9E%E9%A1%BE3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/ - 2019-2021 By Jialong</description>
        </item>
    
    
    
        <item>
        <title>现代操作系统学习日志——文件系统</title>
        <link>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Sat, 13 Nov 2021 19:54:09 +0800</pubDate>
        
        <guid>https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
        <description>Jialong&#39;s Blog https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ -&lt;p&gt;所有计算机应用程序都需要存储和检索信息。&lt;/p&gt;
&lt;p&gt;进程运行时可以在自己的地址空间中存储一定量的信息，但存储容量易受到虚拟地址空间大小的限制。另外，进程终止时，它保存的信息也随之丢失，但对于很多应用（例如数据库）而言，有关信息必须能够保存很长时间甚至永久保留。第三个问题是经常需要多个进程同时访问同一信息，解决方法是使得信息本身独立于任何一个进程。&lt;/p&gt;
&lt;p&gt;所以，长期存储信息有以下基本要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够存储大量信息&lt;/li&gt;
&lt;li&gt;使用信息的进程终止时，信息仍旧存在&lt;/li&gt;
&lt;li&gt;必须能使多个进程并发访问有关信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘能够进行长期存储，我们将其当作一种大小固定的块的线性序列，并且支持读块k和写块k的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件&lt;/strong&gt;是进程创建的信息逻辑单元，一块磁盘中可以有很多文件，每个文件是独立于其他文件的，文件是对磁盘的建模，而不是对RAM的建模。&lt;/p&gt;
&lt;p&gt;进程可以读取已经存在的文件，并在需要时建立新的文件。存储在文件中的信息必须是持久的。&lt;/p&gt;
&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;
&lt;h3 id=&#34;文件命名&#34;&gt;文件命名&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;大小写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展名&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件结构&#34;&gt;文件结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无结构的字节序列（Windows和Unix采用这种方法）&lt;/li&gt;
&lt;li&gt;具有固定长度记录的序列&lt;/li&gt;
&lt;li&gt;有一棵树构成的文件结构，每个记录不必具有相同长度，记录的固定位置上有一个键字段（在一些处理商业数据的大型计算机上广泛应用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件类型&#34;&gt;文件类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;普通文件
&lt;ul&gt;
&lt;li&gt;ASCII文件。优势是可以显示和打印，可以用任何文本编辑器进行编辑&lt;/li&gt;
&lt;li&gt;二进制文件。有一定的内部结构，使用该文件的程序才了解这种结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目录：管理文件系统结构的系统文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，Unix还具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符特殊文件。与I/O有关，用于串行I/O设备。&lt;/li&gt;
&lt;li&gt;块特殊文件。用于磁盘设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个普通文件的例子：一个可执行文件、一个存档文件。详情见书上。&lt;/p&gt;
&lt;h3 id=&#34;文件访问&#34;&gt;文件访问&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;顺序访问&lt;/li&gt;
&lt;li&gt;随机访问文件
&lt;ul&gt;
&lt;li&gt;read操作给出开始读文件的位置&lt;/li&gt;
&lt;li&gt;用seek操作设置当前位置（Windows和UNIX使用这种方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件属性&#34;&gt;文件属性&lt;/h3&gt;
&lt;p&gt;除了文件名和数据外的与文件相关的信息，称为文件&lt;strong&gt;属性&lt;/strong&gt;或&lt;strong&gt;元数据&lt;/strong&gt;。这些信息在不同系统中有着很大差异。主要具有以下属性类别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与文件保护相关的属性。创建者、所有者、口令等。&lt;/li&gt;
&lt;li&gt;标志。用于控制或启动某些特殊属性。&lt;/li&gt;
&lt;li&gt;用关键字查找记录的文件中的属性：记录长度、键的位置和长度等。&lt;/li&gt;
&lt;li&gt;创建时间相关属性。&lt;/li&gt;
&lt;li&gt;当前大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;p&gt;与文件有关的最常用的一些系统调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;open&lt;/li&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;write&lt;/li&gt;
&lt;li&gt;append。write的限制格式，只能从文件末尾添加数据。&lt;/li&gt;
&lt;li&gt;seek&lt;/li&gt;
&lt;li&gt;get attributes&lt;/li&gt;
&lt;li&gt;set attributes&lt;/li&gt;
&lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一个文件系统调用实现复制的简单程序&#34;&gt;一个文件系统调用实现复制的简单程序&lt;/h3&gt;
&lt;p&gt;详情见书上。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;文件系统提供&lt;strong&gt;目录或文件夹&lt;/strong&gt;用于记录文件的位置。很多系统中目录本身也是文件。&lt;/p&gt;
&lt;h3 id=&#34;一级目录&#34;&gt;一级目录&lt;/h3&gt;
&lt;p&gt;有时也称为根目录。&lt;strong&gt;只有一个目录&lt;/strong&gt;，部分原因是只有一个用户。这种目录系统常用于嵌入式装置中。&lt;/p&gt;
&lt;h3 id=&#34;层级目录系统&#34;&gt;层级目录系统&lt;/h3&gt;
&lt;p&gt;使用层次结构（即一个目录树）。可以把文件以自然的方式进行分组，每个而用户可以为自己的目录树拥有自己的私人根目录。用户可以创建任意数量的子目录。&lt;/p&gt;
&lt;h3 id=&#34;路径名&#34;&gt;路径名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;绝对路径名&lt;/li&gt;
&lt;li&gt;相对路径名（又称工作目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持层次目录结构的大多数操作系统在每个目录中有两个特殊目录项&lt;code&gt;.&lt;/code&gt;和&lt;code&gt;..&lt;/code&gt;，常常读作dot和dotdot。dot指当前目录，dotdot指的是其父目录。使用一些与目录相关的命令时可以使用这两个目录项。&lt;/p&gt;
&lt;h3 id=&#34;目录操作&#34;&gt;目录操作&lt;/h3&gt;
&lt;p&gt;这里以UNIX为例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create（有时通过mdir完成）&lt;/li&gt;
&lt;li&gt;delete：删除目录，只有空目录可以删除。&lt;/li&gt;
&lt;li&gt;opendir&lt;/li&gt;
&lt;li&gt;closedir&lt;/li&gt;
&lt;li&gt;readdir&lt;/li&gt;
&lt;li&gt;rename&lt;/li&gt;
&lt;li&gt;link。链接技术允许多个目录中出现同一个文件。这种类型的链接增加了文件的i节点（i-node）计数器的计数，有时称为硬链接。&lt;/li&gt;
&lt;li&gt;unlink。删除目录项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件系统的实现&#34;&gt;文件系统的实现&lt;/h2&gt;
&lt;h3 id=&#34;文件系统布局&#34;&gt;文件系统布局&lt;/h3&gt;
&lt;p&gt;文件系统存放在&lt;strong&gt;磁盘&lt;/strong&gt;上，多数磁盘划分为&lt;strong&gt;一个或多个分区&lt;/strong&gt;，每个分区有一个独立的文件系统。&lt;/p&gt;
&lt;p&gt;磁盘的&lt;strong&gt;0号扇区&lt;/strong&gt;称为&lt;strong&gt;主引导记录（Master Boot Record，MBR）&lt;/strong&gt;，用来引导计算机。&lt;/p&gt;
&lt;p&gt;MBR的结尾是&lt;strong&gt;分区表&lt;/strong&gt;，该表给出了每个分区的起始地址和结束地址。&lt;/p&gt;
&lt;p&gt;计算机被引导时，BIOS读入并执行MBR，确定活动分区，读入其第一个块，称为&lt;strong&gt;引导块&lt;/strong&gt;，并执行之。引导块中的程序将装载该分区中的操作系统。为了统一，每个分区都从一个引导块开始。&lt;/p&gt;
&lt;p&gt;除了从引导块开始，磁盘分区的布局随着文件系统的不同而变化。文件系统通常包含：超级块、空闲空间管理、i节点、根目录、其他文件和目录。&lt;/p&gt;
&lt;h3 id=&#34;文件的实现&#34;&gt;文件的实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;连续分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把每个文件作为一连串连续数据块存储在磁盘中。&lt;/p&gt;
&lt;p&gt;优点：记录每个文件的位置较为简单，只要记住第一块的磁盘地址和文件块数；读操作性能好，只需要一次寻找（一个块）。&lt;/p&gt;
&lt;p&gt;缺点：会产生碎片。&lt;/p&gt;
&lt;p&gt;CD-ROM和DVD使用的就是这种方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个文件构造磁盘块链表，即每个块的第一个字作为指向下一块的指针，块的其他部分存储数据。&lt;/p&gt;
&lt;p&gt;这一方法可以中分利用每个磁盘块。&lt;/p&gt;
&lt;p&gt;这种分配方法中，顺序读文件十分方便，但随机访问相当缓慢。另外，指针占去了一些字节，每个磁盘块存储数据的字节数不再是2的整数次幂。这样怪异的大小降低了系统的运行效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采用内存中的表进行链表分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取出每个磁盘块的指针字，把他们放在内存的一个表中，可以解决上述链表的不足。可以从一个块开始，顺着链走到最后，找到一个文件的全部磁盘块。内存中这样的一个表格称为&lt;strong&gt;文件分配表（File Allocation Table，FAT）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法的缺点是要把整个表都存放在内存中，例如对于一个1TB的磁盘和1KB大小的块，这张表需要有10亿项，每项至少3字节，这张表要占用2.4GB内存，显然并不实用。所以FAT方式不能较好地扩展并应用于大型磁盘中，只是在最初的MS-DOS文件系统比较实用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;i节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给每个文件赋予一个称为i节点的数据结构，其中列出了&lt;strong&gt;文件属性&lt;/strong&gt;和&lt;strong&gt;文件块的磁盘地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只有在对应&lt;strong&gt;文件打开时&lt;/strong&gt;其i节点才在&lt;strong&gt;内存中&lt;/strong&gt;，如果每个i节点占有n个字节，最多K个文件同时打开，那么为了打开文件而保留i节点的数组所占的全部内存仅仅是kn个字节，只需提前保留这么多空间即可。&lt;/p&gt;
&lt;p&gt;这个数组通常比FAT占据的空间要小。因为保留所有磁盘块的链表的表大小正比于磁盘自身的大小。而i节点在内存中数组的大小正比于要&lt;strong&gt;同时打开文件的数量&lt;/strong&gt;，与磁盘空间无关。&lt;/p&gt;
&lt;p&gt;i节点的一个问题是如果一个文件所含的磁盘块的数目超出i节点所能容纳的数据怎么办。解决方法为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后一个磁盘地址不指向数据块，指向一个包含额外磁盘块地址的块的地址&lt;/li&gt;
&lt;li&gt;可以有两个或更多个包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。NTFS采用了相似的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;目录的实现&#34;&gt;目录的实现&lt;/h3&gt;
&lt;p&gt;读文件前必须先打开文件。操作系统利用用户给出的&lt;strong&gt;路径名&lt;/strong&gt;找到相应的&lt;strong&gt;目录项&lt;/strong&gt;。目录项中提供了查找文件磁盘块所需的信息，因系统而异，可以是上一节中介绍的几种方法对应的信息，如整个文件的磁盘地址（连续分配）、第一个块的编号（两种链表分配方案）、i节点号。&lt;/p&gt;
&lt;p&gt;目录系统的主要功能就是把&lt;strong&gt;ASCII文件名&lt;/strong&gt;映射成&lt;strong&gt;定位文件数据所需的信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与此相关的问题是在何处&lt;strong&gt;存放文件属性&lt;/strong&gt;，共有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接存放在&lt;strong&gt;目录项&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录中有一个固定大小的目录项列表，每个文件对应一项，其中包含文件名、文件属性的结构体以及说明磁盘块位置的一个或多个磁盘地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存放在&lt;strong&gt;i节点&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用i节点系统采用的方式，不存放在目录项中。这种情形下&lt;strong&gt;目录项&lt;/strong&gt;会更短：只有&lt;strong&gt;文件名和i节点号&lt;/strong&gt;，这种方法更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现可变长的长文件名的方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种方法是放弃所有目录项一样大。每个目录项有一个固定部分，这个固定部分以目录项长度开始，后面是固定格式的数据，包括各种属性，最后才是一个任意长度的实际文件名。为了使每个目录项从字的边界开始，每个文件名被填充成整数个字。这种方法的缺点是一走文件后引入了一个长度可变的空闲，下一个文件不一定适合这个空隙。另外，一个目录项可能分布在多个内存页面，读取文件名时可能发生缺页。&lt;/li&gt;
&lt;li&gt;另一种方法是使目录项有固定长度，文件名存放在目录后面的堆中。优点是移走一个文件的目录项后，另一个文件的目录项可以适合这个空隙。另外要对堆进行管理，处理文件名时还可能出现缺页。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加速查找文件名的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在每个目录中使用散列表进行查找。一般使用拉链法处理散列表的冲突。&lt;/p&gt;
&lt;p&gt;另一种加快大型目录查找速度的方法是将查找结果存入高速缓存。&lt;/p&gt;
&lt;h3 id=&#34;共享文件&#34;&gt;共享文件&lt;/h3&gt;
&lt;p&gt;通过&lt;strong&gt;链接&lt;/strong&gt;来实现不同目录的用户共享同一个而文件，这样，文件系统本身就是一个&lt;strong&gt;有向无环图DAG&lt;/strong&gt;而不是一棵树，这使得文件系统维护变得复杂，但也是必须付出的代价。&lt;/p&gt;
&lt;p&gt;共享也带来一些问题。若目录中包含磁盘地址，当链接文件时，必须把A目录中的地址复制到B目录，如果A或B随后又向目录中添加了内容，则新的数据块之列入进行添加工作的用户目录中，其他用户对此不知情。解决这个问题的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构，目录指向这个小型数据结构。UNIX中使用的就是&lt;strong&gt;i节点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号链接法&lt;/strong&gt;，又称软链接法。系统建立一个类型为LINK的新文件，将其存放在A的目录下，使得A与B的一个文件存在链接。新文件中只包含了它所链接的文件的路径名。当A读该链接文件时，操作系统看到要读的文件类型为LINK，则找到该文件所链接的文件的名字，去读那个文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;日志结构文件系统&#34;&gt;日志结构文件系统&lt;/h3&gt;
&lt;p&gt;解决磁盘寻道时间没有快速发展的问题。&lt;/p&gt;
&lt;h3 id=&#34;日志文件系统&#34;&gt;日志文件系统&lt;/h3&gt;
&lt;p&gt;借鉴日志结构文件系统的实际应用，基本思想是保存一个用于记录系统下一步要做什么的日志。这样当系统在完成它们即将完成的任务前崩溃时，重新启动后，可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。&lt;/p&gt;
&lt;h3 id=&#34;虚拟文件系统&#34;&gt;虚拟文件系统&lt;/h3&gt;
&lt;p&gt;在同一个操作系统下可能使用很多不同的文件系统。Windows有一个主要的NTFS文件系统，但也包含老的FAT-32或FAT-16驱动器或分区，并且不时需要一个CD-ROM或DVD。Windows通过指定不同盘符来处理这些不同的文件系统。当一个进程打开一个文件，盘符是显式或隐式存在的，所以Windows知道向哪个文件系统传递请求，不需要整合不同类型文件系统。&lt;/p&gt;
&lt;p&gt;相比之下，现代UNIX系统将多种文件系统整合到一个统一的结构中。从用户的观点看，只有一个文件系统层级，他们事实上是多种不相容的文件系统，对用户和进程不可见。&lt;/p&gt;
&lt;p&gt;绝大多数UNIX操作系统都使用虚拟文件系统（Virtual File System, VFS）。关键思想就是抽象出所有文件系统共有的部分，并将这部分单独的代码放在单独一层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.jpg&#34; alt=&#34;虚拟文件系统&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件系统管理和优化&#34;&gt;文件系统管理和优化&lt;/h2&gt;
&lt;h3 id=&#34;磁盘空间管理&#34;&gt;磁盘空间管理&lt;/h3&gt;
&lt;h3 id=&#34;文件系统备份&#34;&gt;文件系统备份&lt;/h3&gt;
&lt;h3 id=&#34;文件系统的一致性&#34;&gt;文件系统的一致性&lt;/h3&gt;
&lt;h3 id=&#34;文件系统性能&#34;&gt;文件系统性能&lt;/h3&gt;
&lt;h3 id=&#34;磁盘碎片整理&#34;&gt;磁盘碎片整理&lt;/h3&gt;
- https://eternityqjl.top/posts/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ - 2019-2021 By Jialong</description>
        </item>
    
    
  </channel>
</rss> 