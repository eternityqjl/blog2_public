<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jialong's Blog</title><link>https://eternityqjl.github.io/blog2_public/</link><description>Recent content on Jialong's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2019-2021 By Jialong</copyright><lastBuildDate>Fri, 13 Aug 2021 16:15:00 +0800</lastBuildDate><atom:link href="https://eternityqjl.github.io/blog2_public/index.xml" rel="self" type="application/rss+xml"/><item><title>算法的时间复杂度和空间复杂度</title><link>https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link><pubDate>Fri, 13 Aug 2021 16:15:00 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/ -&lt;p>用来衡量不同算法之间的优劣。&lt;/p>
&lt;ul>
&lt;li>时间维度：执行当前算法所&lt;strong>消耗的时间&lt;/strong>，用时间复杂度来描述。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>空间维度：执行当前算法需要&lt;strong>占用的内存空间&lt;/strong>，我们通常用空间复杂度来描述。&lt;/li>
&lt;/ul>
&lt;h2 id="时间复杂度">时间复杂度&lt;/h2>
&lt;p>&lt;strong>大O符号表示法&lt;/strong> ，即 T(n) = O(f(n))，这是时间复杂度的公式，f(n)表示&lt;strong>每行代码执行次数之和&lt;/strong>，O表示&lt;strong>正比例关系&lt;/strong>。&lt;/p>
&lt;p>我们通过以下一个程序举例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">for&lt;/span>(i&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>; i&lt;span style="color:#333">&amp;lt;=&lt;/span>n; &lt;span style="color:#333">++&lt;/span>i)
{
j &lt;span style="color:#333">=&lt;/span> i;
j&lt;span style="color:#333">++&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设每行代码的执行时间都一样，我们用&lt;strong>1颗粒时间&lt;/strong>来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间，那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)&lt;/p>
&lt;p>大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。&lt;/p>
&lt;p>如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。&lt;/p>
&lt;h3 id="时间复杂度级">时间复杂度级&lt;/h3>
&lt;p>常见的时间复杂度级有：&lt;/p>
&lt;ul>
&lt;li>常数阶O(1)&lt;/li>
&lt;li>对数阶O(logN)&lt;/li>
&lt;li>线性阶O(n)&lt;/li>
&lt;li>线性对数阶O(nlogN)&lt;/li>
&lt;li>平方阶O(n²)&lt;/li>
&lt;li>立方阶O(n³)&lt;/li>
&lt;li>K次方阶O(n^k)&lt;/li>
&lt;li>指数阶(2^n)&lt;/li>
&lt;/ul>
&lt;p>从上向下时间复杂度越来越大，执行效率越来越低。&lt;/p>
&lt;p>下面来选取一些来举例：&lt;/p>
&lt;h3 id="常数阶o1">常数阶O(1)&lt;/h3>
&lt;p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>;
&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>;
&lt;span style="color:#333">++&lt;/span>i;
j&lt;span style="color:#333">++&lt;/span>;
&lt;span style="color:#339;font-weight:bold">int&lt;/span> m &lt;span style="color:#333">=&lt;/span> i &lt;span style="color:#333">+&lt;/span> j;
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线性阶on">线性阶O(n)&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">for&lt;/span>(i&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>; i&lt;span style="color:#333">&amp;lt;=&lt;/span>n; &lt;span style="color:#333">++&lt;/span>i)
{
j &lt;span style="color:#333">=&lt;/span> i;
j&lt;span style="color:#333">++&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>for循环中的代码会执行n遍。&lt;/p>
&lt;h3 id="对数阶ologn">对数阶O(logN)&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>;
&lt;span style="color:#080;font-weight:bold">while&lt;/span>(i&lt;span style="color:#333">&amp;lt;&lt;/span>n)
{
i &lt;span style="color:#333">=&lt;/span> i &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里可以试着求解以下，假设循环x次后，i就大于n，循环就结束了，即$2^x=n$，那么$x=\log_2n$。即当循环$\log_2n$后代码就结束了，因此时间复杂度为O(logN).&lt;/p>
&lt;h3 id="线性对数阶onlongn">线性对数阶O(nlongN)&lt;/h3>
&lt;p>将时间复杂度为O(longN)的代码循环n遍就可以得到，将上面的代码稍作修改即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">for&lt;/span>(m&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>; m&lt;span style="color:#333">&amp;lt;&lt;/span>n; m&lt;span style="color:#333">++&lt;/span>)
{
i &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>;
&lt;span style="color:#080;font-weight:bold">while&lt;/span>(i&lt;span style="color:#333">&amp;lt;&lt;/span>n)
{
i &lt;span style="color:#333">=&lt;/span> i &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="平方阶on2">平方阶O(n^2)&lt;/h3>
&lt;p>很容易理解，将两个n次循环嵌套即可得到：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">for&lt;/span>(x&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>; i&lt;span style="color:#333">&amp;lt;=&lt;/span>n; x&lt;span style="color:#333">++&lt;/span>)
{
&lt;span style="color:#080;font-weight:bold">for&lt;/span>(i&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>; i&lt;span style="color:#333">&amp;lt;=&lt;/span>n; i&lt;span style="color:#333">++&lt;/span>)
{
j &lt;span style="color:#333">=&lt;/span> i;
j&lt;span style="color:#333">++&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="立方阶on3k次方阶onk">立方阶O(n^3)、k次方阶O(n^k)&lt;/h3>
&lt;p>与平方阶类似，立方阶相当于3层循环。&lt;/p>
&lt;h2 id="空间复杂度">空间复杂度&lt;/h2>
&lt;p>空间复杂度与时间复杂度相同，实际上也不是用来计算程序实际占用的空间的。&lt;/p>
&lt;p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。&lt;/p>
&lt;p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：&lt;/p>
&lt;h3 id="空间复杂度o1">空间复杂度O(1)&lt;/h3>
&lt;p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">int&lt;/span> i &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>;
&lt;span style="color:#339;font-weight:bold">int&lt;/span> j &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>;
&lt;span style="color:#333">++&lt;/span>i;
j&lt;span style="color:#333">++&lt;/span>;
&lt;span style="color:#339;font-weight:bold">int&lt;/span> m &lt;span style="color:#333">=&lt;/span> i &lt;span style="color:#333">+&lt;/span> j;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)&lt;/p>
&lt;h3 id="空间复杂度on">空间复杂度O(n)&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#339;font-weight:bold">int&lt;/span>&lt;span style="color:#333">[]&lt;/span> m &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span>&lt;span style="color:#333">[&lt;/span>n&lt;span style="color:#333">]&lt;/span>
&lt;span style="color:#06b;font-weight:bold">for&lt;/span>&lt;span style="color:#333">(&lt;/span>i&lt;span style="color:#333">=&lt;/span>1&lt;span style="color:#333">;&lt;/span> i&lt;span style="color:#333">&amp;lt;=&lt;/span>n&lt;span style="color:#333">;&lt;/span> &lt;span style="color:#333">++&lt;/span>i&lt;span style="color:#333">)&lt;/span>
&lt;span style="color:#333">{&lt;/span>
j &lt;span style="color:#333">=&lt;/span> i&lt;span style="color:#333">;&lt;/span>
j&lt;span style="color:#333">++;&lt;/span>
&lt;span style="color:#333">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行new了一个数组，这个数据占用的大小为n，第2-6行虽然有循环，但没有分配新的空间，因此空间复杂度看第一行即可，即S(n)=O(n)。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/ - 2019-2021 By Jialong</description></item><item><title>csapp: 3.程序的机器级表示</title><link>https://eternityqjl.github.io/blog2_public/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link><pubDate>Mon, 09 Aug 2021 16:08:05 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/ -&lt;h1 id="第三章-程序的机器级表示">第三章 程序的机器级表示&lt;/h1>
&lt;h2 id="历史观点">历史观点&lt;/h2>
&lt;p>典型的编译器在将C程序结构变换成机器代码时所做的转换。&lt;/p>
&lt;p>英特尔X86-64处理器的发展历史。&lt;/p>
&lt;p>从8086到Core i7&lt;/p>
&lt;h2 id="程序编码">程序编码&lt;/h2>
&lt;h3 id="机器级代码">机器级代码&lt;/h3>
&lt;p>对于机器级编程来说，两种抽象非常重要：&lt;/p>
&lt;ul>
&lt;li>由&lt;strong>指令集体系结构&lt;/strong>或**指令集架构(ISA, Instruction Set Architecture)**来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，以及每条指令对状态的影响。&lt;/li>
&lt;li>机器级程序使用的内存地址是&lt;strong>虚拟地址&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>x86-64机器码中，一些通常对C语言隐藏的处理器状态都是可见的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>程序计数器&lt;/strong>(PC，在x86-64中用%rip表示)：给出将要执行的下一条指令在内存中的地址&lt;/li>
&lt;li>&lt;strong>整数寄存器&lt;/strong>文件：包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址(对应C语言指针)或整数数据。&lt;/li>
&lt;li>&lt;strong>条件码寄存器&lt;/strong>：保存最近执行的算数或逻辑指令的状态信息，用来实现控制或数据流中的条件变化。&lt;/li>
&lt;/ul>
&lt;p>x86-64的虚拟地址由64位的字表示，但目前这些地址的&lt;strong>高16位&lt;/strong>必须设为零，相当于可以表示$2^{48}$或256TB内存范围内的一个字节。及目前的64位计算机只使用48位来表示地址范围。&lt;/p>
&lt;h3 id="代码示例">代码示例&lt;/h3>
&lt;p>机器对产生这些汇编语言指令的源代码几乎一无所知，全都是字节序列。&lt;/p>
&lt;p>生成可执行的代码需要对一组目标代码文件运行链接器，这组目标代码文件中必须含有一个main函数。&lt;/p>
&lt;p>链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。&lt;/p>
&lt;p>反汇编器&lt;/p>
&lt;h3 id="关于格式的注解">关于格式的注解&lt;/h3>
&lt;p>ATT与Intel汇编代码格式的区别&lt;/p>
&lt;ul>
&lt;li>Intel代码省略了指示大小的后缀。例如看到的指令为push和mov而不是pushq和movq。&lt;/li>
&lt;li>Intel代码胜率了寄存器名字前的%符号。&lt;/li>
&lt;li>Intel代码&lt;/li>
&lt;/ul>
&lt;h2 id="数据格式">数据格式&lt;/h2>
&lt;p>Intel用&lt;strong>字(word)&lt;strong>表示&lt;/strong>16位&lt;/strong>数据类型，因此称&lt;strong>32位&lt;/strong>数为&lt;strong>双字&lt;/strong>，称&lt;strong>64位&lt;/strong>数位&lt;strong>四字&lt;/strong>。&lt;/p>
&lt;p>下表给出了C语言基本数据类型对应的x86-64表示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">C声明&lt;/th>
&lt;th style="text-align:center">Intel数据类型&lt;/th>
&lt;th style="text-align:center">汇编代码后缀&lt;/th>
&lt;th style="text-align:center">大小(字节)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">char&lt;/td>
&lt;td style="text-align:center">字节&lt;/td>
&lt;td style="text-align:center">b&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">short&lt;/td>
&lt;td style="text-align:center">字&lt;/td>
&lt;td style="text-align:center">w&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">int&lt;/td>
&lt;td style="text-align:center">双字&lt;/td>
&lt;td style="text-align:center">l&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">long&lt;/td>
&lt;td style="text-align:center">四字&lt;/td>
&lt;td style="text-align:center">q&lt;/td>
&lt;td style="text-align:center">8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">char*&lt;/td>
&lt;td style="text-align:center">四字&lt;/td>
&lt;td style="text-align:center">q&lt;/td>
&lt;td style="text-align:center">8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">float&lt;/td>
&lt;td style="text-align:center">单精度&lt;/td>
&lt;td style="text-align:center">s&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">double&lt;/td>
&lt;td style="text-align:center">双精度&lt;/td>
&lt;td style="text-align:center">l&lt;/td>
&lt;td style="text-align:center">8&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明&lt;strong>操作数的大小&lt;/strong>。例如数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)、movq(传送四字)。&lt;/p>
&lt;p>浮点数和整数使用一组完全不同的指令和寄存器。&lt;/p>
&lt;h2 id="访问信息">访问信息&lt;/h2>
&lt;p>一个x86-64CPU包含一组&lt;strong>16个&lt;/strong>存储64位值的&lt;strong>通用寄存器&lt;/strong>，用来存储整数数据和指针。最初的8086有8个16位的通用寄存器，发展到现在的x86-64后，原来的8个寄存器扩展为了64位，标号从%rax到%rsp，除此之外还新增了8个寄存器，从%r8到%r15。&lt;/p>
&lt;p>在常见程序中不同寄存器扮演不同的角色，最特别的是栈指针%rsp，用来指明运行时栈的结束位置。&lt;/p>
&lt;p>另外15个寄存器的用法更加灵活，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值、以及存储局部和临时数据。&lt;/p>
&lt;h3 id="操作数指示符">操作数指示符&lt;/h3>
&lt;p>大多数指令具有一个或多个&lt;strong>操作数&lt;/strong>，指示出一个操作中要使用的源数据值以及放置结果的目的位置。源数据值可以以常数的形式给出，或从寄存器或内存中读出。结果可以存放在寄存器或内存中。操作数可以分为三类，分别为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>立即数&lt;/strong>：用来表示常数值，在ATT编码格式中，立即数是&lt;code>$&lt;/code>后跟一个用标准C表示法表示的整数，例如&lt;code>$0x1F&lt;/code>。&lt;/li>
&lt;li>&lt;strong>寄存器&lt;/strong>：表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应8位、16位、32位或64位。用符号$r_a$来表示任意寄存器$a$，用引用$R[r_a]$表示它的值。即将寄存器集合看作一个数组R，用寄存器标识符作为引用。&lt;/li>
&lt;li>&lt;strong>内存引用&lt;/strong>：根据计算出的地址访问某个内存位置。用符号$M_b[\text{Addr}]$表示对存储在内存中从Addr地址开始的b个字节值的引用，实际中一般省去下表b。&lt;/li>
&lt;/ul>
&lt;p>有多种不同的&lt;strong>寻址模式&lt;/strong>，最通用的形式为：$Imm(r_b,r_i,s)$，Imm表示一个立即数偏移，$r_b$表示一个基址寄存器，$r_i$表示一个变址寄存器，s表示一个比例因子，操作数值即有效地址为$M[Imm+R[r_b]+R[r_i]\cdot s]$。其他形式都是这种通用形式的特殊情况。&lt;/p>
&lt;h3 id="数据传送指令">数据传送指令&lt;/h3>
&lt;p>最频繁使用的指令是将数据从一个位置复制到另一个位置。这里会介绍很多种数据传送指令，他们或者源和目的类型不同，或者执行的转换不同，或者具有一些副作用。把许多不同指令划分为&lt;strong>指令类&lt;/strong>，每类中的指令执行相同操作，只不过操作数大小不同。&lt;/p>
&lt;p>&lt;strong>MOV类指令&lt;/strong>&lt;/p>
&lt;p>MOV类由四条指令组成，movb(字节), movw(字), movl(双字), movq(四字)。主要区别为他们操作的数据大小不同。&lt;/p>
&lt;p>&lt;code>MOV S, D&lt;/code>：将S(source)传送到D(destination)&lt;/p>
&lt;p>源操作数指定的值是一个&lt;strong>立即数&lt;/strong>，存储在寄存器或内存中；目的操作数指定一个&lt;strong>位置&lt;/strong>，要么是一个寄存器，要么是一个内存地址。&lt;/p>
&lt;p>x86-64的两个操作数&lt;strong>不能都指向内存位置&lt;/strong>，如果要将一个值从内存的一个位置复制到另一个位置，要先将该值读入寄存器，再将寄存器的值写入目标内存。&lt;/p>
&lt;p>movabsq指令能以任意64位立即数值作为源操作数，并且只能以寄存器为目的。&lt;/p>
&lt;p>&lt;strong>将较小源值复制到较大目的：使用MOVZ和MOVS&lt;/strong>&lt;/p>
&lt;p>MOVZ：把目的中剩余的字节填充为0&lt;/p>
&lt;p>MOVS：通过符号扩展来填充，把源操作的最高位进行复制&lt;/p>
&lt;h3 id="数据传送示例代码">数据传送示例代码&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">long&lt;/span> &lt;span style="color:#06b;font-weight:bold">exchange&lt;/span>(&lt;span style="color:#339;font-weight:bold">long&lt;/span> &lt;span style="color:#333">*&lt;/span>xp, &lt;span style="color:#339;font-weight:bold">long&lt;/span> y)
{
&lt;span style="color:#339;font-weight:bold">long&lt;/span> x &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#333">*&lt;/span>xp; &lt;span style="color:#888">//解引用操作符，把指针xp指向地址的数值放入寄存器x
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#333">*&lt;/span>xp &lt;span style="color:#333">=&lt;/span> y; &lt;span style="color:#888">//指针符号，把数y放入指针xp指向的地址
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> x;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code class="language-assembly" data-lang="assembly">;xp in %rdi, y in %rsi
exchange:
movq (%rdi), %rax
movq %rsi, (%rdi)
ret
&lt;/code>&lt;/pre>&lt;p>该例子说明了利用MOV指令从内存中读值到寄存器以及从寄存器写入内存。&lt;/p>
&lt;p>局部变量x通常保存在寄存器中，速度较快。&lt;/p>
&lt;h3 id="压入和弹出栈数据">压入和弹出栈数据&lt;/h3>
&lt;p>将数据压入程序栈中以及从程序栈中弹出数据。栈是一种数据结构，遵循&lt;strong>后进先出&lt;/strong>。弹出的值是最近被压入且仍在栈中的值。&lt;/p>
&lt;p>栈可以实现为一个数组，总是从数组的一端插入和删除值，这一端被称为&lt;strong>栈顶&lt;/strong>。&lt;/p>
&lt;p>程序栈存放于内存的一个区域，栈向下增长，即栈顶元素的地址是&lt;strong>最低&lt;/strong>的，根据惯例倒过来画栈，即栈顶在图的底部。栈指针%rsp保存着栈顶元素的地址。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">pushq S&lt;/td>
&lt;td style="text-align:center">R[%rsp]$\leftarrow$R[%rsp]-8; M[R[%rsp]]$\leftarrow$S&lt;/td>
&lt;td style="text-align:center">将四字压入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">popq D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$M[R[%rsp]]; R[%rsp]$\leftarrow$R[%rsp]+8&lt;/td>
&lt;td style="text-align:center">将四字弹出栈&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="算数和逻辑操作">算数和逻辑操作&lt;/h2>
&lt;h3 id="加载有效地址leaq">加载有效地址leaq&lt;/h3>
&lt;p>leaq指令能执行加法和有限形式的乘法，实际上是movq指令的变形。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">leaq S,D&lt;/td>
&lt;td style="text-align:center">D $\leftarrow$&amp;amp;S&lt;/td>
&lt;td style="text-align:center">加载有效地址&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>该指令实际并未引用内存，而是将有效地址写入到目的操作数。&amp;amp;为取地址符，即产生一个指针。&lt;/p>
&lt;p>例如如果寄存器%rdx的值为x，指令&lt;code>leaq 7(%rdx,%rdx,4),%rax&lt;/code>将寄存器%rax的值设置为5x+7。这种用法与有效地址的计算无关。&lt;/p>
&lt;p>目的操作数必须是一个寄存器。&lt;/p>
&lt;h3 id="一元和二元操作">一元和二元操作&lt;/h3>
&lt;p>一元操作指令和效果：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">INC D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D+1&lt;/td>
&lt;td style="text-align:center">加1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">DEC D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D-1&lt;/td>
&lt;td style="text-align:center">减1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NEG D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$-D&lt;/td>
&lt;td style="text-align:center">取负&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NOT D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$~D&lt;/td>
&lt;td style="text-align:center">取补&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>只有一个操作数，这个操作数可以是一个寄存器或内存位置。&lt;/p>
&lt;p>二元操作指令和效果：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">ADD S,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D+S&lt;/td>
&lt;td style="text-align:center">加&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">SUB S,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D-S&lt;/td>
&lt;td style="text-align:center">减&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">IMUL S,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D*S&lt;/td>
&lt;td style="text-align:center">乘&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">XOR S,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D^S&lt;/td>
&lt;td style="text-align:center">异或&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">OR S,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D|S&lt;/td>
&lt;td style="text-align:center">或&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">AND S,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D&amp;amp;S&lt;/td>
&lt;td style="text-align:center">与&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。&lt;/p>
&lt;p>当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写入内存。&lt;/p>
&lt;h3 id="移位操作">移位操作&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">SAL k,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D&amp;laquo;k&lt;/td>
&lt;td style="text-align:center">左移&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">SHL k,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D&amp;laquo;k&lt;/td>
&lt;td style="text-align:center">左移(等同于SAL)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">SAR k,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D$&amp;raquo;_A$k&lt;/td>
&lt;td style="text-align:center">算数右移&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">SHR k,D&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$D$&amp;raquo;_L$k&lt;/td>
&lt;td style="text-align:center">逻辑右移&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>先给出移位量k，第二项给出的是要移位的数。&lt;/p>
&lt;p>移位量可以是&lt;strong>立即数&lt;/strong>，或放在&lt;strong>单字节寄存器%cl&lt;/strong>中。目标操作数可以是一个寄存器或一个内存位置。&lt;/p>
&lt;h3 id="乘法和除法">乘法和除法&lt;/h3>
&lt;p>INTEL把16字节的数称为8字。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">imulq S&lt;/td>
&lt;td style="text-align:center">$R[%\text{rdx}]: R[%\text{rax}]\leftarrow S\times R[%\text{rax}]$&lt;/td>
&lt;td style="text-align:center">有符号全乘法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">mulq S&lt;/td>
&lt;td style="text-align:center">$R[%\text{rdx}]: R[%\text{rax}]\leftarrow S\times R[%\text{rax}]$&lt;/td>
&lt;td style="text-align:center">无符号全乘法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cqto&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">转换为八字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">idivq S&lt;/td>
&lt;td style="text-align:center">$R[%\text{rdx}]\leftarrow R[%\text{rdx}] : R[%\text{rax}] \ \text{mod} \ S$&lt;/td>
&lt;td style="text-align:center">有符号除法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">divq S&lt;/td>
&lt;td style="text-align:center">$R[%\text{rdx}]\leftarrow R[%\text{rdx}] : R[%\text{rax}] \ \text{mod} \ S$&lt;/td>
&lt;td style="text-align:center">无符号除法&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>imulq指令有两种不同形式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>双操作数&lt;/strong>乘法指令：是IMUL的一种形式，从两个64位操作数产生一个64位乘积&lt;/li>
&lt;li>&lt;strong>单操作数&lt;/strong>乘法指令：计算两个64位值的全128位乘积，一个是无符号数乘法(mulq)，另一个是补码乘法(imulq)，这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数即如上所示的S给出。乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。&lt;/li>
&lt;/ul>
&lt;p>cqto指令：隐含读出%rax的符号位，并将其复制到%rdx的所有位。&lt;/p>
&lt;p>汇编器能通过计算操作数数目，分辨想用哪条指令。&lt;/p>
&lt;p>乘法代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#579">#include&lt;/span> &lt;span style="color:#579">&amp;lt;inttypes.h&amp;gt;&lt;/span>&lt;span style="color:#579">
&lt;/span>&lt;span style="color:#579">&lt;/span>&lt;span style="color:#080;font-weight:bold">typedef&lt;/span> &lt;span style="color:#339;font-weight:bold">unsigned&lt;/span> __int128 uint128_t;
&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">store_uprod&lt;/span>(uint128_t &lt;span style="color:#333">*&lt;/span>dest, &lt;span style="color:#339;font-weight:bold">uint64_t&lt;/span> x, &lt;span style="color:#339;font-weight:bold">uint64_t&lt;/span> y) {
&lt;span style="color:#333">*&lt;/span>dest &lt;span style="color:#333">=&lt;/span> x &lt;span style="color:#333">*&lt;/span> (uint128_t) y;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将x和y显式地声明为64位数字。使用GCC提供的128位整数支持。这段代码指明得到的乘积应该存放在指针dest指向的16字节处。&lt;/p>
&lt;p>生成的汇编代码如下：&lt;/p>
&lt;pre>&lt;code class="language-assembly" data-lang="assembly">;dest in %rdi, x in %rsi, y in %rdx
store_uprod:
movq %rsi, %rax
mulq %rdx
movq %rax, (%rdi)
movq %rdx, 8(%rdi)
ret
&lt;/code>&lt;/pre>&lt;p>存储乘积需要两个movq，一个存储低8个字节，另一个存储高8个字节；由于该机器是小端法及其，所以高位字节存储在大地址。&lt;/p>
&lt;p>除法操作由&lt;strong>单操作数除法指令&lt;/strong>来实现的。&lt;/p>
&lt;p>有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax，将余数存储在寄存器%rdx。&lt;/p>
&lt;p>除法代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">remdiv&lt;/span>(&lt;span style="color:#339;font-weight:bold">long&lt;/span> x, &lt;span style="color:#339;font-weight:bold">long&lt;/span> y, &lt;span style="color:#339;font-weight:bold">long&lt;/span> &lt;span style="color:#333">*&lt;/span>qp, &lt;span style="color:#339;font-weight:bold">long&lt;/span> &lt;span style="color:#333">*&lt;/span>rp) {
&lt;span style="color:#339;font-weight:bold">long&lt;/span> q &lt;span style="color:#333">=&lt;/span> x&lt;span style="color:#333">/&lt;/span>y;
&lt;span style="color:#339;font-weight:bold">long&lt;/span> r &lt;span style="color:#333">=&lt;/span> x&lt;span style="color:#333">%&lt;/span>y;
&lt;span style="color:#333">*&lt;/span>qp &lt;span style="color:#333">=&lt;/span> q;
&lt;span style="color:#333">*&lt;/span>rp &lt;span style="color:#333">=&lt;/span> r;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>生成的汇编代码如下：&lt;/p>
&lt;pre>&lt;code class="language-assembly" data-lang="assembly">;x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
movq %rdx, %r8
movq %rdx, %rax
cqto
idivq %rsi
movq %rax, (%r8)
movq %rdx, (%rcx)
ret
&lt;/code>&lt;/pre>&lt;h2 id="控制">控制&lt;/h2>
&lt;p>条件和跳转。&lt;/p>
&lt;p>C语言中某些结构例如条件语句、循环语句和分支语句，要求有条件地执行，根据数据测试结果来改变控制流或数据流。&lt;/p>
&lt;h3 id="条件码">条件码&lt;/h3>
&lt;p>CPU除了整数寄存器还维护着一组单个位的&lt;strong>条件码寄存器&lt;/strong>，描述了最近的算术和逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。&lt;/p>
&lt;ul>
&lt;li>CF：进位标志。最近的操作使&lt;strong>最高位产生了进位&lt;/strong>则&lt;strong>置为1&lt;/strong>。可用来检测无符号操作的溢出。(carry)&lt;/li>
&lt;li>ZF：零标志。最近的操作得出的&lt;strong>结果为0&lt;/strong>则置为1。(zero)&lt;/li>
&lt;li>SF：符号标志。最近的操作得到的&lt;strong>结果为负数&lt;/strong>则置为1。(symbol)&lt;/li>
&lt;li>OF：溢出标志。最近的操作导致一个&lt;strong>补码溢出&lt;/strong>则置为1。(overflow)&lt;/li>
&lt;/ul>
&lt;p>(F代指Flag)&lt;/p>
&lt;h3 id="访问条件码">访问条件码&lt;/h3>
&lt;p>条件码通常不会直接读取，常用方法有：&lt;/p>
&lt;ul>
&lt;li>根据条件码的某种组合，将一个字节设置为0或1&lt;/li>
&lt;li>可以条件跳转到程序的某个其他部分&lt;/li>
&lt;li>可以有条件地传输数据&lt;/li>
&lt;/ul>
&lt;p>SET指令：第一种情况，根据条件码的某种组合，将一个字节设置为0或1。不同后缀的set指令指明了其所考虑的&lt;strong>条件码组合&lt;/strong>，不是指操作数的大小。&lt;/p>
&lt;p>一条SET指令的&lt;strong>目的操作数&lt;/strong>是&lt;strong>低位单字节寄存器&lt;/strong>元素之一，或&lt;strong>一个字节的内存位置&lt;/strong>，指令会将这个字节设置为0或1.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">同义名&lt;/th>
&lt;th style="text-align:center">效果&lt;/th>
&lt;th style="text-align:center">设置条件&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">sete D&lt;/td>
&lt;td style="text-align:center">setz&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$ZF&lt;/td>
&lt;td style="text-align:center">相等（差为0）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setne D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$~ZF&lt;/td>
&lt;td style="text-align:center">不相等（差不为0）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sets D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$SF&lt;/td>
&lt;td style="text-align:center">负数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setns D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$~SF&lt;/td>
&lt;td style="text-align:center">非负数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setg D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$~(SF^OF)&amp;amp;~ZF&lt;/td>
&lt;td style="text-align:center">大于（有符号&amp;gt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setge D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">D$\leftarrow$~(SF^OF)&lt;/td>
&lt;td style="text-align:center">大于等于（有符号&amp;gt;=）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setl D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">小于（有符号&amp;lt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setle D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">小于等于（有符号&amp;lt;=）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">seta D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">超过（无符号&amp;gt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setae D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">超过或相等（无符号&amp;gt;=）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setb D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">低于（无符号&amp;lt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">setbe D&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">低于或相等（无符号&amp;lt;=）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注：^代指异或运算。&lt;/p>
&lt;p>各个SET命令的描述都是用的情况是：执行比较指令，根据t=a-b设置条件码。&lt;/p>
&lt;ul>
&lt;li>对于有符号比较的测试来说，假设a、b、t分别是变量a、b和t的补码形式表示的整数，因此t
&lt;ul>
&lt;li>溢出位OF和符号位SF的EXCLUSIVE-OR提供了a&amp;lt;b是否为真的测试，其他有符号比较测试基于SF异或OF和ZF的其他组合。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于无符号比较的测试来说，使用的是进位标志CF和零标志ZF的组合。&lt;/li>
&lt;/ul>
&lt;h3 id="跳转指令">跳转指令&lt;/h3>
&lt;p>跳转(jump)指令会导致执行&lt;strong>切换到程序中一个全新的位置&lt;/strong>，汇编代码中这些跳转目的地通常用一个**标号(label)**指明。&lt;/p>
&lt;p>汇编器会确定所有带标号指令的地址，并将&lt;strong>跳转目标&lt;/strong>编码为跳转指令的一部分。&lt;/p>
&lt;p>跳转指令分为有条件条状和无条件跳转。&lt;/p>
&lt;p>&lt;strong>无条件跳转&lt;/strong>：&lt;/p>
&lt;p>jmp指令可以是：&lt;/p>
&lt;ul>
&lt;li>直接跳转：跳转目标作为指令的一部分编码，即直接给出一个标号作为跳转目标&lt;/li>
&lt;li>间接跳转：跳转目标是从寄存器或内存位置中读出&lt;/li>
&lt;/ul>
&lt;p>间接跳转的写法是&lt;code>*&lt;/code>后面跟一个操作数指示符，例如：&lt;code>jmp *%rax&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">跳转条件&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">jmp Label&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">直接跳转&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jmp *Operand&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">间接跳转&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>有条件跳转&lt;/strong>：&lt;/p>
&lt;p>根据&lt;strong>条件码的某种组合&lt;/strong>，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字后缀与SET指令相匹配。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">指令&lt;/th>
&lt;th style="text-align:center">同义名&lt;/th>
&lt;th style="text-align:center">跳转条件&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">je Label&lt;/td>
&lt;td style="text-align:center">jz&lt;/td>
&lt;td style="text-align:center">ZF==1&lt;/td>
&lt;td style="text-align:center">相等（零）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jne Label&lt;/td>
&lt;td style="text-align:center">jnz&lt;/td>
&lt;td style="text-align:center">~ZF==1&lt;/td>
&lt;td style="text-align:center">不相等（非零）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">js&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">负数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jns&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">非负数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jg&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">大于（有符号&amp;gt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jge&lt;/td>
&lt;td style="text-align:center">jnl&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">大于或等于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jl&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">小于（有符号&amp;lt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jle&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">小于或等于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ja&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">超过（无符号&amp;gt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jae&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">超过或相等（无符号&amp;gt;=）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jb&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">低于（无符号&amp;lt;）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">jbe&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">低于或相等&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="跳转指令的编码">跳转指令的编码&lt;/h3>
&lt;p>对于链接的理解非常重要，同时也能帮助理解反汇编器的输出。&lt;/p>
&lt;p>跳转指令最常用的是&lt;strong>PC相对编码&lt;/strong>。即将目标指令的地址与紧跟在跳转指令后的那条指令的地址之差作为编码，这些地址偏移量可以编码为1、2或4字节。&lt;/p>
&lt;p>rep指令用来实现重复的字符串操作，可以忽略。&lt;/p>
&lt;h3 id="用条件控制来实现条件分支">用条件控制来实现条件分支&lt;/h3>
&lt;p>将条件表达式从C语言翻译为机器码，最常用的方式是结合&lt;strong>有条件和无条件跳转&lt;/strong>。&lt;/p>
&lt;p>C语言的if-else语句通用模板：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">if&lt;/span> (test&lt;span style="color:#333">-&lt;/span>expr)
then&lt;span style="color:#333">-&lt;/span>statement
&lt;span style="color:#080;font-weight:bold">else&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span>&lt;span style="color:#333">-&lt;/span>statement
&lt;/code>&lt;/pre>&lt;/div>&lt;p>汇编使用以下形式实现，这里用C语法来描述控制流：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">t &lt;span style="color:#333">=&lt;/span> test&lt;span style="color:#333">-&lt;/span>expr;
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (&lt;span style="color:#333">!&lt;/span>t)
&lt;span style="color:#080;font-weight:bold">goto&lt;/span> &lt;span style="color:#007020">false&lt;/span>;
then&lt;span style="color:#333">-&lt;/span>statement
&lt;span style="color:#080;font-weight:bold">goto&lt;/span> done;
&lt;span style="color:#007020">false&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;span style="color:#080;font-weight:bold">else&lt;/span>&lt;span style="color:#333">-&lt;/span>statement
&lt;span style="color:#970;font-weight:bold">done&lt;/span>:
&lt;/code>&lt;/pre>&lt;/div>&lt;p>汇编器位then-statement和else-statement产生了各自的代码块，它会插入条件和无条件分支，保证能执行正确代码块。&lt;/p>
&lt;h3 id="用条件传送实现条件分支">用条件传送实现条件分支&lt;/h3>
&lt;p>实现条件操作的传统方法是使用&lt;strong>控制&lt;/strong>的条件转移，当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单，但在现代处理器中非常低效。&lt;/p>
&lt;p>替代策略是使用&lt;strong>数据&lt;/strong>的条件转移。这种方法计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。&lt;/p>
&lt;p>举例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">long&lt;/span> &lt;span style="color:#06b;font-weight:bold">absdiff&lt;/span>(&lt;span style="color:#339;font-weight:bold">long&lt;/span> x, &lt;span style="color:#339;font-weight:bold">long&lt;/span> y)
{
&lt;span style="color:#339;font-weight:bold">long&lt;/span> result;
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (x &lt;span style="color:#333">&amp;lt;&lt;/span> y)
result &lt;span style="color:#333">=&lt;/span> y &lt;span style="color:#333">-&lt;/span> x;
&lt;span style="color:#080;font-weight:bold">else&lt;/span>
result &lt;span style="color:#333">=&lt;/span> x &lt;span style="color:#333">-&lt;/span> y;
&lt;span style="color:#080;font-weight:bold">return&lt;/span> result;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>产生的汇编代码为：&lt;/p>
&lt;pre>&lt;code class="language-assembly" data-lang="assembly">;x in %rdi, y in &amp;amp;rsi
absdiff:
movq %rsi, %rax
subq %rdi, %rax ;rval = y - x
movq %rdi, %rdx
subq %rsi, %rdx ;eval = x - y
cmpq %rsi, %rdi ;Compare x:y
cmovge %rdx, %rax ;If &amp;gt;=, rval = eval
ret ;Return rval
&lt;/code>&lt;/pre>&lt;p>条件传送指令：指令的结果取决于条件码的值，&lt;strong>当传送条件满足时，指令把源值S复制到目的R&lt;/strong>。&lt;/p>
&lt;p>每条指令都有两个操作数：源寄存器或内存地址S，和目的寄存器D&lt;/p>
&lt;p>源和目的的值可以为16、32或64位，不支持单字传送。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>指令&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>comove S,R&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovne S,R&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovs S,R&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovns S,R&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovg S,R&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovge S,R&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovl&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovle&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmova&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovae&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cmovb&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读取源值，检查条件码，然后要么更新目的寄存器，要么保持不变。&lt;/p>
&lt;h3 id="循环">循环&lt;/h3>
&lt;p>汇编中没有相应的循环指令，可以使用条件测试和跳转组合起来实现。&lt;/p>
&lt;p>&lt;strong>do-while&lt;/strong>循环&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#970;font-weight:bold">loop&lt;/span>:
body&lt;span style="color:#333">-&lt;/span>statement
t &lt;span style="color:#333">=&lt;/span> test&lt;span style="color:#333">-&lt;/span>expr;
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (t)
&lt;span style="color:#080;font-weight:bold">goto&lt;/span> loop;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>while&lt;/strong>循环&lt;/p>
&lt;p>两种方法：&lt;/p>
&lt;ol>
&lt;li>跳转到中间&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">goto&lt;/span> test;
&lt;span style="color:#970;font-weight:bold">loop&lt;/span>:
body&lt;span style="color:#333">-&lt;/span>statement
&lt;span style="color:#970;font-weight:bold">test&lt;/span>:
t &lt;span style="color:#333">=&lt;/span> test&lt;span style="color:#333">-&lt;/span>expr;
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (t)
&lt;span style="color:#080;font-weight:bold">goto&lt;/span> loop;
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>guarded-do&lt;/li>
&lt;/ol>
&lt;p>首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">t &lt;span style="color:#333">-&lt;/span> test&lt;span style="color:#333">-&lt;/span>expr;
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (&lt;span style="color:#333">!&lt;/span>t)
&lt;span style="color:#080;font-weight:bold">goto&lt;/span> done;
&lt;span style="color:#970;font-weight:bold">loop&lt;/span>:
body&lt;span style="color:#333">-&lt;/span>statement
t &lt;span style="color:#333">=&lt;/span> test&lt;span style="color:#333">-&lt;/span>expr;
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (t)
&lt;span style="color:#080;font-weight:bold">goto&lt;/span> loop;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>for&lt;/strong>循环&lt;/p>
&lt;p>for循环的通用形式为：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">for&lt;/span> (init&lt;span style="color:#333">-&lt;/span>expr; test&lt;span style="color:#333">-&lt;/span>expr; update&lt;span style="color:#333">-&lt;/span>expr) body&lt;span style="color:#333">-&lt;/span>statement
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将其改写为使用while循环的形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">init&lt;span style="color:#333">-&lt;/span>expr;&lt;span style="color:#080;font-weight:bold">while&lt;/span> (test&lt;span style="color:#333">-&lt;/span>expr) { body&lt;span style="color:#333">-&lt;/span>statement update&lt;span style="color:#333">-&lt;/span>expr;}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="switch语句">switch语句&lt;/h3>
&lt;p>switch语句可以根据一个&lt;strong>整数索引值&lt;/strong>进行多重分支。而且可以通过使用&lt;strong>跳转表&lt;/strong>这种数据结构使得实现更加高效。&lt;/p>
&lt;p>跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。&lt;/p>
&lt;p>使用跳转表的优点是执行开关语句的时间&lt;strong>与开关情况的数量无关&lt;/strong>。&lt;/p>
&lt;h2 id="过程">过程&lt;/h2>
&lt;p>提供了一种封装代码的方式，相当于&lt;strong>函数接口&lt;/strong>。用一组指定的参数和一个可选的返回值实现了某种功能。&lt;/p>
&lt;p>要提供对过程的机器级支持，必须要处理许多不同属性。假设过程P调用过程Q，Q执行后返回到P。这些动作包含以下一个或多个机制：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>传递控制&lt;/strong>：进入过程Q时，&lt;strong>程序计数器&lt;/strong>必须被设置为Q的代码的起始位置，然后在返回时，把程序计数器设置为P中调用Q后面那条指令的地址。&lt;/li>
&lt;li>&lt;strong>传递数据&lt;/strong>：P必须能够向Q提供一个或多个参数，Q必须向P返回一个值。&lt;/li>
&lt;li>&lt;strong>分配和释放内存&lt;/strong>：开始时Q可能要为&lt;strong>局部变量&lt;/strong>分配空间，在返回前又必须释放这些空间。&lt;/li>
&lt;/ul>
&lt;h3 id="运行时栈">运行时栈&lt;/h3>
&lt;p>C语言过程调用机制使用了栈数据结构提供后进先出的内存管理原则。&lt;/p>
&lt;p>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。&lt;/p>
&lt;h3 id="转移控制">转移控制&lt;/h3>
&lt;p>当控制从函数P转移到函数Q时，只需要简单地把程序计数器(PC)设置为Q的代码的起始位值，稍后从Q返回时，处理器必须记录好他需要继续P的执行的代码位置。在x86-64中，这个信息用指令&lt;code>call Q&lt;/code>调用过程Q来记录。&lt;/p>
&lt;h2 id="数组分配和访问">数组分配和访问&lt;/h2>
&lt;p>C语言可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译为地址计算。&lt;/p>
&lt;h3 id="基本原则">基本原则&lt;/h3>
&lt;p>对于数据类型T和整型常数N，数组声明如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">T A[N];
&lt;/code>&lt;/pre>&lt;/div>&lt;p>起始位置为$x_A$，在内存中分配一个$L \cdot N$字节的连续区域，L为数据类型T的大小，其次，引入标识符A，可以用A作为指向数组开头的指针，该指针的值为$x_A$。&lt;/p>
&lt;p>例如：&lt;code>char A[12];&lt;/code>，数组A由12个单字节(char)元素组成。&lt;/p>
&lt;h3 id="指针运算">指针运算&lt;/h3>
&lt;h3 id="嵌套的数组">嵌套的数组&lt;/h3>
&lt;p>二维数组可以以嵌套声明，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">int&lt;/span> A[&lt;span style="color:#00d;font-weight:bold">5&lt;/span>][&lt;span style="color:#00d;font-weight:bold">3&lt;/span>];
&lt;/code>&lt;/pre>&lt;/div>&lt;p>等价于：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#080;font-weight:bold">typedef&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> row3_t[&lt;span style="color:#00d;font-weight:bold">3&lt;/span>];
row3_t A[&lt;span style="color:#00d;font-weight:bold">5&lt;/span>];
&lt;/code>&lt;/pre>&lt;/div>&lt;p>二维数组一般按照行优先顺序进行排列。&lt;/p>
&lt;h3 id="定长数组">定长数组&lt;/h3>
&lt;p>一般使用&lt;code>#define&lt;/code>声明将常数与一个名字联系起来，然后一直使用这个名字代替常数的数值。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#579">#define N 16
&lt;/span>&lt;span style="color:#579">&lt;/span>&lt;span style="color:#080;font-weight:bold">typedef&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> fix_matrix[N][N];
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="变长数组">变长数组&lt;/h3>
&lt;p>ISO C99引入一种功能，允许数组的维度是表达式，在数组被分配时才计算出来。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#06b;font-weight:bold">var_ele&lt;/span>(&lt;span style="color:#339;font-weight:bold">long&lt;/span> n, &lt;span style="color:#339;font-weight:bold">int&lt;/span> A[n][n], &lt;span style="color:#339;font-weight:bold">long&lt;/span> i, &lt;span style="color:#339;font-weight:bold">long&lt;/span> j){
&lt;span style="color:#080;font-weight:bold">return&lt;/span> A[i][j];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>参数&lt;code>n&lt;/code>必须在参数&lt;code>A[n][n]&lt;/code>之前.&lt;/p>
&lt;h2 id="数据结构struct和union">数据结构struct和union&lt;/h2>
&lt;p>结构用struct来声明，将多个对象集合到一个单位中。&lt;/p>
&lt;p>联合用union来声明，允许用几种不同类型来引用一个对象。&lt;/p>
&lt;h3 id="结构">结构&lt;/h3>
&lt;p>C语言的struct声明创建一个将不同类型的对象集合到一个对象中的数据类型。&lt;strong>用名字来引用&lt;/strong>结构的各个组成部分，类似于数组的实现。&lt;/p>
&lt;p>结构的所有组成部分都放在内存中的一段&lt;strong>连续区域&lt;/strong>，指向结构的指针就是结构&lt;strong>第一个字节的地址&lt;/strong>。&lt;/p>
&lt;p>编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。&lt;/p>
&lt;blockquote>
&lt;p>面向对象的C++和Java的对象要比C语言中的结构要复杂精细得多，因为他们将一组方法与一个对象联系起来&lt;/p>
&lt;/blockquote>
&lt;p>为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。&lt;/p>
&lt;p>要产生一个指向结构内部对象的指针，只需将结构的地址加上该字段的偏移量。&lt;/p>
&lt;h3 id="联合">联合&lt;/h3>
&lt;p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），union占用的内存等于最长的成员占用的内存。union使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。&lt;/p>
&lt;h3 id="数据对齐">数据对齐&lt;/h3>
&lt;p>一些计算机对&lt;strong>基本数据类型的合法地址&lt;/strong>作出了限制，要求某种类型对象的地址必须是某个值K(通常是2、4、8)的倍数。这种内存对齐限制简化了处理器和内存之间接口的硬件设计。例如，一个处理器每次总是从内存中读取8个字节，则地址必须为8的倍数；如果我们保证double类型数据的地址对其成8的倍数，那么就可以用一次内存操作来读或写值，否则可能执行两次内存访问，因为对象可能被放在两个8字节内存块中。&lt;/p>
&lt;p>内存地址对其是通过编译器来控制的。对于大多数x86-64指令来说，保持数据对其能提高效率，不会影响程序行为。&lt;/p>
&lt;h2 id="数据和控制的交互">数据和控制的交互&lt;/h2>
&lt;h3 id="指针">指针&lt;/h3>
&lt;p>下面是一些指针和它们映射到机器代码的关键原则。&lt;/p>
&lt;ul>
&lt;li>每个指针都&lt;strong>对应一个类型&lt;/strong>。类型表明指针指向对象的类型。指针类型不是机器代码的一部分，是C语言提供的一种抽象，帮助我们避免寻址错误。&lt;/li>
&lt;li>每个指针都有一个值。这个值是某个指定类型对象的地址。&lt;/li>
&lt;li>指针用取地址符&lt;code>&amp;amp;&lt;/code>创建。leaq指令用来计算内存引用的地址，&amp;amp;运算符的机器代码实现常用leaq指令来计算表达式的值。&lt;/li>
&lt;li>*解引用符号用于间接引用指针，结果为一个值。&lt;/li>
&lt;li>数组与指针联系紧密。一个数组名可以像一个指针变量一样引用。&lt;/li>
&lt;li>将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值。&lt;/li>
&lt;li>指针也可以指向函数。函数指针的值是该函数机器代码表示中第一条指令的地址。&lt;/li>
&lt;/ul>
&lt;h3 id="gdb调试器">GDB调试器&lt;/h3>
&lt;h3 id="缓冲区溢出">缓冲区溢出&lt;/h3>
&lt;p>C对数组引用不进行任何边界检查，局部变量和状态信息都存放在栈中，这就可能导致严重错误。对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，制图重新加载寄存器或执行ret执行时就会发生严重错误。&lt;/p>
&lt;p>常见的状态破坏成为缓冲区溢出。例如，在栈中分配一个字符数组保存一个字符串，但字符串的长度超出了为数组分配的空间。&lt;/p>
&lt;p>缓冲区溢出让程序执行它本来不愿意执行的函数。例如，输入一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码&lt;/p>
&lt;h3 id="支持变长栈帧">支持变长栈帧&lt;/h3>
&lt;h2 id="浮点代码">浮点代码&lt;/h2>
- https://eternityqjl.github.io/blog2_public/posts/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/ - 2019-2021 By Jialong</description></item><item><title>计算机网络学习日志（三）——网络层：数据平面</title><link>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</link><pubDate>Thu, 05 Aug 2021 22:23:31 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/ -&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2.png" alt="">&lt;/p>
&lt;p>数据平面指的是网络层中&lt;strong>每台路由器&lt;/strong>的功能，该数据平面功能决定了到达路由器输入链路的数据报如何转发到该路由器的输出链路之一。&lt;/p>
&lt;p>而控制平面的功能指的是&lt;strong>网络范围&lt;/strong>的逻辑，控制平面控制数据报沿着从源主机到目的主机的端到端路径中&lt;strong>路由器之间&lt;/strong>的路由方式。其中包括路由选择算法，以及如今广泛应用的诸如OSPF和BGP等路由选择协议。控制平面和数据平面的功能已经被实现为一个整体，位于一台路由器中。&lt;/p>
&lt;p>**软件定义网络（SDN）**通过将这些控制平面的功能作为一种单独的服务，明确分离数据平面和控制平面，控制平面功能通常位于一台远程的控制器中。&lt;/p>
&lt;h2 id="网络层概述">网络层概述&lt;/h2>
&lt;h3 id="转发和路由选择数据平面和控制平面">转发和路由选择：数据平面和控制平面&lt;/h3>
&lt;ul>
&lt;li>转发：将一个分组从路由器的一条输入链路移动到适当的输出链路&lt;/li>
&lt;li>路由选择：网络层决定分组从发送方到接收方所采用的路由或路径&lt;/li>
&lt;/ul>
&lt;p>转发（forwarding）是路由器本地动作，路由选择（routing）是网络范围处理过程。&lt;/p>
&lt;p>路由器通过&lt;strong>转发表&lt;/strong>来实现转发功能。&lt;/p>
&lt;h3 id="网络服务模型">网络服务模型&lt;/h3>
&lt;p>网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性：&lt;/p>
&lt;ul>
&lt;li>确保交付&lt;/li>
&lt;li>具有时延上界的确保交付&lt;/li>
&lt;li>有序分组交付&lt;/li>
&lt;li>确保最小带宽&lt;/li>
&lt;li>安全性&lt;/li>
&lt;/ul>
&lt;p>因特网的网络层提供了&lt;strong>尽力而为服务&lt;/strong>。并不能对服务做出保证。但尽力而为服务结合适当的玩过带宽已被证明足够好，已被证明能用于大量应用。&lt;/p>
&lt;h2 id="路由器工作原理">路由器工作原理&lt;/h2>
&lt;p>以下为一个通用的路由器体系结构：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.PNG" alt="">&lt;/p>
&lt;ul>
&lt;li>输入端口：终结输入物理链路的物理层功能；还与位于入链路远端的数据链路层交互来执行数据链路层功能；另外还要执行查找功能，通过查询转发表决定路由器的输出端口&lt;/li>
&lt;li>交换结构：将路由器的输入端口连接到它的输出端口&lt;/li>
&lt;li>输出端口：从交换结构接收分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组&lt;/li>
&lt;li>路由选择处理器：执行控制平面功能。在传统路由器中执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在SDN路由器中，路由选择处理器负责与远程控制器通信，接收其计算的转发表项，并在路由器输入端口安装这些表项。&lt;/li>
&lt;/ul>
&lt;h3 id="输入端口处理和基于目的地转发">输入端口处理和基于目的地转发&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86_%E7%BD%91%E7%BB%9C%E5%B1%82.PNG" alt="">&lt;/p>
&lt;h3 id="交换">交换&lt;/h3>
&lt;p>交换结构是路由器的核心，通过这种交换结构，分组才能实际地从一个输入端口交换到一个输出端口中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.PNG" alt="">&lt;/p>
&lt;p>&lt;strong>经内存交换&lt;/strong>：&lt;/p>
&lt;p>输入输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。分组到达输入端口时被复制到处理器内存中，路由选择处理器从其首部中提取目的地址，在转发表中找打适当输出端口，并将该分组复制到输出端口的缓存中。该种情况下若内存带宽为每秒可以写进内存或从内存中读出最多B个分组，则总的转发吞吐量必然小于B/2。另外这种方式不同同时转发两个分组，即使它们有不同的分组。&lt;/p>
&lt;p>&lt;strong>经总线交换&lt;/strong>：&lt;/p>
&lt;p>输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。路由器必须跨过单一总线，所以路由器的交换带宽受总线速率的影响。&lt;/p>
&lt;p>&lt;strong>经互联网络交换&lt;/strong>&lt;/p>
&lt;p>使用更加复杂的交换网络来客服单一、共享式总线带宽的限制。&lt;/p>
&lt;p>例如纵横式交换机就是一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直总线与每条水平总线在交叉点交叉，交叉点通过交换结构控制器控制开启和闭合。&lt;/p>
&lt;p>所以纵横式网络能够并行转发多个分组，是非阻塞的。&lt;/p>
&lt;h3 id="输出端口处理">输出端口处理&lt;/h3>
&lt;p>选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。&lt;/p>
&lt;h3 id="排队">排队&lt;/h3>
&lt;p>&lt;strong>输入排队&lt;/strong>&lt;/p>
&lt;p>&lt;strong>输出排队&lt;/strong>&lt;/p>
&lt;h3 id="分组调度">分组调度&lt;/h3>
&lt;p>解决排队的分组如何经输出链路传输的问题。&lt;/p>
&lt;p>&lt;strong>先进先出&lt;/strong>&lt;/p>
&lt;p>FIFO的链路调度规则，如果分组到达时链路正忙，则需要等待链路中的分组传输完成。&lt;/p>
&lt;p>&lt;strong>优先权排队&lt;/strong>&lt;/p>
&lt;p>不同类型的网络分组有不同的优先权类，每个优先权类通常都有自己的队列。&lt;/p>
&lt;p>&lt;strong>循环和加权公平排队&lt;/strong>&lt;/p>
&lt;p>在&lt;strong>循环排队规则&lt;/strong>中，分组像使用优先权排队那样被分类，但在类之间不存在严格的服务优先权，&lt;strong>循环调度器&lt;/strong>在这些类之间轮流提供服务。一个所谓的&lt;strong>保持工作排队&lt;/strong>规则在有分组排队等待传输时，不允许链路保持空闲。当寻找给定的分组但没有找到时，保持工作的循环规则将立即检查循环序列中的下一个类。&lt;/p>
&lt;p>一种称为&lt;strong>加权平均排队&lt;/strong>（Weighted Fair Queuing, WFQ）规则的通用形式的循环排队已经广泛地实现在路由器中了。WFQ与循环排队的不同在于，每个类在任何时间间隔内可能收到不同数量的服务。每个类i被分配一个权$w_i$，使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接收到的服务部分等于$w_i/(\sum w_j)$，即保证拥有相应权重的带宽。&lt;/p>
&lt;h2 id="网际协议ip">网际协议IP&lt;/h2>
&lt;p>因特网网络层的网际协议（IP）。&lt;/p>
&lt;h3 id="ipv4数据报格式">IPv4数据报格式&lt;/h3>
&lt;p>网络层分组被称为&lt;strong>数据报&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.PNG" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>版本号&lt;/strong>：4比特，规定了数据报的IP协议版本。即区分IPv4和IPv6，路由器根据版本号确定如何处理数据报剩余的部分。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>首部长度&lt;/strong>：一个IPv4数据报包含一些可变数量的选项，需要用这4比特来确定IP数据报中荷载（被封装的运输层报文）实际开始的地方。大多数数据报不包含选项，所以一般具有20字节的首部长度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务类型&lt;/strong>：区别不同类型的数据报（例如一些特别要求低时延、高吞吐量或可靠性的数据报）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据报长度&lt;/strong>：16比特，IP数据报的总长度（包括首部），以字节为单位计；理论最大长度为65535字节。但数据报很少有超过1500字节，因为该长度是以太网帧的最大荷载。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>标识、标志、片偏移&lt;/strong>：这三个字段与IP分片有关。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>寿命（Time-to-live, TTL）&lt;/strong>：确保数据报不会永远在网络中循环。每当一台路由器处理数据报时，该字段的值减一，若TTL字段为0则该数据报必须丢弃。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上层协议&lt;/strong>：该字段指示了IP数据报的数据部分应该交给哪个特定的运输层协议，只有当IP数据报到达最终目的地时才有用。例如值为6表示要交给TCP，值为17表示要交给UDP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>首部检验和&lt;/strong>：将首部中每2个字节当作一个数，用反码算数对这些数求和。该和用于帮助路由器检测收到的IP数据报中的比特错误。路由器要对每个收到的IP数据报计算其首部检验和，如果数据报中携带的检验和与计算的不一致则检测出这是一个差错，需要将该分组丢弃。&lt;/p>
&lt;blockquote>
&lt;p>TCP/IP在运输层与网络层都执行了差错检测，但检测有些区别：IP层只对IP首部计算了检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。另外TCP/UDP与IP不一定都必须属于同一个协议栈。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>源和目的IP地址&lt;/strong>：源生成一个数据报时写入它的IP地址和目的地IP地址，通常目的地址通过DNS查找来实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>选项&lt;/strong>：允许IP首部被扩展。很少使用，在IPv6中已将其去除。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据（有效荷载）&lt;/strong>：最重要的字段，交付给目的地运输层的报文段。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="ipv4数据报分片">IPv4数据报分片&lt;/h3>
&lt;p>并不是所有链路层协议都能承载相同长度的网络层分组，例如以太网能承载不超过1500字节的数据，而某些广域网帧可承载不超过576字节数据。一个链路层帧能承载的最大数据量叫作&lt;strong>最大传送单元（MTU）&lt;/strong>。链路层协议的MTU严格限制着IP数据报的长度。发送方与目的地路径之间的每段链路可能使用不同的链路层协议，每种协议可能有不同的MTU。&lt;/p>
&lt;p>为了能让过大的IP分组放入链路层帧有效的荷载字段，我们将IP数据报中的数据&lt;strong>分片成&lt;/strong>两个多更多个较小的数据报，用单独的链路层帧封装这些小的数据报，每个较小的数据报都称为&lt;strong>片（fragment）&lt;/strong>。&lt;/p>
&lt;p>片在到达目的地运输层前需要重新组装，TCP与UDP都希望从网路层收到完整的、未分片的报文。为了不影响路由器的性能，IPv4的设计者决定将片的重新组装工作放到&lt;strong>端系统&lt;/strong>中。&lt;/p>
&lt;p>当一台目的地主机从同一源收到一系列数据报时，需要确定这些数据报中的某些是否是一些原来较大的数据报的片；如果是这些片的话，还需要确定何时收到了最后一片，并且如何将这些片拼接起来形成初始的数据报。&lt;/p>
&lt;p>IPv4设计者将&lt;strong>标识、标志和片偏移&lt;/strong>字段放在IP数据报首部中。当生成一个数据报时，发送主机为该数据报贴上&lt;strong>标识号&lt;/strong>；发送主机通常将它发送的每个数据报的标识号加1；当某路由器需要对一个数据报分片时，形成的每个片具有原始数据报的&lt;strong>源地址、目的地址和标识号&lt;/strong>，目的主机能通过标识号确定哪些数据报实际上是同一较大数据报的片。&lt;/p>
&lt;p>IP是一种不可靠服务，有些片可能永远到达不了目的地；为了让目的主机相信它已经收到了初始数据报的最后一个片，最后一个片的&lt;strong>标志比特&lt;/strong>被设置为了0，而其他所有片的标志比特被设置为了1。另外为了让目的主机确认是否丢失了一个片（且能够按照正确顺序组装片），使用&lt;strong>偏移字段&lt;/strong>指定该片应该放在初始数据报的哪个位置。&lt;/p>
&lt;h3 id="ipv4编址">IPv4编址&lt;/h3>
&lt;p>一个IP地址与一个接口相关联，接口是主机与物理链路之间的边界。&lt;/p>
&lt;p>每个IP地址的长度为&lt;strong>32比特（4字节）&lt;/strong>，总共有约$2^{32}$，大约40亿个IP地址。这些地址通常按照&lt;strong>点分十进制计法&lt;/strong>书写。&lt;/p>
&lt;p>&lt;strong>子网&lt;/strong>&lt;/p>
&lt;p>因特网的地址分配策略被称为&lt;strong>无类别域间路由选择（Classless Interdomain Routing, CIDR）&lt;/strong>，CIDR将子网寻址的概念一般化了。&lt;/p>
&lt;p>当使用子网寻址时，32比特的IP地址被划为两部分，并且具有点分十进制数形式&lt;code>a.b.c.d/x&lt;/code>，其中x指示了地址的第一部分中的比特数。&lt;/p>
&lt;p>形式为&lt;code>a.b.c.d/x&lt;/code>的地址的x最高比特构成了IP地址的&lt;strong>网络部分&lt;/strong>，经常被称为该地址的&lt;strong>前缀（prefix）&lt;/strong>，一个组成通常被分配一块连续的地址，即具有相同前缀的一段地址。&lt;/p>
&lt;p>使用单个网络前缀通告多个网络的能力称为&lt;strong>地址聚合&lt;/strong>，也成为&lt;strong>路由聚合&lt;/strong>；例如可以用&lt;code>200.23.16.0/20&lt;/code>通告&lt;code>200.23.16.0/23&lt;/code>这个网络。&lt;/p>
&lt;p>当地址不是按照层次的方式分配时，我么使用&lt;strong>最长前缀匹配&lt;/strong>来通告地址块。&lt;/p>
&lt;p>在&lt;strong>CIDR&lt;/strong>采用前，IP地址的网络部分被限制为长度为8、16或24比特，称为&lt;strong>分类编址&lt;/strong>的编址方案，分别称为A、B、C类网络。但这种分配方案存在一些问题，一个C类子网仅能容纳$2^8-2=254$（其中两个地址预留用于特殊用途）台主机，而一个B类地址可以容纳$2^{16}-2=65534$台主机，对于许多组织来说又太大了。&lt;/p>
&lt;p>接下来介绍一个设备如何从某主机的地址块中分配到一个地址：&lt;/p>
&lt;p>&lt;strong>获取一块地址&lt;/strong>&lt;/p>
&lt;p>一个组织从ISP获取一个地址块。&lt;/p>
&lt;p>&lt;strong>获取主机地址：DHCP&lt;/strong>&lt;/p>
&lt;p>通过动态主机配置协议（Dynamic Host Configuration, DHCP）为本组织内的主机和路由器接口配置IP地址。&lt;/p>
&lt;p>DHCP具有即插即用能力，同时避免了网络管理员手动配置网络。&lt;/p>
&lt;p>通过DHCP给新客户分配地址的步骤：&lt;/p>
&lt;ul>
&lt;li>DHCP服务器发现：客户使用&lt;strong>DHCP发现报文&lt;/strong>在UDP分组中向端口67发送报文，该报文封装在一个IP数据报中，DHCP客户使用广播目的地址255.255.255.255并且使用本主机源IP地址0.0.0.0。DHCP客户将IP数据报传递给链路层，链路层将该帧广播到所有与该子网连接的节点。&lt;/li>
&lt;li>DHCP服务器提供：DHCP服务器收到发现报文时，用&lt;strong>DHCP提供报文&lt;/strong>向客户作出相应，该报文向子网的所有节点广播，仍使用IP广播地址255.255.255.255。子网中可能存在几个DHCP服务器，客户可以选择位置较为优越的DHCP服务。每台服务器提供的报文包括收到发现报文的事物ID、向客户推荐的IP地址、网络掩码以及&lt;strong>IP地址租用期&lt;/strong>。&lt;/li>
&lt;li>DHCP请求：新到达的客户从一个或多个DHCP服务器选择一个，并向选中的服务器发送&lt;strong>DHCP请求报文&lt;/strong>进行响应，回显配置参数。&lt;/li>
&lt;li>DHCP ACK：服务器用&lt;strong>DHCP ACK报文&lt;/strong>对DHCP请求报文进行响应，证实所要求的参数。&lt;/li>
&lt;/ul>
&lt;h3 id="nat">NAT&lt;/h3>
&lt;p>网络地址转换使能的路由器对外界就像是一个具有单一IP地址的单一设备。&lt;/p>
&lt;p>&lt;strong>IPv4私有IP地址&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">规定区块名&lt;/th>
&lt;th style="text-align:center">IP地址区块&lt;/th>
&lt;th style="text-align:center">IP数量&lt;/th>
&lt;th style="text-align:center">分类网络说明&lt;/th>
&lt;th style="text-align:center">子网掩码&lt;/th>
&lt;th style="text-align:center">主机端位长&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">24位区块&lt;/td>
&lt;td style="text-align:center">10.0.0.0 – 10.255.255.255&lt;/td>
&lt;td style="text-align:center">16,777,216&lt;/td>
&lt;td style="text-align:center">单个A类网络&lt;/td>
&lt;td style="text-align:center">10.0.0.0/8 (255.0.0.0)&lt;/td>
&lt;td style="text-align:center">24位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">20位区块&lt;/td>
&lt;td style="text-align:center">172.16.0.0 – 172.31.255.255&lt;/td>
&lt;td style="text-align:center">1,048,576&lt;/td>
&lt;td style="text-align:center">16个连续B类网络&lt;/td>
&lt;td style="text-align:center">172.16.0.0/12 (255.240.0.0)&lt;/td>
&lt;td style="text-align:center">20位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">16位区块&lt;/td>
&lt;td style="text-align:center">192.168.0.0 – 192.168.255.255&lt;/td>
&lt;td style="text-align:center">65,536&lt;/td>
&lt;td style="text-align:center">256个连续C类网络&lt;/td>
&lt;td style="text-align:center">192.168.0.0/16 (255.255.0.0)&lt;/td>
&lt;td style="text-align:center">16位&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这些地址只在专用网络中的设备上使用，即这些地址只对该网络中的设备有意义。&lt;/p>
&lt;p>&lt;strong>网络地址转换&lt;/strong>&lt;/p>
&lt;p>NAT路由器上有一张&lt;strong>NAT转换表&lt;/strong>，该表项中包含了&lt;strong>端口号及其地址&lt;/strong>，能够把从广域网到达NAT路由器的分组转发给需要到达的内部主机。&lt;/p>
&lt;p>要将专用网中一台设备的请求发送给广域网中的服务器，首先NAT路由器接收到主机发送的数据报，为该数据报生成一个新的源端口，然后将源IP替换为路由器广域网一侧接口的IP，NAT路由器可以选择任意一个当前未在NAT转换表中的源端口号，NAT协议可以支持超过60000个并行连接。&lt;/p>
&lt;h3 id="ipv6">IPv6&lt;/h3>
&lt;p>主要为了解决IPv4中32比特的IP地址空间即将用尽，同时改进和强化了IPv4的其他方面。&lt;/p>
&lt;p>&lt;strong>IPv6数据报格式&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/IPv6%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.PNG" alt="">&lt;/p>
&lt;p>IPv6引入了以下一些重要的变化：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>扩大的地址容量&lt;/strong>：IP地址长度从32比特增加到了128比特；IPv6还引入了一种&lt;strong>任播地址&lt;/strong>，这种地址可以使数据报交付给一组主机中的任意一个。&lt;/li>
&lt;li>&lt;strong>简化高效的40字节首部&lt;/strong>：一些IPv4字段已经被被舍弃，具体内容如下。&lt;/li>
&lt;li>&lt;strong>流标签&lt;/strong>：该字段可用于给特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种&lt;strong>非默认服务质量&lt;/strong>或&lt;strong>需要实时服务&lt;/strong>的流。&lt;/li>
&lt;/ul>
&lt;p>以下是IPv6定义的字段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>版本&lt;/strong>：这4比特用于表示IP版本号，IPv6将该字段设置为6&lt;/li>
&lt;li>&lt;strong>流量类型&lt;/strong>：这8比特字段与IPv4中的服务类型字段含义相似&lt;/li>
&lt;li>&lt;strong>流标签&lt;/strong>：如上面讨论的，该字段用于标识一条数据报的流&lt;/li>
&lt;li>&lt;strong>有效荷载长度&lt;/strong>：这16比特值作为一个无符号整数，给出了数据的字节数&lt;/li>
&lt;li>&lt;strong>下一首部&lt;/strong>：标识数据字段交付给哪个协议&lt;/li>
&lt;li>&lt;strong>跳限制&lt;/strong>：类似于IPv4的TTL，转发数据报的每台路由器对该字段内容减1&lt;/li>
&lt;li>&lt;strong>源地址和目的地址&lt;/strong>：128比特的IPv6地址&lt;/li>
&lt;li>&lt;strong>数据&lt;/strong>：IPv6数据报的有效荷载&lt;/li>
&lt;/ul>
&lt;p>以下内容是几个在IPv4数据报中出现但在IPv6数据报中已经不存在的字段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分片/重新组装&lt;/strong>：IPv6不允许在中间路由器上i进行分片与重新组装，这种操作只能在源与目的地执行。如果路由器收到的IPv6数据报太大而不能转发到输出链路的话，只需丢掉这个数据报。分片与重新组装是一个耗时的操作，将该功能从路由器中删除并放入端系统中，大大加快了网路中的IP转发速率。&lt;/li>
&lt;li>&lt;strong>首部检验和&lt;/strong>：因为因特网中运输层和数据链路层都进行了检验操作，IP设计者觉得在网路层中具有该项功能较为多余，所以将其去掉。&lt;strong>快速处理IP分组&lt;/strong>才是关注的重点。另外，IPv4首部中包含一个TTL字段，所以在每台路由器上都需要重新计算IPv4首部检验和。&lt;/li>
&lt;li>&lt;strong>选项&lt;/strong>：使得IP首部字段成为定长的40字节。它没有消失，而可能出现在IPv6首部中由下一个首部指出的位置。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>从IPv4到IPv6的迁移&lt;/strong>&lt;/p>
&lt;p>通过建立隧道在IPv4路由器之间传输IPv6数据报。借助于隧道，在隧道发送端可将整个IPv6数据报放到一个IPv4数据报的数据字段中。&lt;/p>
&lt;h2 id="通用转发和sdn">通用转发和SDN&lt;/h2>
&lt;p>软件定义网路：匹配加动作&lt;/p>
&lt;p>分组交换机&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%B8%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/ - 2019-2021 By Jialong</description></item><item><title>计算机网络学习日志（五）——链路层</title><link>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</link><pubDate>Sun, 01 Aug 2021 20:20:52 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ -&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt="">&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>将运行链路层协议的设备称为&lt;strong>节点&lt;/strong>，把沿通信链路连接相邻节点的通信信道称为&lt;strong>链路&lt;/strong>。经过特定链路时，节点将数据包封装在&lt;strong>链路层帧&lt;/strong>中，将该帧传送到链路中。&lt;/p>
&lt;p>链路层提供的服务：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>成帧&lt;/strong>：将网络层数据报用链路层帧封装起来，帧结构由链路层协议决定。&lt;/li>
&lt;li>&lt;strong>链路接入&lt;/strong>：**媒体访问控制协议(MAC)**规定了帧在链路上的传输规则。MAC协议还用于协调多个节点的帧传输。&lt;/li>
&lt;li>&lt;strong>可靠交付&lt;/strong>：链路层通过&lt;em>确认和重传&lt;/em>提供可靠交付服务。无线链路容易产生较高的差错率，一般在本地（差错发生的链路上）纠正一个错误，而非通过应用层或传输层来纠错。如光纤、双绞铜线等有线链路的差错率较低，可靠交付被认为是不必要的开销，所以许多有线链路层协议不提供可靠交付。&lt;/li>
&lt;li>&lt;strong>差错检验和纠正&lt;/strong>：比特差错由信号衰减和电磁干扰产生，链路层差错纠正一般使用硬件实现。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查来实现。&lt;/li>
&lt;/ul>
&lt;p>链路层协议的实现位置：&lt;strong>网络适配器&lt;/strong>（也成为网卡）来实现。&lt;/p>
&lt;h2 id="差错检测和纠正技术">差错检测和纠正技术&lt;/h2>
&lt;p>差错检验要保护的内容包括网络层传来的数据报、链路层级的寻址信号、序号和其他字段。&lt;/p>
&lt;p>这里研究在传输数据中检测差错的3种技术：奇偶校验、检验和方法、循环冗余检测。&lt;/p>
&lt;h3 id="奇偶校验">奇偶校验&lt;/h3>
&lt;p>&lt;strong>单个奇偶校验位&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/oneByteEvenParity.PNG" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>假设共要发送d比特数据，发送方只要附加一个比特，设置其值，使得这d+1个比特中1的总是是偶数，这即为偶数校验。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接收方只要数一数接受的d+1比特中1的个数即可，如果在偶数校验中发现奇数个1，则发生了1个奇数的比特差错。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但如果发生偶数个比特差错，则无法判断。但这种概率是极小的，使用单个比特奇偶校验保护的一帧中未检测出差错的概率大约为&lt;strong>50%&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>二维奇偶校验&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/twoDEvenParity.PNG" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将d个比特划分为i行j列，计算每行每列的奇偶值，共产生i+j+1个奇偶差错比特，用来进行差错检验。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>出现单个比特差错时，比特值改变的行和列都能检测到错误，同时还能定位并纠正错误。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>接收方&lt;/strong>检测和纠正差错的能力被称为&lt;strong>前向纠错（Forward Error Correction，FEC）&lt;/strong>。FEC能够减少发送方重发的次数，同时允许在接收方立即纠正差错，避免了不得不等待的往返时延。&lt;/p>
&lt;h3 id="检验和">检验和&lt;/h3>
&lt;p>将d比特数据当作一个k比特的整数序列处理。&lt;strong>因特网检验和&lt;/strong>是将数据的字节作为16比特整数对待并求和，将和的反码作为检验和携带在报文首部，接收方通过对接受的数据（包括检验和）的和取反码，检测其结果&lt;em>是否全为1比特&lt;/em>来检验。如果这些比特中存在0比特，则出现差错。&lt;/p>
&lt;p>检验和需要较小的分组开支，提供相对弱的差错保护，常用于运输层的检验。而链路层使用CRC，运输层通常是在主机中作为用户操作系统的一部分用软件实现的，用软件实现中较为重要的是使用简单而快速的方案；而链路层的差错检测在适配器中用专用的硬件实现，能够快速执行复杂的CRC操作。&lt;/p>
&lt;h3 id="循环冗余检测crc">循环冗余检测（CRC）&lt;/h3>
&lt;p>冗余检测编码也称多项式编码，该编码能将要发送的比特串看作系数为0和1的一个多项式。&lt;/p>
&lt;p>考虑d比特的数据D，发送节点要将它发送给接收节点，发送方和接收方要协商一个r+1比特模式，称为生成多项式，将其表示为&lt;strong>G&lt;/strong>。我们要求G的最高位有效比特为1.&lt;/p>
&lt;p>对于一个给定的数据段D，发送方要选择r个附加比特R，并将他们附加到D上，得到d+r比特模式用模r算术恰好能被G整除。&lt;/p>
&lt;p>用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特。如果余数非零，接收方知道出现了差错，否则认为数据正确。&lt;/p>
&lt;h2 id="多路访问链路和协议">多路访问链路和协议&lt;/h2>
&lt;p>网络链路的分类：&lt;/p>
&lt;ul>
&lt;li>点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。&lt;/li>
&lt;li>广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。&lt;/li>
&lt;/ul>
&lt;p>多路访问协议：协调多个发送和接收节点对一个共享广播信道的访问。&lt;/p>
&lt;p>因为所有节点都能传输帧，所以多个节点可能同时传输帧，传输的帧在接收方可能会碰撞，碰撞的信号纠缠在一起，所有帧都会丢失。&lt;/p>
&lt;p>我们能够将任何多路访问协议划分为三种类型：信道划分协议、随机接入协议、轮流协议。&lt;/p>
&lt;h3 id="信道划分协议">信道划分协议&lt;/h3>
&lt;p>&lt;strong>时分多路复用（TDM）&lt;/strong>&lt;/p>
&lt;p>假设一个支持N个节点的信道传输速率为R bps。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/TDM.PNG" alt="">&lt;/p>
&lt;ul>
&lt;li>TDM将时间划分为&lt;strong>时间帧（Frame）&lt;/strong>，并进一步把每个时间帧划分为N个&lt;strong>时隙（slot）&lt;/strong>，把每个时隙分配给N个节点中的一个。&lt;/li>
&lt;li>无论何时某个节点有分组要发送时，它在循环的TDM帧中指派给它的时隙内传输分组比特。&lt;/li>
&lt;li>TDM消除了碰撞且非常公平，但存在以下缺点：
&lt;ul>
&lt;li>节点被限制在R/N bps的平均速率，即使只有它一个分组要发送时。&lt;/li>
&lt;li>节点必须总是等待它所在的传输序列的轮次，即使它是唯一一个有帧要发送的节点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>频分多路复用（FDM）&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/FDM.PNG" alt="">&lt;/p>
&lt;ul>
&lt;li>FDM将R bps信道划分为不同频段，每个频段有R/N带宽，并把每个频率分配给N个节点中的一个。&lt;/li>
&lt;li>与TDM有相同的优点和缺点：
&lt;ul>
&lt;li>避免了碰撞，公平划分了带宽，但每个节点只能使用R/N的带宽，即使它是唯一一个有分组发送的节点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>码分多址（CDMA）&lt;/strong>&lt;/p>
&lt;p>码分多址（Code Division Multiple Access）对每个节点分配一种不同的&lt;strong>编码&lt;/strong>，每个节点用其&lt;strong>唯一的编码&lt;/strong>来对发送的数据进行编码，CMDA有一种特性，即不同的节点能同时传输，并且各自的接收方仍能正确接受发送方编码的数据比特，而不在乎其他节点的干扰传输。&lt;/p>
&lt;h3 id="随机接入协议">随机接入协议&lt;/h3>
&lt;p>随机接入协议中，每个传输节点总以&lt;strong>信道的全部速率&lt;/strong>发送，当有碰撞时，涉及碰撞的每个节点重复发送它的帧，直到该帧无碰撞地通过。当一个节点经历一次碰撞时，不必重发该帧，在重发前等待一个&lt;strong>随机时延&lt;/strong>，涉及碰撞的每个节点独立地选择随机时延。&lt;/p>
&lt;p>以下为一些最常用的随机接入协议：&lt;/p>
&lt;p>&lt;strong>时隙ALOHA&lt;/strong>：&lt;/p>
&lt;p>假设条件：&lt;/p>
&lt;ul>
&lt;li>所有帧由L比特组成。&lt;/li>
&lt;li>时间被划分为L/R秒的时隙。&lt;/li>
&lt;li>节点只在时隙起点开始传输帧。&lt;/li>
&lt;li>节点是同步的，每个节点都知道时隙何时开始。&lt;/li>
&lt;li>如果一个时隙中有两个或多个帧碰撞，则所有节点在该时隙结束前检测到该碰撞事件。&lt;/li>
&lt;/ul>
&lt;p>另p为一个概率，即一个在0和1之间的数，在每个节点中，时隙ALOHA的操作如下：&lt;/p>
&lt;ul>
&lt;li>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传送它。&lt;/li>
&lt;li>若没有碰撞，则节点成功传送帧，无需重传。&lt;/li>
&lt;li>若有碰撞，则该节点在时隙结束前检测到该碰撞，以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。&lt;/li>
&lt;/ul>
&lt;p>当具有多个活跃节点时，经计算，该协议的&lt;strong>最大效率仅为37%&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>具有碰撞检测的载波侦听多路访问（CSMA/CD）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>载波侦听：一个节点在传输前先听信道；如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。&lt;/li>
&lt;li>碰撞检测：当一个传输节点传输时一直在侦听此信道，如果它检测到另一个节点正在传输干扰帧，它就停止传输。在重复“侦听-当空闲时传输”循环之前等待一段随机时间。&lt;/li>
&lt;/ul>
&lt;h3 id="轮流协议">轮流协议&lt;/h3>
&lt;p>轮流协议能够实现当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。&lt;/p>
&lt;p>&lt;strong>轮询协议&lt;/strong>&lt;/p>
&lt;p>把所有节点之一指定为&lt;strong>主节点&lt;/strong>，主节点以循环的方式&lt;strong>轮询&lt;/strong>每个节点。例如，主节点向节点1发送一个报文，告诉它能够传输的帧的最多数量，在节点1传输了一些帧后，主节点告诉节点2它能传输的帧的最多数量。以此循环的方式轮询每个节点。&lt;/p>
&lt;p>&lt;strong>令牌传递协议&lt;/strong>&lt;/p>
&lt;p>该协议中没有主节点，有一个称为**令牌(token)**的小的特殊帧在节点间以某种固定次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时才持有这个令牌，否则它立即向下一个节点转发该令牌。令牌传递是分散的，有很高的效率。&lt;/p>
&lt;h2 id="交换局域网">交换局域网&lt;/h2>
&lt;h3 id="链路层寻址和地址解析协议arp">链路层寻址和地址解析协议（ARP）&lt;/h3>
&lt;p>&lt;strong>MAC地址&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>链路层地址在主机或路由器的**适配器(网络接口)**中，所以具有多个网络接口的主机和路由器将有与之相关联的多个链路层地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>链路层交换机&lt;/strong>并不具有与他们的接口相关联的链路层地址，因为链路层交换机的任务是在&lt;strong>主机与路由器之间承载数据报&lt;/strong>，主机或路由器不必将帧寻址到其之间的交换机，交换机透明地执行该项任务。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所有的适配器都有不同的MAC地址，这由IEEE来分配管理。&lt;/p>
&lt;p>某适配器要向目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插入帧中，将该帧发送到局域网中；当适配器接收到一个MAC地址时将其与自己的MAC地址进行比较，检查是否匹配，如果匹配则提取出封装的数据包并沿协议栈向上传送，如果不匹配则丢弃该帧。&lt;/p>
&lt;p>有时发送适配器要让局域网中&lt;strong>所有其他适配器&lt;/strong>接受并处理他发送的帧，发送适配器在该帧的目的地址字段插入一个特殊MAC&lt;strong>广播地址&lt;/strong>，对于使用6字节地址的局域网来说，广播地址为48个1组成的字符串，即以16进制表示为&lt;strong>FF-FF-FF-FF-FF-FF&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>地址解析协议（ARP）&lt;/strong>&lt;/p>
&lt;p>ARP是用来转换网络层&lt;strong>IP地址&lt;/strong>和链路层&lt;strong>MAC地址&lt;/strong>的。&lt;/p>
&lt;p>假设发送主机要向目的主机发送IP数据报，源要向其适配器提供数据报和目的主机的MAC地址，此后源适配器才构造一个包含目的MAC地址的帧发送到局域网中。&lt;/p>
&lt;p>发送主机使用ARP确定目的主机IP地址对应的MAC地址。发送主机向其ARP模块发送目的主机的IP，ARP将IP解析为一个MAC地址。&lt;/p>
&lt;p>每台主机或路由器的内存中有一个&lt;strong>ARP表&lt;/strong>，该表包含了IP地址到MAC地址的映射关系。
&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/ARP%E8%A1%A8.PNG" alt="">&lt;/p>
&lt;p>如果发送方ARP表中&lt;strong>没有目的主机的表项&lt;/strong>，则发送方构造一个&lt;strong>ARP分组&lt;/strong>（分组包括发送和接收IP地址以及MAC地址），并指示适配器用&lt;strong>MAC广播地址&lt;/strong>来发送这个分组，适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将帧传送进入子网，包含该ARP查询的帧能够被子网中的&lt;strong>所有其他适配器&lt;/strong>接收到，每个适配器都把该分组向上传递给ARP模块，ARP模块检查其IP地址是否与ARP分组中的目的IP匹配，若匹配则给查询主机发送回一个带有所希望映射的响应ARP分组，然后查询主机更新它的ARP表，然后发送它的IP数据报。&lt;/p>
&lt;p>查询ARP报文是在&lt;strong>广播帧&lt;/strong>中发送的，响应ARP报文是在一个&lt;strong>标准帧&lt;/strong>中发送的。&lt;/p>
&lt;p>最好把ARP看成跨越链路层和网络层边界两边的协议，因为其既包含IP地址又包含MAC地址。&lt;/p>
&lt;p>&lt;strong>发送数据报到子网以外&lt;/strong>&lt;/p>
&lt;p>先从一个子网将数据包发送到路由器，在从路由器发送到下一个子网的目的适配器，中间需要经过路由器的两个适配器，其中查询MAC地址的过程都是通过ARP来实现的。&lt;/p>
&lt;h3 id="以太网">以太网&lt;/h3>
&lt;p>一种广泛部署的有线局域网。&lt;/p>
&lt;p>以太网的安装使用星形拓扑结构，位于中心的是交换机。&lt;/p>
&lt;p>&lt;strong>以太网帧结构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/Ethernet_frame_structure.PNG" alt="以太网帧结构">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Data(数据字段)&lt;/strong>：46-1500字节，这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节，如果IP数据报超过1500字节，主机就要将该数据报分片。&lt;/li>
&lt;li>&lt;strong>Dest. address(目的地址)&lt;/strong>：6字节，包含了目的适配器的MAC地址。&lt;/li>
&lt;li>&lt;strong>Source address(源地址)&lt;/strong>：6字节，包含了传输该帧到局域网上的适配器的MAC地址。&lt;/li>
&lt;li>&lt;strong>Tyep(类型字段)&lt;/strong>：2字节，类型字段允许以太网复用多种网络协议。&lt;/li>
&lt;li>&lt;strong>CRC&lt;/strong>：4字节，使接收适配器检测帧中是否引入了差错。&lt;/li>
&lt;li>&lt;strong>Preamble(前同步码)&lt;/strong>：8字节，前7字节的值都是10101010；最后一个字节是10101011。前同步码的前7字节用于唤醒接收适配器，将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特（第一个出现的两个连续的1）警告接收适配器，重要的内容就要来了。&lt;/li>
&lt;/ul>
&lt;p>以太网技术都向网络层提供&lt;strong>无连接&lt;/strong>服务。当适配器A向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并把帧发送到局域网上，没有先与适配器B握手。&lt;/p>
&lt;p>以太网技术都向网络层提供&lt;strong>不可靠&lt;/strong>服务。当适配器B收到来自适配器A的一个帧时，对该帧执行CRC校验，但当该帧通过CRC校验时不发送确认帧，当该帧没有通过CRC校验时也不发送否定确认帧。当某帧没有通过CRC校验时适配器B只是丢弃该帧，A并不知道它传输的帧是否到达B且通过校验，意味着传递到网络层的数据报流有间隙。&lt;/p>
&lt;p>丢弃以太网帧后存在了间隙，主机B上的应用可以通过运输层看到这个间隙。当使用UDP协议时，B中的应用会看到这个间隙；当使用TCP协议时，B中的TCP将不会确认包含在丢弃帧中的数据，从而引起主机A的TCP重传。&lt;/p>
&lt;p>&lt;strong>以太网技术的发展&lt;/strong>&lt;/p>
&lt;p>不同速率的以太网：10BASE-T、10BASE-2、100BASE-T、1000BASE-LX和10GBASE-T；第一部分数字代表该标准的速率：10、100、1000、10G；BASE指基带以太网，意味着物理媒体仅承载以太网流量；最后一部分指代物理媒介本身，T指双绞铜线。这些技术指标已经被IEEE 802.3 CSMA/CD标准化。&lt;/p>
&lt;h3 id="链路层交换机">链路层交换机&lt;/h3>
&lt;p>交换机的任务是接收入链路层帧并将它们转发到出链路。交换机对子网的主机和路由器是&lt;strong>透明&lt;/strong>的，某主机/路由器向另一个主机/路由器寻址一个帧，顺利地将该帧发送进局域网，并不知道交换机将会接收帧并将它转发到另一个节点。交换机的输出接口设有&lt;strong>缓存&lt;/strong>，防止输入输出链路速率存在差别。&lt;/p>
&lt;p>&lt;strong>交换机转发和过滤&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>过滤：决定一个帧应该转发到某个接口还是应当将其丢弃。&lt;/li>
&lt;li>转发：决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。&lt;/li>
&lt;/ul>
&lt;p>交换机的过滤和转发借助于&lt;strong>交换机表&lt;/strong>完成。交换机表包含某局域网上某些主机和路由器的表项。&lt;/p>
&lt;p>一个表项包含：&lt;/p>
&lt;ul>
&lt;li>一个MAC地址&lt;/li>
&lt;li>通向该MAC地址的交换机接口&lt;/li>
&lt;li>表项放置在表中的时间&lt;/li>
&lt;/ul>
&lt;p>当交换机的表是完整的时，无需任何广播就向着目的地转发帧。&lt;/p>
&lt;p>&lt;strong>自学习&lt;/strong>&lt;/p>
&lt;p>交换机的表是自动、动态和自治地建立的，这种能力通过以下方式实现：&lt;/p>
&lt;ul>
&lt;li>交换机表初始为空&lt;/li>
&lt;li>对于在接口接收到的每个入帧，该交换机在其表中存储：该帧源地址字段的MAC地址，该帧的到达接口，当前时间。&lt;/li>
&lt;li>如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。&lt;/li>
&lt;/ul>
&lt;p>交换机是&lt;strong>即插即用设备&lt;/strong>，它们不需要网络管理员或用户的干预，也是双工的，可以同时发送和接收。&lt;/p>
&lt;p>&lt;strong>链路层交换机的性质&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>消除碰撞：交换机缓存帧并且不会在网段上同时传输多余一个帧。&lt;/li>
&lt;li>异质的链路：交换机将链路彼此隔离，因此局域网中的不同链路能够以不同速率运行并且能够在不同媒体上运行。&lt;/li>
&lt;li>管理：易于进行网络管理。&lt;/li>
&lt;/ul>
&lt;h3 id="虚拟局域网vlan">虚拟局域网（VLAN）&lt;/h3>
&lt;p>能够限制局域网广播流量；可以将交换机拆分，提高使用效率；能够更加方便地管理用户。&lt;/p>
&lt;p>不同VLAN之间需要通过路由器进行通信，因为VLAN将不同VLAN相互阻隔，一个VLAN中的设备无法直接通过目的MAC地址直接找到目的主机，而是需要通过路由器通过上层的IP进行查找。&lt;/p>
&lt;h2 id="数据中心网络">数据中心网络&lt;/h2>
- https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E4%BA%94%E9%93%BE%E8%B7%AF%E5%B1%82/ - 2019-2021 By Jialong</description></item><item><title>Linux基础知识</title><link>https://eternityqjl.github.io/blog2_public/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Thu, 29 Jul 2021 08:44:21 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ -&lt;h2 id="系统启动过程">系统启动过程&lt;/h2>
&lt;ul>
&lt;li>内核的引导：BIOS开机自检，然后读入/boot目录的内核文件&lt;/li>
&lt;li>运行init：init进程是所有进程的起点，运行级别确定&lt;/li>
&lt;li>系统初始化：&lt;code>rc.sysinit&lt;/code>&lt;/li>
&lt;li>建立终端&lt;/li>
&lt;li>用户登录系统&lt;/li>
&lt;/ul>
&lt;h2 id="系统目录结构">系统目录结构&lt;/h2>
&lt;ul>
&lt;li>&lt;code>/bin&lt;/code>：bin是二进制文件的缩写，存放着最常用的命令&lt;/li>
&lt;li>&lt;code>/boot&lt;/code>：存放启动时的核心文件&lt;/li>
&lt;li>&lt;code>/dev&lt;/code>：dev是Device的缩写，存放Linux的外部设备&lt;/li>
&lt;li>&lt;code>/etc&lt;/code>：Etcetera的缩写，用来存放所有系统管理所需的配置文件和子目录&lt;/li>
&lt;li>&lt;code>/home&lt;/code>：主目录，Linux中，每个用户都有一个自己的目录&lt;/li>
&lt;li>&lt;code>/lib&lt;/code>：Library的缩写，存放着系统最基本的动态连接共享库&lt;/li>
&lt;li>&lt;code>/media&lt;/code>：自动识别一些设备，将其挂载到这个目录&lt;/li>
&lt;li>&lt;code>/mnt&lt;/code>：该目录为了让用户临时挂载别的文件系统&lt;/li>
&lt;li>&lt;code>/opt&lt;/code>：optional的缩写，给主机额外安装软件所设置的目录&lt;/li>
&lt;li>&lt;code>/proc&lt;/code>：Processes进程的缩写，是一种虚拟文件系统，存放着当前内核运行状态的一系列特殊文件。该目录不再硬盘上，而是在内存中。&lt;/li>
&lt;li>&lt;code>/root&lt;/code>：系统管理员主目录&lt;/li>
&lt;li>&lt;code>/tmp&lt;/code>：temporary的缩写，用来存放临时目录&lt;/li>
&lt;li>&lt;code>/usr&lt;/code>：unix shared resources共享资源的缩写，用户的很多应用程序和文件存放于此，类似于windows下的program files&lt;/li>
&lt;li>&lt;code>/usr/bin&lt;/code>：系统用户使用的应用程序&lt;/li>
&lt;li>&lt;code>/usr/src&lt;/code>：内核源代码默认的存放目录&lt;/li>
&lt;li>&lt;code>/var&lt;/code>：variable的缩写，存放着不断扩充着的东西，将经常被修改的目录放在这个目录下，包括各种日志文件&lt;/li>
&lt;/ul>
&lt;h2 id="文件基本属性">文件基本属性&lt;/h2>
&lt;p>Linux系统是一种多用户系统，不同用户有不同权限。&lt;/p>
&lt;p>通常使用以下命令来修文件和目录的权限：&lt;/p>
&lt;ul>
&lt;li>chown(change ownerp)：修改所属用户与组&lt;/li>
&lt;li>chmod(change mode)：修改用户的权限&lt;/li>
&lt;/ul>
&lt;p>在Linux中使用&lt;code>ll&lt;/code>或&lt;code>ls -l&lt;/code>来显示一个文件的属性以及文件所属的用户和组。&lt;/p>
&lt;p>第一个字符代表这个文件的类型，是目录、文件或连接文件等等：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>d&lt;/code>为目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-&lt;/code>为文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>l&lt;/code>为链接文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>b&lt;/code>为可存储的接口设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>c&lt;/code>为串行端口设备&lt;/p>
&lt;p>接下来的字符以三个为一组，为&lt;code>rwx&lt;/code>三个参数的组合，&lt;code>r&lt;/code>代表可读，&lt;code>w&lt;/code>代表可写，&lt;code>x&lt;/code>代表可执行，从前到后分别代表user、group、everyone的权限，如果没有权限，则用&lt;code>-&lt;/code>表示。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于root用户，文件权限不起作用。&lt;/p>
&lt;h3 id="chgrp改变文件属组">chgrp：改变文件属组&lt;/h3>
&lt;p>用法：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">chgrp &lt;span style="color:#333">[&lt;/span>-R&lt;span style="color:#333">]&lt;/span> 属组名 文件名
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-R&lt;/code>：recursion，递归，改变目录下所有文件的属性&lt;/p>
&lt;h3 id="chown更改文件属主也可以同时更改文件属组">chown：更改文件属主，也可以同时更改文件属组&lt;/h3>
&lt;p>用法：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">chown &lt;span style="color:#333">[&lt;/span>-R&lt;span style="color:#333">]&lt;/span> 属主名 文件名
chown &lt;span style="color:#333">[&lt;/span>-r&lt;span style="color:#333">]&lt;/span> 属主名:属组名 文件名
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="chmod更改文件的9个属性">chmod：更改文件的9个属性&lt;/h3>
&lt;p>9个权限分别为&lt;strong>owner/group/others(拥有者/组/其他)&lt;/strong> 三种身份各有自己的 &lt;strong>read/write/execute&lt;/strong> 权限。&lt;/p>
&lt;p>第一种方法使用数字来表示，各权限的分数如下：&lt;/p>
&lt;ul>
&lt;li>r：4&lt;/li>
&lt;li>w：2&lt;/li>
&lt;li>x：1&lt;/li>
&lt;/ul>
&lt;p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： &lt;strong>-rwxrwx&amp;mdash;&lt;/strong> 分数则是：&lt;/p>
&lt;ul>
&lt;li>owner = rwx = 4+2+1 = 7&lt;/li>
&lt;li>group = rwx = 4+2+1 = 7&lt;/li>
&lt;li>others= &amp;mdash; = 0+0+0 = 0&lt;/li>
&lt;/ul>
&lt;p>所以等一下我们设定权限的变更时，该文件的权限数字就是 &lt;strong>770&lt;/strong>.&lt;/p>
&lt;p>第二种方法是使用符号类型改变权限，这里不详细介绍。&lt;/p>
&lt;h2 id="文件与目录管理">文件与目录管理&lt;/h2>
&lt;h3 id="处理目录常用命令">处理目录常用命令：&lt;/h3>
&lt;p>ls（list files）：列出目录和文件名&lt;/p>
&lt;ul>
&lt;li>-a：全部文件，联通隐藏文件&lt;/li>
&lt;li>-d：仅列出目录本身&lt;/li>
&lt;li>-l：长数据串列出，包含文件属性与权限&lt;/li>
&lt;/ul>
&lt;p>cd（change directory）：切换目录&lt;/p>
&lt;p>pwd（print work directory）：显示当前目录&lt;/p>
&lt;ul>
&lt;li>-P：显示出实际的路径，而不是连结（link）路径&lt;/li>
&lt;/ul>
&lt;p>mkdir（make directory）：创建一个新目录&lt;/p>
&lt;ul>
&lt;li>-m：配置文件的权限&lt;/li>
&lt;li>-p：可以递归创建多级目录&lt;/li>
&lt;/ul>
&lt;p>rmdir（remove directory）：删除一个空目录&lt;/p>
&lt;ul>
&lt;li>-p：连同上一级的空目录一起删除&lt;/li>
&lt;/ul>
&lt;p>cp（copy file）：复制文件或目录&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cp &lt;span style="color:#333">[&lt;/span>-adfilprsu&lt;span style="color:#333">]&lt;/span> 来源档&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">source&lt;/span>&lt;span style="color:#333">)&lt;/span> 目标档&lt;span style="color:#333">(&lt;/span>destination&lt;span style="color:#333">)&lt;/span>
cp &lt;span style="color:#333">[&lt;/span>options&lt;span style="color:#333">]&lt;/span> source1 source2 ... directory
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-a：相当于-pdr&lt;/li>
&lt;li>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身&lt;/li>
&lt;li>-f：force，若目标文件已存在且无法开启，则移除后再尝试一次&lt;/li>
&lt;li>-i：若目标档已存在时，在覆盖时会先询问&lt;/li>
&lt;li>-p：连同文件属性一起复制过去&lt;/li>
&lt;li>-f：递归持续复制，用于目录的复制&lt;/li>
&lt;li>-s：复制成为符号连结档(symbolic link)&lt;/li>
&lt;li>-u：若destination比source旧才升级destination&lt;/li>
&lt;/ul>
&lt;p>rm（remove）：删除文件或目录&lt;/p>
&lt;ul>
&lt;li>-f：force&lt;/li>
&lt;li>-r：递归删除，常用在目录的删除&lt;/li>
&lt;li>-i：互动模式，删除前会询问&lt;/li>
&lt;/ul>
&lt;p>mv（move file）：移动文件与目录，或修改文件、目录名称&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mv &lt;span style="color:#333">[&lt;/span>-fiu&lt;span style="color:#333">]&lt;/span> 来源档&lt;span style="color:#333">(&lt;/span>&lt;span style="color:#007020">source&lt;/span>&lt;span style="color:#333">)&lt;/span> 目标档&lt;span style="color:#333">(&lt;/span>destination&lt;span style="color:#333">)&lt;/span>
mv &lt;span style="color:#333">[&lt;/span>options&lt;span style="color:#333">]&lt;/span> source1 source2 ... directory
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-f：force&lt;/li>
&lt;li>-i：若目标文件 (destination) 已经存在时，就会询问是否覆盖&lt;/li>
&lt;li>-u：目标文件已经存在，且 source 比较新，才会升级 (update)&lt;/li>
&lt;/ul>
&lt;h2 id="文件内容查看">文件内容查看&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>cat：从第一行开始显示文件内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tac：从最后一行开始显示文件内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nl：显示行号并列出文件内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>more：一页一页显示和翻动文件&lt;/p>
&lt;ul>
&lt;li>空白键 (space)：代表向下翻一页；&lt;/li>
&lt;li>Enter ：代表向下翻『一行』；&lt;/li>
&lt;li>/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；&lt;/li>
&lt;li>:f ：立刻显示出档名以及目前显示的行数；&lt;/li>
&lt;li>q ：代表立刻离开 more ，不再显示该文件内容。&lt;/li>
&lt;li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>head：取出文件前面几行&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">head &lt;span style="color:#333">[&lt;/span>-n number&lt;span style="color:#333">]&lt;/span> 文件
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>tail：取出文件后面几行&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">tail &lt;span style="color:#333">[&lt;/span>-n number&lt;span style="color:#333">]&lt;/span> 文件
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="磁盘管理">磁盘管理&lt;/h2>
&lt;p>常用的三个命令：df、du、fdisk&lt;/p>
&lt;p>df：列出文件系统的整体磁盘使用量&lt;/p>
&lt;p>du：检查磁盘空间使用量&lt;/p>
&lt;p>fdisk：用于磁盘分区&lt;/p>
&lt;h2 id="配置wsl2开发环境">配置WSL2开发环境&lt;/h2>
&lt;h3 id="cc">C/C++&lt;/h3>
&lt;p>见&lt;a href="https://code.visualstudio.com/docs/cpp/config-wsl">Using C++ and WSL in VS Code&lt;/a>&lt;/p>
&lt;h3 id="python">Python&lt;/h3>
&lt;p>使用脚本安装Anaconda&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ - 2019-2021 By Jialong</description></item><item><title>计算机网络各层级理解</title><link>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</link><pubDate>Fri, 23 Jul 2021 12:59:05 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ -&lt;p>一年多前按照层级详细学习了计算机网络的有关内容，包括从应用层、传输层、网络层、数据链路层到物理层的详细信息，并且也学习了一些其他硬件通信协议，比如CAN控制器局域网、SPI等等。在之后的应用和实践中经常对不同层级的网络和网络设备产生疑惑，例如路由器和交换机到底是什么关系？为什么要通过IP地址和MAC地址划分网络层和数据链路层？这里将会详细说明各层网络的具体作用来加深理解和体会。&lt;/p>
&lt;h2 id="应用层">应用层&lt;/h2>
&lt;p>应用层是计算机网络体系结构中最高层，意味着这是&lt;strong>和人进行交互&lt;/strong>的层次。&lt;/p>
&lt;p>应用层是计算机网络与用户进行交互的&lt;strong>接口&lt;/strong>或界面，直接向用户提供服务；包括Web、E-mail、DNS、DHCP、FTP等等。&lt;/p>
&lt;p>应用层要解决的主要问题就是如何为用户提供&lt;strong>高效、可靠、满意&lt;/strong>的服务，工程师要根据不同业务场景使用不同技术方法解决这些问题，比如使用多线程、高并发的Web框架，分布式处理等等。&lt;/p>
&lt;h2 id="传输层">传输层&lt;/h2>
&lt;p>负责&lt;strong>端到端（进程之间）&lt;strong>的通信。位于两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种&lt;/strong>网络应用进程&lt;/strong>。&lt;/p>
&lt;p>端到端的传输分为两个步骤：&lt;/p>
&lt;ul>
&lt;li>虚拟传输连接的建立&lt;/li>
&lt;li>源端用户数据沿着传输连接传送到目的端&lt;/li>
&lt;/ul>
&lt;p>整个数据传输过程中传输层需要完成以下基本功能：传输层寻址、传输连接建立、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和多路分解、崩溃恢复。&lt;/p>
&lt;h2 id="网络层">网络层&lt;/h2>
&lt;p>也被称为中转层。他很重要也很复杂，既要解决不同网络的节点通信的路由和协议识别问题，又要通过路由选择策略解决网络拥塞问题。&lt;/p>
&lt;p>网络层主要是为了解决不同网络之间&lt;strong>数据传输和转发&lt;/strong>问题。&lt;/p>
&lt;h2 id="数据链路层">数据链路层&lt;/h2>
&lt;p>在原始的、有差错的物理传输线路的基础上，采用差错检测、差错控制和流量控制等方法，将有差错的物理线路改成逻辑上无差错的数据链路，为上一层（网络层）提供高质量服务。&lt;/p>
&lt;p>数据链路层主要是为了&lt;strong>控制数据传输&lt;/strong>。&lt;/p>
&lt;h2 id="物理层">物理层&lt;/h2>
&lt;p>位于体系结构最底层，负责在物理介质上位数据链路层提供&lt;strong>原始比特流&lt;/strong>传输的&lt;strong>物理链接&lt;/strong>。&lt;/p>
&lt;p>物理层解决的问题就是&lt;strong>数据传输&lt;/strong>，所有数据到达物理层都会变成二进制的载波信号。&lt;/p>
&lt;h2 id="交换机和路由器">交换机和路由器&lt;/h2>
&lt;p>见&lt;a href="http://eternityqjl.top/posts/wlan%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E5%92%8C802-11ax/#wlan%e5%9f%ba%e7%a1%80%e5%86%85%e5%ae%b9">WLAN基本内容和802.11ax&lt;/a>中的内容。&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/ - 2019-2021 By Jialong</description></item><item><title>LaTex环境配置和基本功能模块</title><link>https://eternityqjl.github.io/blog2_public/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</link><pubDate>Sun, 18 Jul 2021 20:06:26 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ -&lt;h2 id="环境配置">环境配置&lt;/h2>
&lt;p>我选择使用VS code + Tex Live作为我的LaTex写作环境，具体配置过程参考自：&lt;a href="https://zhuanlan.zhihu.com/p/166523064">Visual Studio Code (vscode)配置LaTeX&lt;/a>&lt;/p>
&lt;p>以下是关于使用过程中一些具体模块的讨论：&lt;/p>
&lt;p>部分内容参考自：&lt;a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档&lt;/a>&lt;/p>
&lt;p>这里使用&lt;code>xeLatTex&lt;/code>进行编译。&lt;/p>
&lt;h2 id="基本文档和中英文">基本文档和中英文&lt;/h2>
&lt;h3 id="基本文档">基本文档&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\documentclass&lt;/span>&lt;span style="color:#007020">{&lt;/span>article&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#888">% 这里是导言区
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
Hello, world!
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tex以&lt;code>%&lt;/code>作为注释标记。若要输出百分号&lt;code>%&lt;/code>字符本身，则要在前面加上反斜杠&lt;code>\&lt;/code>进行转义（escape）。&lt;/p>
&lt;h3 id="中英文混排">中英文混排&lt;/h3>
&lt;p>目前XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题。至此，我们只需要使用几个简单的宏包，就能完成中文支持了。&lt;/p>
&lt;p>我们使用&lt;code>\usepackage{}&lt;/code>来调用宏包。&lt;/p>
&lt;p>另外，我们使用&lt;code>CTex&lt;/code>宏集来处理中文的版式和标点。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\documentclass&lt;/span>&lt;span style="color:#00c">[UTF8]&lt;/span>&lt;span style="color:#007020">{&lt;/span>ctexart&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
你好，world!
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>与开始相比，文档类别变为&lt;code>ctexart&lt;/code>，并且增加了文档类选项&lt;code>UTF8&lt;/code>.&lt;/p>
&lt;h3 id="组织文章基本内容">组织文章基本内容&lt;/h3>
&lt;ol>
&lt;li>标题、作者、日期&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\documentclass&lt;/span>&lt;span style="color:#00c">[UTF8]&lt;/span>&lt;span style="color:#007020">{&lt;/span>ctexart&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\title&lt;/span>&lt;span style="color:#007020">{&lt;/span>你好，world!&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\author&lt;/span>&lt;span style="color:#007020">{&lt;/span>Eternity&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\date&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\today&lt;/span>&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\maketitle&lt;/span>
你好，world!
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上代码中的控制序列&lt;code>\maketitle&lt;/code>能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。&lt;/p>
&lt;p>可以通过宏包&lt;code>titling&lt;/code>修改上述默认格式。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_1.PNG" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>章节和段落&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\documentclass&lt;/span>&lt;span style="color:#00c">[UTF8]&lt;/span>&lt;span style="color:#007020">{&lt;/span>ctexart&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\title&lt;/span>&lt;span style="color:#007020">{&lt;/span>你好，world!&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\author&lt;/span>&lt;span style="color:#007020">{&lt;/span>Liam&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\date&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\today&lt;/span>&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\maketitle&lt;/span>
&lt;span style="color:#080;font-weight:bold">\section&lt;/span>&lt;span style="color:#007020">{&lt;/span>你好中国&lt;span style="color:#007020">}&lt;/span>
中国在East Asia.
&lt;span style="color:#080;font-weight:bold">\subsection&lt;/span>&lt;span style="color:#007020">{&lt;/span>Hello Beijing&lt;span style="color:#007020">}&lt;/span>
北京是capital of China.
&lt;span style="color:#080;font-weight:bold">\subsubsection&lt;/span>&lt;span style="color:#007020">{&lt;/span>Hello Dongcheng District&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\paragraph&lt;/span>&lt;span style="color:#007020">{&lt;/span>Tian&amp;#39;anmen Square&lt;span style="color:#007020">}&lt;/span>
is in the center of Beijing
&lt;span style="color:#080;font-weight:bold">\subparagraph&lt;/span>&lt;span style="color:#007020">{&lt;/span>Chairman Mao&lt;span style="color:#007020">}&lt;/span>
is in the center of 天安门广场。
&lt;span style="color:#080;font-weight:bold">\subsection&lt;/span>&lt;span style="color:#007020">{&lt;/span>Hello 山东&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\paragraph&lt;/span>&lt;span style="color:#007020">{&lt;/span>山东大学&lt;span style="color:#007020">}&lt;/span> is one of the best university in 山东。
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>文档类&lt;code>article&lt;/code>/&lt;code>ctexart&lt;/code>中定义了5个控制序列来调整文章组织结构：&lt;/p>
&lt;ul>
&lt;li>&lt;code>\section{·}&lt;/code>&lt;/li>
&lt;li>&lt;code>\subsection{·}&lt;/code>&lt;/li>
&lt;li>&lt;code>\subsubsection{·}&lt;/code>&lt;/li>
&lt;li>&lt;code>\paragraph{·}&lt;/code>&lt;/li>
&lt;li>&lt;code>\subparagraph{·}&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_2.PNG" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>插入目录&lt;/li>
&lt;/ol>
&lt;p>在控制序列&lt;code>\maketitle&lt;/code>加入&lt;code>tableofcontents&lt;/code>，编译两次观察效果：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/tex_basic_3.PNG" alt="">&lt;/p>
&lt;p>LaTeX 将一个换行当做是一个简单的空格来处理，如果需要换行另起一段，则需要用两个换行（一个空行）来实现。&lt;/p>
&lt;h2 id="版面设置">版面设置&lt;/h2>
&lt;h3 id="页边距">页边距&lt;/h3>
&lt;p>使用&lt;code>geometry&lt;/code> 宏包。&lt;a href="https://texdoc.org/serve/geometry.pdf/0">geometry文档&lt;/a>&lt;/p>
&lt;p>比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>geometry&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\geometry&lt;/span>&lt;span style="color:#007020">{&lt;/span>papersize=&lt;span style="color:#007020">{&lt;/span>20cm,15cm&lt;span style="color:#007020">}}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\geometry&lt;/span>&lt;span style="color:#007020">{&lt;/span>left=1cm,right=2cm,top=3cm,bottom=4cm&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="页眉页脚">页眉页脚&lt;/h3>
&lt;p>设置页眉页脚，推荐使用 &lt;code>fancyhdr&lt;/code> 宏包。&lt;a href="https://texdoc.org/serve/fancyhdr.pdf/0">fancyhdr文档&lt;/a>&lt;/p>
&lt;p>比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>fancyhdr&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\pagestyle&lt;/span>&lt;span style="color:#007020">{&lt;/span>fancy&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\lhead&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\author&lt;/span>&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\chead&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\date&lt;/span>&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\rhead&lt;/span>&lt;span style="color:#007020">{&lt;/span>152xxxxxxxx&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\lfoot&lt;/span>&lt;span style="color:#007020">{}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\cfoot&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\thepage&lt;/span>&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\rfoot&lt;/span>&lt;span style="color:#007020">{}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\renewcommand&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\headrulewidth&lt;/span>&lt;span style="color:#007020">}{&lt;/span>0.4pt&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\renewcommand&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\headwidth&lt;/span>&lt;span style="color:#007020">}{&lt;/span>&lt;span style="color:#080;font-weight:bold">\textwidth&lt;/span>&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\renewcommand&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\footrulewidth&lt;/span>&lt;span style="color:#007020">}{&lt;/span>0pt&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="行间距">行间距&lt;/h3>
&lt;p>我们可以通过 &lt;code>setspace&lt;/code> 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>setspace&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\onehalfspacing&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="段间距">段间距&lt;/h3>
&lt;p>我们可以通过修改长度 &lt;code>\parskip&lt;/code> 的值来调整段间距。例如在导言区添加以下内容&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\addtolength&lt;/span>&lt;span style="color:#007020">{&lt;/span>&lt;span style="color:#080;font-weight:bold">\parskip&lt;/span>&lt;span style="color:#007020">}{&lt;/span>.4em&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="代码">代码&lt;/h2>
&lt;p>希望代码中的特殊字符不被LaTex处理，并且希望有代码高亮。&lt;/p>
&lt;p>使用&lt;code>listings&lt;/code>宏包来在tex中添加代码段。基本设置参数如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>listings&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\lstset&lt;/span>&lt;span style="color:#007020">{&lt;/span>
language=Matlab,
escapeinside=``,
numbers=left,
numberstyle=&lt;span style="color:#080;font-weight:bold">\tiny&lt;/span>,
breaklines=true,
backgroundcolor=&lt;span style="color:#080;font-weight:bold">\color&lt;/span>&lt;span style="color:#007020">{&lt;/span>lightgray!40!white&lt;span style="color:#007020">}&lt;/span>,
frame=single,
framerule=0pt,
extendedchars=false,
keywordstyle=&lt;span style="color:#080;font-weight:bold">\color&lt;/span>&lt;span style="color:#007020">{&lt;/span>blue!70&lt;span style="color:#007020">}&lt;/span>&lt;span style="color:#080;font-weight:bold">\bfseries&lt;/span>,
basicstyle=&lt;span style="color:#080;font-weight:bold">\ttfamily&lt;/span>,
commentstyle=&lt;span style="color:#080;font-weight:bold">\ttfamily\color&lt;/span>&lt;span style="color:#007020">{&lt;/span>green!40!black&lt;span style="color:#007020">}&lt;/span>,
showstringspaces=false&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="图片">图片&lt;/h2>
&lt;p>在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 &lt;code>graphicx&lt;/code> 宏包提供的 &lt;code>\includegraphics&lt;/code> 命令。比如你在你的 TeX 源文件同目录下，有名为 &lt;code>a.jpg&lt;/code> 的图片，你可以用这样的方式将它插入到输出文档中：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\documentclass&lt;/span>&lt;span style="color:#007020">{&lt;/span>article&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>graphicx&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\includegraphics&lt;/span>&lt;span style="color:#007020">{&lt;/span>a.jpg&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>document&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 &lt;code>\includegraphics&lt;/code> 控制序列的可选参数来控制。比如&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\includegraphics&lt;/span>&lt;span style="color:#00c">[width = .8\textwidth]&lt;/span>&lt;span style="color:#007020">{&lt;/span>a.jpg&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样图片的宽度会被缩放至&lt;strong>页面宽度的百分之八十&lt;/strong>，图片的总高度会按比例缩放。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>\includegraphics&lt;/code>还有很多其他控制序列可以选择使用，可以查看宏包选择。&lt;/p>
&lt;/blockquote>
&lt;h2 id="表格">表格&lt;/h2>
&lt;p>&lt;code>tabular&lt;/code> 环境提供了最简单的表格功能。它用 &lt;code>\hline&lt;/code> 命令表示横线，在列格式中用 &lt;code>|&lt;/code> 表示竖线；用 &lt;code>&amp;amp;&lt;/code> 来分列，用 &lt;code>\\&lt;/code> 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 &lt;code>l&lt;/code>、&lt;code>c&lt;/code>、&lt;code>r&lt;/code> 来表示。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>tabular&lt;span style="color:#007020">}{&lt;/span>|l|c|r|&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\hline&lt;/span>
操作系统&lt;span style="color:#007020">&amp;amp;&lt;/span> 发行版&lt;span style="color:#007020">&amp;amp;&lt;/span> 编辑器&lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\hline&lt;/span>
Windows &lt;span style="color:#007020">&amp;amp;&lt;/span> MikTeX &lt;span style="color:#007020">&amp;amp;&lt;/span> TexMakerX &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\hline&lt;/span>
Unix/Linux &lt;span style="color:#007020">&amp;amp;&lt;/span> teTeX &lt;span style="color:#007020">&amp;amp;&lt;/span> Kile &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\hline&lt;/span>
Mac OS &lt;span style="color:#007020">&amp;amp;&lt;/span> MacTeX &lt;span style="color:#007020">&amp;amp;&lt;/span> TeXShop &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\hline&lt;/span>
通用&lt;span style="color:#007020">&amp;amp;&lt;/span> TeX Live &lt;span style="color:#007020">&amp;amp;&lt;/span> TeXworks &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
&lt;span style="color:#080;font-weight:bold">\hline&lt;/span>
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>tabular&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果如下：&lt;/p>
&lt;h2 id="数学公式">数学公式&lt;/h2>
&lt;p>在导言区添加&lt;code>amsmath&lt;/code>宏包来使用数学功能：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\usepackage&lt;/span>&lt;span style="color:#007020">{&lt;/span>amsmath&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数学模式">数学模式&lt;/h3>
&lt;p>与Markdown中相同，LaTex共有&lt;strong>行内公式&lt;/strong>和&lt;strong>行间公式&lt;/strong>两种模式。&lt;/p>
&lt;p>在行文中，使用 &lt;code>$ ... $&lt;/code> 可以插入行内公式，使用 &lt;code>\[ ... \]&lt;/code> 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 &lt;code>equation&lt;/code> 环境：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>equation&lt;span style="color:#007020">}&lt;/span>
...
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>equation&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>无编号的行间公式也可以使用 &lt;code>\begin{displaymath} ... \end{displaymath}&lt;/code> 或者 &lt;code>\begin{equation*} ... \end{equation*}&lt;/code> 来插入，但略显麻烦。（&lt;code>equation*&lt;/code> 中的 &lt;code>*&lt;/code> 表示环境不编号）&lt;/p>
&lt;p>也有 plainTeX 风格的 &lt;code>$$ ... $$&lt;/code> 来插入不编号的行间公式。但是在 LaTeX 中这样做会改变行文的默认行间距，不推荐。&lt;/p>
&lt;/blockquote>
&lt;h3 id="标点符号">标点符号&lt;/h3>
&lt;p>行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。&lt;/p>
&lt;h3 id="多行公式">多行公式&lt;/h3>
&lt;p>有的公式特别长，我们需要手动为他们换行；&lt;/p>
&lt;p>有几个公式是一组，我们需要将他们放在一起；&lt;/p>
&lt;p>还有些类似分段函数，我们需要给它加上一个左边的花括号。&lt;/p>
&lt;ol>
&lt;li>长公式&lt;/li>
&lt;/ol>
&lt;p>不对齐：无须对齐的长公式可以使用 &lt;code>multline&lt;/code> 环境。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>multline&lt;span style="color:#007020">}&lt;/span>
x = a+b+c+&lt;span style="color:#007020">{}&lt;/span> &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
d+e+f+g
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>multline&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果如下：&lt;/p>
&lt;p>如果不需要编号，可以使用 &lt;code>multline*&lt;/code> 环境代替。&lt;/p>
&lt;p>对齐：需要对齐的公式，可以使用 &lt;code>aligned&lt;/code> &lt;em>次环境&lt;/em>来实现，它必须包含在数学环境之内。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="background-color:#fff0f0">\[&lt;/span>&lt;span style="color:#963">\begin&lt;/span>&lt;span style="color:#007020">{aligned}
&lt;/span>&lt;span style="color:#007020">x &lt;/span>&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#007020">{}&amp;amp; a&lt;/span>&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#007020">b&lt;/span>&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#007020">c&lt;/span>&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#007020">{} &lt;/span>&lt;span style="color:#963">\\&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;span style="color:#007020">&amp;amp;d&lt;/span>&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#007020">e&lt;/span>&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#007020">f&lt;/span>&lt;span style="color:#333">+&lt;/span>&lt;span style="color:#007020">g
&lt;/span>&lt;span style="color:#007020">&lt;/span>&lt;span style="color:#963">\end&lt;/span>&lt;span style="color:#007020">{aligned}&lt;/span>&lt;span style="background-color:#fff0f0">\]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果如下：&lt;/p>
&lt;ol start="2">
&lt;li>公式组&lt;/li>
&lt;/ol>
&lt;p>无需对齐的公式组可以使用 &lt;code>gather&lt;/code> 环境，需要对齐的公式组可以使用 &lt;code>align&lt;/code> 环境。他们都带有编号，如果不需要编号可以使用带&lt;code>*&lt;/code>的版本。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>gather&lt;span style="color:#007020">}&lt;/span>
a = b+c+d &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
x = y+z
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>gather&lt;span style="color:#007020">}&lt;/span>
&lt;span style="color:#080;font-weight:bold">\begin&lt;/span>&lt;span style="color:#007020">{&lt;/span>align&lt;span style="color:#007020">}&lt;/span>
a &lt;span style="color:#007020">&amp;amp;&lt;/span>= b+c+d &lt;span style="color:#080;font-weight:bold">\\&lt;/span>
x &lt;span style="color:#007020">&amp;amp;&lt;/span>= y+z
&lt;span style="color:#080;font-weight:bold">\end&lt;/span>&lt;span style="color:#007020">{&lt;/span>align&lt;span style="color:#007020">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果如下：&lt;/p>
&lt;ol start="3">
&lt;li>分段函数&lt;/li>
&lt;/ol>
&lt;p>分段函数可以用&lt;code>cases&lt;/code>次环境来实现，它必须包含在数学环境之内。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-tex" data-lang="tex">&lt;span style="background-color:#fff0f0">\[&lt;/span>&lt;span style="color:#007020"> y&lt;/span>&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#007020"> &lt;/span>&lt;span style="color:#963">\begin&lt;/span>&lt;span style="color:#007020">{cases}
&lt;/span>&lt;span style="color:#007020">&lt;/span>&lt;span style="color:#333">-&lt;/span>&lt;span style="color:#007020">x,&lt;/span>&lt;span style="color:#963">\quad&lt;/span>&lt;span style="color:#007020"> x&lt;/span>&lt;span style="color:#963">\leq&lt;/span>&lt;span style="color:#007020"> &lt;/span>&lt;span style="color:#60e;font-weight:bold">0&lt;/span>&lt;span style="color:#007020"> &lt;/span>&lt;span style="color:#963">\\&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;span style="color:#007020">x,&lt;/span>&lt;span style="color:#963">\quad&lt;/span>&lt;span style="color:#007020"> x&amp;gt;&lt;/span>&lt;span style="color:#60e;font-weight:bold">0&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;span style="color:#007020">&lt;/span>&lt;span style="color:#963">\end&lt;/span>&lt;span style="color:#007020">{cases} &lt;/span>&lt;span style="background-color:#fff0f0">\]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>- https://eternityqjl.github.io/blog2_public/posts/latex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/ - 2019-2021 By Jialong</description></item><item><title>csapp: 2.信息的表示和处理（部分完成）</title><link>https://eternityqjl.github.io/blog2_public/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 12 Jul 2021 21:26:27 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ -&lt;p>第一部分内容：程序结构和执行&lt;/p>
&lt;p>我们需要用方法表示&lt;strong>基本数据类型&lt;/strong>，然后考虑机器级指令如何操作这样的数据，以及编译器如何将C程序翻译成这样的指令。接下来研究集中处理器的方法，使得我们能够更好地了解硬件资源如何被用来执行指令。&lt;/p>
&lt;h2 id="信息存储">信息存储&lt;/h2>
&lt;h3 id="十六进制表示法及转换">十六进制表示法及转换&lt;/h3>
&lt;p>二进制和十进制对描述&lt;strong>位模式&lt;/strong>来说都不方便，因此采用16进制数(hex)来表示位模式。&lt;/p>
&lt;p>C语言中16进制数以0X或0x开头，字符‘A’~‘F’既可以是大写也可以是小写。&lt;/p>
&lt;p>二进制和十六进制之间的转换较为简单，不再赘述。&lt;/p>
&lt;p>十进制和十六进制数之间的转换要反复利用乘法和除法进行处理：&lt;/p>
&lt;ul>
&lt;li>从十进制到十六进制：反复用16除十进制数&lt;/li>
&lt;li>从十六进制到十进制：用相应的16的幂乘以每个十六进制数。&lt;/li>
&lt;/ul>
&lt;h3 id="字数据大小">字数据大小&lt;/h3>
&lt;p>字长指明指针数据的标称大小。虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是&lt;strong>虚拟地址空间的最大大小&lt;/strong>。&lt;/p>
&lt;p>对一个字长为w的机器而言，虚拟地址的范围是$0$ ~$2^w-1$，程序最多访问$2^w-1$个字节。&lt;/p>
&lt;p>近年，很多机器都从32位字长迁移到了64位字长。大多64位字长机器可以运行32位字长机器编译的程序。32位程序和64位程序的区别在于程序是&lt;strong>如何编译&lt;/strong>成的，而不是运行的机器类型。&lt;/p>
&lt;h3 id="寻址和字节顺序">寻址和字节顺序&lt;/h3>
&lt;p>小端法、大端法&lt;/p>
&lt;p>对于跨越多个字节的程序对象，我们必须明确：&lt;/p>
&lt;ol>
&lt;li>这个对象的地址是什么&lt;/li>
&lt;li>如何在内存中排列这些字节&lt;/li>
&lt;/ol>
&lt;p>一般来说，多字节对象被存储为&lt;strong>连续的字节序列&lt;/strong>，对象的地址为所使用字节中&lt;strong>最小的地址&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>小端法：将&lt;strong>最低有效字节&lt;/strong>放在最前面(最小地址)存储。（例如一个二进制数最右边的8位是最低有效字节）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大端法：将&lt;strong>最高有效字节&lt;/strong>放在最前面(最小地址)存储。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>大多Intel兼容机使用小端模式。&lt;/p>
&lt;p>以下代码使用强制类型转换来访问和打印不同程序对象的字节表示。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#579">#include&lt;/span> &lt;span style="color:#579">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#579">
&lt;/span>&lt;span style="color:#579">&lt;/span>
&lt;span style="color:#080;font-weight:bold">typedef&lt;/span> &lt;span style="color:#339;font-weight:bold">unsigned&lt;/span> &lt;span style="color:#339;font-weight:bold">char&lt;/span> &lt;span style="color:#333">*&lt;/span>byte_pointer; &lt;span style="color:#888">//将byte_pointer定义为一个指向类型为unsigned char对象的指针
&lt;/span>&lt;span style="color:#888">//指针被强制类型转换为unsigned char *, 这告诉编译器程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。
&lt;/span>&lt;span style="color:#888">&lt;/span>
&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">show_bytes&lt;/span>(byte_pointer start, size_t len)
{&lt;span style="color:#888">//按顺序显示出指针指向对象的每个字节内容，可以判断出系统使用的小端法还是大端法
&lt;/span>&lt;span style="color:#888">&lt;/span> size_t i;
&lt;span style="color:#080;font-weight:bold">for&lt;/span> (i &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>; i &lt;span style="color:#333">&amp;lt;&lt;/span> len; i&lt;span style="color:#333">++&lt;/span>)
printf(&lt;span style="background-color:#fff0f0">&amp;#34;%.2x&amp;#34;&lt;/span>, start[i]);
printf(&lt;span style="background-color:#fff0f0">&amp;#34;&lt;/span>&lt;span style="color:#666;background-color:#fff0f0;font-weight:bold">\n&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;&lt;/span>);
}
&lt;span style="color:#888">//使用sizeof确定对象使用的字节数
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">show_int&lt;/span>(&lt;span style="color:#339;font-weight:bold">int&lt;/span> x)
{&lt;span style="color:#888">//显示int对象的字节内容
&lt;/span>&lt;span style="color:#888">&lt;/span> show_bytes((byte_pointer) &lt;span style="color:#333">&amp;amp;&lt;/span>x, &lt;span style="color:#080;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#339;font-weight:bold">int&lt;/span>));
}
&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">show_float&lt;/span>(&lt;span style="color:#339;font-weight:bold">float&lt;/span> x)
{&lt;span style="color:#888">//显示float对象的字节内容
&lt;/span>&lt;span style="color:#888">&lt;/span> show_bytes((byte_pointer) &lt;span style="color:#333">&amp;amp;&lt;/span>x, &lt;span style="color:#080;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#339;font-weight:bold">float&lt;/span>));
}
&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#06b;font-weight:bold">show_pointer&lt;/span>(&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#333">*&lt;/span>x)
{&lt;span style="color:#888">//显示void *对象的字节内容
&lt;/span>&lt;span style="color:#888">&lt;/span> show_bytes((byte_pointer) &lt;span style="color:#333">&amp;amp;&lt;/span>x, &lt;span style="color:#080;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#339;font-weight:bold">void&lt;/span> &lt;span style="color:#333">*&lt;/span>));
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="表示字符串">表示字符串&lt;/h3>
&lt;p>对文本进行编码。&lt;/p>
&lt;p>ASCII编码、Unicode编码&lt;/p>
&lt;p>之前写过一篇相关博客：&lt;a href="http://eternityqjl.top/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81unicode-utf-8/">字符编码：Unicode, UTF-8&lt;/a>&lt;/p>
&lt;h3 id="布尔代数">布尔代数&lt;/h3>
&lt;p>四种布尔运算：&lt;/p>
&lt;p>与、或、非、异或&lt;/p>
&lt;blockquote>
&lt;p>异或：当P或Q为真但不同时为真时，异或成立；即当p=1且q=0或p=1且q=1时，p^q=1&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>位向量的布尔运算&lt;/strong>&lt;/p>
&lt;p>按位进行布尔运算。&lt;/p>
&lt;h3 id="c语言中的位级运算">C语言中的位级运算&lt;/h3>
&lt;p>按照对应位进行布尔运算。&lt;/p>
&lt;h3 id="c语言中的逻辑运算">C语言中的逻辑运算&lt;/h3>
&lt;p>&lt;code>||&lt;/code>、&lt;code>&amp;amp;&amp;amp;&lt;/code>、&lt;code>!&lt;/code>&lt;/p>
&lt;p>逻辑运算和位级运算完全不同，逻辑运算认为所有非零的参数都表示TRUE，参数0表示FALSE。以下是一些表达式求值举例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>表达式&lt;/th>
&lt;th>结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>!0x41&lt;/td>
&lt;td>0x00&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!0x00&lt;/td>
&lt;td>0x01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!!0x41&lt;/td>
&lt;td>0x01&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="c语言中的移位运算">C语言中的移位运算&lt;/h3>
&lt;p>左移k位：将操作数向左移动k位，丢弃掉最高的k位并在右端补k个0&lt;/p>
&lt;p>逻辑右移：在左端补k个0&lt;/p>
&lt;p>算数右移：在左端补k个最高有效位的值&lt;/p>
&lt;p>几乎所有编译器都对&lt;strong>有符号数&lt;/strong>使用&lt;strong>算术右移&lt;/strong>，对&lt;strong>无符号数&lt;/strong>使用逻辑右移。&lt;/p>
&lt;h2 id="整数表示">整数表示&lt;/h2>
&lt;p>用&lt;strong>位&lt;/strong>来编码整数的两种不同方式：&lt;/p>
&lt;ul>
&lt;li>一种只能表示&lt;strong>非负数&lt;/strong>&lt;/li>
&lt;li>另一种能表示&lt;strong>负数、零和正数&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="整型数据类型">整型数据类型&lt;/h3>
&lt;p>C语言通过&lt;strong>关键字&lt;/strong>来表示多种整型数据类型，这些关键字包括char、short、long，同时还能指示被表示的数字是非负数（声明为unsigned）。&lt;/p>
&lt;p>为不同大小分配的字节数根据程序编译为32位还是64位有所不同；根据字节分配，不同大小所能表示的值的范围是不同的。&lt;/p>
&lt;p>取值范围是不对称的，负数的范围比正数大1.&lt;/p>
&lt;h3 id="无符号数的编码">无符号数的编码&lt;/h3>
&lt;p>直接按照二进制进行编码即可。B2U：将二进制编码映射到一个非负整数&lt;/p>
&lt;p>无符号数的编码具有唯一性&lt;/p>
&lt;h3 id="补码编码">补码编码&lt;/h3>
&lt;p>(two&amp;rsquo;s-complement)。用来表示有符号数，将字的最高有效位解释为&lt;strong>负权&lt;/strong>，用$B2T_w$表示：
$$
B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2_i
$$
最高有效位$x_{w-1}$称为符号位，它的权重为$-2^{w-1}$，是无符号表示中权重的负数。&lt;/p>
&lt;p>从维向量到整数映射的举例：
$$
B2T_4([0001])=1 \&lt;br>
B2T_4([0101])=5 \&lt;br>
B2T_4([1011])=5 \&lt;br>
B2T_4([1111])=-1
$$
w位补码所能表示的值的范围是：$[-2^{w-1},2^{w-1}-1]$，例如长度为4的补码可以表示的范围是$[-8,7]$。与无符号数一样，在可表示的取值范围内，每个数字都唯一的w位补码。&lt;/p>
&lt;p>&lt;strong>用补码来编码负数（有符号数）&lt;/strong>。几乎所有现代机器目前都采用补码编码。&lt;/p>
&lt;blockquote>
&lt;p>反码：最高有效位的权是$-(2^{w-1}-1)$，其他和补码一样。&lt;/p>
&lt;p>原码：最高有效位是符号位，用来确定剩下的位应该取负权还是正权。&lt;/p>
&lt;p>这两种表示方式对于数字0都有两种不同的编码方式。&lt;/p>
&lt;/blockquote>
&lt;h3 id="有符号数和无符号数之间的转换">有符号数和无符号数之间的转换&lt;/h3>
&lt;p>对于多数C语言的实现来说，这个问题都是从&lt;strong>位级&lt;/strong>角度来看的，而不是&lt;strong>数&lt;/strong>的角度。&lt;/p>
&lt;p>处理同样字长的有符号和无符号数之间相互转换的规则为：数值可能会改变，但&lt;strong>位模式&lt;/strong>不变。&lt;/p>
&lt;p>补码转换为无符号数$T2U_w(x)$，当x&amp;lt;0时值改变，计算结果为$x+2^w$，当x&amp;gt;0时值不变。&lt;/p>
&lt;h3 id="c语言中的有符号数和无符号数">C语言中的有符号数和无符号数&lt;/h3>
&lt;p>C语言支持所有整型数据类型的有符号和无符号计算，几乎所有机器都采用&lt;strong>补码&lt;/strong>表示有符号数。通常大多数数字都默认是有符号的。&lt;/p>
&lt;h3 id="扩展一个数字的位表示">扩展一个数字的位表示&lt;/h3>
&lt;p>将无符号数扩展为一个更大的数据类型：只需在表示的开头添加0即可。&lt;/p>
&lt;p>将一个补码扩展为一个更大的数据类型：执行一个&lt;strong>符号扩展&lt;/strong>，即在开头添加最高有效位数字。&lt;/p>
&lt;p>符号扩展不改变补码表示的数字。&lt;/p>
&lt;h3 id="截断数字">截断数字&lt;/h3>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>为了避免出现错误或漏洞，我们&lt;strong>绝不使用无符号数&lt;/strong>。&lt;/p>
&lt;h2 id="整数运算">整数运算&lt;/h2>
&lt;h3 id="无符号加法">无符号加法&lt;/h3>
&lt;p>两个无符号数相加，如果完整的整数结果不能放到数据类型的字长限制中去，那么就会发生溢出，当无符号数加法发生溢出时，结果为丢弃溢出的最高位后的结果，即减去$2^w$。&lt;/p>
&lt;h3 id="补码加法">补码加法&lt;/h3>
&lt;p>分为正溢出、正常、负溢出三种情况。&lt;/p>
&lt;ul>
&lt;li>正溢出：和减去$2^w$&lt;/li>
&lt;li>负溢出：和加上$2^w$&lt;/li>
&lt;/ul>
&lt;h3 id="补码的非">补码的非&lt;/h3>
&lt;p>当$x=\text{TMin}_w$时，补码的非的结果为：$\text{TMin}_w$，否则结果为$-x$&lt;/p>
&lt;h3 id="无符号乘法">无符号乘法&lt;/h3>
&lt;p>乘积可能需要$2w$位来表示，C语言中无符号被定义为产生w位值，即2w乘积结果的低2w位。将一个无符号数截断为w位等价于计算该值模$2^w$&lt;/p>
&lt;h3 id="补码乘法">补码乘法&lt;/h3>
&lt;h3 id="总结-1">总结&lt;/h3>
&lt;p>计算机的整数运算实际上是一种模运算，表示数字时的有限字长限制了可能的值的取值范围，结果运算溢出。&lt;/p>
&lt;p>补码提供了一种既能表示整数也能表示负数的灵活方法，同时使用了与执行无符号算术相同的位级实现。&lt;/p>
&lt;h2 id="浮点数">浮点数&lt;/h2>
&lt;h3 id="二进制小数">二进制小数&lt;/h3>
&lt;h3 id="ieee浮点数表示">IEEE浮点数表示&lt;/h3>
&lt;h3 id="舍入">舍入&lt;/h3>
&lt;h3 id="浮点运算">浮点运算&lt;/h3>
- https://eternityqjl.github.io/blog2_public/posts/csapp-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/ - 2019-2021 By Jialong</description></item><item><title>CAN总线</title><link>https://eternityqjl.github.io/blog2_public/posts/can%E6%80%BB%E7%BA%BF/</link><pubDate>Mon, 12 Jul 2021 18:16:41 +0800</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/can%E6%80%BB%E7%BA%BF/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/can%E6%80%BB%E7%BA%BF/ -&lt;h2 id="概要">概要&lt;/h2>
&lt;p>Controller Area Network&lt;/p>
&lt;p>CAN总线由BOSCH公司开发，是一种多主控(Multi-Master)的现场总线系统，CAN网络的消息是广播式的，即同一时刻网络上所有节点侦测的数据是一致的，是一种基于&lt;strong>消息广播&lt;/strong>模式的串行通信总线。&lt;/p>
&lt;p>CAN总线的很多优点，使得它得到了广泛的应用，如传输速度最高到1Mbps, 通信距离最远到10km，无损位仲裁机制，多主结构。&lt;/p>
&lt;p>&lt;strong>CAN总线标准&lt;/strong>规定了&lt;strong>物理层&lt;/strong>和&lt;strong>数据链路层&lt;/strong>，应用层标准由具体应用决定。&lt;/p>
&lt;h2 id="can物理层">CAN物理层&lt;/h2>
&lt;p>连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的&lt;strong>差分电平信号&lt;/strong>。&lt;/p>
&lt;p>节点主要包括Host、控制器和收发器。&lt;/p>
&lt;p>&lt;strong>Host&lt;/strong>常集成有CAN控制器，&lt;strong>CAN控制器&lt;/strong>负责处理协议相关功能，以减轻Host的负担。&lt;/p>
&lt;p>&lt;strong>CAN收发器&lt;/strong>将控制器连接到传输媒介。通常控制器和总线收发器通过光耦或磁耦隔离，这样即使总线上过压损坏收发器，控制器和Host设备也可以得到保护。&lt;/p>
&lt;p>在发送数据时，CAN控制器把要发送的二进制编码通过&lt;strong>CAN_Tx线&lt;/strong>发送到CAN收发器，然后由收发器把这个普通的逻辑电平信号转化成&lt;strong>差分信号&lt;/strong>，通过&lt;strong>差分线CAN_High和CAN_Low&lt;/strong>输出到CAN总线网络。接收数据过程，相反。采用差分信号，可以取得更好的电磁兼容效果。因此，CAN总线物理传输媒介只需要两根线。&lt;/p>
&lt;p>下图为一CAN收发器应用的例子：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_example.PNG" alt="CAN总线示例">&lt;/p>
&lt;p>高速CAN总线最高信号传输速率为1Mbps，支持最长距离40m。ISO11898-2要求在高速CAN总线两段安装&lt;strong>端接电阻&lt;/strong>RL（端接电阻一般为120Ω，因为电缆的特性阻抗为120 Ω，为了模拟无限远的传输线。）以消除反射。低速CAN最高速度只有125Kbps，所以ISO11898-3没有端接要求。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_bus_Res.jpg" alt="">&lt;/p>
&lt;h3 id="差分信号">差分信号&lt;/h3>
&lt;p>CAN总线采用差分信号传输，通常情况下只需要两根信号线就可以进行正常的通信。在差分信号中，逻辑0和逻辑1是用两根差分信号线的电压差来表示。&lt;/p>
&lt;p>当处于&lt;strong>逻辑1&lt;/strong>，CAN_High和CAN_Low的电压差小于0.5V时，称为&lt;strong>隐性电平（Recessive）&lt;/strong>；&lt;/p>
&lt;p>当处于&lt;strong>逻辑0&lt;/strong>，CAN_High和CAN_Low的电压差大于0.9V，称为&lt;strong>显性电平（Dominant）&lt;/strong>。&lt;/p>
&lt;p>CAN总线遵从“线与”机制：“显性”位可以覆 盖“隐性”位；只有所有节点都发 送“隐性”位， 总线才处于“隐性” 状态。这种“线与”机制使CAN总线呈现显性优先的特性。&lt;/p>
&lt;h2 id="can数据链路层">CAN数据链路层&lt;/h2>
&lt;p>在SPI通信中，片选、时钟信号、数据输入及数据输出这四个信号都有单独的信号线。而CAN使用的是两条差分信号线，&lt;strong>只能表达一个信号&lt;/strong>。简洁的物理层决定了CAN必然要配上一套更为复杂的协议。如何用一个信号通道实现同样甚至更强大的功能，答案就是对数据或操作命令进行打包。&lt;/p>
&lt;h3 id="通信机制">通信机制&lt;/h3>
&lt;p>&lt;strong>多主机(Multi-Master)&lt;/strong>：&lt;/p>
&lt;p>安全敏感的应用（如汽车动力）对通信系统的&lt;strong>可靠性&lt;/strong>要求很高。将总线能否正常工作归结到单一节点是非常危险的，比较合理的方案是对总线接入的&lt;strong>去中心化&lt;/strong>，即每个节点都有接入总线的能力。这也是CAN总线采用多主控（Multi-Master）线性拓扑结构的原因。&lt;/p>
&lt;p>在CAN总线上，每个节点都有往总线上发送消息的能力，而消息的发送不必遵从任何预先设定的时序，通信是&lt;strong>事件驱动&lt;/strong>的。只有当有新的信息传递时，CAN总线才处于忙碌的状态，这使得节点接入总线速度非常快。CAN总线理论最高数据传输速率为1Mbps，对于异步事件反应迅速，基本对于ms级别的实时应用没有任何问题。&lt;/p>
&lt;p>&lt;strong>寻址机制&lt;/strong>：&lt;/p>
&lt;p>CAN总线不设定节点的地址，而是通过消息的&lt;strong>标识符（Identifier）&lt;strong>来区别消息。这种机制虽然会增加消息的复杂度（增加标识符），但是节点在此情况下可以无需了解其他节点的状况，而&lt;/strong>相互间独立工作&lt;/strong>。在总线上增加节点时仅需关注消息类型，而非系统上其他节点的状况。这种以消息标识符寻址的方式，让总线上增加节点变得更加灵活。&lt;/p>
&lt;p>&lt;strong>总线访问 CSMA/CD+AMP&lt;/strong>&lt;/p>
&lt;p>多路载波侦听+基于消息优先级的冲突检测和非破坏性的仲裁机制（CSMA/CD+AMP）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CSMA（Carrie Sense Multiple Access）指的是所有节点必须都等到总线处于&lt;strong>空闲状态&lt;/strong>时才能往总线上发送消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CD+AMP（Collision Detection + Arbitration on Message Priority）指的是如果多个节点往总线上发送消息时，具备&lt;strong>最高优先级&lt;/strong>的消息获得总线。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非破坏性仲裁机制：通过ID仲裁，ID&lt;strong>数值越小&lt;/strong>，报文&lt;strong>优先级越高&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_1.jpg" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_2.jpg" alt="">&lt;/p>
&lt;p>发送低优先级报文的节点退出仲裁后，在下次总线空闲时自动重发报文。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_communicate_3.jpg" alt="">&lt;/p>
&lt;p>高优先级的报文&lt;strong>不能中断&lt;/strong>低优先级报文的发送。&lt;/p>
&lt;p>&lt;strong>报文接受过滤&lt;/strong>&lt;/p>
&lt;p>CAN控制器大多具有根据ID过滤报文的功能，即只接收某些ID的报文。节点对接收到的报文进行过滤：比较消息ID与选择器（Accepter）中和接受过滤相关位是否相同。如果相同，接收；如果不相同，则过滤。&lt;/p>
&lt;h3 id="报文种类及结构">报文种类及结构&lt;/h3>
&lt;p>在原始数据段的前面加上&lt;strong>传输起始标签、片选（识别）标签、控制标签&lt;/strong>，在数据的尾段加上&lt;strong>CRC校验标签、应答标签和传输结束标签&lt;/strong>。把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了。&lt;/p>
&lt;p>各种各样的标签，起到了协同传输的作用。当整个数据包被传输到其他设备时，只要这些设备按格式去解读，就能还原出原始数据。类似这样的数据包就被称为CAN的数据帧。&lt;/p>
&lt;p>为了更有效的控制通信，CAN一共规定了5中类型的帧，帧也称为报文。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">帧&lt;/th>
&lt;th style="text-align:center">帧用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">数据帧&lt;/td>
&lt;td style="text-align:center">用于发送单元向接收单元传输数据的帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">远程帧&lt;/td>
&lt;td style="text-align:center">用于接收单元向具有相同ID的发送单元请求数据的帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">错误帧&lt;/td>
&lt;td style="text-align:center">用于当检测出错误时，向其他单元通知错误的帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">超载帧&lt;/td>
&lt;td style="text-align:center">用于接收单元通知其尚未做好接受准备的帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">帧间隔&lt;/td>
&lt;td style="text-align:center">用于将数据帧及遥控帧与前面其他帧分离开的帧&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>数据帧&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/CAN_dataFrame.jpg" alt="">&lt;/p>
&lt;p>共分为7个段：&lt;/p>
&lt;ul>
&lt;li>帧起始（SOF）：标识一个数据帧的开始，固定一个显性位。用于同步，总线空闲期间的任何隐性到线性的跳变都将引起节点进行硬同步&lt;/li>
&lt;li>仲裁段：内容为本数据帧的ID信息&lt;/li>
&lt;li>控制段：r1和r0为保留位，默认设置为显性位。DLC（Data Length Code）段用二进制编码表示本报文的数据段包含多少字节，由4位组成，DLC3-DLC0，表示的数字为0-8.&lt;/li>
&lt;li>数据段：数据帧的核心内容，有0-8个字节长度。&lt;/li>
&lt;li>CRC段：报文包含了一段15位的CRC校验码，来检验是否出错。&lt;/li>
&lt;li>ACK段：包含确认位和界定符。在发送节点发送时为隐形位，当接收节点收到正确报文时，将其覆盖为显性。&lt;/li>
&lt;li>帧结束段（EOF）：由发送端发送7个隐形位表示结束。&lt;/li>
&lt;/ul>
&lt;h2 id="同步">同步&lt;/h2>
&lt;p>CAN总线使用&lt;strong>位同步&lt;/strong>的方式来确保通信时序，以及对总线的电平进行正确采样。&lt;/p>
&lt;h3 id="位时序">位时序&lt;/h3>
&lt;h3 id="同步-1">同步&lt;/h3>
&lt;p>分为硬同步和重新同步。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>部分内容转载自：&lt;a href="https://zhuanlan.zhihu.com/p/32262127">知乎-Choris-一口气从零读懂CAN总线&lt;/a>&lt;/p>
- https://eternityqjl.github.io/blog2_public/posts/can%E6%80%BB%E7%BA%BF/ - 2019-2021 By Jialong</description></item><item><title>存储器详解</title><link>https://eternityqjl.github.io/blog2_public/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</link><pubDate>Sun, 04 Jul 2021 16:09:50 +0000</pubDate><guid>https://eternityqjl.github.io/blog2_public/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid><description>Jialong's Blog https://eternityqjl.github.io/blog2_public/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ -&lt;p>计算机存储器只要分为内存和外存。内存是CPU直接寻址的存储空间，访问频率快，而外存访问慢。&lt;/p>
&lt;h2 id="易失性存储器随机存取存储器ram">易失性存储器（随机存取存储器，RAM）&lt;/h2>
&lt;p>Random Access Memory，存储在其中的资料会在电力切断后消失，所以属于易失性存储器。&lt;/p>
&lt;h3 id="动态随机存取存储器dram">动态随机存取存储器（DRAM）&lt;/h3>
&lt;p>Dynamic Random Access Memory，主要的作用原理是利用电容内&lt;strong>存储电荷的多寡&lt;/strong>来代表一个二进制比特（bit）是1还是0。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别资料，而导致资料毁损。因此对于DRAM来说，周期性地充电是一个不可避免的条件。由于这种需要&lt;strong>定时刷新&lt;/strong>的特性，因此被称为“动态”存储器。&lt;/p>
&lt;h3 id="静态随机存取存储器sram">静态随机存取存储器（SRAM）&lt;/h3>
&lt;p>Static Random Access Memory，所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失。&lt;/p>
&lt;p>SRAM由存储矩阵、地址译码器和读/写控制电路组成，容量的扩展有两个方面：位数的扩展用芯片的并联，字数的扩展可用外加译码器控制芯片的片选输入端[2]。SRAM中的每一bit储存在由4个场效应管（M1, M2, M3, M4）构成两个交叉耦合的反相器中。另外两个场效应管（M5, M6）是储存基本单元到用于读写的位线（Bit Line）的控制开关。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/eternityqjl/blogGallery/master/SRAM_Cell_(6_Transistors).svg" alt="">&lt;/p>
&lt;h2 id="非易失性存储器主要为只读存储器rom">非易失性存储器（主要为只读存储器，ROM）&lt;/h2>
&lt;p>Read-Only Memory，一旦存储资料就无法再将之改变或删除，且内容不会因为电源关闭而消失。&lt;/p>
&lt;h3 id="可编程式只读存储器prom">可编程式只读存储器（PROM）&lt;/h3>
&lt;p>Programmable read-only memory，每个比特都由熔丝或反熔丝的状态决定资料内容。这种存储器用作永久存放程序之用。常用于电子游戏机、电子词典等预存固定资料或程序的各式电子产品之上。PROM与狭义的ROM（Mask ROM）的差别在于前者可在IC制造完成后才依需要写入资料，后者的资料需在制造IC时一并制作在里面。&lt;/p>
&lt;p>一个典型的PROM一开始时每个比特都会是1，编程中如将该比特的熔丝（fuse）烧断则成为0，这一过程是不可逆的（即刻录后不能再改变），断电后也不会消失记忆，所以这种存储器是一种只读存储器。&lt;/p>
&lt;h3 id="可擦除可编程式只读存储器eprom">可擦除可编程式只读存储器（EPROM）&lt;/h3>
&lt;p>Erasable Programmable Read Only Memory，它是一组浮栅晶体管，被一个提供比电子电路中常用电压更高电压的电子器件分别编程。一旦编程完成后，EPROM只能用强紫外线照射来擦除。通过封装顶部能看见硅片的透明窗口，很容易识别EPROM，这个窗口同时用来进行紫外线擦除。&lt;/p>
&lt;h3 id="电子抹除式可复写只读存储器eeprom">电子抹除式可复写只读存储器（EEPROM）&lt;/h3>
&lt;p>Electrically-Erasable Programmable Read-Only Memory，是一种可以通过电子方式多次复写的半导体存储设备。相比EPROM， EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据， EEPROM 属于SPD（串行存在检测）技术的一种延伸。&lt;/p>
&lt;p>在民用的DDR SDRAM及其主流后续产品中，一般 EEPROM 主要用于保存内存的开发者信息、生产时间、内存信息、通信协议、既定内存频率、供电电压、供电电流、物理信息以及内存XMP等信息，并且电脑会在开机自检（Power-On Self-Test；POST）时会读取这些信息以保持电脑的正常开机。&lt;/p>
&lt;h3 id="闪存flash-memory">闪存（Flash Memory）&lt;/h3>
&lt;p>闪存是一种特殊的、以宏块抹写的EEPROM。&lt;/p>
&lt;p>NOR和NAND两种类型&lt;/p>
&lt;h4 id="nand-flash">NAND Flash&lt;/h4>
&lt;p>SLC(单阶存储单元)、MLC(多阶存储单元，一般指2)、TLC(三阶存储单元)、QLC&lt;/p>
&lt;p>现在消费级产品都是TLC&lt;/p>
&lt;h4 id="移动端使用的闪存协议变化">移动端使用的闪存协议变化&lt;/h4>
&lt;p>eMMC-UFS&lt;/p>- https://eternityqjl.github.io/blog2_public/posts/%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%A6%E8%A7%A3/ - 2019-2021 By Jialong</description></item></channel></rss>